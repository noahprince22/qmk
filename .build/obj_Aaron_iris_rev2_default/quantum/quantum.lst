   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB13:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  19:quantum/quantum.c **** #include "outputselect.h"
  20:quantum/quantum.c **** #endif
  21:quantum/quantum.c **** 
  22:quantum/quantum.c **** #ifndef TAPPING_TERM
  23:quantum/quantum.c **** #define TAPPING_TERM 200
  24:quantum/quantum.c **** #endif
  25:quantum/quantum.c **** 
  26:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  27:quantum/quantum.c **** #define BREATHING_PERIOD 6
  28:quantum/quantum.c **** #endif
  29:quantum/quantum.c **** 
  30:quantum/quantum.c **** #include "backlight.h"
  31:quantum/quantum.c **** extern backlight_config_t backlight_config;
  32:quantum/quantum.c **** 
  33:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  34:quantum/quantum.c **** #include "fauxclicky.h"
  35:quantum/quantum.c **** #endif
  36:quantum/quantum.c **** 
  37:quantum/quantum.c **** #ifdef API_ENABLE
  38:quantum/quantum.c **** #include "api.h"
  39:quantum/quantum.c **** #endif
  40:quantum/quantum.c **** 
  41:quantum/quantum.c **** #ifdef MIDI_ENABLE
  42:quantum/quantum.c **** #include "process_midi.h"
  43:quantum/quantum.c **** #endif
  44:quantum/quantum.c **** 
  45:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  46:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  47:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  48:quantum/quantum.c ****   #endif
  49:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  50:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  51:quantum/quantum.c ****   #endif
  52:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  53:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  54:quantum/quantum.c ****   #endif
  55:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  56:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  57:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  58:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  59:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  60:quantum/quantum.c ****   #endif
  61:quantum/quantum.c **** #endif
  62:quantum/quantum.c **** 
  63:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 63 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  38 0008 8C01      		movw r16,r24
  39 000a EB01      		movw r28,r22
  64:quantum/quantum.c ****   switch (code) {
  40               		.loc 1 64 0
  41 000c 9A95      		dec r25
  42               	.LVL1:
  43 000e 8115      		cp r24,__zero_reg__
  44 0010 9F41      		sbci r25,31
  45 0012 00F4      		brsh .L1
  65:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  66:quantum/quantum.c ****     break;
  67:quantum/quantum.c ****   default:
  68:quantum/quantum.c ****     return;
  69:quantum/quantum.c ****   }
  70:quantum/quantum.c **** 
  71:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 71 0
  47 0014 10FF      		sbrs r17,0
  48 0016 00C0      		rjmp .L4
  72:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 72 0
  50 0018 80EE      		ldi r24,lo8(-32)
  51 001a FB01      		movw r30,r22
  52 001c 0995      		icall
  53               	.LVL2:
  54               	.L4:
  73:quantum/quantum.c ****   if (code & QK_LSFT)
  55               		.loc 1 73 0
  56 001e 11FF      		sbrs r17,1
  57 0020 00C0      		rjmp .L5
  74:quantum/quantum.c ****     f(KC_LSFT);
  58               		.loc 1 74 0
  59 0022 81EE      		ldi r24,lo8(-31)
  60 0024 FE01      		movw r30,r28
  61 0026 0995      		icall
  62               	.LVL3:
  63               	.L5:
  75:quantum/quantum.c ****   if (code & QK_LALT)
  64               		.loc 1 75 0
  65 0028 12FF      		sbrs r17,2
  66 002a 00C0      		rjmp .L6
  76:quantum/quantum.c ****     f(KC_LALT);
  67               		.loc 1 76 0
  68 002c 82EE      		ldi r24,lo8(-30)
  69 002e FE01      		movw r30,r28
  70 0030 0995      		icall
  71               	.LVL4:
  72               	.L6:
  77:quantum/quantum.c ****   if (code & QK_LGUI)
  73               		.loc 1 77 0
  74 0032 13FF      		sbrs r17,3
  75 0034 00C0      		rjmp .L7
  78:quantum/quantum.c ****     f(KC_LGUI);
  76               		.loc 1 78 0
  77 0036 83EE      		ldi r24,lo8(-29)
  78 0038 FE01      		movw r30,r28
  79 003a 0995      		icall
  80               	.LVL5:
  81               	.L7:
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  82               		.loc 1 80 0
  83 003c 0115      		cp r16,__zero_reg__
  84 003e 1041      		sbci r17,16
  85 0040 00F0      		brlo .L1
  81:quantum/quantum.c **** 
  82:quantum/quantum.c ****   if (code & QK_RCTL)
  83:quantum/quantum.c ****     f(KC_RCTL);
  86               		.loc 1 83 0
  87 0042 84EE      		ldi r24,lo8(-28)
  88 0044 FE01      		movw r30,r28
  89 0046 0995      		icall
  90               	.LVL6:
  84:quantum/quantum.c ****   if (code & QK_RSFT)
  85:quantum/quantum.c ****     f(KC_RSFT);
  91               		.loc 1 85 0
  92 0048 85EE      		ldi r24,lo8(-27)
  93 004a FE01      		movw r30,r28
  94 004c 0995      		icall
  95               	.LVL7:
  86:quantum/quantum.c ****   if (code & QK_RALT)
  87:quantum/quantum.c ****     f(KC_RALT);
  96               		.loc 1 87 0
  97 004e 86EE      		ldi r24,lo8(-26)
  98 0050 FE01      		movw r30,r28
  99 0052 0995      		icall
 100               	.LVL8:
  88:quantum/quantum.c ****   if (code & QK_RGUI)
  89:quantum/quantum.c ****     f(KC_RGUI);
 101               		.loc 1 89 0
 102 0054 87EE      		ldi r24,lo8(-25)
 103 0056 FE01      		movw r30,r28
 104               	/* epilogue start */
  90:quantum/quantum.c **** }
 105               		.loc 1 90 0
 106 0058 DF91      		pop r29
 107 005a CF91      		pop r28
 108               	.LVL9:
 109 005c 1F91      		pop r17
 110 005e 0F91      		pop r16
 111               	.LVL10:
  89:quantum/quantum.c ****     f(KC_RGUI);
 112               		.loc 1 89 0
 113 0060 0994      		ijmp
 114               	.LVL11:
 115               	.L1:
 116               	/* epilogue start */
 117               		.loc 1 90 0
 118 0062 DF91      		pop r29
 119 0064 CF91      		pop r28
 120               	.LVL12:
 121 0066 1F91      		pop r17
 122 0068 0F91      		pop r16
 123               	.LVL13:
 124 006a 0895      		ret
 125               		.cfi_endproc
 126               	.LFE13:
 128               		.section	.text.qk_register_weak_mods,"ax",@progbits
 130               	qk_register_weak_mods:
 131               	.LFB14:
  91:quantum/quantum.c **** 
  92:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 132               		.loc 1 92 0
 133               		.cfi_startproc
 134               	.LVL14:
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  93:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 139               		.loc 1 93 0
 140 0000 8770      		andi r24,lo8(7)
 141               	.LVL15:
 142 0002 91E0      		ldi r25,lo8(1)
 143 0004 00C0      		rjmp 2f
 144               		1:
 145 0006 990F      		lsl r25
 146               		2:
 147 0008 8A95      		dec r24
 148 000a 02F4      		brpl 1b
 149 000c 892F      		mov r24,r25
 150 000e 0E94 0000 		call add_weak_mods
 151               	.LVL16:
  94:quantum/quantum.c ****     send_keyboard_report();
 152               		.loc 1 94 0
 153 0012 0C94 0000 		jmp send_keyboard_report
 154               	.LVL17:
 155               		.cfi_endproc
 156               	.LFE14:
 158               		.section	.text.qk_register_mods,"ax",@progbits
 160               	qk_register_mods:
 161               	.LFB16:
  95:quantum/quantum.c **** }
  96:quantum/quantum.c **** 
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
  99:quantum/quantum.c ****     send_keyboard_report();
 100:quantum/quantum.c **** }
 101:quantum/quantum.c **** 
 102:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 162               		.loc 1 102 0
 163               		.cfi_startproc
 164               	.LVL18:
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 103:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 169               		.loc 1 103 0
 170 0000 8770      		andi r24,lo8(7)
 171               	.LVL19:
 172 0002 91E0      		ldi r25,lo8(1)
 173 0004 00C0      		rjmp 2f
 174               		1:
 175 0006 990F      		lsl r25
 176               		2:
 177 0008 8A95      		dec r24
 178 000a 02F4      		brpl 1b
 179 000c 892F      		mov r24,r25
 180 000e 0E94 0000 		call add_weak_mods
 181               	.LVL20:
 104:quantum/quantum.c ****     send_keyboard_report();
 182               		.loc 1 104 0
 183 0012 0C94 0000 		jmp send_keyboard_report
 184               	.LVL21:
 185               		.cfi_endproc
 186               	.LFE16:
 188               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 190               	qk_unregister_weak_mods:
 191               	.LFB15:
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
 192               		.loc 1 97 0
 193               		.cfi_startproc
 194               	.LVL22:
 195               	/* prologue: function */
 196               	/* frame size = 0 */
 197               	/* stack size = 0 */
 198               	.L__stack_usage = 0
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 199               		.loc 1 98 0
 200 0000 8770      		andi r24,lo8(7)
 201               	.LVL23:
 202 0002 91E0      		ldi r25,lo8(1)
 203 0004 00C0      		rjmp 2f
 204               		1:
 205 0006 990F      		lsl r25
 206               		2:
 207 0008 8A95      		dec r24
 208 000a 02F4      		brpl 1b
 209 000c 892F      		mov r24,r25
 210 000e 0E94 0000 		call del_weak_mods
 211               	.LVL24:
  99:quantum/quantum.c ****     send_keyboard_report();
 212               		.loc 1 99 0
 213 0012 0C94 0000 		jmp send_keyboard_report
 214               	.LVL25:
 215               		.cfi_endproc
 216               	.LFE15:
 218               		.section	.text.qk_unregister_mods,"ax",@progbits
 220               	qk_unregister_mods:
 221               	.LFB17:
 105:quantum/quantum.c **** }
 106:quantum/quantum.c **** 
 107:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 222               		.loc 1 107 0
 223               		.cfi_startproc
 224               	.LVL26:
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 227               	/* stack size = 0 */
 228               	.L__stack_usage = 0
 108:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 229               		.loc 1 108 0
 230 0000 8770      		andi r24,lo8(7)
 231               	.LVL27:
 232 0002 91E0      		ldi r25,lo8(1)
 233 0004 00C0      		rjmp 2f
 234               		1:
 235 0006 990F      		lsl r25
 236               		2:
 237 0008 8A95      		dec r24
 238 000a 02F4      		brpl 1b
 239 000c 892F      		mov r24,r25
 240 000e 0E94 0000 		call del_weak_mods
 241               	.LVL28:
 109:quantum/quantum.c ****     send_keyboard_report();
 242               		.loc 1 109 0
 243 0012 0C94 0000 		jmp send_keyboard_report
 244               	.LVL29:
 245               		.cfi_endproc
 246               	.LFE17:
 248               		.section	.text.register_code16,"ax",@progbits
 249               	.global	register_code16
 251               	register_code16:
 252               	.LFB18:
 110:quantum/quantum.c **** }
 111:quantum/quantum.c **** 
 112:quantum/quantum.c **** void register_code16 (uint16_t code) {
 253               		.loc 1 112 0
 254               		.cfi_startproc
 255               	.LVL30:
 256 0000 CF93      		push r28
 257               	.LCFI4:
 258               		.cfi_def_cfa_offset 3
 259               		.cfi_offset 28, -2
 260 0002 DF93      		push r29
 261               	.LCFI5:
 262               		.cfi_def_cfa_offset 4
 263               		.cfi_offset 29, -3
 264               	/* prologue: function */
 265               	/* frame size = 0 */
 266               	/* stack size = 2 */
 267               	.L__stack_usage = 2
 268 0004 EC01      		movw r28,r24
 113:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 269               		.loc 1 113 0
 270 0006 805E      		subi r24,-32
 271 0008 9109      		sbc r25,__zero_reg__
 272               	.LVL31:
 273 000a 0897      		sbiw r24,8
 274 000c 00F0      		brlo .L26
 275               		.loc 1 113 0 is_stmt 0 discriminator 1
 276 000e 2097      		sbiw r28,0
 277 0010 01F4      		brne .L27
 278               	.L26:
 114:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 279               		.loc 1 114 0 is_stmt 1
 280 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 281 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 282 0016 00C0      		rjmp .L29
 283               	.L27:
 115:quantum/quantum.c ****   } else {
 116:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 284               		.loc 1 116 0
 285 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 286 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 287               	.L29:
 288 001c CE01      		movw r24,r28
 289 001e 0E94 0000 		call do_code16
 290               	.LVL32:
 117:quantum/quantum.c ****   }
 118:quantum/quantum.c ****   register_code (code);
 291               		.loc 1 118 0
 292 0022 8C2F      		mov r24,r28
 293               	/* epilogue start */
 119:quantum/quantum.c **** }
 294               		.loc 1 119 0
 295 0024 DF91      		pop r29
 296 0026 CF91      		pop r28
 297               	.LVL33:
 118:quantum/quantum.c ****   register_code (code);
 298               		.loc 1 118 0
 299 0028 0C94 0000 		jmp register_code
 300               	.LVL34:
 301               		.cfi_endproc
 302               	.LFE18:
 304               		.section	.text.unregister_code16,"ax",@progbits
 305               	.global	unregister_code16
 307               	unregister_code16:
 308               	.LFB19:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 309               		.loc 1 121 0
 310               		.cfi_startproc
 311               	.LVL35:
 312 0000 CF93      		push r28
 313               	.LCFI6:
 314               		.cfi_def_cfa_offset 3
 315               		.cfi_offset 28, -2
 316 0002 DF93      		push r29
 317               	.LCFI7:
 318               		.cfi_def_cfa_offset 4
 319               		.cfi_offset 29, -3
 320               	/* prologue: function */
 321               	/* frame size = 0 */
 322               	/* stack size = 2 */
 323               	.L__stack_usage = 2
 324 0004 EC01      		movw r28,r24
 122:quantum/quantum.c ****   unregister_code (code);
 325               		.loc 1 122 0
 326 0006 0E94 0000 		call unregister_code
 327               	.LVL36:
 123:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 328               		.loc 1 123 0
 329 000a CE01      		movw r24,r28
 330 000c 805E      		subi r24,-32
 331 000e 9109      		sbc r25,__zero_reg__
 332 0010 0897      		sbiw r24,8
 333 0012 00F0      		brlo .L31
 334               		.loc 1 123 0 is_stmt 0 discriminator 1
 335 0014 2097      		sbiw r28,0
 336 0016 01F4      		brne .L32
 337               	.L31:
 124:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 338               		.loc 1 124 0 is_stmt 1
 339 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 340 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 341 001c 00C0      		rjmp .L33
 342               	.L32:
 125:quantum/quantum.c ****   } else {
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 343               		.loc 1 126 0
 344 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 345 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 346               	.L33:
 347 0022 CE01      		movw r24,r28
 348               	/* epilogue start */
 127:quantum/quantum.c ****   }
 128:quantum/quantum.c **** }
 349               		.loc 1 128 0
 350 0024 DF91      		pop r29
 351 0026 CF91      		pop r28
 352               	.LVL37:
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 353               		.loc 1 126 0
 354 0028 0C94 0000 		jmp do_code16
 355               	.LVL38:
 356               		.cfi_endproc
 357               	.LFE19:
 359               		.section	.text.process_action_kb,"ax",@progbits
 360               		.weak	process_action_kb
 362               	process_action_kb:
 363               	.LFB20:
 129:quantum/quantum.c **** 
 130:quantum/quantum.c **** __attribute__ ((weak))
 131:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 364               		.loc 1 131 0
 365               		.cfi_startproc
 366               	.LVL39:
 367               	/* prologue: function */
 368               	/* frame size = 0 */
 369               	/* stack size = 0 */
 370               	.L__stack_usage = 0
 132:quantum/quantum.c ****   return true;
 133:quantum/quantum.c **** }
 371               		.loc 1 133 0
 372 0000 81E0      		ldi r24,lo8(1)
 373               	.LVL40:
 374 0002 0895      		ret
 375               		.cfi_endproc
 376               	.LFE20:
 378               		.section	.text.process_record_user,"ax",@progbits
 379               		.weak	process_record_user
 381               	process_record_user:
 382               	.LFB22:
 134:quantum/quantum.c **** 
 135:quantum/quantum.c **** __attribute__ ((weak))
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 138:quantum/quantum.c **** }
 139:quantum/quantum.c **** 
 140:quantum/quantum.c **** __attribute__ ((weak))
 141:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 383               		.loc 1 141 0
 384               		.cfi_startproc
 385               	.LVL41:
 386               	/* prologue: function */
 387               	/* frame size = 0 */
 388               	/* stack size = 0 */
 389               	.L__stack_usage = 0
 142:quantum/quantum.c ****   return true;
 143:quantum/quantum.c **** }
 390               		.loc 1 143 0
 391 0000 81E0      		ldi r24,lo8(1)
 392               	.LVL42:
 393 0002 0895      		ret
 394               		.cfi_endproc
 395               	.LFE22:
 397               		.section	.text.process_record_kb,"ax",@progbits
 398               		.weak	process_record_kb
 400               	process_record_kb:
 401               	.LFB21:
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 402               		.loc 1 136 0
 403               		.cfi_startproc
 404               	.LVL43:
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407               	/* stack size = 0 */
 408               	.L__stack_usage = 0
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 409               		.loc 1 137 0
 410 0000 0C94 0000 		jmp process_record_user
 411               	.LVL44:
 412               		.cfi_endproc
 413               	.LFE21:
 415               		.section	.text.reset_keyboard,"ax",@progbits
 416               	.global	reset_keyboard
 418               	reset_keyboard:
 419               	.LFB23:
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** void reset_keyboard(void) {
 420               		.loc 1 145 0
 421               		.cfi_startproc
 422               	/* prologue: function */
 423               	/* frame size = 0 */
 424               	/* stack size = 0 */
 425               	.L__stack_usage = 0
 146:quantum/quantum.c ****   clear_keyboard();
 426               		.loc 1 146 0
 427 0000 0E94 0000 		call clear_keyboard
 428               	.LVL45:
 429               	.LBB31:
 430               	.LBB32:
 431               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 432               		.loc 2 164 0
 433 0004 2FEF      		ldi r18,lo8(799999)
 434 0006 84E3      		ldi r24,hi8(799999)
 435 0008 9CE0      		ldi r25,hlo8(799999)
 436 000a 2150      		1: subi r18,1
 437 000c 8040      		sbci r24,0
 438 000e 9040      		sbci r25,0
 439 0010 01F4      		brne 1b
 440 0012 00C0      		rjmp .
 441 0014 0000      		nop
 442               	.LBE32:
 443               	.LBE31:
 147:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 148:quantum/quantum.c ****   process_midi_all_notes_off();
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 151:quantum/quantum.c ****   music_all_notes_off();
 152:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 153:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 154:quantum/quantum.c ****   shutdown_user();
 155:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 156:quantum/quantum.c ****     wait_ms(1);
 157:quantum/quantum.c ****   stop_all_notes();
 158:quantum/quantum.c **** #else
 159:quantum/quantum.c ****   wait_ms(250);
 160:quantum/quantum.c **** #endif
 161:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 162:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 163:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 444               		.loc 1 163 0
 445 0016 87E7      		ldi r24,lo8(119)
 446 0018 97E7      		ldi r25,lo8(119)
 447 001a 9093 0108 		sts 2048+1,r25
 448 001e 8093 0008 		sts 2048,r24
 164:quantum/quantum.c **** #endif
 165:quantum/quantum.c ****   bootloader_jump();
 449               		.loc 1 165 0
 450 0022 0C94 0000 		jmp bootloader_jump
 451               	.LVL46:
 452               		.cfi_endproc
 453               	.LFE23:
 455               		.section	.text.process_record_quantum,"ax",@progbits
 456               	.global	process_record_quantum
 458               	process_record_quantum:
 459               	.LFB24:
 166:quantum/quantum.c **** }
 167:quantum/quantum.c **** 
 168:quantum/quantum.c **** // Shift / paren setup
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** #ifndef LSPO_KEY
 171:quantum/quantum.c ****   #define LSPO_KEY KC_9
 172:quantum/quantum.c **** #endif
 173:quantum/quantum.c **** #ifndef RSPC_KEY
 174:quantum/quantum.c ****   #define RSPC_KEY KC_0
 175:quantum/quantum.c **** #endif
 176:quantum/quantum.c **** 
 177:quantum/quantum.c **** // Shift / Enter setup
 178:quantum/quantum.c **** #ifndef SFTENT_KEY
 179:quantum/quantum.c ****   #define SFTENT_KEY KC_ENT
 180:quantum/quantum.c **** #endif
 181:quantum/quantum.c **** 
 182:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 183:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 184:quantum/quantum.c **** 
 185:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 186:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 187:quantum/quantum.c ****  */
 188:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 460               		.loc 1 190 0
 461               		.cfi_startproc
 462               	.LVL47:
 463 0000 0F93      		push r16
 464               	.LCFI8:
 465               		.cfi_def_cfa_offset 3
 466               		.cfi_offset 16, -2
 467 0002 1F93      		push r17
 468               	.LCFI9:
 469               		.cfi_def_cfa_offset 4
 470               		.cfi_offset 17, -3
 471 0004 CF93      		push r28
 472               	.LCFI10:
 473               		.cfi_def_cfa_offset 5
 474               		.cfi_offset 28, -4
 475 0006 DF93      		push r29
 476               	.LCFI11:
 477               		.cfi_def_cfa_offset 6
 478               		.cfi_offset 29, -5
 479               	/* prologue: function */
 480               	/* frame size = 0 */
 481               	/* stack size = 4 */
 482               	.L__stack_usage = 4
 483 0008 8C01      		movw r16,r24
 191:quantum/quantum.c **** 
 192:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 193:quantum/quantum.c ****   keypos_t key = record->event.key;
 484               		.loc 1 193 0
 485 000a FC01      		movw r30,r24
 486 000c C081      		ld r28,Z
 487 000e D181      		ldd r29,Z+1
 488               	.LVL48:
 194:quantum/quantum.c ****   uint16_t keycode;
 195:quantum/quantum.c **** 
 196:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 197:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 198:quantum/quantum.c ****     if (!disable_action_cache) {
 199:quantum/quantum.c ****       uint8_t layer;
 200:quantum/quantum.c **** 
 201:quantum/quantum.c ****       if (record->event.pressed) {
 202:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 203:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 204:quantum/quantum.c ****       } else {
 205:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 206:quantum/quantum.c ****       }
 207:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 208:quantum/quantum.c ****     } else
 209:quantum/quantum.c ****   #endif
 210:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 489               		.loc 1 210 0
 490 0010 CE01      		movw r24,r28
 491               	.LVL49:
 492 0012 0E94 0000 		call layer_switch_get_layer
 493               	.LVL50:
 494 0016 BE01      		movw r22,r28
 495 0018 0E94 0000 		call keymap_key_to_keycode
 496               	.LVL51:
 497 001c EC01      		movw r28,r24
 498               	.LVL52:
 211:quantum/quantum.c **** 
 212:quantum/quantum.c ****     // This is how you use actions here
 213:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 214:quantum/quantum.c ****     //   action_t action;
 215:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 216:quantum/quantum.c ****     //   process_action(record, action);
 217:quantum/quantum.c ****     //   return false;
 218:quantum/quantum.c ****     // }
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 221:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 222:quantum/quantum.c ****   #endif
 223:quantum/quantum.c **** 
 224:quantum/quantum.c ****   if (!(
 225:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 226:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 227:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 228:quantum/quantum.c ****   #endif
 229:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 230:quantum/quantum.c ****       process_clicky(keycode, record) &&
 231:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 499               		.loc 1 232 0
 500 001e B801      		movw r22,r16
 501 0020 0E94 0000 		call process_record_kb
 502               	.LVL53:
 503 0024 8823      		tst r24
 504 0026 01F4      		brne .+2
 505 0028 00C0      		rjmp .L151
 233:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 234:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 235:quantum/quantum.c ****   #endif
 236:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 237:quantum/quantum.c ****     process_midi(keycode, record) &&
 238:quantum/quantum.c ****   #endif
 239:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 240:quantum/quantum.c ****     process_audio(keycode, record) &&
 241:quantum/quantum.c ****   #endif
 242:quantum/quantum.c ****   #ifdef STENO_ENABLE
 243:quantum/quantum.c ****     process_steno(keycode, record) &&
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c ****   #if ( defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSI
 246:quantum/quantum.c ****     process_music(keycode, record) &&
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 250:quantum/quantum.c ****   #endif
 251:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 252:quantum/quantum.c ****     process_leader(keycode, record) &&
 506               		.loc 1 252 0 discriminator 2
 507 002a B801      		movw r22,r16
 508 002c CE01      		movw r24,r28
 509 002e 0E94 0000 		call process_leader
 510               	.LVL54:
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 511               		.loc 1 232 0 discriminator 2
 512 0032 8823      		tst r24
 513 0034 01F4      		brne .+2
 514 0036 00C0      		rjmp .L151
 253:quantum/quantum.c ****   #endif
 254:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 255:quantum/quantum.c ****     process_chording(keycode, record) &&
 256:quantum/quantum.c ****   #endif
 257:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 258:quantum/quantum.c ****     process_combo(keycode, record) &&
 259:quantum/quantum.c ****   #endif
 260:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 261:quantum/quantum.c ****     process_unicode(keycode, record) &&
 262:quantum/quantum.c ****   #endif
 263:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 264:quantum/quantum.c ****     process_ucis(keycode, record) &&
 265:quantum/quantum.c ****   #endif
 266:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 267:quantum/quantum.c ****     process_printer(keycode, record) &&
 268:quantum/quantum.c ****   #endif
 269:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 270:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 271:quantum/quantum.c ****   #endif
 272:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 273:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 274:quantum/quantum.c ****   #endif
 275:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 276:quantum/quantum.c ****     process_terminal(keycode, record) &&
 277:quantum/quantum.c ****   #endif
 278:quantum/quantum.c ****       true)) {
 279:quantum/quantum.c ****     return false;
 280:quantum/quantum.c ****   }
 281:quantum/quantum.c **** 
 282:quantum/quantum.c ****   // Shift / paren setup
 283:quantum/quantum.c **** 
 284:quantum/quantum.c ****   switch(keycode) {
 515               		.loc 1 284 0
 516 0038 C93C      		cpi r28,-55
 517 003a FCE5      		ldi r31,92
 518 003c DF07      		cpc r29,r31
 519 003e 01F4      		brne .L215
 285:quantum/quantum.c ****     case RESET:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 287:quantum/quantum.c ****         reset_keyboard();
 288:quantum/quantum.c ****       }
 289:quantum/quantum.c ****     return false;
 290:quantum/quantum.c ****     case DEBUG:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 292:quantum/quantum.c ****           debug_enable = true;
 293:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 294:quantum/quantum.c ****       }
 295:quantum/quantum.c ****     return false;
 296:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 297:quantum/quantum.c ****   case FC_TOG:
 298:quantum/quantum.c ****     if (record->event.pressed) {
 299:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 300:quantum/quantum.c ****     }
 301:quantum/quantum.c ****     return false;
 302:quantum/quantum.c ****   case FC_ON:
 303:quantum/quantum.c ****     if (record->event.pressed) {
 304:quantum/quantum.c ****       FAUXCLICKY_ON;
 305:quantum/quantum.c ****     }
 306:quantum/quantum.c ****     return false;
 307:quantum/quantum.c ****   case FC_OFF:
 308:quantum/quantum.c ****     if (record->event.pressed) {
 309:quantum/quantum.c ****       FAUXCLICKY_OFF;
 310:quantum/quantum.c ****     }
 311:quantum/quantum.c ****     return false;
 312:quantum/quantum.c ****   #endif
 313:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 314:quantum/quantum.c ****   case RGB_TOG:
 315:quantum/quantum.c ****     if (record->event.pressed) {
 316:quantum/quantum.c ****       rgblight_toggle();
 317:quantum/quantum.c ****     }
 318:quantum/quantum.c ****     return false;
 319:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 320:quantum/quantum.c ****     if (record->event.pressed) {
 321:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 322:quantum/quantum.c ****       if(shifted) {
 323:quantum/quantum.c ****         rgblight_step_reverse();
 324:quantum/quantum.c ****       }
 325:quantum/quantum.c ****       else {
 326:quantum/quantum.c ****         rgblight_step();
 327:quantum/quantum.c ****       }
 328:quantum/quantum.c ****     }
 329:quantum/quantum.c ****     return false;
 330:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 331:quantum/quantum.c ****     if (record->event.pressed) {
 332:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 333:quantum/quantum.c ****       if(shifted) {
 334:quantum/quantum.c ****         rgblight_step();
 335:quantum/quantum.c ****       }
 336:quantum/quantum.c ****       else {
 337:quantum/quantum.c ****         rgblight_step_reverse();
 338:quantum/quantum.c ****       }
 339:quantum/quantum.c ****     }
 340:quantum/quantum.c ****     return false;
 341:quantum/quantum.c ****   case RGB_HUI:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 343:quantum/quantum.c ****       rgblight_increase_hue();
 344:quantum/quantum.c ****     }
 345:quantum/quantum.c ****     return false;
 346:quantum/quantum.c ****   case RGB_HUD:
 347:quantum/quantum.c ****     if (record->event.pressed) {
 348:quantum/quantum.c ****       rgblight_decrease_hue();
 349:quantum/quantum.c ****     }
 350:quantum/quantum.c ****     return false;
 351:quantum/quantum.c ****   case RGB_SAI:
 352:quantum/quantum.c ****     if (record->event.pressed) {
 353:quantum/quantum.c ****       rgblight_increase_sat();
 354:quantum/quantum.c ****     }
 355:quantum/quantum.c ****     return false;
 356:quantum/quantum.c ****   case RGB_SAD:
 357:quantum/quantum.c ****     if (record->event.pressed) {
 358:quantum/quantum.c ****       rgblight_decrease_sat();
 359:quantum/quantum.c ****     }
 360:quantum/quantum.c ****     return false;
 361:quantum/quantum.c ****   case RGB_VAI:
 362:quantum/quantum.c ****     if (record->event.pressed) {
 363:quantum/quantum.c ****       rgblight_increase_val();
 364:quantum/quantum.c ****     }
 365:quantum/quantum.c ****     return false;
 366:quantum/quantum.c ****   case RGB_VAD:
 367:quantum/quantum.c ****     if (record->event.pressed) {
 368:quantum/quantum.c ****       rgblight_decrease_val();
 369:quantum/quantum.c ****     }
 370:quantum/quantum.c ****     return false;
 371:quantum/quantum.c ****   case RGB_SPI:
 372:quantum/quantum.c ****     if (record->event.pressed) {
 520               		.loc 1 372 0
 521 0040 F801      		movw r30,r16
 522 0042 8281      		ldd r24,Z+2
 523 0044 8823      		tst r24
 524 0046 01F4      		brne .+2
 525 0048 00C0      		rjmp .L151
 373:quantum/quantum.c ****       rgblight_increase_speed();
 526               		.loc 1 373 0
 527 004a 0E94 0000 		call rgblight_increase_speed
 528               	.LVL55:
 529 004e 00C0      		rjmp .L151
 530               	.L215:
 284:quantum/quantum.c ****   switch(keycode) {
 531               		.loc 1 284 0
 532 0050 CA3C      		cpi r28,-54
 533 0052 8CE5      		ldi r24,92
 534 0054 D807      		cpc r29,r24
 535 0056 00F0      		brlo .+2
 536 0058 00C0      		rjmp .L116
 537 005a C13C      		cpi r28,-63
 538 005c 9CE5      		ldi r25,92
 539 005e D907      		cpc r29,r25
 540 0060 01F4      		brne .L216
 320:quantum/quantum.c ****     if (record->event.pressed) {
 541               		.loc 1 320 0
 542 0062 F801      		movw r30,r16
 543 0064 8281      		ldd r24,Z+2
 544 0066 8823      		tst r24
 545 0068 01F4      		brne .+2
 546 006a 00C0      		rjmp .L151
 547               	.LBB33:
 321:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 548               		.loc 1 321 0
 549 006c 0E94 0000 		call get_mods
 550               	.LVL56:
 551 0070 8272      		andi r24,lo8(34)
 552               	.LVL57:
 322:quantum/quantum.c ****       if(shifted) {
 553               		.loc 1 322 0
 554 0072 01F0      		breq .L46
 555               	.LVL58:
 556               	.L48:
 323:quantum/quantum.c ****         rgblight_step_reverse();
 557               		.loc 1 323 0
 558 0074 0E94 0000 		call rgblight_step_reverse
 559               	.LVL59:
 560 0078 00C0      		rjmp .L151
 561               	.L216:
 562               	.LBE33:
 284:quantum/quantum.c ****   switch(keycode) {
 563               		.loc 1 284 0
 564 007a C23C      		cpi r28,-62
 565 007c ECE5      		ldi r30,92
 566 007e DE07      		cpc r29,r30
 567 0080 00F0      		brlo .L217
 568 0082 F801      		movw r30,r16
 569 0084 8281      		ldd r24,Z+2
 570 0086 C53C      		cpi r28,-59
 571 0088 FCE5      		ldi r31,92
 572 008a DF07      		cpc r29,r31
 573 008c 01F4      		brne .+2
 574 008e 00C0      		rjmp .L51
 575 0090 00F0      		brlo .+2
 576 0092 00C0      		rjmp .L119
 577 0094 C33C      		cpi r28,-61
 578 0096 ECE5      		ldi r30,92
 579 0098 DE07      		cpc r29,r30
 580 009a 01F4      		brne .+2
 581 009c 00C0      		rjmp .L49
 582 009e 00F0      		brlo .+2
 583 00a0 00C0      		rjmp .L218
 331:quantum/quantum.c ****     if (record->event.pressed) {
 584               		.loc 1 331 0
 585 00a2 8823      		tst r24
 586 00a4 01F4      		brne .+2
 587 00a6 00C0      		rjmp .L151
 588               	.LBB34:
 332:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 589               		.loc 1 332 0
 590 00a8 0E94 0000 		call get_mods
 591               	.LVL60:
 592 00ac 8272      		andi r24,lo8(34)
 593               	.LVL61:
 333:quantum/quantum.c ****       if(shifted) {
 594               		.loc 1 333 0
 595 00ae 01F0      		breq .L48
 596               	.LVL62:
 597               	.L46:
 598               	.LBE34:
 599               	.LBB35:
 326:quantum/quantum.c ****         rgblight_step();
 600               		.loc 1 326 0
 601 00b0 0E94 0000 		call rgblight_step
 602               	.LVL63:
 603 00b4 00C0      		rjmp .L151
 604               	.L217:
 605               	.LBE35:
 284:quantum/quantum.c ****   switch(keycode) {
 606               		.loc 1 284 0
 607 00b6 C531      		cpi r28,21
 608 00b8 FCE5      		ldi r31,92
 609 00ba DF07      		cpc r29,r31
 610 00bc 00F0      		brlo .+2
 611 00be 00C0      		rjmp .L118
 612 00c0 C230      		cpi r28,2
 613 00c2 8CE5      		ldi r24,92
 614 00c4 D807      		cpc r29,r24
 615 00c6 00F4      		brsh .+2
 616 00c8 00C0      		rjmp .L219
 374:quantum/quantum.c ****     }
 375:quantum/quantum.c ****     return false;
 376:quantum/quantum.c ****   case RGB_SPD:
 377:quantum/quantum.c ****     if (record->event.pressed) {
 378:quantum/quantum.c ****       rgblight_decrease_speed();
 379:quantum/quantum.c ****     }
 380:quantum/quantum.c ****     return false;
 381:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 382:quantum/quantum.c ****     if (record->event.pressed) {
 383:quantum/quantum.c ****       rgblight_mode(1);
 384:quantum/quantum.c ****     }
 385:quantum/quantum.c ****     return false;
 386:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 387:quantum/quantum.c ****     if (record->event.pressed) {
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 389:quantum/quantum.c ****         rgblight_step();
 390:quantum/quantum.c ****       } else {
 391:quantum/quantum.c ****         rgblight_mode(2);
 392:quantum/quantum.c ****       }
 393:quantum/quantum.c ****     }
 394:quantum/quantum.c ****     return false;
 395:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 396:quantum/quantum.c ****     if (record->event.pressed) {
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 398:quantum/quantum.c ****         rgblight_step();
 399:quantum/quantum.c ****       } else {
 400:quantum/quantum.c ****         rgblight_mode(6);
 401:quantum/quantum.c ****       }
 402:quantum/quantum.c ****     }
 403:quantum/quantum.c ****     return false;
 404:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 405:quantum/quantum.c ****     if (record->event.pressed) {
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 407:quantum/quantum.c ****         rgblight_step();
 408:quantum/quantum.c ****       } else {
 409:quantum/quantum.c ****         rgblight_mode(9);
 410:quantum/quantum.c ****       }
 411:quantum/quantum.c ****     }
 412:quantum/quantum.c ****     return false;
 413:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 414:quantum/quantum.c ****     if (record->event.pressed) {
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 416:quantum/quantum.c ****         rgblight_step();
 417:quantum/quantum.c ****       } else {
 418:quantum/quantum.c ****         rgblight_mode(15);
 419:quantum/quantum.c ****       }
 420:quantum/quantum.c ****     }
 421:quantum/quantum.c ****     return false;
 422:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 423:quantum/quantum.c ****     if (record->event.pressed) {
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 425:quantum/quantum.c ****         rgblight_step();
 426:quantum/quantum.c ****       } else {
 427:quantum/quantum.c ****         rgblight_mode(21);
 428:quantum/quantum.c ****       }
 429:quantum/quantum.c ****     }
 430:quantum/quantum.c ****     return false;
 431:quantum/quantum.c ****   case RGB_MODE_XMAS:
 432:quantum/quantum.c ****     if (record->event.pressed) {
 433:quantum/quantum.c ****       rgblight_mode(24);
 434:quantum/quantum.c ****     }
 435:quantum/quantum.c ****     return false;
 436:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 437:quantum/quantum.c ****     if (record->event.pressed) {
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 439:quantum/quantum.c ****         rgblight_step();
 440:quantum/quantum.c ****       } else {
 441:quantum/quantum.c ****         rgblight_mode(25);
 442:quantum/quantum.c ****       }
 443:quantum/quantum.c ****     }
 444:quantum/quantum.c ****     return false;
 445:quantum/quantum.c ****   #endif
 446:quantum/quantum.c ****     #ifdef PROTOCOL_LUFA
 447:quantum/quantum.c ****     case OUT_AUTO:
 448:quantum/quantum.c ****       if (record->event.pressed) {
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 450:quantum/quantum.c ****       }
 451:quantum/quantum.c ****       return false;
 452:quantum/quantum.c ****     case OUT_USB:
 453:quantum/quantum.c ****       if (record->event.pressed) {
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 455:quantum/quantum.c ****       }
 456:quantum/quantum.c ****       return false;
 457:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 458:quantum/quantum.c ****     case OUT_BT:
 459:quantum/quantum.c ****       if (record->event.pressed) {
 460:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 461:quantum/quantum.c ****       }
 462:quantum/quantum.c ****       return false;
 463:quantum/quantum.c ****     #endif
 464:quantum/quantum.c ****     #endif
 465:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 466:quantum/quantum.c ****       if (record->event.pressed) {
 617               		.loc 1 466 0
 618 00ca F801      		movw r30,r16
 619 00cc 8281      		ldd r24,Z+2
 620 00ce 8823      		tst r24
 621 00d0 01F4      		brne .+2
 622 00d2 00C0      		rjmp .L74
 467:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 468:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 623               		.loc 1 468 0
 624 00d4 0E94 0000 		call eeconfig_is_enabled
 625               	.LVL64:
 626 00d8 8111      		cpse r24,__zero_reg__
 627 00da 00C0      		rjmp .L75
 469:quantum/quantum.c ****             eeconfig_init();
 628               		.loc 1 469 0
 629 00dc 0E94 0000 		call eeconfig_init
 630               	.LVL65:
 631               	.L75:
 470:quantum/quantum.c ****         }
 471:quantum/quantum.c ****         /* keymap config */
 472:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 632               		.loc 1 472 0
 633 00e0 0E94 0000 		call eeconfig_read_keymap
 634               	.LVL66:
 635 00e4 90E0      		ldi r25,0
 636 00e6 9093 0000 		sts keymap_config+1,r25
 637 00ea 8093 0000 		sts keymap_config,r24
 473:quantum/quantum.c ****         switch (keycode)
 638               		.loc 1 473 0
 639 00ee FE01      		movw r30,r28
 640 00f0 E350      		subi r30,3
 641 00f2 FC45      		sbci r31,92
 642 00f4 E231      		cpi r30,18
 643 00f6 F105      		cpc r31,__zero_reg__
 644 00f8 00F4      		brsh .L76
 645 00fa E050      		subi r30,lo8(-(gs(.L78)))
 646 00fc F040      		sbci r31,hi8(-(gs(.L78)))
 647 00fe 0C94 0000 		jmp __tablejump2__
 648               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 649               		.p2align	1
 650               	.L78:
 651 0000 0000      		.word gs(.L77)
 652 0002 0000      		.word gs(.L79)
 653 0004 0000      		.word gs(.L80)
 654 0006 0000      		.word gs(.L81)
 655 0008 0000      		.word gs(.L82)
 656 000a 0000      		.word gs(.L83)
 657 000c 0000      		.word gs(.L84)
 658 000e 0000      		.word gs(.L85)
 659 0010 0000      		.word gs(.L86)
 660 0012 0000      		.word gs(.L87)
 661 0014 0000      		.word gs(.L88)
 662 0016 0000      		.word gs(.L89)
 663 0018 0000      		.word gs(.L90)
 664 001a 0000      		.word gs(.L91)
 665 001c 0000      		.word gs(.L92)
 666 001e 0000      		.word gs(.L93)
 667 0020 0000      		.word gs(.L94)
 668 0022 0000      		.word gs(.L95)
 669               		.section	.text.process_record_quantum
 670               	.L76:
 474:quantum/quantum.c ****         {
 475:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 476:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 671               		.loc 1 476 0
 672 0102 8091 0000 		lds r24,keymap_config
 673 0106 8160      		ori r24,lo8(1<<0)
 674 0108 00C0      		rjmp .L208
 675               	.L77:
 477:quantum/quantum.c ****             break;
 478:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 479:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 676               		.loc 1 479 0
 677 010a 8091 0000 		lds r24,keymap_config
 678 010e 8260      		ori r24,lo8(1<<1)
 679               	.L208:
 680 0110 8093 0000 		sts keymap_config,r24
 480:quantum/quantum.c ****             break;
 681               		.loc 1 480 0
 682 0114 00C0      		rjmp .L96
 683               	.L79:
 481:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 482:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 684               		.loc 1 482 0
 685 0116 8091 0000 		lds r24,keymap_config
 686 011a 8460      		ori r24,lo8(1<<2)
 687 011c 00C0      		rjmp .L208
 688               	.L80:
 483:quantum/quantum.c ****             break;
 484:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 485:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 689               		.loc 1 485 0
 690 011e 8091 0000 		lds r24,keymap_config
 691 0122 00C0      		rjmp .L214
 692               	.L81:
 486:quantum/quantum.c ****             break;
 487:quantum/quantum.c ****           case MAGIC_NO_GUI:
 488:quantum/quantum.c ****             keymap_config.no_gui = true;
 693               		.loc 1 488 0
 694 0124 8091 0000 		lds r24,keymap_config
 695 0128 8061      		ori r24,lo8(1<<4)
 696 012a 00C0      		rjmp .L208
 697               	.L82:
 489:quantum/quantum.c ****             break;
 490:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 491:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 698               		.loc 1 491 0
 699 012c 8091 0000 		lds r24,keymap_config
 700 0130 8062      		ori r24,lo8(1<<5)
 701 0132 00C0      		rjmp .L208
 702               	.L83:
 492:quantum/quantum.c ****             break;
 493:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 494:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 703               		.loc 1 494 0
 704 0134 8091 0000 		lds r24,keymap_config
 705 0138 8064      		ori r24,lo8(1<<6)
 706 013a 00C0      		rjmp .L208
 707               	.L84:
 495:quantum/quantum.c ****             break;
 496:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 497:quantum/quantum.c ****             keymap_config.nkro = true;
 708               		.loc 1 497 0
 709 013c 8091 0000 		lds r24,keymap_config
 710 0140 8068      		ori r24,lo8(1<<7)
 711 0142 00C0      		rjmp .L208
 712               	.L85:
 498:quantum/quantum.c ****             break;
 499:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 500:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 713               		.loc 1 500 0
 714 0144 8091 0000 		lds r24,keymap_config
 501:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 715               		.loc 1 501 0
 716 0148 8460      		ori r24,lo8(4)
 717               	.L214:
 718 014a 8860      		ori r24,lo8(1<<3)
 719 014c 00C0      		rjmp .L208
 720               	.L86:
 502:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 503:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 504:quantum/quantum.c ****             #endif
 505:quantum/quantum.c ****             break;
 506:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 507:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 721               		.loc 1 507 0
 722 014e 8091 0000 		lds r24,keymap_config
 723 0152 8E7F      		andi r24,lo8(~(1<<0))
 724 0154 00C0      		rjmp .L208
 725               	.L87:
 508:quantum/quantum.c ****             break;
 509:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 510:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 726               		.loc 1 510 0
 727 0156 8091 0000 		lds r24,keymap_config
 728 015a 8D7F      		andi r24,lo8(~(1<<1))
 729 015c 00C0      		rjmp .L208
 730               	.L88:
 511:quantum/quantum.c ****             break;
 512:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 513:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 731               		.loc 1 513 0
 732 015e 8091 0000 		lds r24,keymap_config
 733 0162 8B7F      		andi r24,lo8(~(1<<2))
 734 0164 00C0      		rjmp .L208
 735               	.L89:
 514:quantum/quantum.c ****             break;
 515:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 516:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 736               		.loc 1 516 0
 737 0166 8091 0000 		lds r24,keymap_config
 738 016a 00C0      		rjmp .L213
 739               	.L90:
 517:quantum/quantum.c ****             break;
 518:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 519:quantum/quantum.c ****             keymap_config.no_gui = false;
 740               		.loc 1 519 0
 741 016c 8091 0000 		lds r24,keymap_config
 742 0170 8F7E      		andi r24,lo8(~(1<<4))
 743 0172 00C0      		rjmp .L208
 744               	.L91:
 520:quantum/quantum.c ****             break;
 521:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 522:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 745               		.loc 1 522 0
 746 0174 8091 0000 		lds r24,keymap_config
 747 0178 8F7D      		andi r24,lo8(~(1<<5))
 748 017a 00C0      		rjmp .L208
 749               	.L92:
 523:quantum/quantum.c ****             break;
 524:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 525:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 750               		.loc 1 525 0
 751 017c 8091 0000 		lds r24,keymap_config
 752 0180 8F7B      		andi r24,lo8(~(1<<6))
 753 0182 00C0      		rjmp .L208
 754               	.L93:
 526:quantum/quantum.c ****             break;
 527:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 528:quantum/quantum.c ****             keymap_config.nkro = false;
 755               		.loc 1 528 0
 756 0184 8091 0000 		lds r24,keymap_config
 757 0188 8F77      		andi r24,lo8(~(1<<7))
 758 018a 00C0      		rjmp .L208
 759               	.L94:
 529:quantum/quantum.c ****             break;
 530:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 531:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 760               		.loc 1 531 0
 761 018c 8091 0000 		lds r24,keymap_config
 532:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 762               		.loc 1 532 0
 763 0190 8B7F      		andi r24,lo8(-5)
 764               	.L213:
 765 0192 877F      		andi r24,lo8(~(1<<3))
 766 0194 00C0      		rjmp .L208
 767               	.L95:
 533:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 534:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 535:quantum/quantum.c ****             #endif
 536:quantum/quantum.c ****             break;
 537:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 538:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 768               		.loc 1 538 0
 769 0196 9091 0000 		lds r25,keymap_config
 770 019a 97FB      		bst r25,7
 771 019c 8827      		clr r24
 772 019e 80F9      		bld r24,0
 773 01a0 21E0      		ldi r18,lo8(1)
 774 01a2 8227      		eor r24,r18
 775 01a4 80FB      		bst r24,0
 776 01a6 97F9      		bld r25,7
 777 01a8 9093 0000 		sts keymap_config,r25
 778               	.L96:
 539:quantum/quantum.c ****             break;
 540:quantum/quantum.c ****           default:
 541:quantum/quantum.c ****             break;
 542:quantum/quantum.c ****         }
 543:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 779               		.loc 1 543 0
 780 01ac 8091 0000 		lds r24,keymap_config
 781 01b0 0E94 0000 		call eeconfig_update_keymap
 782               	.LVL67:
 544:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 783               		.loc 1 544 0
 784 01b4 0E94 0000 		call clear_keyboard
 785               	.LVL68:
 545:quantum/quantum.c **** 
 546:quantum/quantum.c ****         return false;
 786               		.loc 1 546 0
 787 01b8 00C0      		rjmp .L151
 788               	.L219:
 284:quantum/quantum.c ****   switch(keycode) {
 789               		.loc 1 284 0
 790 01ba C115      		cp r28,__zero_reg__
 791 01bc 9CE5      		ldi r25,92
 792 01be D907      		cpc r29,r25
 793 01c0 01F0      		breq .L41
 794 01c2 C130      		cpi r28,1
 795 01c4 DC45      		sbci r29,92
 796 01c6 01F0      		breq .L43
 797               	.L115:
 547:quantum/quantum.c ****       }
 548:quantum/quantum.c ****       break;
 549:quantum/quantum.c ****     case KC_LSPO: {
 550:quantum/quantum.c ****       if (record->event.pressed) {
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 554:quantum/quantum.c ****       }
 555:quantum/quantum.c ****       else {
 556:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 557:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 558:quantum/quantum.c ****             shift_interrupted[0] = true;
 559:quantum/quantum.c ****             shift_interrupted[1] = true;
 560:quantum/quantum.c ****           }
 561:quantum/quantum.c ****         #endif
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 565:quantum/quantum.c ****         }
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 567:quantum/quantum.c ****       }
 568:quantum/quantum.c ****       return false;
 569:quantum/quantum.c ****     }
 570:quantum/quantum.c **** 
 571:quantum/quantum.c ****     case KC_RSPC: {
 572:quantum/quantum.c ****       if (record->event.pressed) {
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 576:quantum/quantum.c ****       }
 577:quantum/quantum.c ****       else {
 578:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 579:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 580:quantum/quantum.c ****             shift_interrupted[0] = true;
 581:quantum/quantum.c ****             shift_interrupted[1] = true;
 582:quantum/quantum.c ****           }
 583:quantum/quantum.c ****         #endif
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 587:quantum/quantum.c ****         }
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 589:quantum/quantum.c ****       }
 590:quantum/quantum.c ****       return false;
 591:quantum/quantum.c ****     }
 592:quantum/quantum.c **** 
 593:quantum/quantum.c ****     case KC_SFTENT: {
 594:quantum/quantum.c ****       if (record->event.pressed) {
 595:quantum/quantum.c ****         shift_interrupted[1] = false;
 596:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 597:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 598:quantum/quantum.c ****       }
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 603:quantum/quantum.c ****       }
 604:quantum/quantum.c ****       else {
 605:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 606:quantum/quantum.c ****       }
 607:quantum/quantum.c ****       return false;
 608:quantum/quantum.c ****     }
 609:quantum/quantum.c **** 
 610:quantum/quantum.c ****     case GRAVE_ESC: {
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 612:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 613:quantum/quantum.c **** 
 614:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 615:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 616:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 617:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 618:quantum/quantum.c ****         shifted = 0;
 619:quantum/quantum.c ****       }
 620:quantum/quantum.c **** #endif
 621:quantum/quantum.c **** 
 622:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 623:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 624:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 625:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 626:quantum/quantum.c ****         shifted = 0;
 627:quantum/quantum.c ****       }
 628:quantum/quantum.c **** #endif
 629:quantum/quantum.c **** 
 630:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 631:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 632:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 633:quantum/quantum.c ****         shifted = 0;
 634:quantum/quantum.c ****       }
 635:quantum/quantum.c **** #endif
 636:quantum/quantum.c **** 
 637:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 638:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 639:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 640:quantum/quantum.c ****         shifted = 0;
 641:quantum/quantum.c ****       }
 642:quantum/quantum.c **** #endif
 643:quantum/quantum.c **** 
 644:quantum/quantum.c ****       if (record->event.pressed) {
 645:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 646:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 647:quantum/quantum.c ****       }
 648:quantum/quantum.c ****       else {
 649:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 650:quantum/quantum.c ****       }
 651:quantum/quantum.c **** 
 652:quantum/quantum.c ****       send_keyboard_report();
 653:quantum/quantum.c ****       return false;
 654:quantum/quantum.c ****     }
 655:quantum/quantum.c **** 
 656:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 657:quantum/quantum.c ****     case BL_BRTG: {
 658:quantum/quantum.c ****       if (record->event.pressed)
 659:quantum/quantum.c ****         breathing_toggle();
 660:quantum/quantum.c ****       return false;
 661:quantum/quantum.c ****     }
 662:quantum/quantum.c **** #endif
 663:quantum/quantum.c **** 
 664:quantum/quantum.c ****     default: {
 665:quantum/quantum.c ****       shift_interrupted[0] = true;
 798               		.loc 1 665 0
 799 01c8 81E0      		ldi r24,lo8(1)
 800 01ca 8093 0000 		sts shift_interrupted,r24
 666:quantum/quantum.c ****       shift_interrupted[1] = true;
 801               		.loc 1 666 0
 802 01ce 8093 0000 		sts shift_interrupted+1,r24
 803               	.L74:
 667:quantum/quantum.c ****       break;
 668:quantum/quantum.c ****     }
 669:quantum/quantum.c ****   }
 670:quantum/quantum.c **** 
 671:quantum/quantum.c ****   return process_action_kb(record);
 804               		.loc 1 671 0
 805 01d2 C801      		movw r24,r16
 806               	/* epilogue start */
 672:quantum/quantum.c **** }
 807               		.loc 1 672 0
 808 01d4 DF91      		pop r29
 809 01d6 CF91      		pop r28
 810               	.LVL69:
 811 01d8 1F91      		pop r17
 812 01da 0F91      		pop r16
 813               	.LVL70:
 671:quantum/quantum.c ****   return process_action_kb(record);
 814               		.loc 1 671 0
 815 01dc 0C94 0000 		jmp process_action_kb
 816               	.LVL71:
 817               	.L41:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 818               		.loc 1 286 0
 819 01e0 F801      		movw r30,r16
 820 01e2 8281      		ldd r24,Z+2
 821 01e4 8823      		tst r24
 822 01e6 01F4      		brne .+2
 823 01e8 00C0      		rjmp .L151
 287:quantum/quantum.c ****         reset_keyboard();
 824               		.loc 1 287 0
 825 01ea 0E94 0000 		call reset_keyboard
 826               	.LVL72:
 827 01ee 00C0      		rjmp .L151
 828               	.L43:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 829               		.loc 1 291 0
 830 01f0 F801      		movw r30,r16
 831 01f2 8281      		ldd r24,Z+2
 832 01f4 8823      		tst r24
 833 01f6 01F4      		brne .+2
 834 01f8 00C0      		rjmp .L151
 292:quantum/quantum.c ****           debug_enable = true;
 835               		.loc 1 292 0
 836 01fa 8091 0000 		lds r24,debug_config
 837 01fe 8160      		ori r24,lo8(1<<0)
 838 0200 8093 0000 		sts debug_config,r24
 839 0204 00C0      		rjmp .L151
 840               	.L118:
 284:quantum/quantum.c ****   switch(keycode) {
 841               		.loc 1 284 0
 842 0206 C531      		cpi r28,21
 843 0208 FCE5      		ldi r31,92
 844 020a DF07      		cpc r29,r31
 845 020c 01F4      		brne .L220
 846               	.LBB36:
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 847               		.loc 1 611 0
 848 020e 0E94 0000 		call get_mods
 849               	.LVL73:
 850 0212 382F      		mov r19,r24
 851               	.LVL74:
 644:quantum/quantum.c ****       if (record->event.pressed) {
 852               		.loc 1 644 0
 853 0214 F801      		movw r30,r16
 854 0216 2281      		ldd r18,Z+2
 855 0218 8091 0000 		lds r24,keyboard_report
 856 021c 9091 0000 		lds r25,keyboard_report+1
 857 0220 2223      		tst r18
 858 0222 01F0      		breq .L110
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 859               		.loc 1 611 0
 860 0224 3A7A      		andi r19,lo8(-86)
 861               	.LVL75:
 645:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 862               		.loc 1 645 0
 863 0226 21E0      		ldi r18,lo8(1)
 864 0228 01F4      		brne .L111
 865 022a 20E0      		ldi r18,0
 866               	.L111:
 867 022c 2093 0000 		sts grave_esc_was_shifted,r18
 646:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 868               		.loc 1 646 0
 869 0230 2223      		tst r18
 870 0232 01F0      		breq .L123
 871 0234 65E3      		ldi r22,lo8(53)
 872 0236 00C0      		rjmp .L112
 873               	.L123:
 874 0238 69E2      		ldi r22,lo8(41)
 875               	.L112:
 876               	.LVL76:
 877               	.LBB37:
 878               	.LBB38:
 879               		.file 3 "./tmk_core/common/action_util.h"
   1:./tmk_core/common/action_util.h **** /*
   2:./tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action_util.h **** 
   4:./tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action_util.h **** (at your option) any later version.
   8:./tmk_core/common/action_util.h **** 
   9:./tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:./tmk_core/common/action_util.h **** 
  14:./tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action_util.h **** */
  17:./tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:./tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:./tmk_core/common/action_util.h **** 
  20:./tmk_core/common/action_util.h **** #include <stdint.h>
  21:./tmk_core/common/action_util.h **** #include "report.h"
  22:./tmk_core/common/action_util.h **** 
  23:./tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:./tmk_core/common/action_util.h **** extern "C" {
  25:./tmk_core/common/action_util.h **** #endif
  26:./tmk_core/common/action_util.h **** 
  27:./tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:./tmk_core/common/action_util.h **** 
  29:./tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:./tmk_core/common/action_util.h **** 
  31:./tmk_core/common/action_util.h **** /* key */
  32:./tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 880               		.loc 3 33 0 discriminator 1
 881 023a 0E94 0000 		call add_key_to_report
 882               	.LVL77:
 883 023e 00C0      		rjmp .L113
 884               	.LVL78:
 885               	.L110:
 886               	.LBE38:
 887               	.LBE37:
 649:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 888               		.loc 1 649 0
 889 0240 2091 0000 		lds r18,grave_esc_was_shifted
 890 0244 2223      		tst r18
 891 0246 01F0      		breq .L124
 892 0248 65E3      		ldi r22,lo8(53)
 893 024a 00C0      		rjmp .L114
 894               	.L124:
 895 024c 69E2      		ldi r22,lo8(41)
 896               	.L114:
 897               	.LVL79:
 898               	.LBB39:
 899               	.LBB40:
  34:./tmk_core/common/action_util.h **** }
  35:./tmk_core/common/action_util.h **** 
  36:./tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:./tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 900               		.loc 3 37 0 discriminator 3
 901 024e 0E94 0000 		call del_key_from_report
 902               	.LVL80:
 903               	.L113:
 904               	.LBE40:
 905               	.LBE39:
 652:quantum/quantum.c ****       send_keyboard_report();
 906               		.loc 1 652 0
 907 0252 0E94 0000 		call send_keyboard_report
 908               	.LVL81:
 653:quantum/quantum.c ****       return false;
 909               		.loc 1 653 0
 910 0256 00C0      		rjmp .L151
 911               	.L220:
 912               	.LBE36:
 284:quantum/quantum.c ****   switch(keycode) {
 913               		.loc 1 284 0
 914 0258 C03C      		cpi r28,-64
 915 025a DC45      		sbci r29,92
 916 025c 01F0      		breq .+2
 917 025e 00C0      		rjmp .L115
 315:quantum/quantum.c ****     if (record->event.pressed) {
 918               		.loc 1 315 0
 919 0260 F801      		movw r30,r16
 920 0262 8281      		ldd r24,Z+2
 921 0264 8823      		tst r24
 922 0266 01F4      		brne .+2
 923 0268 00C0      		rjmp .L151
 316:quantum/quantum.c ****       rgblight_toggle();
 924               		.loc 1 316 0
 925 026a 0E94 0000 		call rgblight_toggle
 926               	.LVL82:
 927 026e 00C0      		rjmp .L151
 928               	.L51:
 352:quantum/quantum.c ****     if (record->event.pressed) {
 929               		.loc 1 352 0
 930 0270 8823      		tst r24
 931 0272 01F4      		brne .+2
 932 0274 00C0      		rjmp .L151
 353:quantum/quantum.c ****       rgblight_increase_sat();
 933               		.loc 1 353 0
 934 0276 0E94 0000 		call rgblight_increase_sat
 935               	.LVL83:
 936 027a 00C0      		rjmp .L151
 937               	.L49:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 938               		.loc 1 342 0
 939 027c 8823      		tst r24
 940 027e 01F4      		brne .+2
 941 0280 00C0      		rjmp .L151
 343:quantum/quantum.c ****       rgblight_increase_hue();
 942               		.loc 1 343 0
 943 0282 0E94 0000 		call rgblight_increase_hue
 944               	.LVL84:
 945 0286 00C0      		rjmp .L151
 946               	.L218:
 347:quantum/quantum.c ****     if (record->event.pressed) {
 947               		.loc 1 347 0
 948 0288 8823      		tst r24
 949 028a 01F4      		brne .+2
 950 028c 00C0      		rjmp .L151
 348:quantum/quantum.c ****       rgblight_decrease_hue();
 951               		.loc 1 348 0
 952 028e 0E94 0000 		call rgblight_decrease_hue
 953               	.LVL85:
 954 0292 00C0      		rjmp .L151
 955               	.L119:
 284:quantum/quantum.c ****   switch(keycode) {
 956               		.loc 1 284 0
 957 0294 C73C      		cpi r28,-57
 958 0296 9CE5      		ldi r25,92
 959 0298 D907      		cpc r29,r25
 960 029a 01F4      		brne .L221
 362:quantum/quantum.c ****     if (record->event.pressed) {
 961               		.loc 1 362 0
 962 029c 8823      		tst r24
 963 029e 01F4      		brne .+2
 964 02a0 00C0      		rjmp .L151
 363:quantum/quantum.c ****       rgblight_increase_val();
 965               		.loc 1 363 0
 966 02a2 0E94 0000 		call rgblight_increase_val
 967               	.LVL86:
 968 02a6 00C0      		rjmp .L151
 969               	.L221:
 284:quantum/quantum.c ****   switch(keycode) {
 970               		.loc 1 284 0
 971 02a8 C83C      		cpi r28,-56
 972 02aa DC45      		sbci r29,92
 973 02ac 00F4      		brsh .L222
 357:quantum/quantum.c ****     if (record->event.pressed) {
 974               		.loc 1 357 0
 975 02ae 8823      		tst r24
 976 02b0 01F4      		brne .+2
 977 02b2 00C0      		rjmp .L151
 358:quantum/quantum.c ****       rgblight_decrease_sat();
 978               		.loc 1 358 0
 979 02b4 0E94 0000 		call rgblight_decrease_sat
 980               	.LVL87:
 981 02b8 00C0      		rjmp .L151
 982               	.L222:
 367:quantum/quantum.c ****     if (record->event.pressed) {
 983               		.loc 1 367 0
 984 02ba 8823      		tst r24
 985 02bc 01F4      		brne .+2
 986 02be 00C0      		rjmp .L151
 368:quantum/quantum.c ****       rgblight_decrease_val();
 987               		.loc 1 368 0
 988 02c0 0E94 0000 		call rgblight_decrease_val
 989               	.LVL88:
 990 02c4 00C0      		rjmp .L151
 991               	.L116:
 284:quantum/quantum.c ****   switch(keycode) {
 992               		.loc 1 284 0
 993 02c6 C03D      		cpi r28,-48
 994 02c8 FCE5      		ldi r31,92
 995 02ca DF07      		cpc r29,r31
 996 02cc 01F4      		brne .L223
 423:quantum/quantum.c ****     if (record->event.pressed) {
 997               		.loc 1 423 0
 998 02ce F801      		movw r30,r16
 999 02d0 8281      		ldd r24,Z+2
 1000 02d2 8823      		tst r24
 1001 02d4 01F4      		brne .+2
 1002 02d6 00C0      		rjmp .L151
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 1003               		.loc 1 424 0
 1004 02d8 0E94 0000 		call rgblight_get_mode
 1005               	.LVL89:
 1006 02dc 6531      		cpi r22,21
 1007 02de 7105      		cpc r23,__zero_reg__
 1008 02e0 8105      		cpc r24,__zero_reg__
 1009 02e2 9105      		cpc r25,__zero_reg__
 1010 02e4 00F0      		brlo .L67
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 1011               		.loc 1 424 0 is_stmt 0 discriminator 1
 1012 02e6 0E94 0000 		call rgblight_get_mode
 1013               	.LVL90:
 1014 02ea 6731      		cpi r22,23
 1015 02ec 7105      		cpc r23,__zero_reg__
 1016 02ee 8105      		cpc r24,__zero_reg__
 1017 02f0 9105      		cpc r25,__zero_reg__
 1018 02f2 00F4      		brsh .+2
 1019 02f4 00C0      		rjmp .L46
 1020               	.L67:
 427:quantum/quantum.c ****         rgblight_mode(21);
 1021               		.loc 1 427 0 is_stmt 1
 1022 02f6 85E1      		ldi r24,lo8(21)
 1023               	.L209:
 391:quantum/quantum.c ****         rgblight_mode(2);
 1024               		.loc 1 391 0
 1025 02f8 0E94 0000 		call rgblight_mode
 1026               	.LVL91:
 1027 02fc 00C0      		rjmp .L151
 1028               	.L223:
 284:quantum/quantum.c ****   switch(keycode) {
 1029               		.loc 1 284 0
 1030 02fe C13D      		cpi r28,-47
 1031 0300 8CE5      		ldi r24,92
 1032 0302 D807      		cpc r29,r24
 1033 0304 00F0      		brlo .+2
 1034 0306 00C0      		rjmp .L120
 1035 0308 CC3C      		cpi r28,-52
 1036 030a 9CE5      		ldi r25,92
 1037 030c D907      		cpc r29,r25
 1038 030e 01F4      		brne .L224
 387:quantum/quantum.c ****     if (record->event.pressed) {
 1039               		.loc 1 387 0
 1040 0310 F801      		movw r30,r16
 1041 0312 8281      		ldd r24,Z+2
 1042 0314 8823      		tst r24
 1043 0316 01F4      		brne .+2
 1044 0318 00C0      		rjmp .L151
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 1045               		.loc 1 388 0
 1046 031a 0E94 0000 		call rgblight_get_mode
 1047               	.LVL92:
 1048 031e 6230      		cpi r22,2
 1049 0320 7105      		cpc r23,__zero_reg__
 1050 0322 8105      		cpc r24,__zero_reg__
 1051 0324 9105      		cpc r25,__zero_reg__
 1052 0326 00F0      		brlo .L59
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 1053               		.loc 1 388 0 is_stmt 0 discriminator 1
 1054 0328 0E94 0000 		call rgblight_get_mode
 1055               	.LVL93:
 1056 032c 6530      		cpi r22,5
 1057 032e 7105      		cpc r23,__zero_reg__
 1058 0330 8105      		cpc r24,__zero_reg__
 1059 0332 9105      		cpc r25,__zero_reg__
 1060 0334 00F4      		brsh .+2
 1061 0336 00C0      		rjmp .L46
 1062               	.L59:
 391:quantum/quantum.c ****         rgblight_mode(2);
 1063               		.loc 1 391 0 is_stmt 1
 1064 0338 82E0      		ldi r24,lo8(2)
 1065 033a 00C0      		rjmp .L209
 1066               	.L224:
 284:quantum/quantum.c ****   switch(keycode) {
 1067               		.loc 1 284 0
 1068 033c CD3C      		cpi r28,-51
 1069 033e ECE5      		ldi r30,92
 1070 0340 DE07      		cpc r29,r30
 1071 0342 00F4      		brsh .L121
 1072 0344 CA3C      		cpi r28,-54
 1073 0346 FCE5      		ldi r31,92
 1074 0348 DF07      		cpc r29,r31
 1075 034a 01F4      		brne .L225
 377:quantum/quantum.c ****     if (record->event.pressed) {
 1076               		.loc 1 377 0
 1077 034c F801      		movw r30,r16
 1078 034e 8281      		ldd r24,Z+2
 1079 0350 8823      		tst r24
 1080 0352 01F4      		brne .+2
 1081 0354 00C0      		rjmp .L151
 378:quantum/quantum.c ****       rgblight_decrease_speed();
 1082               		.loc 1 378 0
 1083 0356 0E94 0000 		call rgblight_decrease_speed
 1084               	.LVL94:
 1085 035a 00C0      		rjmp .L151
 1086               	.L225:
 284:quantum/quantum.c ****   switch(keycode) {
 1087               		.loc 1 284 0
 1088 035c CB3C      		cpi r28,-53
 1089 035e DC45      		sbci r29,92
 1090 0360 01F0      		breq .+2
 1091 0362 00C0      		rjmp .L115
 382:quantum/quantum.c ****     if (record->event.pressed) {
 1092               		.loc 1 382 0
 1093 0364 F801      		movw r30,r16
 1094 0366 8281      		ldd r24,Z+2
 1095 0368 8823      		tst r24
 1096 036a 01F4      		brne .+2
 1097 036c 00C0      		rjmp .L151
 383:quantum/quantum.c ****       rgblight_mode(1);
 1098               		.loc 1 383 0
 1099 036e 81E0      		ldi r24,lo8(1)
 1100 0370 00C0      		rjmp .L209
 1101               	.L121:
 1102 0372 F801      		movw r30,r16
 1103 0374 8281      		ldd r24,Z+2
 284:quantum/quantum.c ****   switch(keycode) {
 1104               		.loc 1 284 0
 1105 0376 CE3C      		cpi r28,-50
 1106 0378 FCE5      		ldi r31,92
 1107 037a DF07      		cpc r29,r31
 1108 037c 01F4      		brne .L226
 405:quantum/quantum.c ****     if (record->event.pressed) {
 1109               		.loc 1 405 0
 1110 037e 8823      		tst r24
 1111 0380 01F4      		brne .+2
 1112 0382 00C0      		rjmp .L151
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 1113               		.loc 1 406 0
 1114 0384 0E94 0000 		call rgblight_get_mode
 1115               	.LVL95:
 1116 0388 6930      		cpi r22,9
 1117 038a 7105      		cpc r23,__zero_reg__
 1118 038c 8105      		cpc r24,__zero_reg__
 1119 038e 9105      		cpc r25,__zero_reg__
 1120 0390 00F0      		brlo .L63
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 1121               		.loc 1 406 0 is_stmt 0 discriminator 1
 1122 0392 0E94 0000 		call rgblight_get_mode
 1123               	.LVL96:
 1124 0396 6E30      		cpi r22,14
 1125 0398 7105      		cpc r23,__zero_reg__
 1126 039a 8105      		cpc r24,__zero_reg__
 1127 039c 9105      		cpc r25,__zero_reg__
 1128 039e 00F4      		brsh .+2
 1129 03a0 00C0      		rjmp .L46
 1130               	.L63:
 409:quantum/quantum.c ****         rgblight_mode(9);
 1131               		.loc 1 409 0 is_stmt 1
 1132 03a2 89E0      		ldi r24,lo8(9)
 1133 03a4 00C0      		rjmp .L209
 1134               	.L226:
 284:quantum/quantum.c ****   switch(keycode) {
 1135               		.loc 1 284 0
 1136 03a6 CF3C      		cpi r28,-49
 1137 03a8 DC45      		sbci r29,92
 1138 03aa 00F4      		brsh .L227
 396:quantum/quantum.c ****     if (record->event.pressed) {
 1139               		.loc 1 396 0
 1140 03ac 8823      		tst r24
 1141 03ae 01F4      		brne .+2
 1142 03b0 00C0      		rjmp .L151
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 1143               		.loc 1 397 0
 1144 03b2 0E94 0000 		call rgblight_get_mode
 1145               	.LVL97:
 1146 03b6 6630      		cpi r22,6
 1147 03b8 7105      		cpc r23,__zero_reg__
 1148 03ba 8105      		cpc r24,__zero_reg__
 1149 03bc 9105      		cpc r25,__zero_reg__
 1150 03be 00F0      		brlo .L61
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 1151               		.loc 1 397 0 is_stmt 0 discriminator 1
 1152 03c0 0E94 0000 		call rgblight_get_mode
 1153               	.LVL98:
 1154 03c4 6830      		cpi r22,8
 1155 03c6 7105      		cpc r23,__zero_reg__
 1156 03c8 8105      		cpc r24,__zero_reg__
 1157 03ca 9105      		cpc r25,__zero_reg__
 1158 03cc 00F4      		brsh .+2
 1159 03ce 00C0      		rjmp .L46
 1160               	.L61:
 400:quantum/quantum.c ****         rgblight_mode(6);
 1161               		.loc 1 400 0 is_stmt 1
 1162 03d0 86E0      		ldi r24,lo8(6)
 1163 03d2 00C0      		rjmp .L209
 1164               	.L227:
 414:quantum/quantum.c ****     if (record->event.pressed) {
 1165               		.loc 1 414 0
 1166 03d4 8823      		tst r24
 1167 03d6 01F4      		brne .+2
 1168 03d8 00C0      		rjmp .L151
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 1169               		.loc 1 415 0
 1170 03da 0E94 0000 		call rgblight_get_mode
 1171               	.LVL99:
 1172 03de 6F30      		cpi r22,15
 1173 03e0 7105      		cpc r23,__zero_reg__
 1174 03e2 8105      		cpc r24,__zero_reg__
 1175 03e4 9105      		cpc r25,__zero_reg__
 1176 03e6 00F0      		brlo .L65
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 1177               		.loc 1 415 0 is_stmt 0 discriminator 1
 1178 03e8 0E94 0000 		call rgblight_get_mode
 1179               	.LVL100:
 1180 03ec 6431      		cpi r22,20
 1181 03ee 7105      		cpc r23,__zero_reg__
 1182 03f0 8105      		cpc r24,__zero_reg__
 1183 03f2 9105      		cpc r25,__zero_reg__
 1184 03f4 00F4      		brsh .+2
 1185 03f6 00C0      		rjmp .L46
 1186               	.L65:
 418:quantum/quantum.c ****         rgblight_mode(15);
 1187               		.loc 1 418 0 is_stmt 1
 1188 03f8 8FE0      		ldi r24,lo8(15)
 1189 03fa 00C0      		rjmp .L209
 1190               	.L120:
 284:quantum/quantum.c ****   switch(keycode) {
 1191               		.loc 1 284 0
 1192 03fc C43D      		cpi r28,-44
 1193 03fe ECE5      		ldi r30,92
 1194 0400 DE07      		cpc r29,r30
 1195 0402 01F4      		brne .L228
 572:quantum/quantum.c ****       if (record->event.pressed) {
 1196               		.loc 1 572 0
 1197 0404 F801      		movw r30,r16
 1198 0406 8281      		ldd r24,Z+2
 1199 0408 8823      		tst r24
 1200 040a 01F0      		breq .L103
 1201               	.L108:
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 1202               		.loc 1 573 0
 1203 040c 1092 0000 		sts shift_interrupted+1,__zero_reg__
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 1204               		.loc 1 574 0
 1205 0410 0E94 0000 		call timer_read
 1206               	.LVL101:
 1207 0414 9093 0000 		sts scs_timer+2+1,r25
 1208 0418 8093 0000 		sts scs_timer+2,r24
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 1209               		.loc 1 575 0
 1210 041c 80E2      		ldi r24,lo8(32)
 1211               	.L211:
 1212 041e 0E94 0000 		call register_mods
 1213               	.LVL102:
 1214 0422 00C0      		rjmp .L151
 1215               	.L103:
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1216               		.loc 1 584 0
 1217 0424 8091 0000 		lds r24,shift_interrupted+1
 1218 0428 8111      		cpse r24,__zero_reg__
 1219 042a 00C0      		rjmp .L105
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1220               		.loc 1 584 0 is_stmt 0 discriminator 1
 1221 042c 8091 0000 		lds r24,scs_timer+2
 1222 0430 9091 0000 		lds r25,scs_timer+2+1
 1223 0434 0E94 0000 		call timer_elapsed
 1224               	.LVL103:
 1225 0438 883C      		cpi r24,-56
 1226 043a 9105      		cpc r25,__zero_reg__
 1227 043c 00F4      		brsh .L105
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 1228               		.loc 1 585 0 is_stmt 1
 1229 043e 87E2      		ldi r24,lo8(39)
 1230 0440 0E94 0000 		call register_code
 1231               	.LVL104:
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 1232               		.loc 1 586 0
 1233 0444 87E2      		ldi r24,lo8(39)
 1234 0446 0E94 0000 		call unregister_code
 1235               	.LVL105:
 1236               	.L105:
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1237               		.loc 1 588 0
 1238 044a 80E2      		ldi r24,lo8(32)
 1239               	.L210:
 1240 044c 0E94 0000 		call unregister_mods
 1241               	.LVL106:
 1242 0450 00C0      		rjmp .L151
 1243               	.L228:
 284:quantum/quantum.c ****   switch(keycode) {
 1244               		.loc 1 284 0
 1245 0452 C53D      		cpi r28,-43
 1246 0454 FCE5      		ldi r31,92
 1247 0456 DF07      		cpc r29,r31
 1248 0458 00F0      		brlo .+2
 1249 045a 00C0      		rjmp .L122
 1250 045c F801      		movw r30,r16
 1251 045e 8281      		ldd r24,Z+2
 1252 0460 C23D      		cpi r28,-46
 1253 0462 FCE5      		ldi r31,92
 1254 0464 DF07      		cpc r29,r31
 1255 0466 01F4      		brne .L229
 437:quantum/quantum.c ****     if (record->event.pressed) {
 1256               		.loc 1 437 0
 1257 0468 8823      		tst r24
 1258 046a 01F4      		brne .+2
 1259 046c 00C0      		rjmp .L151
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 1260               		.loc 1 438 0
 1261 046e 0E94 0000 		call rgblight_get_mode
 1262               	.LVL107:
 1263 0472 6931      		cpi r22,25
 1264 0474 7105      		cpc r23,__zero_reg__
 1265 0476 8105      		cpc r24,__zero_reg__
 1266 0478 9105      		cpc r25,__zero_reg__
 1267 047a 00F0      		brlo .L70
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 1268               		.loc 1 438 0 is_stmt 0 discriminator 1
 1269 047c 0E94 0000 		call rgblight_get_mode
 1270               	.LVL108:
 1271 0480 6232      		cpi r22,34
 1272 0482 7105      		cpc r23,__zero_reg__
 1273 0484 8105      		cpc r24,__zero_reg__
 1274 0486 9105      		cpc r25,__zero_reg__
 1275 0488 00F4      		brsh .+2
 1276 048a 00C0      		rjmp .L46
 1277               	.L70:
 441:quantum/quantum.c ****         rgblight_mode(25);
 1278               		.loc 1 441 0 is_stmt 1
 1279 048c 89E1      		ldi r24,lo8(25)
 1280 048e 00C0      		rjmp .L209
 1281               	.L229:
 284:quantum/quantum.c ****   switch(keycode) {
 1282               		.loc 1 284 0
 1283 0490 C33D      		cpi r28,-45
 1284 0492 DC45      		sbci r29,92
 1285 0494 00F4      		brsh .L230
 432:quantum/quantum.c ****     if (record->event.pressed) {
 1286               		.loc 1 432 0
 1287 0496 8823      		tst r24
 1288 0498 01F4      		brne .+2
 1289 049a 00C0      		rjmp .L151
 433:quantum/quantum.c ****       rgblight_mode(24);
 1290               		.loc 1 433 0
 1291 049c 88E1      		ldi r24,lo8(24)
 1292 049e 00C0      		rjmp .L209
 1293               	.L230:
 550:quantum/quantum.c ****       if (record->event.pressed) {
 1294               		.loc 1 550 0
 1295 04a0 8823      		tst r24
 1296 04a2 01F0      		breq .L98
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 1297               		.loc 1 551 0
 1298 04a4 1092 0000 		sts shift_interrupted,__zero_reg__
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 1299               		.loc 1 552 0
 1300 04a8 0E94 0000 		call timer_read
 1301               	.LVL109:
 1302 04ac 9093 0000 		sts scs_timer+1,r25
 1303 04b0 8093 0000 		sts scs_timer,r24
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 1304               		.loc 1 553 0
 1305 04b4 82E0      		ldi r24,lo8(2)
 1306 04b6 00C0      		rjmp .L211
 1307               	.L98:
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 1308               		.loc 1 562 0
 1309 04b8 8091 0000 		lds r24,shift_interrupted
 1310 04bc 8111      		cpse r24,__zero_reg__
 1311 04be 00C0      		rjmp .L100
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 1312               		.loc 1 562 0 is_stmt 0 discriminator 1
 1313 04c0 8091 0000 		lds r24,scs_timer
 1314 04c4 9091 0000 		lds r25,scs_timer+1
 1315 04c8 0E94 0000 		call timer_elapsed
 1316               	.LVL110:
 1317 04cc 883C      		cpi r24,-56
 1318 04ce 9105      		cpc r25,__zero_reg__
 1319 04d0 00F4      		brsh .L100
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 1320               		.loc 1 563 0 is_stmt 1
 1321 04d2 86E2      		ldi r24,lo8(38)
 1322 04d4 0E94 0000 		call register_code
 1323               	.LVL111:
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 1324               		.loc 1 564 0
 1325 04d8 86E2      		ldi r24,lo8(38)
 1326 04da 0E94 0000 		call unregister_code
 1327               	.LVL112:
 1328               	.L100:
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 1329               		.loc 1 566 0
 1330 04de 82E0      		ldi r24,lo8(2)
 1331 04e0 00C0      		rjmp .L210
 1332               	.L122:
 284:quantum/quantum.c ****   switch(keycode) {
 1333               		.loc 1 284 0
 1334 04e2 C83D      		cpi r28,-40
 1335 04e4 ECE5      		ldi r30,92
 1336 04e6 DE07      		cpc r29,r30
 1337 04e8 01F4      		brne .L231
 448:quantum/quantum.c ****       if (record->event.pressed) {
 1338               		.loc 1 448 0
 1339 04ea F801      		movw r30,r16
 1340 04ec 8281      		ldd r24,Z+2
 1341 04ee 8823      		tst r24
 1342 04f0 01F0      		breq .L151
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 1343               		.loc 1 449 0
 1344 04f2 80E0      		ldi r24,0
 1345 04f4 00C0      		rjmp .L212
 1346               	.L231:
 284:quantum/quantum.c ****   switch(keycode) {
 1347               		.loc 1 284 0
 1348 04f6 C93D      		cpi r28,-39
 1349 04f8 FCE5      		ldi r31,92
 1350 04fa DF07      		cpc r29,r31
 1351 04fc 01F4      		brne .L232
 453:quantum/quantum.c ****       if (record->event.pressed) {
 1352               		.loc 1 453 0
 1353 04fe F801      		movw r30,r16
 1354 0500 8281      		ldd r24,Z+2
 1355 0502 8823      		tst r24
 1356 0504 01F0      		breq .L151
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 1357               		.loc 1 454 0
 1358 0506 82E0      		ldi r24,lo8(2)
 1359               	.L212:
 1360 0508 0E94 0000 		call set_output
 1361               	.LVL113:
 1362 050c 00C0      		rjmp .L151
 1363               	.L232:
 284:quantum/quantum.c ****   switch(keycode) {
 1364               		.loc 1 284 0
 1365 050e C53D      		cpi r28,-43
 1366 0510 DC45      		sbci r29,92
 1367 0512 01F0      		breq .+2
 1368 0514 00C0      		rjmp .L115
 594:quantum/quantum.c ****       if (record->event.pressed) {
 1369               		.loc 1 594 0
 1370 0516 F801      		movw r30,r16
 1371 0518 8281      		ldd r24,Z+2
 1372 051a 8111      		cpse r24,__zero_reg__
 1373 051c 00C0      		rjmp .L108
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1374               		.loc 1 599 0
 1375 051e 8091 0000 		lds r24,shift_interrupted+1
 1376 0522 8111      		cpse r24,__zero_reg__
 1377 0524 00C0      		rjmp .L105
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1378               		.loc 1 599 0 is_stmt 0 discriminator 1
 1379 0526 8091 0000 		lds r24,scs_timer+2
 1380 052a 9091 0000 		lds r25,scs_timer+2+1
 1381 052e 0E94 0000 		call timer_elapsed
 1382               	.LVL114:
 1383 0532 883C      		cpi r24,-56
 1384 0534 9105      		cpc r25,__zero_reg__
 1385 0536 00F0      		brlo .+2
 1386 0538 00C0      		rjmp .L105
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1387               		.loc 1 600 0 is_stmt 1
 1388 053a 80E2      		ldi r24,lo8(32)
 1389 053c 0E94 0000 		call unregister_mods
 1390               	.LVL115:
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 1391               		.loc 1 601 0
 1392 0540 88E2      		ldi r24,lo8(40)
 1393 0542 0E94 0000 		call register_code
 1394               	.LVL116:
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 1395               		.loc 1 602 0
 1396 0546 88E2      		ldi r24,lo8(40)
 1397 0548 0E94 0000 		call unregister_code
 1398               	.LVL117:
 1399               	.L151:
 1400               		.loc 1 672 0
 1401 054c 80E0      		ldi r24,0
 1402               	/* epilogue start */
 1403 054e DF91      		pop r29
 1404 0550 CF91      		pop r28
 1405               	.LVL118:
 1406 0552 1F91      		pop r17
 1407 0554 0F91      		pop r16
 1408               	.LVL119:
 1409 0556 0895      		ret
 1410               		.cfi_endproc
 1411               	.LFE24:
 1413               		.section	.text.send_char,"ax",@progbits
 1414               	.global	send_char
 1416               	send_char:
 1417               	.LFB29:
 673:quantum/quantum.c **** 
 674:quantum/quantum.c **** __attribute__ ((weak))
 675:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 676:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 677:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 678:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 679:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 680:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 681:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 682:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 683:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 684:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 685:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 686:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 687:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 688:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 689:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 690:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 691:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 692:quantum/quantum.c **** };
 693:quantum/quantum.c **** 
 694:quantum/quantum.c **** __attribute__ ((weak))
 695:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 696:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 697:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 698:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 699:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 700:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 701:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 702:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 703:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 704:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 705:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 706:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 707:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 708:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 709:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 710:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 711:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 712:quantum/quantum.c **** };
 713:quantum/quantum.c **** 
 714:quantum/quantum.c **** void send_string(const char *str) {
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 716:quantum/quantum.c **** }
 717:quantum/quantum.c **** 
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 720:quantum/quantum.c **** }
 721:quantum/quantum.c **** 
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 723:quantum/quantum.c ****     while (1) {
 724:quantum/quantum.c ****         char ascii_code = *str;
 725:quantum/quantum.c ****         if (!ascii_code) break;
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 727:quantum/quantum.c ****           // tap
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 729:quantum/quantum.c ****           register_code(keycode);
 730:quantum/quantum.c ****           unregister_code(keycode);
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 732:quantum/quantum.c ****           // down
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 734:quantum/quantum.c ****           register_code(keycode);
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 736:quantum/quantum.c ****           // up
 737:quantum/quantum.c ****           uint8_t keycode = *(++str);
 738:quantum/quantum.c ****           unregister_code(keycode);
 739:quantum/quantum.c ****         } else {
 740:quantum/quantum.c ****           send_char(ascii_code);
 741:quantum/quantum.c ****         }
 742:quantum/quantum.c ****         ++str;
 743:quantum/quantum.c ****         // interval
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 745:quantum/quantum.c ****     }
 746:quantum/quantum.c **** }
 747:quantum/quantum.c **** 
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 749:quantum/quantum.c ****     while (1) {
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 751:quantum/quantum.c ****         if (!ascii_code) break;
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 753:quantum/quantum.c ****           // tap
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 755:quantum/quantum.c ****           register_code(keycode);
 756:quantum/quantum.c ****           unregister_code(keycode);
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 758:quantum/quantum.c ****           // down
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 760:quantum/quantum.c ****           register_code(keycode);
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 762:quantum/quantum.c ****           // up
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 764:quantum/quantum.c ****           unregister_code(keycode);
 765:quantum/quantum.c ****         } else {
 766:quantum/quantum.c ****           send_char(ascii_code);
 767:quantum/quantum.c ****         }
 768:quantum/quantum.c ****         ++str;
 769:quantum/quantum.c ****         // interval
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 771:quantum/quantum.c ****     }
 772:quantum/quantum.c **** }
 773:quantum/quantum.c **** 
 774:quantum/quantum.c **** void send_char(char ascii_code) {
 1418               		.loc 1 774 0
 1419               		.cfi_startproc
 1420               	.LVL120:
 1421 0000 CF93      		push r28
 1422               	.LCFI12:
 1423               		.cfi_def_cfa_offset 3
 1424               		.cfi_offset 28, -2
 1425               	/* prologue: function */
 1426               	/* frame size = 0 */
 1427               	/* stack size = 1 */
 1428               	.L__stack_usage = 1
 1429               	.LBB41:
 775:quantum/quantum.c ****   uint8_t keycode;
 776:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 1430               		.loc 1 776 0
 1431 0002 282F      		mov r18,r24
 1432 0004 30E0      		ldi r19,0
 1433               	.LVL121:
 1434 0006 F901      		movw r30,r18
 1435 0008 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 1436 000a F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 1437               	.LVL122:
 1438               	/* #APP */
 1439               	 ;  776 "quantum/quantum.c" 1
 1440 000c C491      		lpm r28, Z
 1441               		
 1442               	 ;  0 "" 2
 1443               	.LVL123:
 1444               	/* #NOAPP */
 1445               	.LBE41:
 1446               	.LBB42:
 777:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 1447               		.loc 1 777 0
 1448 000e F901      		movw r30,r18
 1449               	.LVL124:
 1450 0010 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 1451 0012 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 1452               	.LVL125:
 1453               	/* #APP */
 1454               	 ;  777 "quantum/quantum.c" 1
 1455 0014 2491      		lpm r18, Z
 1456               		
 1457               	 ;  0 "" 2
 1458               	.LVL126:
 1459               	/* #NOAPP */
 1460               	.LBE42:
 1461 0016 2223      		tst r18
 1462 0018 01F0      		breq .L234
 778:quantum/quantum.c ****       register_code(KC_LSFT);
 1463               		.loc 1 778 0
 1464 001a 81EE      		ldi r24,lo8(-31)
 1465               	.LVL127:
 1466 001c 0E94 0000 		call register_code
 1467               	.LVL128:
 779:quantum/quantum.c ****       register_code(keycode);
 1468               		.loc 1 779 0
 1469 0020 8C2F      		mov r24,r28
 1470 0022 0E94 0000 		call register_code
 1471               	.LVL129:
 780:quantum/quantum.c ****       unregister_code(keycode);
 1472               		.loc 1 780 0
 1473 0026 8C2F      		mov r24,r28
 1474 0028 0E94 0000 		call unregister_code
 1475               	.LVL130:
 781:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1476               		.loc 1 781 0
 1477 002c 81EE      		ldi r24,lo8(-31)
 1478 002e 00C0      		rjmp .L235
 1479               	.LVL131:
 1480               	.L234:
 782:quantum/quantum.c ****   } else {
 783:quantum/quantum.c ****       register_code(keycode);
 1481               		.loc 1 783 0
 1482 0030 8C2F      		mov r24,r28
 1483               	.LVL132:
 1484 0032 0E94 0000 		call register_code
 1485               	.LVL133:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1486               		.loc 1 784 0
 1487 0036 8C2F      		mov r24,r28
 1488               	.L235:
 1489               	/* epilogue start */
 785:quantum/quantum.c ****   }
 786:quantum/quantum.c **** }
 1490               		.loc 1 786 0
 1491 0038 CF91      		pop r28
 1492               	.LVL134:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1493               		.loc 1 784 0
 1494 003a 0C94 0000 		jmp unregister_code
 1495               	.LVL135:
 1496               		.cfi_endproc
 1497               	.LFE29:
 1499               		.section	.text.send_string_with_delay,"ax",@progbits
 1500               	.global	send_string_with_delay
 1502               	send_string_with_delay:
 1503               	.LFB27:
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 1504               		.loc 1 722 0
 1505               		.cfi_startproc
 1506               	.LVL136:
 1507 0000 FF92      		push r15
 1508               	.LCFI13:
 1509               		.cfi_def_cfa_offset 3
 1510               		.cfi_offset 15, -2
 1511 0002 0F93      		push r16
 1512               	.LCFI14:
 1513               		.cfi_def_cfa_offset 4
 1514               		.cfi_offset 16, -3
 1515 0004 1F93      		push r17
 1516               	.LCFI15:
 1517               		.cfi_def_cfa_offset 5
 1518               		.cfi_offset 17, -4
 1519 0006 CF93      		push r28
 1520               	.LCFI16:
 1521               		.cfi_def_cfa_offset 6
 1522               		.cfi_offset 28, -5
 1523 0008 DF93      		push r29
 1524               	.LCFI17:
 1525               		.cfi_def_cfa_offset 7
 1526               		.cfi_offset 29, -6
 1527               	/* prologue: function */
 1528               	/* frame size = 0 */
 1529               	/* stack size = 5 */
 1530               	.L__stack_usage = 5
 1531 000a EC01      		movw r28,r24
 1532 000c F62E      		mov r15,r22
 1533               	.LVL137:
 1534               	.L244:
 1535               	.LBB43:
 724:quantum/quantum.c ****         char ascii_code = *str;
 1536               		.loc 1 724 0
 1537 000e 8881      		ld r24,Y
 1538               	.LVL138:
 725:quantum/quantum.c ****         if (!ascii_code) break;
 1539               		.loc 1 725 0
 1540 0010 8823      		tst r24
 1541 0012 01F0      		breq .L236
 1542 0014 8E01      		movw r16,r28
 1543 0016 0F5F      		subi r16,-1
 1544 0018 1F4F      		sbci r17,-1
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 1545               		.loc 1 726 0
 1546 001a 8130      		cpi r24,lo8(1)
 1547 001c 01F4      		brne .L238
 1548               	.LVL139:
 1549               	.LBB44:
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 1550               		.loc 1 728 0
 1551 001e C981      		ldd r28,Y+1
 1552               	.LVL140:
 729:quantum/quantum.c ****           register_code(keycode);
 1553               		.loc 1 729 0
 1554 0020 8C2F      		mov r24,r28
 1555               	.LVL141:
 1556 0022 0E94 0000 		call register_code
 1557               	.LVL142:
 730:quantum/quantum.c ****           unregister_code(keycode);
 1558               		.loc 1 730 0
 1559 0026 8C2F      		mov r24,r28
 1560 0028 00C0      		rjmp .L246
 1561               	.LVL143:
 1562               	.L238:
 1563               	.LBE44:
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1564               		.loc 1 731 0
 1565 002a 8230      		cpi r24,lo8(2)
 1566 002c 01F4      		brne .L240
 1567               	.LVL144:
 1568               	.LBB45:
 734:quantum/quantum.c ****           register_code(keycode);
 1569               		.loc 1 734 0
 1570 002e 8981      		ldd r24,Y+1
 1571               	.LVL145:
 1572 0030 0E94 0000 		call register_code
 1573               	.LVL146:
 1574               	.L245:
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 1575               		.loc 1 733 0
 1576 0034 E801      		movw r28,r16
 1577               	.LBE45:
 1578 0036 00C0      		rjmp .L239
 1579               	.LVL147:
 1580               	.L240:
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1581               		.loc 1 735 0
 1582 0038 8330      		cpi r24,lo8(3)
 1583 003a 01F4      		brne .L241
 1584               	.LVL148:
 1585               	.LBB46:
 738:quantum/quantum.c ****           unregister_code(keycode);
 1586               		.loc 1 738 0
 1587 003c 8981      		ldd r24,Y+1
 1588               	.LVL149:
 1589               	.L246:
 1590 003e 0E94 0000 		call unregister_code
 1591               	.LVL150:
 1592 0042 00C0      		rjmp .L245
 1593               	.LVL151:
 1594               	.L241:
 1595               	.LBE46:
 740:quantum/quantum.c ****           send_char(ascii_code);
 1596               		.loc 1 740 0
 1597 0044 0E94 0000 		call send_char
 1598               	.LVL152:
 1599               	.L239:
 742:quantum/quantum.c ****         ++str;
 1600               		.loc 1 742 0
 1601 0048 2196      		adiw r28,1
 1602               	.LVL153:
 1603               	.LBB47:
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1604               		.loc 1 744 0
 1605 004a 8F2D      		mov r24,r15
 1606               	.LVL154:
 1607               	.L242:
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1608               		.loc 1 744 0 is_stmt 0 discriminator 1
 1609 004c 8823      		tst r24
 1610 004e 01F0      		breq .L244
 1611               	.LVL155:
 1612               	.LBB48:
 1613               	.LBB49:
 1614               		.loc 2 164 0 is_stmt 1
 1615 0050 EFE9      		ldi r30,lo8(3999)
 1616 0052 FFE0      		ldi r31,hi8(3999)
 1617 0054 3197      		1: sbiw r30,1
 1618 0056 01F4      		brne 1b
 1619 0058 00C0      		rjmp .
 1620 005a 0000      		nop
 1621 005c 8150      		subi r24,lo8(-(-1))
 1622               	.LVL156:
 1623 005e 00C0      		rjmp .L242
 1624               	.LVL157:
 1625               	.L236:
 1626               	/* epilogue start */
 1627               	.LBE49:
 1628               	.LBE48:
 1629               	.LBE47:
 1630               	.LBE43:
 746:quantum/quantum.c **** }
 1631               		.loc 1 746 0
 1632 0060 DF91      		pop r29
 1633 0062 CF91      		pop r28
 1634               	.LVL158:
 1635 0064 1F91      		pop r17
 1636 0066 0F91      		pop r16
 1637 0068 FF90      		pop r15
 1638               	.LVL159:
 1639 006a 0895      		ret
 1640               		.cfi_endproc
 1641               	.LFE27:
 1643               		.section	.text.send_string,"ax",@progbits
 1644               	.global	send_string
 1646               	send_string:
 1647               	.LFB25:
 714:quantum/quantum.c **** void send_string(const char *str) {
 1648               		.loc 1 714 0
 1649               		.cfi_startproc
 1650               	.LVL160:
 1651               	/* prologue: function */
 1652               	/* frame size = 0 */
 1653               	/* stack size = 0 */
 1654               	.L__stack_usage = 0
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 1655               		.loc 1 715 0
 1656 0000 60E0      		ldi r22,0
 1657 0002 0C94 0000 		jmp send_string_with_delay
 1658               	.LVL161:
 1659               		.cfi_endproc
 1660               	.LFE25:
 1662               		.section	.text.send_string_with_delay_P,"ax",@progbits
 1663               	.global	send_string_with_delay_P
 1665               	send_string_with_delay_P:
 1666               	.LFB28:
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 1667               		.loc 1 748 0
 1668               		.cfi_startproc
 1669               	.LVL162:
 1670 0000 0F93      		push r16
 1671               	.LCFI18:
 1672               		.cfi_def_cfa_offset 3
 1673               		.cfi_offset 16, -2
 1674 0002 1F93      		push r17
 1675               	.LCFI19:
 1676               		.cfi_def_cfa_offset 4
 1677               		.cfi_offset 17, -3
 1678 0004 CF93      		push r28
 1679               	.LCFI20:
 1680               		.cfi_def_cfa_offset 5
 1681               		.cfi_offset 28, -4
 1682 0006 DF93      		push r29
 1683               	.LCFI21:
 1684               		.cfi_def_cfa_offset 6
 1685               		.cfi_offset 29, -5
 1686               	/* prologue: function */
 1687               	/* frame size = 0 */
 1688               	/* stack size = 4 */
 1689               	.L__stack_usage = 4
 1690 0008 EC01      		movw r28,r24
 1691 000a 062F      		mov r16,r22
 1692               	.LVL163:
 1693               	.L256:
 1694               	.LBB50:
 1695               	.LBB51:
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 1696               		.loc 1 750 0
 1697 000c FE01      		movw r30,r28
 1698               	/* #APP */
 1699               	 ;  750 "quantum/quantum.c" 1
 1700 000e 8491      		lpm r24, Z
 1701               		
 1702               	 ;  0 "" 2
 1703               	.LVL164:
 1704               	/* #NOAPP */
 1705               	.LBE51:
 751:quantum/quantum.c ****         if (!ascii_code) break;
 1706               		.loc 1 751 0
 1707 0010 8823      		tst r24
 1708 0012 01F0      		breq .L248
 1709 0014 9E01      		movw r18,r28
 1710 0016 2F5F      		subi r18,-1
 1711 0018 3F4F      		sbci r19,-1
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 1712               		.loc 1 752 0
 1713 001a 8130      		cpi r24,lo8(1)
 1714 001c 01F4      		brne .L250
 1715               	.LBB52:
 1716               	.LBB53:
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1717               		.loc 1 754 0
 1718 001e E901      		movw r28,r18
 1719               	.LVL165:
 1720 0020 F901      		movw r30,r18
 1721               	.LVL166:
 1722               	/* #APP */
 1723               	 ;  754 "quantum/quantum.c" 1
 1724 0022 1491      		lpm r17, Z
 1725               		
 1726               	 ;  0 "" 2
 1727               	.LVL167:
 1728               	/* #NOAPP */
 1729               	.LBE53:
 755:quantum/quantum.c ****           register_code(keycode);
 1730               		.loc 1 755 0
 1731 0024 812F      		mov r24,r17
 1732               	.LVL168:
 1733 0026 0E94 0000 		call register_code
 1734               	.LVL169:
 756:quantum/quantum.c ****           unregister_code(keycode);
 1735               		.loc 1 756 0
 1736 002a 812F      		mov r24,r17
 1737 002c 00C0      		rjmp .L257
 1738               	.LVL170:
 1739               	.L250:
 1740               	.LBE52:
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1741               		.loc 1 757 0
 1742 002e 8230      		cpi r24,lo8(2)
 1743 0030 01F4      		brne .L252
 1744               	.LBB54:
 1745               	.LBB55:
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1746               		.loc 1 759 0
 1747 0032 E901      		movw r28,r18
 1748               	.LVL171:
 1749 0034 F901      		movw r30,r18
 1750               	.LVL172:
 1751               	/* #APP */
 1752               	 ;  759 "quantum/quantum.c" 1
 1753 0036 8491      		lpm r24, Z
 1754               		
 1755               	 ;  0 "" 2
 1756               	.LVL173:
 1757               	/* #NOAPP */
 1758               	.LBE55:
 760:quantum/quantum.c ****           register_code(keycode);
 1759               		.loc 1 760 0
 1760 0038 0E94 0000 		call register_code
 1761               	.LVL174:
 1762               	.LBE54:
 1763 003c 00C0      		rjmp .L251
 1764               	.LVL175:
 1765               	.L252:
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1766               		.loc 1 761 0
 1767 003e 8330      		cpi r24,lo8(3)
 1768 0040 01F4      		brne .L253
 1769               	.LBB56:
 1770               	.LBB57:
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1771               		.loc 1 763 0
 1772 0042 E901      		movw r28,r18
 1773               	.LVL176:
 1774 0044 F901      		movw r30,r18
 1775               	.LVL177:
 1776               	/* #APP */
 1777               	 ;  763 "quantum/quantum.c" 1
 1778 0046 8491      		lpm r24, Z
 1779               		
 1780               	 ;  0 "" 2
 1781               	.LVL178:
 1782               	/* #NOAPP */
 1783               	.L257:
 1784               	.LBE57:
 764:quantum/quantum.c ****           unregister_code(keycode);
 1785               		.loc 1 764 0
 1786 0048 0E94 0000 		call unregister_code
 1787               	.LVL179:
 1788               	.LBE56:
 1789 004c 00C0      		rjmp .L251
 1790               	.LVL180:
 1791               	.L253:
 766:quantum/quantum.c ****           send_char(ascii_code);
 1792               		.loc 1 766 0
 1793 004e 0E94 0000 		call send_char
 1794               	.LVL181:
 1795               	.L251:
 768:quantum/quantum.c ****         ++str;
 1796               		.loc 1 768 0
 1797 0052 2196      		adiw r28,1
 1798               	.LVL182:
 1799               	.LBB58:
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1800               		.loc 1 770 0
 1801 0054 802F      		mov r24,r16
 1802               	.LVL183:
 1803               	.L254:
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1804               		.loc 1 770 0 is_stmt 0 discriminator 1
 1805 0056 8823      		tst r24
 1806 0058 01F0      		breq .L256
 1807               	.LVL184:
 1808               	.LBB59:
 1809               	.LBB60:
 1810               		.loc 2 164 0 is_stmt 1
 1811 005a EFE9      		ldi r30,lo8(3999)
 1812 005c FFE0      		ldi r31,hi8(3999)
 1813 005e 3197      		1: sbiw r30,1
 1814 0060 01F4      		brne 1b
 1815 0062 00C0      		rjmp .
 1816 0064 0000      		nop
 1817 0066 8150      		subi r24,lo8(-(-1))
 1818               	.LVL185:
 1819 0068 00C0      		rjmp .L254
 1820               	.LVL186:
 1821               	.L248:
 1822               	/* epilogue start */
 1823               	.LBE60:
 1824               	.LBE59:
 1825               	.LBE58:
 1826               	.LBE50:
 772:quantum/quantum.c **** }
 1827               		.loc 1 772 0
 1828 006a DF91      		pop r29
 1829 006c CF91      		pop r28
 1830               	.LVL187:
 1831 006e 1F91      		pop r17
 1832 0070 0F91      		pop r16
 1833               	.LVL188:
 1834 0072 0895      		ret
 1835               		.cfi_endproc
 1836               	.LFE28:
 1838               		.section	.text.send_string_P,"ax",@progbits
 1839               	.global	send_string_P
 1841               	send_string_P:
 1842               	.LFB26:
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 1843               		.loc 1 718 0
 1844               		.cfi_startproc
 1845               	.LVL189:
 1846               	/* prologue: function */
 1847               	/* frame size = 0 */
 1848               	/* stack size = 0 */
 1849               	.L__stack_usage = 0
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1850               		.loc 1 719 0
 1851 0000 60E0      		ldi r22,0
 1852 0002 0C94 0000 		jmp send_string_with_delay_P
 1853               	.LVL190:
 1854               		.cfi_endproc
 1855               	.LFE26:
 1857               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1858               	.global	set_single_persistent_default_layer
 1860               	set_single_persistent_default_layer:
 1861               	.LFB30:
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1862               		.loc 1 788 0
 1863               		.cfi_startproc
 1864               	.LVL191:
 1865 0000 CF93      		push r28
 1866               	.LCFI22:
 1867               		.cfi_def_cfa_offset 3
 1868               		.cfi_offset 28, -2
 1869 0002 DF93      		push r29
 1870               	.LCFI23:
 1871               		.cfi_def_cfa_offset 4
 1872               		.cfi_offset 29, -3
 1873               	/* prologue: function */
 1874               	/* frame size = 0 */
 1875               	/* stack size = 2 */
 1876               	.L__stack_usage = 2
 789:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 790:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 791:quantum/quantum.c ****   #endif
 792:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1877               		.loc 1 792 0
 1878 0004 C1E0      		ldi r28,lo8(1)
 1879 0006 D0E0      		ldi r29,0
 1880 0008 00C0      		rjmp 2f
 1881               		1:
 1882 000a CC0F      		lsl r28
 1883 000c DD1F      		rol r29
 1884               		2:
 1885 000e 8A95      		dec r24
 1886 0010 02F4      		brpl 1b
 1887 0012 8C2F      		mov r24,r28
 1888               	.LVL192:
 1889 0014 0E94 0000 		call eeconfig_update_default_layer
 1890               	.LVL193:
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1891               		.loc 1 793 0
 1892 0018 BE01      		movw r22,r28
 1893 001a 80E0      		ldi r24,0
 1894 001c 90E0      		ldi r25,0
 1895               	/* epilogue start */
 794:quantum/quantum.c **** }
 1896               		.loc 1 794 0
 1897 001e DF91      		pop r29
 1898 0020 CF91      		pop r28
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1899               		.loc 1 793 0
 1900 0022 0C94 0000 		jmp default_layer_set
 1901               	.LVL194:
 1902               		.cfi_endproc
 1903               	.LFE30:
 1905               		.section	.text.update_tri_layer_state,"ax",@progbits
 1906               	.global	update_tri_layer_state
 1908               	update_tri_layer_state:
 1909               	.LFB31:
 795:quantum/quantum.c **** 
 796:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1910               		.loc 1 796 0
 1911               		.cfi_startproc
 1912               	.LVL195:
 1913 0000 4F92      		push r4
 1914               	.LCFI24:
 1915               		.cfi_def_cfa_offset 3
 1916               		.cfi_offset 4, -2
 1917 0002 5F92      		push r5
 1918               	.LCFI25:
 1919               		.cfi_def_cfa_offset 4
 1920               		.cfi_offset 5, -3
 1921 0004 6F92      		push r6
 1922               	.LCFI26:
 1923               		.cfi_def_cfa_offset 5
 1924               		.cfi_offset 6, -4
 1925 0006 7F92      		push r7
 1926               	.LCFI27:
 1927               		.cfi_def_cfa_offset 6
 1928               		.cfi_offset 7, -5
 1929 0008 8F92      		push r8
 1930               	.LCFI28:
 1931               		.cfi_def_cfa_offset 7
 1932               		.cfi_offset 8, -6
 1933 000a 9F92      		push r9
 1934               	.LCFI29:
 1935               		.cfi_def_cfa_offset 8
 1936               		.cfi_offset 9, -7
 1937 000c AF92      		push r10
 1938               	.LCFI30:
 1939               		.cfi_def_cfa_offset 9
 1940               		.cfi_offset 10, -8
 1941 000e BF92      		push r11
 1942               	.LCFI31:
 1943               		.cfi_def_cfa_offset 10
 1944               		.cfi_offset 11, -9
 1945 0010 CF92      		push r12
 1946               	.LCFI32:
 1947               		.cfi_def_cfa_offset 11
 1948               		.cfi_offset 12, -10
 1949 0012 DF92      		push r13
 1950               	.LCFI33:
 1951               		.cfi_def_cfa_offset 12
 1952               		.cfi_offset 13, -11
 1953 0014 EF92      		push r14
 1954               	.LCFI34:
 1955               		.cfi_def_cfa_offset 13
 1956               		.cfi_offset 14, -12
 1957 0016 FF92      		push r15
 1958               	.LCFI35:
 1959               		.cfi_def_cfa_offset 14
 1960               		.cfi_offset 15, -13
 1961 0018 0F93      		push r16
 1962               	.LCFI36:
 1963               		.cfi_def_cfa_offset 15
 1964               		.cfi_offset 16, -14
 1965 001a 1F93      		push r17
 1966               	.LCFI37:
 1967               		.cfi_def_cfa_offset 16
 1968               		.cfi_offset 17, -15
 1969               	/* prologue: function */
 1970               	/* frame size = 0 */
 1971               	/* stack size = 14 */
 1972               	.L__stack_usage = 14
 1973 001c 2B01      		movw r4,r22
 1974 001e 3C01      		movw r6,r24
 797:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 1975               		.loc 1 797 0
 1976 0020 C12C      		mov r12,__zero_reg__
 1977 0022 D12C      		mov r13,__zero_reg__
 1978 0024 7601      		movw r14,r12
 1979 0026 C394      		inc r12
 1980 0028 D701      		movw r26,r14
 1981 002a C601      		movw r24,r12
 1982 002c 00C0      		rjmp 2f
 1983               		1:
 1984 002e 880F      		lsl r24
 1985 0030 991F      		rol r25
 1986 0032 AA1F      		rol r26
 1987 0034 BB1F      		rol r27
 1988               		2:
 1989 0036 4A95      		dec r20
 1990 0038 02F4      		brpl 1b
 1991 003a AC01      		movw r20,r24
 1992 003c BD01      		movw r22,r26
 1993               	.LVL196:
 1994 003e 4601      		movw r8,r12
 1995 0040 5701      		movw r10,r14
 1996 0042 00C0      		rjmp 2f
 1997               		1:
 1998 0044 880C      		lsl r8
 1999 0046 991C      		rol r9
 2000 0048 AA1C      		rol r10
 2001 004a BB1C      		rol r11
 2002               		2:
 2003 004c 2A95      		dec r18
 2004 004e 02F4      		brpl 1b
 2005 0050 4829      		or r20,r8
 2006 0052 5929      		or r21,r9
 2007 0054 6A29      		or r22,r10
 2008 0056 7B29      		or r23,r11
 2009               	.LVL197:
 798:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 2010               		.loc 1 798 0
 2011 0058 D701      		movw r26,r14
 2012 005a C601      		movw r24,r12
 2013 005c 00C0      		rjmp 2f
 2014               		1:
 2015 005e 880F      		lsl r24
 2016 0060 991F      		rol r25
 2017 0062 AA1F      		rol r26
 2018 0064 BB1F      		rol r27
 2019               		2:
 2020 0066 0A95      		dec r16
 2021 0068 02F4      		brpl 1b
 2022               	.LVL198:
 799:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 2023               		.loc 1 799 0
 2024 006a 6A01      		movw r12,r20
 2025 006c 7B01      		movw r14,r22
 2026 006e C420      		and r12,r4
 2027 0070 D520      		and r13,r5
 2028 0072 E620      		and r14,r6
 2029 0074 F720      		and r15,r7
 2030 0076 C416      		cp r12,r20
 2031 0078 D506      		cpc r13,r21
 2032 007a E606      		cpc r14,r22
 2033 007c F706      		cpc r15,r23
 2034 007e 01F4      		brne .L261
 2035               		.loc 1 799 0 is_stmt 0 discriminator 1
 2036 0080 BC01      		movw r22,r24
 2037 0082 CD01      		movw r24,r26
 2038               	.LVL199:
 2039 0084 6429      		or r22,r4
 2040 0086 7529      		or r23,r5
 2041 0088 8629      		or r24,r6
 2042 008a 9729      		or r25,r7
 2043 008c 00C0      		rjmp .L262
 2044               	.L261:
 2045               		.loc 1 799 0 discriminator 2
 2046 008e BC01      		movw r22,r24
 2047 0090 CD01      		movw r24,r26
 2048 0092 6095      		com r22
 2049 0094 7095      		com r23
 2050 0096 8095      		com r24
 2051 0098 9095      		com r25
 2052 009a 6421      		and r22,r4
 2053 009c 7521      		and r23,r5
 2054 009e 8621      		and r24,r6
 2055 00a0 9721      		and r25,r7
 2056               	.L262:
 2057               	/* epilogue start */
 800:quantum/quantum.c **** }
 2058               		.loc 1 800 0 is_stmt 1 discriminator 3
 2059 00a2 1F91      		pop r17
 2060 00a4 0F91      		pop r16
 2061               	.LVL200:
 2062 00a6 FF90      		pop r15
 2063               	.LVL201:
 2064 00a8 EF90      		pop r14
 2065               	.LVL202:
 2066 00aa DF90      		pop r13
 2067               	.LVL203:
 2068 00ac CF90      		pop r12
 2069               	.LVL204:
 2070 00ae BF90      		pop r11
 2071               	.LVL205:
 2072 00b0 AF90      		pop r10
 2073               	.LVL206:
 2074 00b2 9F90      		pop r9
 2075               	.LVL207:
 2076 00b4 8F90      		pop r8
 2077               	.LVL208:
 2078 00b6 7F90      		pop r7
 2079               	.LVL209:
 2080 00b8 6F90      		pop r6
 2081               	.LVL210:
 2082 00ba 5F90      		pop r5
 2083               	.LVL211:
 2084 00bc 4F90      		pop r4
 2085               	.LVL212:
 2086 00be 0895      		ret
 2087               		.cfi_endproc
 2088               	.LFE31:
 2090               		.section	.text.update_tri_layer,"ax",@progbits
 2091               	.global	update_tri_layer
 2093               	update_tri_layer:
 2094               	.LFB32:
 801:quantum/quantum.c **** 
 802:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 2095               		.loc 1 802 0
 2096               		.cfi_startproc
 2097               	.LVL213:
 2098 0000 0F93      		push r16
 2099               	.LCFI38:
 2100               		.cfi_def_cfa_offset 3
 2101               		.cfi_offset 16, -2
 2102               	/* prologue: function */
 2103               	/* frame size = 0 */
 2104               	/* stack size = 1 */
 2105               	.L__stack_usage = 1
 2106 0002 382F      		mov r19,r24
 2107 0004 262F      		mov r18,r22
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 2108               		.loc 1 803 0
 2109 0006 6091 0000 		lds r22,layer_state
 2110 000a 7091 0000 		lds r23,layer_state+1
 2111 000e 8091 0000 		lds r24,layer_state+2
 2112 0012 9091 0000 		lds r25,layer_state+3
 2113               	.LVL214:
 2114 0016 042F      		mov r16,r20
 2115 0018 432F      		mov r20,r19
 2116               	.LVL215:
 2117 001a 0E94 0000 		call update_tri_layer_state
 2118               	.LVL216:
 2119               	/* epilogue start */
 804:quantum/quantum.c **** }
 2120               		.loc 1 804 0
 2121 001e 0F91      		pop r16
 2122               	.LVL217:
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 2123               		.loc 1 803 0
 2124 0020 0C94 0000 		jmp layer_state_set
 2125               	.LVL218:
 2126               		.cfi_endproc
 2127               	.LFE32:
 2129               		.section	.text.tap_random_base64,"ax",@progbits
 2130               	.global	tap_random_base64
 2132               	tap_random_base64:
 2133               	.LFB33:
 805:quantum/quantum.c **** 
 806:quantum/quantum.c **** void tap_random_base64(void) {
 2134               		.loc 1 806 0
 2135               		.cfi_startproc
 2136 0000 CF93      		push r28
 2137               	.LCFI39:
 2138               		.cfi_def_cfa_offset 3
 2139               		.cfi_offset 28, -2
 2140               	/* prologue: function */
 2141               	/* frame size = 0 */
 2142               	/* stack size = 1 */
 2143               	.L__stack_usage = 1
 807:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 808:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 2144               		.loc 1 808 0
 2145 0002 66B5      		in r22,0x26
 2146 0004 4091 8400 		lds r20,132
 2147 0008 5091 8500 		lds r21,132+1
 2148 000c 8091 9400 		lds r24,148
 2149 0010 9091 9500 		lds r25,148+1
 2150 0014 2091 BE00 		lds r18,190
 2151 0018 3091 BF00 		lds r19,190+1
 2152 001c C42F      		mov r28,r20
 2153 001e C80F      		add r28,r24
 2154 0020 C60F      		add r28,r22
 2155 0022 C20F      		add r28,r18
 2156 0024 CF73      		andi r28,lo8(63)
 2157               	.LVL219:
 809:quantum/quantum.c ****   #else
 810:quantum/quantum.c ****     uint8_t key = rand() % 64;
 811:quantum/quantum.c ****   #endif
 812:quantum/quantum.c ****   switch (key) {
 2158               		.loc 1 812 0
 2159 0026 CE33      		cpi r28,lo8(62)
 2160 0028 00F4      		brsh .L266
 2161 002a C533      		cpi r28,lo8(53)
 2162 002c 00F4      		brsh .L267
 2163 002e CA31      		cpi r28,lo8(26)
 2164 0030 00F0      		brlo .L265
 2165 0032 C433      		cpi r28,lo8(52)
 2166 0034 00F4      		brsh .L272
 813:quantum/quantum.c ****     case 0 ... 25:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 815:quantum/quantum.c ****       register_code(key + KC_A);
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 817:quantum/quantum.c ****       unregister_code(KC_LSFT);
 818:quantum/quantum.c ****       break;
 819:quantum/quantum.c ****     case 26 ... 51:
 820:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 2167               		.loc 1 820 0
 2168 0036 C651      		subi r28,lo8(-(-22))
 2169               	.LVL220:
 2170 0038 00C0      		rjmp .L275
 2171               	.LVL221:
 2172               	.L266:
 812:quantum/quantum.c ****   switch (key) {
 2173               		.loc 1 812 0
 2174 003a CE33      		cpi r28,lo8(62)
 2175 003c 01F0      		breq .L270
 2176 003e CF33      		cpi r28,lo8(63)
 2177 0040 01F0      		breq .L271
 2178               	.L265:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 2179               		.loc 1 814 0
 2180 0042 81EE      		ldi r24,lo8(-31)
 2181 0044 0E94 0000 		call register_code
 2182               	.LVL222:
 815:quantum/quantum.c ****       register_code(key + KC_A);
 2183               		.loc 1 815 0
 2184 0048 CC5F      		subi r28,lo8(-(4))
 2185               	.LVL223:
 2186 004a 8C2F      		mov r24,r28
 2187 004c 0E94 0000 		call register_code
 2188               	.LVL224:
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 2189               		.loc 1 816 0
 2190 0050 8C2F      		mov r24,r28
 2191 0052 00C0      		rjmp .L274
 2192               	.LVL225:
 2193               	.L272:
 821:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 822:quantum/quantum.c ****       break;
 823:quantum/quantum.c ****     case 52:
 824:quantum/quantum.c ****       register_code(KC_0);
 2194               		.loc 1 824 0
 2195 0054 87E2      		ldi r24,lo8(39)
 2196 0056 0E94 0000 		call register_code
 2197               	.LVL226:
 825:quantum/quantum.c ****       unregister_code(KC_0);
 2198               		.loc 1 825 0
 2199 005a 87E2      		ldi r24,lo8(39)
 2200 005c 00C0      		rjmp .L273
 2201               	.L267:
 826:quantum/quantum.c ****       break;
 827:quantum/quantum.c ****     case 53 ... 61:
 828:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 2202               		.loc 1 828 0
 2203 005e C751      		subi r28,lo8(-(-23))
 2204               	.LVL227:
 2205               	.L275:
 2206 0060 8C2F      		mov r24,r28
 2207               	.LVL228:
 2208 0062 0E94 0000 		call register_code
 2209               	.LVL229:
 829:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 2210               		.loc 1 829 0
 2211 0066 8C2F      		mov r24,r28
 2212 0068 00C0      		rjmp .L273
 2213               	.LVL230:
 2214               	.L270:
 830:quantum/quantum.c ****       break;
 831:quantum/quantum.c ****     case 62:
 832:quantum/quantum.c ****       register_code(KC_LSFT);
 2215               		.loc 1 832 0
 2216 006a 81EE      		ldi r24,lo8(-31)
 2217 006c 0E94 0000 		call register_code
 2218               	.LVL231:
 833:quantum/quantum.c ****       register_code(KC_EQL);
 2219               		.loc 1 833 0
 2220 0070 8EE2      		ldi r24,lo8(46)
 2221 0072 0E94 0000 		call register_code
 2222               	.LVL232:
 834:quantum/quantum.c ****       unregister_code(KC_EQL);
 2223               		.loc 1 834 0
 2224 0076 8EE2      		ldi r24,lo8(46)
 2225               	.LVL233:
 2226               	.L274:
 2227 0078 0E94 0000 		call unregister_code
 2228               	.LVL234:
 835:quantum/quantum.c ****       unregister_code(KC_LSFT);
 2229               		.loc 1 835 0
 2230 007c 81EE      		ldi r24,lo8(-31)
 2231 007e 00C0      		rjmp .L273
 2232               	.LVL235:
 2233               	.L271:
 836:quantum/quantum.c ****       break;
 837:quantum/quantum.c ****     case 63:
 838:quantum/quantum.c ****       register_code(KC_SLSH);
 2234               		.loc 1 838 0
 2235 0080 88E3      		ldi r24,lo8(56)
 2236 0082 0E94 0000 		call register_code
 2237               	.LVL236:
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2238               		.loc 1 839 0
 2239 0086 88E3      		ldi r24,lo8(56)
 2240               	.LVL237:
 2241               	.L273:
 2242               	/* epilogue start */
 840:quantum/quantum.c ****       break;
 841:quantum/quantum.c ****   }
 842:quantum/quantum.c **** }
 2243               		.loc 1 842 0
 2244 0088 CF91      		pop r28
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2245               		.loc 1 839 0
 2246 008a 0C94 0000 		jmp unregister_code
 2247               	.LVL238:
 2248               		.cfi_endproc
 2249               	.LFE33:
 2251               		.section	.text.matrix_scan_quantum,"ax",@progbits
 2252               	.global	matrix_scan_quantum
 2254               	matrix_scan_quantum:
 2255               	.LFB35:
 843:quantum/quantum.c **** 
 844:quantum/quantum.c **** void matrix_init_quantum() {
 845:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 846:quantum/quantum.c ****     backlight_init_ports();
 847:quantum/quantum.c ****   #endif
 848:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 849:quantum/quantum.c ****     audio_init();
 850:quantum/quantum.c ****   #endif
 851:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 852:quantum/quantum.c ****     rgb_matrix_init_drivers();
 853:quantum/quantum.c ****   #endif
 854:quantum/quantum.c ****   matrix_init_kb();
 855:quantum/quantum.c **** }
 856:quantum/quantum.c **** 
 857:quantum/quantum.c **** uint8_t rgb_matrix_task_counter = 0;
 858:quantum/quantum.c **** 
 859:quantum/quantum.c **** #ifndef RGB_MATRIX_SKIP_FRAMES
 860:quantum/quantum.c ****   #define RGB_MATRIX_SKIP_FRAMES 1
 861:quantum/quantum.c **** #endif
 862:quantum/quantum.c **** 
 863:quantum/quantum.c **** void matrix_scan_quantum() {
 2256               		.loc 1 863 0
 2257               		.cfi_startproc
 2258               	/* prologue: function */
 2259               	/* frame size = 0 */
 2260               	/* stack size = 0 */
 2261               	.L__stack_usage = 0
 864:quantum/quantum.c ****   #if defined(AUDIO_ENABLE)
 865:quantum/quantum.c ****     matrix_scan_music();
 866:quantum/quantum.c ****   #endif
 867:quantum/quantum.c **** 
 868:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 869:quantum/quantum.c ****     matrix_scan_tap_dance();
 870:quantum/quantum.c ****   #endif
 871:quantum/quantum.c **** 
 872:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 873:quantum/quantum.c ****     matrix_scan_combo();
 874:quantum/quantum.c ****   #endif
 875:quantum/quantum.c **** 
 876:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 877:quantum/quantum.c ****     backlight_task();
 878:quantum/quantum.c ****   #endif
 879:quantum/quantum.c **** 
 880:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 881:quantum/quantum.c ****     rgb_matrix_task();
 882:quantum/quantum.c ****     if (rgb_matrix_task_counter == 0) {
 883:quantum/quantum.c ****       rgb_matrix_update_pwm_buffers();
 884:quantum/quantum.c ****     }
 885:quantum/quantum.c ****     rgb_matrix_task_counter = ((rgb_matrix_task_counter + 1) % (RGB_MATRIX_SKIP_FRAMES + 1));
 886:quantum/quantum.c ****   #endif
 887:quantum/quantum.c **** 
 888:quantum/quantum.c ****   matrix_scan_kb();
 2262               		.loc 1 888 0
 2263 0000 0C94 0000 		jmp matrix_scan_kb
 2264               	.LVL239:
 2265               		.cfi_endproc
 2266               	.LFE35:
 2268               		.section	.text.backlight_set,"ax",@progbits
 2269               		.weak	backlight_set
 2271               	backlight_set:
 2272               	.LFB38:
 889:quantum/quantum.c **** }
 890:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 891:quantum/quantum.c **** 
 892:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 893:quantum/quantum.c **** 
 894:quantum/quantum.c **** // depending on the pin, we use a different output compare unit
 895:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 896:quantum/quantum.c **** #  define COM1x1 COM1C1
 897:quantum/quantum.c **** #  define OCR1x  OCR1C
 898:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 899:quantum/quantum.c **** #  define COM1x1 COM1B1
 900:quantum/quantum.c **** #  define OCR1x  OCR1B
 901:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 902:quantum/quantum.c **** #  define COM1x1 COM1A1
 903:quantum/quantum.c **** #  define OCR1x  OCR1A
 904:quantum/quantum.c **** #else
 905:quantum/quantum.c **** #  define NO_HARDWARE_PWM
 906:quantum/quantum.c **** #endif
 907:quantum/quantum.c **** 
 908:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
 909:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
 910:quantum/quantum.c **** #endif
 911:quantum/quantum.c **** 
 912:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM // pwm through software
 913:quantum/quantum.c **** 
 914:quantum/quantum.c **** __attribute__ ((weak))
 915:quantum/quantum.c **** void backlight_init_ports(void)
 916:quantum/quantum.c **** {
 917:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
 918:quantum/quantum.c ****   // DDRx |= n
 919:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 920:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
 921:quantum/quantum.c ****     // PORTx &= ~n
 922:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 923:quantum/quantum.c ****   #else
 924:quantum/quantum.c ****     // PORTx |= n
 925:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 926:quantum/quantum.c ****   #endif
 927:quantum/quantum.c **** }
 928:quantum/quantum.c **** 
 929:quantum/quantum.c **** __attribute__ ((weak))
 930:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 931:quantum/quantum.c **** 
 932:quantum/quantum.c **** uint8_t backlight_tick = 0;
 933:quantum/quantum.c **** 
 934:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 935:quantum/quantum.c **** void backlight_task(void) {
 936:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
 937:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 938:quantum/quantum.c ****       // PORTx &= ~n
 939:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 940:quantum/quantum.c ****     #else
 941:quantum/quantum.c ****       // PORTx |= n
 942:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 943:quantum/quantum.c ****     #endif
 944:quantum/quantum.c ****   } else {
 945:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 946:quantum/quantum.c ****       // PORTx |= n
 947:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 948:quantum/quantum.c ****     #else
 949:quantum/quantum.c ****       // PORTx &= ~n
 950:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 951:quantum/quantum.c ****     #endif
 952:quantum/quantum.c ****   }
 953:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
 954:quantum/quantum.c **** }
 955:quantum/quantum.c **** #endif
 956:quantum/quantum.c **** 
 957:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 958:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
 959:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
 960:quantum/quantum.c ****   #endif
 961:quantum/quantum.c **** #endif
 962:quantum/quantum.c **** 
 963:quantum/quantum.c **** #else // pwm through timer
 964:quantum/quantum.c **** 
 965:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
 966:quantum/quantum.c **** 
 967:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
 968:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
 969:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
 970:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 971:quantum/quantum.c ****   else {
 972:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
 973:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
 974:quantum/quantum.c ****     // and revert what we've done again after squaring.
 975:quantum/quantum.c ****     y = y * y * y >> 8;
 976:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 977:quantum/quantum.c ****       return 0xFFFFU;
 978:quantum/quantum.c ****     else
 979:quantum/quantum.c ****       return (uint16_t) y;
 980:quantum/quantum.c ****   }
 981:quantum/quantum.c **** }
 982:quantum/quantum.c **** 
 983:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
 984:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
 985:quantum/quantum.c ****   OCR1x = val;
 986:quantum/quantum.c **** }
 987:quantum/quantum.c **** 
 988:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 989:quantum/quantum.c **** __attribute__ ((weak))
 990:quantum/quantum.c **** void backlight_set(uint8_t level) {
 2273               		.loc 1 990 0
 2274               		.cfi_startproc
 2275               	.LVL240:
 2276 0000 CF92      		push r12
 2277               	.LCFI40:
 2278               		.cfi_def_cfa_offset 3
 2279               		.cfi_offset 12, -2
 2280 0002 DF92      		push r13
 2281               	.LCFI41:
 2282               		.cfi_def_cfa_offset 4
 2283               		.cfi_offset 13, -3
 2284 0004 EF92      		push r14
 2285               	.LCFI42:
 2286               		.cfi_def_cfa_offset 5
 2287               		.cfi_offset 14, -4
 2288 0006 FF92      		push r15
 2289               	.LCFI43:
 2290               		.cfi_def_cfa_offset 6
 2291               		.cfi_offset 15, -5
 2292               	/* prologue: function */
 2293               	/* frame size = 0 */
 2294               	/* stack size = 4 */
 2295               	.L__stack_usage = 4
 991:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
 2296               		.loc 1 991 0
 2297 0008 8630      		cpi r24,lo8(6)
 2298 000a 00F4      		brsh .L282
 992:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 993:quantum/quantum.c **** 
 994:quantum/quantum.c ****   if (level == 0) {
 2299               		.loc 1 994 0
 2300 000c 8111      		cpse r24,__zero_reg__
 2301 000e 00C0      		rjmp .L278
 995:quantum/quantum.c ****     // Turn off PWM control on backlight pin
 996:quantum/quantum.c ****     TCCR1A &= ~(_BV(COM1x1));
 2302               		.loc 1 996 0
 2303 0010 9091 8000 		lds r25,128
 2304 0014 9F77      		andi r25,lo8(127)
 2305 0016 00C0      		rjmp .L284
 2306               	.L282:
 992:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 2307               		.loc 1 992 0
 2308 0018 85E0      		ldi r24,lo8(5)
 2309               	.LVL241:
 2310               	.L278:
 997:quantum/quantum.c ****   } else {
 998:quantum/quantum.c ****     // Turn on PWM control of backlight pin
 999:quantum/quantum.c ****     TCCR1A |= _BV(COM1x1);
 2311               		.loc 1 999 0
 2312 001a 9091 8000 		lds r25,128
 2313 001e 9068      		ori r25,lo8(-128)
 2314               	.L284:
 2315 0020 9093 8000 		sts 128,r25
1000:quantum/quantum.c ****   }
1001:quantum/quantum.c ****   // Set the brightness
1002:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
 2316               		.loc 1 1002 0
 2317 0024 282F      		mov r18,r24
 2318 0026 30E0      		ldi r19,0
 2319 0028 AFEF      		ldi r26,lo8(-1)
 2320 002a BFEF      		ldi r27,lo8(-1)
 2321 002c 0E94 0000 		call __umulhisi3
 2322 0030 25E0      		ldi r18,lo8(5)
 2323 0032 30E0      		ldi r19,0
 2324 0034 40E0      		ldi r20,0
 2325 0036 50E0      		ldi r21,0
 2326 0038 0E94 0000 		call __udivmodsi4
 2327 003c C901      		movw r24,r18
 2328               	.LVL242:
 2329               	.LBB66:
 2330               	.LBB67:
 969:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
 2331               		.loc 1 969 0
 2332 003e 2C37      		cpi r18,124
 2333 0040 64E1      		ldi r22,20
 2334 0042 3607      		cpc r19,r22
 2335 0044 00F4      		brsh .L280
 970:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 2336               		.loc 1 970 0
 2337 0046 69E0      		ldi r22,lo8(9)
 2338 0048 70E0      		ldi r23,0
 2339 004a 0E94 0000 		call __udivmodhi4
 2340 004e 00C0      		rjmp .L281
 2341               	.L280:
 2342               	.LBB68:
 972:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
 2343               		.loc 1 972 0
 2344 0050 DA01      		movw r26,r20
 2345 0052 C901      		movw r24,r18
 2346 0054 8A50      		subi r24,10
 2347 0056 974D      		sbci r25,-41
 2348 0058 AF4F      		sbci r26,-1
 2349 005a BF4F      		sbci r27,-1
 2350 005c 6627      		clr r22
 2351 005e 782F      		mov r23,r24
 2352 0060 892F      		mov r24,r25
 2353 0062 9A2F      		mov r25,r26
 2354               	.LVL243:
 2355 0064 25EF      		ldi r18,lo8(-11)
 2356 0066 38E2      		ldi r19,lo8(40)
 2357 0068 41E0      		ldi r20,lo8(1)
 2358 006a 50E0      		ldi r21,0
 2359 006c 0E94 0000 		call __udivmodsi4
 2360 0070 6901      		movw r12,r18
 2361 0072 7A01      		movw r14,r20
 2362               	.LVL244:
 975:quantum/quantum.c ****     y = y * y * y >> 8;
 2363               		.loc 1 975 0
 2364 0074 CA01      		movw r24,r20
 2365 0076 B901      		movw r22,r18
 2366 0078 0E94 0000 		call __mulsi3
 2367 007c 9B01      		movw r18,r22
 2368 007e AC01      		movw r20,r24
 2369 0080 C701      		movw r24,r14
 2370 0082 B601      		movw r22,r12
 2371 0084 0E94 0000 		call __mulsi3
 2372 0088 BB27      		clr r27
 2373 008a A92F      		mov r26,r25
 2374 008c 982F      		mov r25,r24
 2375 008e 872F      		mov r24,r23
 2376               	.LVL245:
 976:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 2377               		.loc 1 976 0
 2378 0090 0097      		sbiw r24,0
 2379 0092 21E0      		ldi r18,1
 2380 0094 A207      		cpc r26,r18
 2381 0096 B105      		cpc r27,__zero_reg__
 2382 0098 01F0      		breq .L283
 979:quantum/quantum.c ****       return (uint16_t) y;
 2383               		.loc 1 979 0
 2384 009a BC01      		movw r22,r24
 2385 009c 00C0      		rjmp .L281
 2386               	.L283:
 977:quantum/quantum.c ****       return 0xFFFFU;
 2387               		.loc 1 977 0
 2388 009e 6FEF      		ldi r22,lo8(-1)
 2389 00a0 7FEF      		ldi r23,lo8(-1)
 2390               	.LVL246:
 2391               	.L281:
 2392               	.LBE68:
 2393               	.LBE67:
 2394               	.LBE66:
 2395               	.LBB69:
 2396               	.LBB70:
 985:quantum/quantum.c ****   OCR1x = val;
 2397               		.loc 1 985 0
 2398 00a2 7093 8900 		sts 136+1,r23
 2399 00a6 6093 8800 		sts 136,r22
 2400               	/* epilogue start */
 2401               	.LBE70:
 2402               	.LBE69:
1003:quantum/quantum.c **** }
 2403               		.loc 1 1003 0
 2404 00aa FF90      		pop r15
 2405 00ac EF90      		pop r14
 2406 00ae DF90      		pop r13
 2407 00b0 CF90      		pop r12
 2408 00b2 0895      		ret
 2409               		.cfi_endproc
 2410               	.LFE38:
 2412               		.section	.text.backlight_task,"ax",@progbits
 2413               	.global	backlight_task
 2415               	backlight_task:
 2416               	.LFB39:
1004:quantum/quantum.c **** 
1005:quantum/quantum.c **** void backlight_task(void) {}
 2417               		.loc 1 1005 0
 2418               		.cfi_startproc
 2419               	/* prologue: function */
 2420               	/* frame size = 0 */
 2421               	/* stack size = 0 */
 2422               	.L__stack_usage = 0
 2423 0000 0895      		ret
 2424               		.cfi_endproc
 2425               	.LFE39:
 2427               		.section	.text.backlight_init_ports,"ax",@progbits
 2428               		.weak	backlight_init_ports
 2430               	backlight_init_ports:
 2431               	.LFB40:
1006:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1007:quantum/quantum.c **** 
1008:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1009:quantum/quantum.c **** 
1010:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1011:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1012:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1013:quantum/quantum.c **** #define BREATHING_STEPS 128
1014:quantum/quantum.c **** 
1015:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1016:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1017:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1018:quantum/quantum.c **** 
1019:quantum/quantum.c **** bool is_breathing(void) {
1020:quantum/quantum.c ****     return !!(TIMSK1 & _BV(TOIE1));
1021:quantum/quantum.c **** }
1022:quantum/quantum.c **** 
1023:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSK1 |= _BV(TOIE1);} while (0)
1024:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSK1 &= ~_BV(TOIE1);} while (0)
1025:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1026:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1027:quantum/quantum.c **** 
1028:quantum/quantum.c **** void breathing_enable(void)
1029:quantum/quantum.c **** {
1030:quantum/quantum.c ****   breathing_counter = 0;
1031:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1032:quantum/quantum.c ****   breathing_interrupt_enable();
1033:quantum/quantum.c **** }
1034:quantum/quantum.c **** 
1035:quantum/quantum.c **** void breathing_pulse(void)
1036:quantum/quantum.c **** {
1037:quantum/quantum.c ****     if (get_backlight_level() == 0)
1038:quantum/quantum.c ****       breathing_min();
1039:quantum/quantum.c ****     else
1040:quantum/quantum.c ****       breathing_max();
1041:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1042:quantum/quantum.c ****     breathing_interrupt_enable();
1043:quantum/quantum.c **** }
1044:quantum/quantum.c **** 
1045:quantum/quantum.c **** void breathing_disable(void)
1046:quantum/quantum.c **** {
1047:quantum/quantum.c ****     breathing_interrupt_disable();
1048:quantum/quantum.c ****     // Restore backlight level
1049:quantum/quantum.c ****     backlight_set(get_backlight_level());
1050:quantum/quantum.c **** }
1051:quantum/quantum.c **** 
1052:quantum/quantum.c **** void breathing_self_disable(void)
1053:quantum/quantum.c **** {
1054:quantum/quantum.c ****   if (get_backlight_level() == 0)
1055:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1056:quantum/quantum.c ****   else
1057:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1058:quantum/quantum.c **** }
1059:quantum/quantum.c **** 
1060:quantum/quantum.c **** void breathing_toggle(void) {
1061:quantum/quantum.c ****   if (is_breathing())
1062:quantum/quantum.c ****     breathing_disable();
1063:quantum/quantum.c ****   else
1064:quantum/quantum.c ****     breathing_enable();
1065:quantum/quantum.c **** }
1066:quantum/quantum.c **** 
1067:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1068:quantum/quantum.c **** {
1069:quantum/quantum.c ****   if (!value)
1070:quantum/quantum.c ****     value = 1;
1071:quantum/quantum.c ****   breathing_period = value;
1072:quantum/quantum.c **** }
1073:quantum/quantum.c **** 
1074:quantum/quantum.c **** void breathing_period_default(void) {
1075:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1076:quantum/quantum.c **** }
1077:quantum/quantum.c **** 
1078:quantum/quantum.c **** void breathing_period_inc(void)
1079:quantum/quantum.c **** {
1080:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1081:quantum/quantum.c **** }
1082:quantum/quantum.c **** 
1083:quantum/quantum.c **** void breathing_period_dec(void)
1084:quantum/quantum.c **** {
1085:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1086:quantum/quantum.c **** }
1087:quantum/quantum.c **** 
1088:quantum/quantum.c **** /* To generate breathing curve in python:
1089:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1090:quantum/quantum.c ****  */
1091:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1092:quantum/quantum.c **** 
1093:quantum/quantum.c **** // Use this before the cie_lightness function.
1094:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1095:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1096:quantum/quantum.c **** }
1097:quantum/quantum.c **** 
1098:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1099:quantum/quantum.c ****  * about 244 times per second.
1100:quantum/quantum.c ****  */
1101:quantum/quantum.c **** ISR(TIMER1_OVF_vect)
1102:quantum/quantum.c **** {
1103:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1104:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1105:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1106:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1107:quantum/quantum.c **** 
1108:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1109:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1110:quantum/quantum.c ****   {
1111:quantum/quantum.c ****       breathing_interrupt_disable();
1112:quantum/quantum.c ****   }
1113:quantum/quantum.c **** 
1114:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1115:quantum/quantum.c **** }
1116:quantum/quantum.c **** 
1117:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1118:quantum/quantum.c **** 
1119:quantum/quantum.c **** __attribute__ ((weak))
1120:quantum/quantum.c **** void backlight_init_ports(void)
1121:quantum/quantum.c **** {
 2432               		.loc 1 1121 0
 2433               		.cfi_startproc
 2434               	/* prologue: function */
 2435               	/* frame size = 0 */
 2436               	/* stack size = 0 */
 2437               	.L__stack_usage = 0
1122:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1123:quantum/quantum.c ****   // DDRx |= n
1124:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 2438               		.loc 1 1124 0
 2439 0000 259A      		sbi 0x4,5
1125:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1126:quantum/quantum.c ****     // PORTx &= ~n
1127:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 2440               		.loc 1 1127 0
 2441 0002 2D98      		cbi 0x5,5
1128:quantum/quantum.c ****   #else
1129:quantum/quantum.c ****     // PORTx |= n
1130:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1131:quantum/quantum.c ****   #endif
1132:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1133:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1134:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1135:quantum/quantum.c **** 
1136:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1137:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1138:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1139:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1140:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1141:quantum/quantum.c **** 
1142:quantum/quantum.c ****   /*
1143:quantum/quantum.c ****   14.8.3:
1144:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1145:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1146:quantum/quantum.c ****   */
1147:quantum/quantum.c **** 
1148:quantum/quantum.c ****   TCCR1A = _BV(COM1x1) | _BV(WGM11); // = 0b00001010;
 2442               		.loc 1 1148 0
 2443 0004 82E8      		ldi r24,lo8(-126)
 2444 0006 8093 8000 		sts 128,r24
1149:quantum/quantum.c ****   TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
 2445               		.loc 1 1149 0
 2446 000a 89E1      		ldi r24,lo8(25)
 2447 000c 8093 8100 		sts 129,r24
1150:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1151:quantum/quantum.c ****   ICR1 = TIMER_TOP;
 2448               		.loc 1 1151 0
 2449 0010 8FEF      		ldi r24,lo8(-1)
 2450 0012 9FEF      		ldi r25,lo8(-1)
 2451 0014 9093 8700 		sts 134+1,r25
 2452 0018 8093 8600 		sts 134,r24
1152:quantum/quantum.c **** 
1153:quantum/quantum.c ****   backlight_init();
 2453               		.loc 1 1153 0
 2454 001c 0C94 0000 		jmp backlight_init
 2455               	.LVL247:
 2456               		.cfi_endproc
 2457               	.LFE40:
 2459               		.section	.text.matrix_init_quantum,"ax",@progbits
 2460               	.global	matrix_init_quantum
 2462               	matrix_init_quantum:
 2463               	.LFB34:
 844:quantum/quantum.c **** void matrix_init_quantum() {
 2464               		.loc 1 844 0
 2465               		.cfi_startproc
 2466               	/* prologue: function */
 2467               	/* frame size = 0 */
 2468               	/* stack size = 0 */
 2469               	.L__stack_usage = 0
 846:quantum/quantum.c ****     backlight_init_ports();
 2470               		.loc 1 846 0
 2471 0000 0E94 0000 		call backlight_init_ports
 2472               	.LVL248:
 854:quantum/quantum.c ****   matrix_init_kb();
 2473               		.loc 1 854 0
 2474 0004 0C94 0000 		jmp matrix_init_kb
 2475               	.LVL249:
 2476               		.cfi_endproc
 2477               	.LFE34:
 2479               		.section	.text.send_nibble,"ax",@progbits
 2480               	.global	send_nibble
 2482               	send_nibble:
 2483               	.LFB44:
1154:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1155:quantum/quantum.c ****     breathing_enable();
1156:quantum/quantum.c ****   #endif
1157:quantum/quantum.c **** }
1158:quantum/quantum.c **** 
1159:quantum/quantum.c **** #endif // NO_HARDWARE_PWM
1160:quantum/quantum.c **** 
1161:quantum/quantum.c **** #else // backlight
1162:quantum/quantum.c **** 
1163:quantum/quantum.c **** __attribute__ ((weak))
1164:quantum/quantum.c **** void backlight_init_ports(void) {}
1165:quantum/quantum.c **** 
1166:quantum/quantum.c **** __attribute__ ((weak))
1167:quantum/quantum.c **** void backlight_set(uint8_t level) {}
1168:quantum/quantum.c **** 
1169:quantum/quantum.c **** #endif // backlight
1170:quantum/quantum.c **** 
1171:quantum/quantum.c **** 
1172:quantum/quantum.c **** // Functions for spitting out values
1173:quantum/quantum.c **** //
1174:quantum/quantum.c **** 
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1176:quantum/quantum.c ****     uint16_t word = (number >> 16);
1177:quantum/quantum.c ****     send_word(word);
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1179:quantum/quantum.c **** }
1180:quantum/quantum.c **** 
1181:quantum/quantum.c **** void send_word(uint16_t number) {
1182:quantum/quantum.c ****     uint8_t byte = number >> 8;
1183:quantum/quantum.c ****     send_byte(byte);
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
1185:quantum/quantum.c **** }
1186:quantum/quantum.c **** 
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
1188:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1189:quantum/quantum.c ****     send_nibble(nibble);
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
1191:quantum/quantum.c **** }
1192:quantum/quantum.c **** 
1193:quantum/quantum.c **** void send_nibble(uint8_t number) {
 2484               		.loc 1 1193 0
 2485               		.cfi_startproc
 2486               	.LVL250:
 2487 0000 CF93      		push r28
 2488               	.LCFI44:
 2489               		.cfi_def_cfa_offset 3
 2490               		.cfi_offset 28, -2
 2491               	/* prologue: function */
 2492               	/* frame size = 0 */
 2493               	/* stack size = 1 */
 2494               	.L__stack_usage = 1
1194:quantum/quantum.c ****     switch (number) {
 2495               		.loc 1 1194 0
 2496 0002 8A30      		cpi r24,lo8(10)
 2497 0004 00F4      		brsh .L290
 2498 0006 8130      		cpi r24,lo8(1)
 2499 0008 00F4      		brsh .L298
1195:quantum/quantum.c ****         case 0:
1196:quantum/quantum.c ****             register_code(KC_0);
 2500               		.loc 1 1196 0
 2501 000a 87E2      		ldi r24,lo8(39)
 2502               	.LVL251:
 2503 000c 0E94 0000 		call register_code
 2504               	.LVL252:
1197:quantum/quantum.c ****             unregister_code(KC_0);
 2505               		.loc 1 1197 0
 2506 0010 87E2      		ldi r24,lo8(39)
 2507 0012 00C0      		rjmp .L296
 2508               	.LVL253:
 2509               	.L290:
1194:quantum/quantum.c ****     switch (number) {
 2510               		.loc 1 1194 0
 2511 0014 8031      		cpi r24,lo8(16)
 2512 0016 00F4      		brsh .L299
1198:quantum/quantum.c ****             break;
1199:quantum/quantum.c ****         case 1 ... 9:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1201:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1202:quantum/quantum.c ****             break;
1203:quantum/quantum.c ****         case 0xA ... 0xF:
1204:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 2513               		.loc 1 1204 0
 2514 0018 CAEF      		ldi r28,lo8(-6)
 2515 001a 00C0      		rjmp .L297
 2516               	.L298:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
 2517               		.loc 1 1200 0
 2518 001c CDE1      		ldi r28,lo8(29)
 2519               	.L297:
 2520               		.loc 1 1204 0
 2521 001e C80F      		add r28,r24
 2522 0020 8C2F      		mov r24,r28
 2523               	.LVL254:
 2524 0022 0E94 0000 		call register_code
 2525               	.LVL255:
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2526               		.loc 1 1205 0
 2527 0026 8C2F      		mov r24,r28
 2528               	.L296:
 2529               	/* epilogue start */
1206:quantum/quantum.c ****             break;
1207:quantum/quantum.c ****     }
1208:quantum/quantum.c **** }
 2530               		.loc 1 1208 0
 2531 0028 CF91      		pop r28
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2532               		.loc 1 1205 0
 2533 002a 0C94 0000 		jmp unregister_code
 2534               	.LVL256:
 2535               	.L299:
 2536               	/* epilogue start */
 2537               		.loc 1 1208 0
 2538 002e CF91      		pop r28
 2539 0030 0895      		ret
 2540               		.cfi_endproc
 2541               	.LFE44:
 2543               		.section	.text.send_byte,"ax",@progbits
 2544               	.global	send_byte
 2546               	send_byte:
 2547               	.LFB43:
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
 2548               		.loc 1 1187 0
 2549               		.cfi_startproc
 2550               	.LVL257:
 2551 0000 CF93      		push r28
 2552               	.LCFI45:
 2553               		.cfi_def_cfa_offset 3
 2554               		.cfi_offset 28, -2
 2555               	/* prologue: function */
 2556               	/* frame size = 0 */
 2557               	/* stack size = 1 */
 2558               	.L__stack_usage = 1
 2559 0002 C82F      		mov r28,r24
 2560               	.LVL258:
1189:quantum/quantum.c ****     send_nibble(nibble);
 2561               		.loc 1 1189 0
 2562 0004 8295      		swap r24
 2563               	.LVL259:
 2564 0006 8F70      		andi r24,lo8(15)
 2565 0008 0E94 0000 		call send_nibble
 2566               	.LVL260:
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
 2567               		.loc 1 1190 0
 2568 000c 8C2F      		mov r24,r28
 2569 000e 8F70      		andi r24,lo8(15)
 2570               	/* epilogue start */
1191:quantum/quantum.c **** }
 2571               		.loc 1 1191 0
 2572 0010 CF91      		pop r28
 2573               	.LVL261:
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
 2574               		.loc 1 1190 0
 2575 0012 0C94 0000 		jmp send_nibble
 2576               	.LVL262:
 2577               		.cfi_endproc
 2578               	.LFE43:
 2580               		.section	.text.send_word,"ax",@progbits
 2581               	.global	send_word
 2583               	send_word:
 2584               	.LFB42:
1181:quantum/quantum.c **** void send_word(uint16_t number) {
 2585               		.loc 1 1181 0
 2586               		.cfi_startproc
 2587               	.LVL263:
 2588 0000 CF93      		push r28
 2589               	.LCFI46:
 2590               		.cfi_def_cfa_offset 3
 2591               		.cfi_offset 28, -2
 2592               	/* prologue: function */
 2593               	/* frame size = 0 */
 2594               	/* stack size = 1 */
 2595               	.L__stack_usage = 1
 2596 0002 C82F      		mov r28,r24
 2597               	.LVL264:
1183:quantum/quantum.c ****     send_byte(byte);
 2598               		.loc 1 1183 0
 2599 0004 892F      		mov r24,r25
 2600               	.LVL265:
 2601 0006 0E94 0000 		call send_byte
 2602               	.LVL266:
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
 2603               		.loc 1 1184 0
 2604 000a 8C2F      		mov r24,r28
 2605               	/* epilogue start */
1185:quantum/quantum.c **** }
 2606               		.loc 1 1185 0
 2607 000c CF91      		pop r28
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
 2608               		.loc 1 1184 0
 2609 000e 0C94 0000 		jmp send_byte
 2610               	.LVL267:
 2611               		.cfi_endproc
 2612               	.LFE42:
 2614               		.section	.text.send_dword,"ax",@progbits
 2615               	.global	send_dword
 2617               	send_dword:
 2618               	.LFB41:
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
 2619               		.loc 1 1175 0
 2620               		.cfi_startproc
 2621               	.LVL268:
 2622 0000 CF92      		push r12
 2623               	.LCFI47:
 2624               		.cfi_def_cfa_offset 3
 2625               		.cfi_offset 12, -2
 2626 0002 DF92      		push r13
 2627               	.LCFI48:
 2628               		.cfi_def_cfa_offset 4
 2629               		.cfi_offset 13, -3
 2630 0004 EF92      		push r14
 2631               	.LCFI49:
 2632               		.cfi_def_cfa_offset 5
 2633               		.cfi_offset 14, -4
 2634 0006 FF92      		push r15
 2635               	.LCFI50:
 2636               		.cfi_def_cfa_offset 6
 2637               		.cfi_offset 15, -5
 2638               	/* prologue: function */
 2639               	/* frame size = 0 */
 2640               	/* stack size = 4 */
 2641               	.L__stack_usage = 4
 2642 0008 6B01      		movw r12,r22
 2643 000a 7C01      		movw r14,r24
 2644               	.LVL269:
1177:quantum/quantum.c ****     send_word(word);
 2645               		.loc 1 1177 0
 2646 000c C701      		movw r24,r14
 2647 000e 0E94 0000 		call send_word
 2648               	.LVL270:
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2649               		.loc 1 1178 0
 2650 0012 C601      		movw r24,r12
 2651               	/* epilogue start */
1179:quantum/quantum.c **** }
 2652               		.loc 1 1179 0
 2653 0014 FF90      		pop r15
 2654 0016 EF90      		pop r14
 2655 0018 DF90      		pop r13
 2656 001a CF90      		pop r12
 2657               	.LVL271:
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2658               		.loc 1 1178 0
 2659 001c 0C94 0000 		jmp send_word
 2660               	.LVL272:
 2661               		.cfi_endproc
 2662               	.LFE41:
 2664               		.section	.text.hex_to_keycode,"ax",@progbits
 2665               		.weak	hex_to_keycode
 2667               	hex_to_keycode:
 2668               	.LFB45:
1209:quantum/quantum.c **** 
1210:quantum/quantum.c **** 
1211:quantum/quantum.c **** __attribute__((weak))
1212:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1213:quantum/quantum.c **** {
 2669               		.loc 1 1213 0
 2670               		.cfi_startproc
 2671               	.LVL273:
 2672               	/* prologue: function */
 2673               	/* frame size = 0 */
 2674               	/* stack size = 0 */
 2675               	.L__stack_usage = 0
1214:quantum/quantum.c ****   hex = hex & 0xF;
 2676               		.loc 1 1214 0
 2677 0000 282F      		mov r18,r24
 2678 0002 2F70      		andi r18,lo8(15)
 2679               	.LVL274:
1215:quantum/quantum.c ****   if (hex == 0x0) {
 2680               		.loc 1 1215 0
 2681 0004 01F0      		breq .L306
 2682 0006 822F      		mov r24,r18
 2683 0008 90E0      		ldi r25,0
1216:quantum/quantum.c ****     return KC_0;
1217:quantum/quantum.c ****   } else if (hex < 0xA) {
 2684               		.loc 1 1217 0
 2685 000a 2A30      		cpi r18,lo8(10)
 2686 000c 00F4      		brsh .L305
1218:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 2687               		.loc 1 1218 0
 2688 000e 4D96      		adiw r24,29
 2689 0010 0895      		ret
 2690               	.L305:
1219:quantum/quantum.c ****   } else {
1220:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 2691               		.loc 1 1220 0
 2692 0012 0697      		sbiw r24,6
 2693 0014 0895      		ret
 2694               	.L306:
1216:quantum/quantum.c ****     return KC_0;
 2695               		.loc 1 1216 0
 2696 0016 87E2      		ldi r24,lo8(39)
 2697 0018 90E0      		ldi r25,0
1221:quantum/quantum.c ****   }
1222:quantum/quantum.c **** }
 2698               		.loc 1 1222 0
 2699 001a 0895      		ret
 2700               		.cfi_endproc
 2701               	.LFE45:
 2703               		.section	.text.api_send_unicode,"ax",@progbits
 2704               	.global	api_send_unicode
 2706               	api_send_unicode:
 2707               	.LFB46:
1223:quantum/quantum.c **** 
1224:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 2708               		.loc 1 1224 0
 2709               		.cfi_startproc
 2710               	.LVL275:
 2711               	/* prologue: function */
 2712               	/* frame size = 0 */
 2713               	/* stack size = 0 */
 2714               	.L__stack_usage = 0
 2715 0000 0895      		ret
 2716               		.cfi_endproc
 2717               	.LFE46:
 2719               		.section	.text.led_set_user,"ax",@progbits
 2720               		.weak	led_set_user
 2722               	led_set_user:
 2723               	.LFB47:
1225:quantum/quantum.c **** #ifdef API_ENABLE
1226:quantum/quantum.c ****     uint8_t chunk[4];
1227:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1228:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1229:quantum/quantum.c **** #endif
1230:quantum/quantum.c **** }
1231:quantum/quantum.c **** 
1232:quantum/quantum.c **** __attribute__ ((weak))
1233:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 2724               		.loc 1 1233 0
 2725               		.cfi_startproc
 2726               	.LVL276:
 2727               	/* prologue: function */
 2728               	/* frame size = 0 */
 2729               	/* stack size = 0 */
 2730               	.L__stack_usage = 0
 2731 0000 0895      		ret
 2732               		.cfi_endproc
 2733               	.LFE47:
 2735               		.section	.text.led_set_kb,"ax",@progbits
 2736               		.weak	led_set_kb
 2738               	led_set_kb:
 2739               	.LFB48:
1234:quantum/quantum.c **** 
1235:quantum/quantum.c **** }
1236:quantum/quantum.c **** 
1237:quantum/quantum.c **** __attribute__ ((weak))
1238:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 2740               		.loc 1 1238 0
 2741               		.cfi_startproc
 2742               	.LVL277:
 2743               	/* prologue: function */
 2744               	/* frame size = 0 */
 2745               	/* stack size = 0 */
 2746               	.L__stack_usage = 0
1239:quantum/quantum.c ****     led_set_user(usb_led);
 2747               		.loc 1 1239 0
 2748 0000 0C94 0000 		jmp led_set_user
 2749               	.LVL278:
 2750               		.cfi_endproc
 2751               	.LFE48:
 2753               		.section	.text.led_init_ports,"ax",@progbits
 2754               		.weak	led_init_ports
 2756               	led_init_ports:
 2757               	.LFB49:
1240:quantum/quantum.c **** }
1241:quantum/quantum.c **** 
1242:quantum/quantum.c **** __attribute__ ((weak))
1243:quantum/quantum.c **** void led_init_ports(void)
1244:quantum/quantum.c **** {
 2758               		.loc 1 1244 0
 2759               		.cfi_startproc
 2760               	/* prologue: function */
 2761               	/* frame size = 0 */
 2762               	/* stack size = 0 */
 2763               	.L__stack_usage = 0
 2764 0000 0895      		ret
 2765               		.cfi_endproc
 2766               	.LFE49:
 2768               		.section	.text.led_set,"ax",@progbits
 2769               		.weak	led_set
 2771               	led_set:
 2772               	.LFB50:
1245:quantum/quantum.c **** 
1246:quantum/quantum.c **** }
1247:quantum/quantum.c **** 
1248:quantum/quantum.c **** __attribute__ ((weak))
1249:quantum/quantum.c **** void led_set(uint8_t usb_led)
1250:quantum/quantum.c **** {
 2773               		.loc 1 1250 0
 2774               		.cfi_startproc
 2775               	.LVL279:
 2776               	/* prologue: function */
 2777               	/* frame size = 0 */
 2778               	/* stack size = 0 */
 2779               	.L__stack_usage = 0
1251:quantum/quantum.c **** 
1252:quantum/quantum.c ****   // Example LED Code
1253:quantum/quantum.c ****   //
1254:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1255:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1256:quantum/quantum.c ****     // {
1257:quantum/quantum.c ****     //     // Output high.
1258:quantum/quantum.c ****     //     DDRE |= (1<<6);
1259:quantum/quantum.c ****     //     PORTE |= (1<<6);
1260:quantum/quantum.c ****     // }
1261:quantum/quantum.c ****     // else
1262:quantum/quantum.c ****     // {
1263:quantum/quantum.c ****     //     // Output low.
1264:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1265:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1266:quantum/quantum.c ****     // }
1267:quantum/quantum.c **** 
1268:quantum/quantum.c ****   led_set_kb(usb_led);
 2780               		.loc 1 1268 0
 2781 0000 0C94 0000 		jmp led_set_kb
 2782               	.LVL280:
 2783               		.cfi_endproc
 2784               	.LFE50:
 2786               		.section	.text.startup_user,"ax",@progbits
 2787               		.weak	startup_user
 2789               	startup_user:
 2790               	.LFB51:
1269:quantum/quantum.c **** }
1270:quantum/quantum.c **** 
1271:quantum/quantum.c **** 
1272:quantum/quantum.c **** //------------------------------------------------------------------------------
1273:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1274:quantum/quantum.c **** // different events such as startup and bootloader jump
1275:quantum/quantum.c **** 
1276:quantum/quantum.c **** __attribute__ ((weak))
1277:quantum/quantum.c **** void startup_user() {}
 2791               		.loc 1 1277 0
 2792               		.cfi_startproc
 2793               	/* prologue: function */
 2794               	/* frame size = 0 */
 2795               	/* stack size = 0 */
 2796               	.L__stack_usage = 0
 2797 0000 0895      		ret
 2798               		.cfi_endproc
 2799               	.LFE51:
 2801               		.section	.text.shutdown_user,"ax",@progbits
 2802               		.weak	shutdown_user
 2804               	shutdown_user:
 2805               	.LFB52:
1278:quantum/quantum.c **** 
1279:quantum/quantum.c **** __attribute__ ((weak))
1280:quantum/quantum.c **** void shutdown_user() {}
 2806               		.loc 1 1280 0
 2807               		.cfi_startproc
 2808               	/* prologue: function */
 2809               	/* frame size = 0 */
 2810               	/* stack size = 0 */
 2811               	.L__stack_usage = 0
 2812 0000 0895      		ret
 2813               		.cfi_endproc
 2814               	.LFE52:
 2816               	.global	rgb_matrix_task_counter
 2817               		.section	.bss.rgb_matrix_task_counter,"aw",@nobits
 2820               	rgb_matrix_task_counter:
 2821 0000 00        		.zero	1
 2822               		.weak	ascii_to_keycode_lut
 2823               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2826               	ascii_to_keycode_lut:
 2827 0000 00        		.byte	0
 2828 0001 00        		.byte	0
 2829 0002 00        		.byte	0
 2830 0003 00        		.byte	0
 2831 0004 00        		.byte	0
 2832 0005 00        		.byte	0
 2833 0006 00        		.byte	0
 2834 0007 00        		.byte	0
 2835 0008 2A        		.byte	42
 2836 0009 2B        		.byte	43
 2837 000a 28        		.byte	40
 2838 000b 00        		.byte	0
 2839 000c 00        		.byte	0
 2840 000d 00        		.byte	0
 2841 000e 00        		.byte	0
 2842 000f 00        		.byte	0
 2843 0010 00        		.byte	0
 2844 0011 00        		.byte	0
 2845 0012 00        		.byte	0
 2846 0013 00        		.byte	0
 2847 0014 00        		.byte	0
 2848 0015 00        		.byte	0
 2849 0016 00        		.byte	0
 2850 0017 00        		.byte	0
 2851 0018 00        		.byte	0
 2852 0019 00        		.byte	0
 2853 001a 00        		.byte	0
 2854 001b 29        		.byte	41
 2855 001c 00        		.byte	0
 2856 001d 00        		.byte	0
 2857 001e 00        		.byte	0
 2858 001f 00        		.byte	0
 2859 0020 2C        		.byte	44
 2860 0021 1E        		.byte	30
 2861 0022 34        		.byte	52
 2862 0023 20        		.byte	32
 2863 0024 21        		.byte	33
 2864 0025 22        		.byte	34
 2865 0026 24        		.byte	36
 2866 0027 34        		.byte	52
 2867 0028 26        		.byte	38
 2868 0029 27        		.byte	39
 2869 002a 25        		.byte	37
 2870 002b 2E        		.byte	46
 2871 002c 36        		.byte	54
 2872 002d 2D        		.byte	45
 2873 002e 37        		.byte	55
 2874 002f 38        		.byte	56
 2875 0030 27        		.byte	39
 2876 0031 1E        		.byte	30
 2877 0032 1F        		.byte	31
 2878 0033 20        		.byte	32
 2879 0034 21        		.byte	33
 2880 0035 22        		.byte	34
 2881 0036 23        		.byte	35
 2882 0037 24        		.byte	36
 2883 0038 25        		.byte	37
 2884 0039 26        		.byte	38
 2885 003a 33        		.byte	51
 2886 003b 33        		.byte	51
 2887 003c 36        		.byte	54
 2888 003d 2E        		.byte	46
 2889 003e 37        		.byte	55
 2890 003f 38        		.byte	56
 2891 0040 1F        		.byte	31
 2892 0041 04        		.byte	4
 2893 0042 05        		.byte	5
 2894 0043 06        		.byte	6
 2895 0044 07        		.byte	7
 2896 0045 08        		.byte	8
 2897 0046 09        		.byte	9
 2898 0047 0A        		.byte	10
 2899 0048 0B        		.byte	11
 2900 0049 0C        		.byte	12
 2901 004a 0D        		.byte	13
 2902 004b 0E        		.byte	14
 2903 004c 0F        		.byte	15
 2904 004d 10        		.byte	16
 2905 004e 11        		.byte	17
 2906 004f 12        		.byte	18
 2907 0050 13        		.byte	19
 2908 0051 14        		.byte	20
 2909 0052 15        		.byte	21
 2910 0053 16        		.byte	22
 2911 0054 17        		.byte	23
 2912 0055 18        		.byte	24
 2913 0056 19        		.byte	25
 2914 0057 1A        		.byte	26
 2915 0058 1B        		.byte	27
 2916 0059 1C        		.byte	28
 2917 005a 1D        		.byte	29
 2918 005b 2F        		.byte	47
 2919 005c 31        		.byte	49
 2920 005d 30        		.byte	48
 2921 005e 23        		.byte	35
 2922 005f 2D        		.byte	45
 2923 0060 35        		.byte	53
 2924 0061 04        		.byte	4
 2925 0062 05        		.byte	5
 2926 0063 06        		.byte	6
 2927 0064 07        		.byte	7
 2928 0065 08        		.byte	8
 2929 0066 09        		.byte	9
 2930 0067 0A        		.byte	10
 2931 0068 0B        		.byte	11
 2932 0069 0C        		.byte	12
 2933 006a 0D        		.byte	13
 2934 006b 0E        		.byte	14
 2935 006c 0F        		.byte	15
 2936 006d 10        		.byte	16
 2937 006e 11        		.byte	17
 2938 006f 12        		.byte	18
 2939 0070 13        		.byte	19
 2940 0071 14        		.byte	20
 2941 0072 15        		.byte	21
 2942 0073 16        		.byte	22
 2943 0074 17        		.byte	23
 2944 0075 18        		.byte	24
 2945 0076 19        		.byte	25
 2946 0077 1A        		.byte	26
 2947 0078 1B        		.byte	27
 2948 0079 1C        		.byte	28
 2949 007a 1D        		.byte	29
 2950 007b 2F        		.byte	47
 2951 007c 31        		.byte	49
 2952 007d 30        		.byte	48
 2953 007e 35        		.byte	53
 2954 007f 4C        		.byte	76
 2955               		.weak	ascii_to_shift_lut
 2956               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2959               	ascii_to_shift_lut:
 2960 0000 00        		.byte	0
 2961 0001 00        		.byte	0
 2962 0002 00        		.byte	0
 2963 0003 00        		.byte	0
 2964 0004 00        		.byte	0
 2965 0005 00        		.byte	0
 2966 0006 00        		.byte	0
 2967 0007 00        		.byte	0
 2968 0008 00        		.byte	0
 2969 0009 00        		.byte	0
 2970 000a 00        		.byte	0
 2971 000b 00        		.byte	0
 2972 000c 00        		.byte	0
 2973 000d 00        		.byte	0
 2974 000e 00        		.byte	0
 2975 000f 00        		.byte	0
 2976 0010 00        		.byte	0
 2977 0011 00        		.byte	0
 2978 0012 00        		.byte	0
 2979 0013 00        		.byte	0
 2980 0014 00        		.byte	0
 2981 0015 00        		.byte	0
 2982 0016 00        		.byte	0
 2983 0017 00        		.byte	0
 2984 0018 00        		.byte	0
 2985 0019 00        		.byte	0
 2986 001a 00        		.byte	0
 2987 001b 00        		.byte	0
 2988 001c 00        		.byte	0
 2989 001d 00        		.byte	0
 2990 001e 00        		.byte	0
 2991 001f 00        		.byte	0
 2992 0020 00        		.byte	0
 2993 0021 01        		.byte	1
 2994 0022 01        		.byte	1
 2995 0023 01        		.byte	1
 2996 0024 01        		.byte	1
 2997 0025 01        		.byte	1
 2998 0026 01        		.byte	1
 2999 0027 00        		.byte	0
 3000 0028 01        		.byte	1
 3001 0029 01        		.byte	1
 3002 002a 01        		.byte	1
 3003 002b 01        		.byte	1
 3004 002c 00        		.byte	0
 3005 002d 00        		.byte	0
 3006 002e 00        		.byte	0
 3007 002f 00        		.byte	0
 3008 0030 00        		.byte	0
 3009 0031 00        		.byte	0
 3010 0032 00        		.byte	0
 3011 0033 00        		.byte	0
 3012 0034 00        		.byte	0
 3013 0035 00        		.byte	0
 3014 0036 00        		.byte	0
 3015 0037 00        		.byte	0
 3016 0038 00        		.byte	0
 3017 0039 00        		.byte	0
 3018 003a 01        		.byte	1
 3019 003b 00        		.byte	0
 3020 003c 01        		.byte	1
 3021 003d 00        		.byte	0
 3022 003e 01        		.byte	1
 3023 003f 01        		.byte	1
 3024 0040 01        		.byte	1
 3025 0041 01        		.byte	1
 3026 0042 01        		.byte	1
 3027 0043 01        		.byte	1
 3028 0044 01        		.byte	1
 3029 0045 01        		.byte	1
 3030 0046 01        		.byte	1
 3031 0047 01        		.byte	1
 3032 0048 01        		.byte	1
 3033 0049 01        		.byte	1
 3034 004a 01        		.byte	1
 3035 004b 01        		.byte	1
 3036 004c 01        		.byte	1
 3037 004d 01        		.byte	1
 3038 004e 01        		.byte	1
 3039 004f 01        		.byte	1
 3040 0050 01        		.byte	1
 3041 0051 01        		.byte	1
 3042 0052 01        		.byte	1
 3043 0053 01        		.byte	1
 3044 0054 01        		.byte	1
 3045 0055 01        		.byte	1
 3046 0056 01        		.byte	1
 3047 0057 01        		.byte	1
 3048 0058 01        		.byte	1
 3049 0059 01        		.byte	1
 3050 005a 01        		.byte	1
 3051 005b 00        		.byte	0
 3052 005c 00        		.byte	0
 3053 005d 00        		.byte	0
 3054 005e 01        		.byte	1
 3055 005f 01        		.byte	1
 3056 0060 00        		.byte	0
 3057 0061 00        		.byte	0
 3058 0062 00        		.byte	0
 3059 0063 00        		.byte	0
 3060 0064 00        		.byte	0
 3061 0065 00        		.byte	0
 3062 0066 00        		.byte	0
 3063 0067 00        		.byte	0
 3064 0068 00        		.byte	0
 3065 0069 00        		.byte	0
 3066 006a 00        		.byte	0
 3067 006b 00        		.byte	0
 3068 006c 00        		.byte	0
 3069 006d 00        		.byte	0
 3070 006e 00        		.byte	0
 3071 006f 00        		.byte	0
 3072 0070 00        		.byte	0
 3073 0071 00        		.byte	0
 3074 0072 00        		.byte	0
 3075 0073 00        		.byte	0
 3076 0074 00        		.byte	0
 3077 0075 00        		.byte	0
 3078 0076 00        		.byte	0
 3079 0077 00        		.byte	0
 3080 0078 00        		.byte	0
 3081 0079 00        		.byte	0
 3082 007a 00        		.byte	0
 3083 007b 01        		.byte	1
 3084 007c 01        		.byte	1
 3085 007d 01        		.byte	1
 3086 007e 01        		.byte	1
 3087 007f 00        		.byte	0
 3088               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 3091               	grave_esc_was_shifted:
 3092 0000 00        		.zero	1
 3093               		.section	.bss.scs_timer,"aw",@nobits
 3096               	scs_timer:
 3097 0000 0000 0000 		.zero	4
 3098               		.section	.bss.shift_interrupted,"aw",@nobits
 3101               	shift_interrupted:
 3102 0000 0000      		.zero	2
 3103               		.text
 3104               	.Letext0:
 3105               		.file 4 "/usr/lib/avr/include/stdint.h"
 3106               		.file 5 "./tmk_core/common/keyboard.h"
 3107               		.file 6 "./tmk_core/common/action.h"
 3108               		.file 7 "./tmk_core/common/report.h"
 3109               		.file 8 "./tmk_core/common/debug.h"
 3110               		.file 9 "quantum/keycode_config.h"
 3111               		.file 10 "./tmk_core/common/keycode.h"
 3112               		.file 11 "quantum/quantum_keycodes.h"
 3113               		.file 12 "./tmk_core/protocol/lufa/outputselect.h"
 3114               		.file 13 "quantum/quantum.h"
 3115               		.file 14 "./tmk_core/common/bootloader.h"
 3116               		.file 15 "quantum/rgblight.h"
 3117               		.file 16 "./tmk_core/common/action_layer.h"
 3118               		.file 17 "quantum/keymap.h"
 3119               		.file 18 "./quantum/process_keycode/process_leader.h"
 3120               		.file 19 "./tmk_core/common/eeconfig.h"
 3121               		.file 20 "./tmk_core/common/timer.h"
 3122               		.file 21 "./tmk_core/common/backlight.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/ccQ1JJna.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccQ1JJna.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccQ1JJna.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccQ1JJna.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccQ1JJna.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccQ1JJna.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/ccQ1JJna.s:130    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
     /tmp/ccQ1JJna.s:160    .text.qk_register_mods:0000000000000000 qk_register_mods
     /tmp/ccQ1JJna.s:190    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
     /tmp/ccQ1JJna.s:220    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
     /tmp/ccQ1JJna.s:251    .text.register_code16:0000000000000000 register_code16
     /tmp/ccQ1JJna.s:307    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/ccQ1JJna.s:362    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/ccQ1JJna.s:381    .text.process_record_user:0000000000000000 process_record_user
     /tmp/ccQ1JJna.s:400    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/ccQ1JJna.s:418    .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/ccQ1JJna.s:458    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccQ1JJna.s:3101   .bss.shift_interrupted:0000000000000000 shift_interrupted
     /tmp/ccQ1JJna.s:3091   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted
     /tmp/ccQ1JJna.s:3096   .bss.scs_timer:0000000000000000 scs_timer
     /tmp/ccQ1JJna.s:1416   .text.send_char:0000000000000000 send_char
     /tmp/ccQ1JJna.s:2826   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
     /tmp/ccQ1JJna.s:2959   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
     /tmp/ccQ1JJna.s:1502   .text.send_string_with_delay:0000000000000000 send_string_with_delay
     /tmp/ccQ1JJna.s:1646   .text.send_string:0000000000000000 send_string
     /tmp/ccQ1JJna.s:1665   .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
     /tmp/ccQ1JJna.s:1841   .text.send_string_P:0000000000000000 send_string_P
     /tmp/ccQ1JJna.s:1860   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/ccQ1JJna.s:1908   .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
     /tmp/ccQ1JJna.s:2093   .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/ccQ1JJna.s:2132   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/ccQ1JJna.s:2254   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccQ1JJna.s:2271   .text.backlight_set:0000000000000000 backlight_set
     /tmp/ccQ1JJna.s:2415   .text.backlight_task:0000000000000000 backlight_task
     /tmp/ccQ1JJna.s:2430   .text.backlight_init_ports:0000000000000000 backlight_init_ports
     /tmp/ccQ1JJna.s:2462   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccQ1JJna.s:2482   .text.send_nibble:0000000000000000 send_nibble
     /tmp/ccQ1JJna.s:2546   .text.send_byte:0000000000000000 send_byte
     /tmp/ccQ1JJna.s:2583   .text.send_word:0000000000000000 send_word
     /tmp/ccQ1JJna.s:2617   .text.send_dword:0000000000000000 send_dword
     /tmp/ccQ1JJna.s:2667   .text.hex_to_keycode:0000000000000000 hex_to_keycode
     /tmp/ccQ1JJna.s:2706   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/ccQ1JJna.s:2722   .text.led_set_user:0000000000000000 led_set_user
     /tmp/ccQ1JJna.s:2738   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/ccQ1JJna.s:2756   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/ccQ1JJna.s:2771   .text.led_set:0000000000000000 led_set
     /tmp/ccQ1JJna.s:2789   .text.startup_user:0000000000000000 startup_user
     /tmp/ccQ1JJna.s:2804   .text.shutdown_user:0000000000000000 shutdown_user
     /tmp/ccQ1JJna.s:2820   .bss.rgb_matrix_task_counter:0000000000000000 rgb_matrix_task_counter

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
clear_keyboard
bootloader_jump
layer_switch_get_layer
keymap_key_to_keycode
process_leader
rgblight_increase_speed
get_mods
rgblight_step_reverse
rgblight_step
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
debug_config
keyboard_report
add_key_to_report
del_key_from_report
rgblight_toggle
rgblight_increase_sat
rgblight_increase_hue
rgblight_decrease_hue
rgblight_increase_val
rgblight_decrease_sat
rgblight_decrease_val
rgblight_get_mode
rgblight_mode
rgblight_decrease_speed
timer_read
register_mods
timer_elapsed
unregister_mods
set_output
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_scan_kb
__umulhisi3
__udivmodsi4
__udivmodhi4
__mulsi3
backlight_init
matrix_init_kb
__do_clear_bss
