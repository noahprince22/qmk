   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB13:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  19:quantum/quantum.c **** #include "outputselect.h"
  20:quantum/quantum.c **** #endif
  21:quantum/quantum.c **** 
  22:quantum/quantum.c **** #ifndef TAPPING_TERM
  23:quantum/quantum.c **** #define TAPPING_TERM 200
  24:quantum/quantum.c **** #endif
  25:quantum/quantum.c **** 
  26:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  27:quantum/quantum.c **** #define BREATHING_PERIOD 6
  28:quantum/quantum.c **** #endif
  29:quantum/quantum.c **** 
  30:quantum/quantum.c **** #include "backlight.h"
  31:quantum/quantum.c **** extern backlight_config_t backlight_config;
  32:quantum/quantum.c **** 
  33:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  34:quantum/quantum.c **** #include "fauxclicky.h"
  35:quantum/quantum.c **** #endif
  36:quantum/quantum.c **** 
  37:quantum/quantum.c **** #ifdef API_ENABLE
  38:quantum/quantum.c **** #include "api.h"
  39:quantum/quantum.c **** #endif
  40:quantum/quantum.c **** 
  41:quantum/quantum.c **** #ifdef MIDI_ENABLE
  42:quantum/quantum.c **** #include "process_midi.h"
  43:quantum/quantum.c **** #endif
  44:quantum/quantum.c **** 
  45:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  46:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  47:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  48:quantum/quantum.c ****   #endif
  49:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  50:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  51:quantum/quantum.c ****   #endif
  52:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  53:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  54:quantum/quantum.c ****   #endif
  55:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  56:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  57:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  58:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  59:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  60:quantum/quantum.c ****   #endif
  61:quantum/quantum.c **** #endif
  62:quantum/quantum.c **** 
  63:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 63 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  38 0008 8C01      		movw r16,r24
  39 000a EB01      		movw r28,r22
  64:quantum/quantum.c ****   switch (code) {
  40               		.loc 1 64 0
  41 000c 9A95      		dec r25
  42               	.LVL1:
  43 000e 8115      		cp r24,__zero_reg__
  44 0010 9F41      		sbci r25,31
  45 0012 00F4      		brsh .L1
  65:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  66:quantum/quantum.c ****     break;
  67:quantum/quantum.c ****   default:
  68:quantum/quantum.c ****     return;
  69:quantum/quantum.c ****   }
  70:quantum/quantum.c **** 
  71:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 71 0
  47 0014 10FF      		sbrs r17,0
  48 0016 00C0      		rjmp .L4
  72:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 72 0
  50 0018 80EE      		ldi r24,lo8(-32)
  51 001a FB01      		movw r30,r22
  52 001c 0995      		icall
  53               	.LVL2:
  54               	.L4:
  73:quantum/quantum.c ****   if (code & QK_LSFT)
  55               		.loc 1 73 0
  56 001e 11FF      		sbrs r17,1
  57 0020 00C0      		rjmp .L5
  74:quantum/quantum.c ****     f(KC_LSFT);
  58               		.loc 1 74 0
  59 0022 81EE      		ldi r24,lo8(-31)
  60 0024 FE01      		movw r30,r28
  61 0026 0995      		icall
  62               	.LVL3:
  63               	.L5:
  75:quantum/quantum.c ****   if (code & QK_LALT)
  64               		.loc 1 75 0
  65 0028 12FF      		sbrs r17,2
  66 002a 00C0      		rjmp .L6
  76:quantum/quantum.c ****     f(KC_LALT);
  67               		.loc 1 76 0
  68 002c 82EE      		ldi r24,lo8(-30)
  69 002e FE01      		movw r30,r28
  70 0030 0995      		icall
  71               	.LVL4:
  72               	.L6:
  77:quantum/quantum.c ****   if (code & QK_LGUI)
  73               		.loc 1 77 0
  74 0032 13FF      		sbrs r17,3
  75 0034 00C0      		rjmp .L7
  78:quantum/quantum.c ****     f(KC_LGUI);
  76               		.loc 1 78 0
  77 0036 83EE      		ldi r24,lo8(-29)
  78 0038 FE01      		movw r30,r28
  79 003a 0995      		icall
  80               	.LVL5:
  81               	.L7:
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  82               		.loc 1 80 0
  83 003c 0115      		cp r16,__zero_reg__
  84 003e 1041      		sbci r17,16
  85 0040 00F0      		brlo .L1
  81:quantum/quantum.c **** 
  82:quantum/quantum.c ****   if (code & QK_RCTL)
  83:quantum/quantum.c ****     f(KC_RCTL);
  86               		.loc 1 83 0
  87 0042 84EE      		ldi r24,lo8(-28)
  88 0044 FE01      		movw r30,r28
  89 0046 0995      		icall
  90               	.LVL6:
  84:quantum/quantum.c ****   if (code & QK_RSFT)
  85:quantum/quantum.c ****     f(KC_RSFT);
  91               		.loc 1 85 0
  92 0048 85EE      		ldi r24,lo8(-27)
  93 004a FE01      		movw r30,r28
  94 004c 0995      		icall
  95               	.LVL7:
  86:quantum/quantum.c ****   if (code & QK_RALT)
  87:quantum/quantum.c ****     f(KC_RALT);
  96               		.loc 1 87 0
  97 004e 86EE      		ldi r24,lo8(-26)
  98 0050 FE01      		movw r30,r28
  99 0052 0995      		icall
 100               	.LVL8:
  88:quantum/quantum.c ****   if (code & QK_RGUI)
  89:quantum/quantum.c ****     f(KC_RGUI);
 101               		.loc 1 89 0
 102 0054 87EE      		ldi r24,lo8(-25)
 103 0056 FE01      		movw r30,r28
 104               	/* epilogue start */
  90:quantum/quantum.c **** }
 105               		.loc 1 90 0
 106 0058 DF91      		pop r29
 107 005a CF91      		pop r28
 108               	.LVL9:
 109 005c 1F91      		pop r17
 110 005e 0F91      		pop r16
 111               	.LVL10:
  89:quantum/quantum.c ****     f(KC_RGUI);
 112               		.loc 1 89 0
 113 0060 0994      		ijmp
 114               	.LVL11:
 115               	.L1:
 116               	/* epilogue start */
 117               		.loc 1 90 0
 118 0062 DF91      		pop r29
 119 0064 CF91      		pop r28
 120               	.LVL12:
 121 0066 1F91      		pop r17
 122 0068 0F91      		pop r16
 123               	.LVL13:
 124 006a 0895      		ret
 125               		.cfi_endproc
 126               	.LFE13:
 128               		.section	.text.qk_register_weak_mods,"ax",@progbits
 130               	qk_register_weak_mods:
 131               	.LFB14:
  91:quantum/quantum.c **** 
  92:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 132               		.loc 1 92 0
 133               		.cfi_startproc
 134               	.LVL14:
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  93:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 139               		.loc 1 93 0
 140 0000 8770      		andi r24,lo8(7)
 141               	.LVL15:
 142 0002 91E0      		ldi r25,lo8(1)
 143 0004 00C0      		rjmp 2f
 144               		1:
 145 0006 990F      		lsl r25
 146               		2:
 147 0008 8A95      		dec r24
 148 000a 02F4      		brpl 1b
 149 000c 892F      		mov r24,r25
 150 000e 0E94 0000 		call add_weak_mods
 151               	.LVL16:
  94:quantum/quantum.c ****     send_keyboard_report();
 152               		.loc 1 94 0
 153 0012 0C94 0000 		jmp send_keyboard_report
 154               	.LVL17:
 155               		.cfi_endproc
 156               	.LFE14:
 158               		.section	.text.qk_register_mods,"ax",@progbits
 160               	qk_register_mods:
 161               	.LFB16:
  95:quantum/quantum.c **** }
  96:quantum/quantum.c **** 
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
  99:quantum/quantum.c ****     send_keyboard_report();
 100:quantum/quantum.c **** }
 101:quantum/quantum.c **** 
 102:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 162               		.loc 1 102 0
 163               		.cfi_startproc
 164               	.LVL18:
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 103:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 169               		.loc 1 103 0
 170 0000 8770      		andi r24,lo8(7)
 171               	.LVL19:
 172 0002 91E0      		ldi r25,lo8(1)
 173 0004 00C0      		rjmp 2f
 174               		1:
 175 0006 990F      		lsl r25
 176               		2:
 177 0008 8A95      		dec r24
 178 000a 02F4      		brpl 1b
 179 000c 892F      		mov r24,r25
 180 000e 0E94 0000 		call add_weak_mods
 181               	.LVL20:
 104:quantum/quantum.c ****     send_keyboard_report();
 182               		.loc 1 104 0
 183 0012 0C94 0000 		jmp send_keyboard_report
 184               	.LVL21:
 185               		.cfi_endproc
 186               	.LFE16:
 188               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 190               	qk_unregister_weak_mods:
 191               	.LFB15:
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
 192               		.loc 1 97 0
 193               		.cfi_startproc
 194               	.LVL22:
 195               	/* prologue: function */
 196               	/* frame size = 0 */
 197               	/* stack size = 0 */
 198               	.L__stack_usage = 0
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 199               		.loc 1 98 0
 200 0000 8770      		andi r24,lo8(7)
 201               	.LVL23:
 202 0002 91E0      		ldi r25,lo8(1)
 203 0004 00C0      		rjmp 2f
 204               		1:
 205 0006 990F      		lsl r25
 206               		2:
 207 0008 8A95      		dec r24
 208 000a 02F4      		brpl 1b
 209 000c 892F      		mov r24,r25
 210 000e 0E94 0000 		call del_weak_mods
 211               	.LVL24:
  99:quantum/quantum.c ****     send_keyboard_report();
 212               		.loc 1 99 0
 213 0012 0C94 0000 		jmp send_keyboard_report
 214               	.LVL25:
 215               		.cfi_endproc
 216               	.LFE15:
 218               		.section	.text.qk_unregister_mods,"ax",@progbits
 220               	qk_unregister_mods:
 221               	.LFB17:
 105:quantum/quantum.c **** }
 106:quantum/quantum.c **** 
 107:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 222               		.loc 1 107 0
 223               		.cfi_startproc
 224               	.LVL26:
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 227               	/* stack size = 0 */
 228               	.L__stack_usage = 0
 108:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 229               		.loc 1 108 0
 230 0000 8770      		andi r24,lo8(7)
 231               	.LVL27:
 232 0002 91E0      		ldi r25,lo8(1)
 233 0004 00C0      		rjmp 2f
 234               		1:
 235 0006 990F      		lsl r25
 236               		2:
 237 0008 8A95      		dec r24
 238 000a 02F4      		brpl 1b
 239 000c 892F      		mov r24,r25
 240 000e 0E94 0000 		call del_weak_mods
 241               	.LVL28:
 109:quantum/quantum.c ****     send_keyboard_report();
 242               		.loc 1 109 0
 243 0012 0C94 0000 		jmp send_keyboard_report
 244               	.LVL29:
 245               		.cfi_endproc
 246               	.LFE17:
 248               		.section	.text.register_code16,"ax",@progbits
 249               	.global	register_code16
 251               	register_code16:
 252               	.LFB18:
 110:quantum/quantum.c **** }
 111:quantum/quantum.c **** 
 112:quantum/quantum.c **** void register_code16 (uint16_t code) {
 253               		.loc 1 112 0
 254               		.cfi_startproc
 255               	.LVL30:
 256 0000 CF93      		push r28
 257               	.LCFI4:
 258               		.cfi_def_cfa_offset 3
 259               		.cfi_offset 28, -2
 260 0002 DF93      		push r29
 261               	.LCFI5:
 262               		.cfi_def_cfa_offset 4
 263               		.cfi_offset 29, -3
 264               	/* prologue: function */
 265               	/* frame size = 0 */
 266               	/* stack size = 2 */
 267               	.L__stack_usage = 2
 268 0004 EC01      		movw r28,r24
 113:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 269               		.loc 1 113 0
 270 0006 805E      		subi r24,-32
 271 0008 9109      		sbc r25,__zero_reg__
 272               	.LVL31:
 273 000a 0897      		sbiw r24,8
 274 000c 00F0      		brlo .L26
 275               		.loc 1 113 0 is_stmt 0 discriminator 1
 276 000e 2097      		sbiw r28,0
 277 0010 01F4      		brne .L27
 278               	.L26:
 114:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 279               		.loc 1 114 0 is_stmt 1
 280 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 281 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 282 0016 00C0      		rjmp .L29
 283               	.L27:
 115:quantum/quantum.c ****   } else {
 116:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 284               		.loc 1 116 0
 285 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 286 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 287               	.L29:
 288 001c CE01      		movw r24,r28
 289 001e 0E94 0000 		call do_code16
 290               	.LVL32:
 117:quantum/quantum.c ****   }
 118:quantum/quantum.c ****   register_code (code);
 291               		.loc 1 118 0
 292 0022 8C2F      		mov r24,r28
 293               	/* epilogue start */
 119:quantum/quantum.c **** }
 294               		.loc 1 119 0
 295 0024 DF91      		pop r29
 296 0026 CF91      		pop r28
 297               	.LVL33:
 118:quantum/quantum.c ****   register_code (code);
 298               		.loc 1 118 0
 299 0028 0C94 0000 		jmp register_code
 300               	.LVL34:
 301               		.cfi_endproc
 302               	.LFE18:
 304               		.section	.text.unregister_code16,"ax",@progbits
 305               	.global	unregister_code16
 307               	unregister_code16:
 308               	.LFB19:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 309               		.loc 1 121 0
 310               		.cfi_startproc
 311               	.LVL35:
 312 0000 CF93      		push r28
 313               	.LCFI6:
 314               		.cfi_def_cfa_offset 3
 315               		.cfi_offset 28, -2
 316 0002 DF93      		push r29
 317               	.LCFI7:
 318               		.cfi_def_cfa_offset 4
 319               		.cfi_offset 29, -3
 320               	/* prologue: function */
 321               	/* frame size = 0 */
 322               	/* stack size = 2 */
 323               	.L__stack_usage = 2
 324 0004 EC01      		movw r28,r24
 122:quantum/quantum.c ****   unregister_code (code);
 325               		.loc 1 122 0
 326 0006 0E94 0000 		call unregister_code
 327               	.LVL36:
 123:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 328               		.loc 1 123 0
 329 000a CE01      		movw r24,r28
 330 000c 805E      		subi r24,-32
 331 000e 9109      		sbc r25,__zero_reg__
 332 0010 0897      		sbiw r24,8
 333 0012 00F0      		brlo .L31
 334               		.loc 1 123 0 is_stmt 0 discriminator 1
 335 0014 2097      		sbiw r28,0
 336 0016 01F4      		brne .L32
 337               	.L31:
 124:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 338               		.loc 1 124 0 is_stmt 1
 339 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 340 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 341 001c 00C0      		rjmp .L33
 342               	.L32:
 125:quantum/quantum.c ****   } else {
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 343               		.loc 1 126 0
 344 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 345 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 346               	.L33:
 347 0022 CE01      		movw r24,r28
 348               	/* epilogue start */
 127:quantum/quantum.c ****   }
 128:quantum/quantum.c **** }
 349               		.loc 1 128 0
 350 0024 DF91      		pop r29
 351 0026 CF91      		pop r28
 352               	.LVL37:
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 353               		.loc 1 126 0
 354 0028 0C94 0000 		jmp do_code16
 355               	.LVL38:
 356               		.cfi_endproc
 357               	.LFE19:
 359               		.section	.text.process_action_kb,"ax",@progbits
 360               		.weak	process_action_kb
 362               	process_action_kb:
 363               	.LFB20:
 129:quantum/quantum.c **** 
 130:quantum/quantum.c **** __attribute__ ((weak))
 131:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 364               		.loc 1 131 0
 365               		.cfi_startproc
 366               	.LVL39:
 367               	/* prologue: function */
 368               	/* frame size = 0 */
 369               	/* stack size = 0 */
 370               	.L__stack_usage = 0
 132:quantum/quantum.c ****   return true;
 133:quantum/quantum.c **** }
 371               		.loc 1 133 0
 372 0000 81E0      		ldi r24,lo8(1)
 373               	.LVL40:
 374 0002 0895      		ret
 375               		.cfi_endproc
 376               	.LFE20:
 378               		.section	.text.process_record_user,"ax",@progbits
 379               		.weak	process_record_user
 381               	process_record_user:
 382               	.LFB22:
 134:quantum/quantum.c **** 
 135:quantum/quantum.c **** __attribute__ ((weak))
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 138:quantum/quantum.c **** }
 139:quantum/quantum.c **** 
 140:quantum/quantum.c **** __attribute__ ((weak))
 141:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 383               		.loc 1 141 0
 384               		.cfi_startproc
 385               	.LVL41:
 386               	/* prologue: function */
 387               	/* frame size = 0 */
 388               	/* stack size = 0 */
 389               	.L__stack_usage = 0
 142:quantum/quantum.c ****   return true;
 143:quantum/quantum.c **** }
 390               		.loc 1 143 0
 391 0000 81E0      		ldi r24,lo8(1)
 392               	.LVL42:
 393 0002 0895      		ret
 394               		.cfi_endproc
 395               	.LFE22:
 397               		.section	.text.process_record_kb,"ax",@progbits
 398               		.weak	process_record_kb
 400               	process_record_kb:
 401               	.LFB21:
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 402               		.loc 1 136 0
 403               		.cfi_startproc
 404               	.LVL43:
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407               	/* stack size = 0 */
 408               	.L__stack_usage = 0
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 409               		.loc 1 137 0
 410 0000 0C94 0000 		jmp process_record_user
 411               	.LVL44:
 412               		.cfi_endproc
 413               	.LFE21:
 415               		.section	.text.reset_keyboard,"ax",@progbits
 416               	.global	reset_keyboard
 418               	reset_keyboard:
 419               	.LFB23:
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** void reset_keyboard(void) {
 420               		.loc 1 145 0
 421               		.cfi_startproc
 422               	/* prologue: function */
 423               	/* frame size = 0 */
 424               	/* stack size = 0 */
 425               	.L__stack_usage = 0
 146:quantum/quantum.c ****   clear_keyboard();
 426               		.loc 1 146 0
 427 0000 0E94 0000 		call clear_keyboard
 428               	.LVL45:
 429               	.LBB29:
 430               	.LBB30:
 431               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 432               		.loc 2 164 0
 433 0004 2FEF      		ldi r18,lo8(799999)
 434 0006 84E3      		ldi r24,hi8(799999)
 435 0008 9CE0      		ldi r25,hlo8(799999)
 436 000a 2150      		1: subi r18,1
 437 000c 8040      		sbci r24,0
 438 000e 9040      		sbci r25,0
 439 0010 01F4      		brne 1b
 440 0012 00C0      		rjmp .
 441 0014 0000      		nop
 442               	.LBE30:
 443               	.LBE29:
 147:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 148:quantum/quantum.c ****   process_midi_all_notes_off();
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 151:quantum/quantum.c ****   music_all_notes_off();
 152:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 153:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 154:quantum/quantum.c ****   shutdown_user();
 155:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 156:quantum/quantum.c ****     wait_ms(1);
 157:quantum/quantum.c ****   stop_all_notes();
 158:quantum/quantum.c **** #else
 159:quantum/quantum.c ****   wait_ms(250);
 160:quantum/quantum.c **** #endif
 161:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 162:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 163:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 444               		.loc 1 163 0
 445 0016 87E7      		ldi r24,lo8(119)
 446 0018 97E7      		ldi r25,lo8(119)
 447 001a 9093 0108 		sts 2048+1,r25
 448 001e 8093 0008 		sts 2048,r24
 164:quantum/quantum.c **** #endif
 165:quantum/quantum.c ****   bootloader_jump();
 449               		.loc 1 165 0
 450 0022 0C94 0000 		jmp bootloader_jump
 451               	.LVL46:
 452               		.cfi_endproc
 453               	.LFE23:
 455               		.section	.text.process_record_quantum,"ax",@progbits
 456               	.global	process_record_quantum
 458               	process_record_quantum:
 459               	.LFB24:
 166:quantum/quantum.c **** }
 167:quantum/quantum.c **** 
 168:quantum/quantum.c **** // Shift / paren setup
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** #ifndef LSPO_KEY
 171:quantum/quantum.c ****   #define LSPO_KEY KC_9
 172:quantum/quantum.c **** #endif
 173:quantum/quantum.c **** #ifndef RSPC_KEY
 174:quantum/quantum.c ****   #define RSPC_KEY KC_0
 175:quantum/quantum.c **** #endif
 176:quantum/quantum.c **** 
 177:quantum/quantum.c **** // Shift / Enter setup
 178:quantum/quantum.c **** #ifndef SFTENT_KEY
 179:quantum/quantum.c ****   #define SFTENT_KEY KC_ENT
 180:quantum/quantum.c **** #endif
 181:quantum/quantum.c **** 
 182:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 183:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 184:quantum/quantum.c **** 
 185:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 186:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 187:quantum/quantum.c ****  */
 188:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 460               		.loc 1 190 0
 461               		.cfi_startproc
 462               	.LVL47:
 463 0000 0F93      		push r16
 464               	.LCFI8:
 465               		.cfi_def_cfa_offset 3
 466               		.cfi_offset 16, -2
 467 0002 1F93      		push r17
 468               	.LCFI9:
 469               		.cfi_def_cfa_offset 4
 470               		.cfi_offset 17, -3
 471 0004 CF93      		push r28
 472               	.LCFI10:
 473               		.cfi_def_cfa_offset 5
 474               		.cfi_offset 28, -4
 475 0006 DF93      		push r29
 476               	.LCFI11:
 477               		.cfi_def_cfa_offset 6
 478               		.cfi_offset 29, -5
 479               	/* prologue: function */
 480               	/* frame size = 0 */
 481               	/* stack size = 4 */
 482               	.L__stack_usage = 4
 483 0008 8C01      		movw r16,r24
 191:quantum/quantum.c **** 
 192:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 193:quantum/quantum.c ****   keypos_t key = record->event.key;
 484               		.loc 1 193 0
 485 000a FC01      		movw r30,r24
 486 000c C081      		ld r28,Z
 487 000e D181      		ldd r29,Z+1
 488               	.LVL48:
 194:quantum/quantum.c ****   uint16_t keycode;
 195:quantum/quantum.c **** 
 196:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 197:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 198:quantum/quantum.c ****     if (!disable_action_cache) {
 199:quantum/quantum.c ****       uint8_t layer;
 200:quantum/quantum.c **** 
 201:quantum/quantum.c ****       if (record->event.pressed) {
 202:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 203:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 204:quantum/quantum.c ****       } else {
 205:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 206:quantum/quantum.c ****       }
 207:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 208:quantum/quantum.c ****     } else
 209:quantum/quantum.c ****   #endif
 210:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 489               		.loc 1 210 0
 490 0010 CE01      		movw r24,r28
 491               	.LVL49:
 492 0012 0E94 0000 		call layer_switch_get_layer
 493               	.LVL50:
 494 0016 BE01      		movw r22,r28
 495 0018 0E94 0000 		call keymap_key_to_keycode
 496               	.LVL51:
 497 001c EC01      		movw r28,r24
 498               	.LVL52:
 211:quantum/quantum.c **** 
 212:quantum/quantum.c ****     // This is how you use actions here
 213:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 214:quantum/quantum.c ****     //   action_t action;
 215:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 216:quantum/quantum.c ****     //   process_action(record, action);
 217:quantum/quantum.c ****     //   return false;
 218:quantum/quantum.c ****     // }
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 221:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 499               		.loc 1 221 0
 500 001e B801      		movw r22,r16
 501 0020 0E94 0000 		call preprocess_tap_dance
 502               	.LVL53:
 222:quantum/quantum.c ****   #endif
 223:quantum/quantum.c **** 
 224:quantum/quantum.c ****   if (!(
 225:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 226:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 227:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 228:quantum/quantum.c ****   #endif
 229:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 230:quantum/quantum.c ****       process_clicky(keycode, record) &&
 231:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 503               		.loc 1 232 0
 504 0024 B801      		movw r22,r16
 505 0026 CE01      		movw r24,r28
 506 0028 0E94 0000 		call process_record_kb
 507               	.LVL54:
 233:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 234:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 235:quantum/quantum.c ****   #endif
 236:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 237:quantum/quantum.c ****     process_midi(keycode, record) &&
 238:quantum/quantum.c ****   #endif
 239:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 240:quantum/quantum.c ****     process_audio(keycode, record) &&
 241:quantum/quantum.c ****   #endif
 242:quantum/quantum.c ****   #ifdef STENO_ENABLE
 243:quantum/quantum.c ****     process_steno(keycode, record) &&
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c ****   #if ( defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSI
 246:quantum/quantum.c ****     process_music(keycode, record) &&
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 508               		.loc 1 249 0
 509 002c 8823      		tst r24
 510 002e 01F4      		brne .+2
 511 0030 00C0      		rjmp .L152
 512               		.loc 1 249 0 is_stmt 0 discriminator 2
 513 0032 B801      		movw r22,r16
 514 0034 CE01      		movw r24,r28
 515 0036 0E94 0000 		call process_tap_dance
 516               	.LVL55:
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 517               		.loc 1 232 0 is_stmt 1 discriminator 2
 518 003a 8823      		tst r24
 519 003c 01F4      		brne .+2
 520 003e 00C0      		rjmp .L152
 250:quantum/quantum.c ****   #endif
 251:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 252:quantum/quantum.c ****     process_leader(keycode, record) &&
 521               		.loc 1 252 0
 522 0040 B801      		movw r22,r16
 523 0042 CE01      		movw r24,r28
 524 0044 0E94 0000 		call process_leader
 525               	.LVL56:
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 526               		.loc 1 249 0
 527 0048 8823      		tst r24
 528 004a 01F4      		brne .+2
 529 004c 00C0      		rjmp .L152
 253:quantum/quantum.c ****   #endif
 254:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 255:quantum/quantum.c ****     process_chording(keycode, record) &&
 256:quantum/quantum.c ****   #endif
 257:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 258:quantum/quantum.c ****     process_combo(keycode, record) &&
 259:quantum/quantum.c ****   #endif
 260:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 261:quantum/quantum.c ****     process_unicode(keycode, record) &&
 262:quantum/quantum.c ****   #endif
 263:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 264:quantum/quantum.c ****     process_ucis(keycode, record) &&
 265:quantum/quantum.c ****   #endif
 266:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 267:quantum/quantum.c ****     process_printer(keycode, record) &&
 268:quantum/quantum.c ****   #endif
 269:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 270:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 271:quantum/quantum.c ****   #endif
 272:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 273:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 274:quantum/quantum.c ****   #endif
 275:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 276:quantum/quantum.c ****     process_terminal(keycode, record) &&
 277:quantum/quantum.c ****   #endif
 278:quantum/quantum.c ****       true)) {
 279:quantum/quantum.c ****     return false;
 280:quantum/quantum.c ****   }
 281:quantum/quantum.c **** 
 282:quantum/quantum.c ****   // Shift / paren setup
 283:quantum/quantum.c **** 
 284:quantum/quantum.c ****   switch(keycode) {
 530               		.loc 1 284 0
 531 004e C93C      		cpi r28,-55
 532 0050 FCE5      		ldi r31,92
 533 0052 DF07      		cpc r29,r31
 534 0054 01F4      		brne .L218
 285:quantum/quantum.c ****     case RESET:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 287:quantum/quantum.c ****         reset_keyboard();
 288:quantum/quantum.c ****       }
 289:quantum/quantum.c ****     return false;
 290:quantum/quantum.c ****     case DEBUG:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 292:quantum/quantum.c ****           debug_enable = true;
 293:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 294:quantum/quantum.c ****       }
 295:quantum/quantum.c ****     return false;
 296:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 297:quantum/quantum.c ****   case FC_TOG:
 298:quantum/quantum.c ****     if (record->event.pressed) {
 299:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 300:quantum/quantum.c ****     }
 301:quantum/quantum.c ****     return false;
 302:quantum/quantum.c ****   case FC_ON:
 303:quantum/quantum.c ****     if (record->event.pressed) {
 304:quantum/quantum.c ****       FAUXCLICKY_ON;
 305:quantum/quantum.c ****     }
 306:quantum/quantum.c ****     return false;
 307:quantum/quantum.c ****   case FC_OFF:
 308:quantum/quantum.c ****     if (record->event.pressed) {
 309:quantum/quantum.c ****       FAUXCLICKY_OFF;
 310:quantum/quantum.c ****     }
 311:quantum/quantum.c ****     return false;
 312:quantum/quantum.c ****   #endif
 313:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 314:quantum/quantum.c ****   case RGB_TOG:
 315:quantum/quantum.c ****     if (record->event.pressed) {
 316:quantum/quantum.c ****       rgblight_toggle();
 317:quantum/quantum.c ****     }
 318:quantum/quantum.c ****     return false;
 319:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 320:quantum/quantum.c ****     if (record->event.pressed) {
 321:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 322:quantum/quantum.c ****       if(shifted) {
 323:quantum/quantum.c ****         rgblight_step_reverse();
 324:quantum/quantum.c ****       }
 325:quantum/quantum.c ****       else {
 326:quantum/quantum.c ****         rgblight_step();
 327:quantum/quantum.c ****       }
 328:quantum/quantum.c ****     }
 329:quantum/quantum.c ****     return false;
 330:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 331:quantum/quantum.c ****     if (record->event.pressed) {
 332:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 333:quantum/quantum.c ****       if(shifted) {
 334:quantum/quantum.c ****         rgblight_step();
 335:quantum/quantum.c ****       }
 336:quantum/quantum.c ****       else {
 337:quantum/quantum.c ****         rgblight_step_reverse();
 338:quantum/quantum.c ****       }
 339:quantum/quantum.c ****     }
 340:quantum/quantum.c ****     return false;
 341:quantum/quantum.c ****   case RGB_HUI:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 343:quantum/quantum.c ****       rgblight_increase_hue();
 344:quantum/quantum.c ****     }
 345:quantum/quantum.c ****     return false;
 346:quantum/quantum.c ****   case RGB_HUD:
 347:quantum/quantum.c ****     if (record->event.pressed) {
 348:quantum/quantum.c ****       rgblight_decrease_hue();
 349:quantum/quantum.c ****     }
 350:quantum/quantum.c ****     return false;
 351:quantum/quantum.c ****   case RGB_SAI:
 352:quantum/quantum.c ****     if (record->event.pressed) {
 353:quantum/quantum.c ****       rgblight_increase_sat();
 354:quantum/quantum.c ****     }
 355:quantum/quantum.c ****     return false;
 356:quantum/quantum.c ****   case RGB_SAD:
 357:quantum/quantum.c ****     if (record->event.pressed) {
 358:quantum/quantum.c ****       rgblight_decrease_sat();
 359:quantum/quantum.c ****     }
 360:quantum/quantum.c ****     return false;
 361:quantum/quantum.c ****   case RGB_VAI:
 362:quantum/quantum.c ****     if (record->event.pressed) {
 363:quantum/quantum.c ****       rgblight_increase_val();
 364:quantum/quantum.c ****     }
 365:quantum/quantum.c ****     return false;
 366:quantum/quantum.c ****   case RGB_VAD:
 367:quantum/quantum.c ****     if (record->event.pressed) {
 368:quantum/quantum.c ****       rgblight_decrease_val();
 369:quantum/quantum.c ****     }
 370:quantum/quantum.c ****     return false;
 371:quantum/quantum.c ****   case RGB_SPI:
 372:quantum/quantum.c ****     if (record->event.pressed) {
 535               		.loc 1 372 0
 536 0056 F801      		movw r30,r16
 537 0058 8281      		ldd r24,Z+2
 538 005a 8823      		tst r24
 539 005c 01F4      		brne .+2
 540 005e 00C0      		rjmp .L152
 373:quantum/quantum.c ****       rgblight_increase_speed();
 541               		.loc 1 373 0
 542 0060 0E94 0000 		call rgblight_increase_speed
 543               	.LVL57:
 544 0064 00C0      		rjmp .L152
 545               	.L218:
 284:quantum/quantum.c ****   switch(keycode) {
 546               		.loc 1 284 0
 547 0066 CA3C      		cpi r28,-54
 548 0068 8CE5      		ldi r24,92
 549 006a D807      		cpc r29,r24
 550 006c 00F0      		brlo .+2
 551 006e 00C0      		rjmp .L116
 552 0070 C13C      		cpi r28,-63
 553 0072 9CE5      		ldi r25,92
 554 0074 D907      		cpc r29,r25
 555 0076 01F4      		brne .L219
 320:quantum/quantum.c ****     if (record->event.pressed) {
 556               		.loc 1 320 0
 557 0078 F801      		movw r30,r16
 558 007a 8281      		ldd r24,Z+2
 559 007c 8823      		tst r24
 560 007e 01F4      		brne .+2
 561 0080 00C0      		rjmp .L152
 562               	.LBB31:
 321:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 563               		.loc 1 321 0
 564 0082 0E94 0000 		call get_mods
 565               	.LVL58:
 566 0086 8272      		andi r24,lo8(34)
 567               	.LVL59:
 322:quantum/quantum.c ****       if(shifted) {
 568               		.loc 1 322 0
 569 0088 01F0      		breq .L46
 570               	.LVL60:
 571               	.L48:
 323:quantum/quantum.c ****         rgblight_step_reverse();
 572               		.loc 1 323 0
 573 008a 0E94 0000 		call rgblight_step_reverse
 574               	.LVL61:
 575 008e 00C0      		rjmp .L152
 576               	.L219:
 577               	.LBE31:
 284:quantum/quantum.c ****   switch(keycode) {
 578               		.loc 1 284 0
 579 0090 C23C      		cpi r28,-62
 580 0092 ECE5      		ldi r30,92
 581 0094 DE07      		cpc r29,r30
 582 0096 00F0      		brlo .L220
 583 0098 F801      		movw r30,r16
 584 009a 8281      		ldd r24,Z+2
 585 009c C53C      		cpi r28,-59
 586 009e FCE5      		ldi r31,92
 587 00a0 DF07      		cpc r29,r31
 588 00a2 01F4      		brne .+2
 589 00a4 00C0      		rjmp .L51
 590 00a6 00F0      		brlo .+2
 591 00a8 00C0      		rjmp .L119
 592 00aa C33C      		cpi r28,-61
 593 00ac ECE5      		ldi r30,92
 594 00ae DE07      		cpc r29,r30
 595 00b0 01F4      		brne .+2
 596 00b2 00C0      		rjmp .L49
 597 00b4 00F0      		brlo .+2
 598 00b6 00C0      		rjmp .L221
 331:quantum/quantum.c ****     if (record->event.pressed) {
 599               		.loc 1 331 0
 600 00b8 8823      		tst r24
 601 00ba 01F4      		brne .+2
 602 00bc 00C0      		rjmp .L152
 603               	.LBB32:
 332:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 604               		.loc 1 332 0
 605 00be 0E94 0000 		call get_mods
 606               	.LVL62:
 607 00c2 8272      		andi r24,lo8(34)
 608               	.LVL63:
 333:quantum/quantum.c ****       if(shifted) {
 609               		.loc 1 333 0
 610 00c4 01F0      		breq .L48
 611               	.LVL64:
 612               	.L46:
 613               	.LBE32:
 614               	.LBB33:
 326:quantum/quantum.c ****         rgblight_step();
 615               		.loc 1 326 0
 616 00c6 0E94 0000 		call rgblight_step
 617               	.LVL65:
 618 00ca 00C0      		rjmp .L152
 619               	.L220:
 620               	.LBE33:
 284:quantum/quantum.c ****   switch(keycode) {
 621               		.loc 1 284 0
 622 00cc C531      		cpi r28,21
 623 00ce FCE5      		ldi r31,92
 624 00d0 DF07      		cpc r29,r31
 625 00d2 00F0      		brlo .+2
 626 00d4 00C0      		rjmp .L118
 627 00d6 C230      		cpi r28,2
 628 00d8 8CE5      		ldi r24,92
 629 00da D807      		cpc r29,r24
 630 00dc 00F4      		brsh .+2
 631 00de 00C0      		rjmp .L222
 374:quantum/quantum.c ****     }
 375:quantum/quantum.c ****     return false;
 376:quantum/quantum.c ****   case RGB_SPD:
 377:quantum/quantum.c ****     if (record->event.pressed) {
 378:quantum/quantum.c ****       rgblight_decrease_speed();
 379:quantum/quantum.c ****     }
 380:quantum/quantum.c ****     return false;
 381:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 382:quantum/quantum.c ****     if (record->event.pressed) {
 383:quantum/quantum.c ****       rgblight_mode(1);
 384:quantum/quantum.c ****     }
 385:quantum/quantum.c ****     return false;
 386:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 387:quantum/quantum.c ****     if (record->event.pressed) {
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 389:quantum/quantum.c ****         rgblight_step();
 390:quantum/quantum.c ****       } else {
 391:quantum/quantum.c ****         rgblight_mode(2);
 392:quantum/quantum.c ****       }
 393:quantum/quantum.c ****     }
 394:quantum/quantum.c ****     return false;
 395:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 396:quantum/quantum.c ****     if (record->event.pressed) {
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 398:quantum/quantum.c ****         rgblight_step();
 399:quantum/quantum.c ****       } else {
 400:quantum/quantum.c ****         rgblight_mode(6);
 401:quantum/quantum.c ****       }
 402:quantum/quantum.c ****     }
 403:quantum/quantum.c ****     return false;
 404:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 405:quantum/quantum.c ****     if (record->event.pressed) {
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 407:quantum/quantum.c ****         rgblight_step();
 408:quantum/quantum.c ****       } else {
 409:quantum/quantum.c ****         rgblight_mode(9);
 410:quantum/quantum.c ****       }
 411:quantum/quantum.c ****     }
 412:quantum/quantum.c ****     return false;
 413:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 414:quantum/quantum.c ****     if (record->event.pressed) {
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 416:quantum/quantum.c ****         rgblight_step();
 417:quantum/quantum.c ****       } else {
 418:quantum/quantum.c ****         rgblight_mode(15);
 419:quantum/quantum.c ****       }
 420:quantum/quantum.c ****     }
 421:quantum/quantum.c ****     return false;
 422:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 423:quantum/quantum.c ****     if (record->event.pressed) {
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 425:quantum/quantum.c ****         rgblight_step();
 426:quantum/quantum.c ****       } else {
 427:quantum/quantum.c ****         rgblight_mode(21);
 428:quantum/quantum.c ****       }
 429:quantum/quantum.c ****     }
 430:quantum/quantum.c ****     return false;
 431:quantum/quantum.c ****   case RGB_MODE_XMAS:
 432:quantum/quantum.c ****     if (record->event.pressed) {
 433:quantum/quantum.c ****       rgblight_mode(24);
 434:quantum/quantum.c ****     }
 435:quantum/quantum.c ****     return false;
 436:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 437:quantum/quantum.c ****     if (record->event.pressed) {
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 439:quantum/quantum.c ****         rgblight_step();
 440:quantum/quantum.c ****       } else {
 441:quantum/quantum.c ****         rgblight_mode(25);
 442:quantum/quantum.c ****       }
 443:quantum/quantum.c ****     }
 444:quantum/quantum.c ****     return false;
 445:quantum/quantum.c ****   #endif
 446:quantum/quantum.c ****     #ifdef PROTOCOL_LUFA
 447:quantum/quantum.c ****     case OUT_AUTO:
 448:quantum/quantum.c ****       if (record->event.pressed) {
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 450:quantum/quantum.c ****       }
 451:quantum/quantum.c ****       return false;
 452:quantum/quantum.c ****     case OUT_USB:
 453:quantum/quantum.c ****       if (record->event.pressed) {
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 455:quantum/quantum.c ****       }
 456:quantum/quantum.c ****       return false;
 457:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 458:quantum/quantum.c ****     case OUT_BT:
 459:quantum/quantum.c ****       if (record->event.pressed) {
 460:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 461:quantum/quantum.c ****       }
 462:quantum/quantum.c ****       return false;
 463:quantum/quantum.c ****     #endif
 464:quantum/quantum.c ****     #endif
 465:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 466:quantum/quantum.c ****       if (record->event.pressed) {
 632               		.loc 1 466 0
 633 00e0 F801      		movw r30,r16
 634 00e2 8281      		ldd r24,Z+2
 635 00e4 8823      		tst r24
 636 00e6 01F4      		brne .+2
 637 00e8 00C0      		rjmp .L74
 467:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 468:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 638               		.loc 1 468 0
 639 00ea 0E94 0000 		call eeconfig_is_enabled
 640               	.LVL66:
 641 00ee 8111      		cpse r24,__zero_reg__
 642 00f0 00C0      		rjmp .L75
 469:quantum/quantum.c ****             eeconfig_init();
 643               		.loc 1 469 0
 644 00f2 0E94 0000 		call eeconfig_init
 645               	.LVL67:
 646               	.L75:
 470:quantum/quantum.c ****         }
 471:quantum/quantum.c ****         /* keymap config */
 472:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 647               		.loc 1 472 0
 648 00f6 0E94 0000 		call eeconfig_read_keymap
 649               	.LVL68:
 650 00fa 90E0      		ldi r25,0
 651 00fc 9093 0000 		sts keymap_config+1,r25
 652 0100 8093 0000 		sts keymap_config,r24
 473:quantum/quantum.c ****         switch (keycode)
 653               		.loc 1 473 0
 654 0104 FE01      		movw r30,r28
 655 0106 E350      		subi r30,3
 656 0108 FC45      		sbci r31,92
 657 010a E231      		cpi r30,18
 658 010c F105      		cpc r31,__zero_reg__
 659 010e 00F4      		brsh .L76
 660 0110 E050      		subi r30,lo8(-(gs(.L78)))
 661 0112 F040      		sbci r31,hi8(-(gs(.L78)))
 662 0114 0C94 0000 		jmp __tablejump2__
 663               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 664               		.p2align	1
 665               	.L78:
 666 0000 0000      		.word gs(.L77)
 667 0002 0000      		.word gs(.L79)
 668 0004 0000      		.word gs(.L80)
 669 0006 0000      		.word gs(.L81)
 670 0008 0000      		.word gs(.L82)
 671 000a 0000      		.word gs(.L83)
 672 000c 0000      		.word gs(.L84)
 673 000e 0000      		.word gs(.L85)
 674 0010 0000      		.word gs(.L86)
 675 0012 0000      		.word gs(.L87)
 676 0014 0000      		.word gs(.L88)
 677 0016 0000      		.word gs(.L89)
 678 0018 0000      		.word gs(.L90)
 679 001a 0000      		.word gs(.L91)
 680 001c 0000      		.word gs(.L92)
 681 001e 0000      		.word gs(.L93)
 682 0020 0000      		.word gs(.L94)
 683 0022 0000      		.word gs(.L95)
 684               		.section	.text.process_record_quantum
 685               	.L76:
 474:quantum/quantum.c ****         {
 475:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 476:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 686               		.loc 1 476 0
 687 0118 8091 0000 		lds r24,keymap_config
 688 011c 8160      		ori r24,lo8(1<<0)
 689 011e 00C0      		rjmp .L211
 690               	.L77:
 477:quantum/quantum.c ****             break;
 478:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 479:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 691               		.loc 1 479 0
 692 0120 8091 0000 		lds r24,keymap_config
 693 0124 8260      		ori r24,lo8(1<<1)
 694               	.L211:
 695 0126 8093 0000 		sts keymap_config,r24
 480:quantum/quantum.c ****             break;
 696               		.loc 1 480 0
 697 012a 00C0      		rjmp .L96
 698               	.L79:
 481:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 482:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 699               		.loc 1 482 0
 700 012c 8091 0000 		lds r24,keymap_config
 701 0130 8460      		ori r24,lo8(1<<2)
 702 0132 00C0      		rjmp .L211
 703               	.L80:
 483:quantum/quantum.c ****             break;
 484:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 485:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 704               		.loc 1 485 0
 705 0134 8091 0000 		lds r24,keymap_config
 706 0138 00C0      		rjmp .L217
 707               	.L81:
 486:quantum/quantum.c ****             break;
 487:quantum/quantum.c ****           case MAGIC_NO_GUI:
 488:quantum/quantum.c ****             keymap_config.no_gui = true;
 708               		.loc 1 488 0
 709 013a 8091 0000 		lds r24,keymap_config
 710 013e 8061      		ori r24,lo8(1<<4)
 711 0140 00C0      		rjmp .L211
 712               	.L82:
 489:quantum/quantum.c ****             break;
 490:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 491:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 713               		.loc 1 491 0
 714 0142 8091 0000 		lds r24,keymap_config
 715 0146 8062      		ori r24,lo8(1<<5)
 716 0148 00C0      		rjmp .L211
 717               	.L83:
 492:quantum/quantum.c ****             break;
 493:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 494:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 718               		.loc 1 494 0
 719 014a 8091 0000 		lds r24,keymap_config
 720 014e 8064      		ori r24,lo8(1<<6)
 721 0150 00C0      		rjmp .L211
 722               	.L84:
 495:quantum/quantum.c ****             break;
 496:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 497:quantum/quantum.c ****             keymap_config.nkro = true;
 723               		.loc 1 497 0
 724 0152 8091 0000 		lds r24,keymap_config
 725 0156 8068      		ori r24,lo8(1<<7)
 726 0158 00C0      		rjmp .L211
 727               	.L85:
 498:quantum/quantum.c ****             break;
 499:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 500:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 728               		.loc 1 500 0
 729 015a 8091 0000 		lds r24,keymap_config
 501:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 730               		.loc 1 501 0
 731 015e 8460      		ori r24,lo8(4)
 732               	.L217:
 733 0160 8860      		ori r24,lo8(1<<3)
 734 0162 00C0      		rjmp .L211
 735               	.L86:
 502:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 503:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 504:quantum/quantum.c ****             #endif
 505:quantum/quantum.c ****             break;
 506:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 507:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 736               		.loc 1 507 0
 737 0164 8091 0000 		lds r24,keymap_config
 738 0168 8E7F      		andi r24,lo8(~(1<<0))
 739 016a 00C0      		rjmp .L211
 740               	.L87:
 508:quantum/quantum.c ****             break;
 509:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 510:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 741               		.loc 1 510 0
 742 016c 8091 0000 		lds r24,keymap_config
 743 0170 8D7F      		andi r24,lo8(~(1<<1))
 744 0172 00C0      		rjmp .L211
 745               	.L88:
 511:quantum/quantum.c ****             break;
 512:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 513:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 746               		.loc 1 513 0
 747 0174 8091 0000 		lds r24,keymap_config
 748 0178 8B7F      		andi r24,lo8(~(1<<2))
 749 017a 00C0      		rjmp .L211
 750               	.L89:
 514:quantum/quantum.c ****             break;
 515:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 516:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 751               		.loc 1 516 0
 752 017c 8091 0000 		lds r24,keymap_config
 753 0180 00C0      		rjmp .L216
 754               	.L90:
 517:quantum/quantum.c ****             break;
 518:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 519:quantum/quantum.c ****             keymap_config.no_gui = false;
 755               		.loc 1 519 0
 756 0182 8091 0000 		lds r24,keymap_config
 757 0186 8F7E      		andi r24,lo8(~(1<<4))
 758 0188 00C0      		rjmp .L211
 759               	.L91:
 520:quantum/quantum.c ****             break;
 521:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 522:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 760               		.loc 1 522 0
 761 018a 8091 0000 		lds r24,keymap_config
 762 018e 8F7D      		andi r24,lo8(~(1<<5))
 763 0190 00C0      		rjmp .L211
 764               	.L92:
 523:quantum/quantum.c ****             break;
 524:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 525:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 765               		.loc 1 525 0
 766 0192 8091 0000 		lds r24,keymap_config
 767 0196 8F7B      		andi r24,lo8(~(1<<6))
 768 0198 00C0      		rjmp .L211
 769               	.L93:
 526:quantum/quantum.c ****             break;
 527:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 528:quantum/quantum.c ****             keymap_config.nkro = false;
 770               		.loc 1 528 0
 771 019a 8091 0000 		lds r24,keymap_config
 772 019e 8F77      		andi r24,lo8(~(1<<7))
 773 01a0 00C0      		rjmp .L211
 774               	.L94:
 529:quantum/quantum.c ****             break;
 530:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 531:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 775               		.loc 1 531 0
 776 01a2 8091 0000 		lds r24,keymap_config
 532:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 777               		.loc 1 532 0
 778 01a6 8B7F      		andi r24,lo8(-5)
 779               	.L216:
 780 01a8 877F      		andi r24,lo8(~(1<<3))
 781 01aa 00C0      		rjmp .L211
 782               	.L95:
 533:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 534:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 535:quantum/quantum.c ****             #endif
 536:quantum/quantum.c ****             break;
 537:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 538:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 783               		.loc 1 538 0
 784 01ac 9091 0000 		lds r25,keymap_config
 785 01b0 97FB      		bst r25,7
 786 01b2 8827      		clr r24
 787 01b4 80F9      		bld r24,0
 788 01b6 21E0      		ldi r18,lo8(1)
 789 01b8 8227      		eor r24,r18
 790 01ba 80FB      		bst r24,0
 791 01bc 97F9      		bld r25,7
 792 01be 9093 0000 		sts keymap_config,r25
 793               	.L96:
 539:quantum/quantum.c ****             break;
 540:quantum/quantum.c ****           default:
 541:quantum/quantum.c ****             break;
 542:quantum/quantum.c ****         }
 543:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 794               		.loc 1 543 0
 795 01c2 8091 0000 		lds r24,keymap_config
 796 01c6 0E94 0000 		call eeconfig_update_keymap
 797               	.LVL69:
 544:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 798               		.loc 1 544 0
 799 01ca 0E94 0000 		call clear_keyboard
 800               	.LVL70:
 545:quantum/quantum.c **** 
 546:quantum/quantum.c ****         return false;
 801               		.loc 1 546 0
 802 01ce 00C0      		rjmp .L152
 803               	.L222:
 284:quantum/quantum.c ****   switch(keycode) {
 804               		.loc 1 284 0
 805 01d0 C115      		cp r28,__zero_reg__
 806 01d2 9CE5      		ldi r25,92
 807 01d4 D907      		cpc r29,r25
 808 01d6 01F0      		breq .L41
 809 01d8 C130      		cpi r28,1
 810 01da DC45      		sbci r29,92
 811 01dc 01F0      		breq .L43
 812               	.L115:
 547:quantum/quantum.c ****       }
 548:quantum/quantum.c ****       break;
 549:quantum/quantum.c ****     case KC_LSPO: {
 550:quantum/quantum.c ****       if (record->event.pressed) {
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 554:quantum/quantum.c ****       }
 555:quantum/quantum.c ****       else {
 556:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 557:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 558:quantum/quantum.c ****             shift_interrupted[0] = true;
 559:quantum/quantum.c ****             shift_interrupted[1] = true;
 560:quantum/quantum.c ****           }
 561:quantum/quantum.c ****         #endif
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 565:quantum/quantum.c ****         }
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 567:quantum/quantum.c ****       }
 568:quantum/quantum.c ****       return false;
 569:quantum/quantum.c ****     }
 570:quantum/quantum.c **** 
 571:quantum/quantum.c ****     case KC_RSPC: {
 572:quantum/quantum.c ****       if (record->event.pressed) {
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 576:quantum/quantum.c ****       }
 577:quantum/quantum.c ****       else {
 578:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 579:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 580:quantum/quantum.c ****             shift_interrupted[0] = true;
 581:quantum/quantum.c ****             shift_interrupted[1] = true;
 582:quantum/quantum.c ****           }
 583:quantum/quantum.c ****         #endif
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 587:quantum/quantum.c ****         }
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 589:quantum/quantum.c ****       }
 590:quantum/quantum.c ****       return false;
 591:quantum/quantum.c ****     }
 592:quantum/quantum.c **** 
 593:quantum/quantum.c ****     case KC_SFTENT: {
 594:quantum/quantum.c ****       if (record->event.pressed) {
 595:quantum/quantum.c ****         shift_interrupted[1] = false;
 596:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 597:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 598:quantum/quantum.c ****       }
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 603:quantum/quantum.c ****       }
 604:quantum/quantum.c ****       else {
 605:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 606:quantum/quantum.c ****       }
 607:quantum/quantum.c ****       return false;
 608:quantum/quantum.c ****     }
 609:quantum/quantum.c **** 
 610:quantum/quantum.c ****     case GRAVE_ESC: {
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 612:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 613:quantum/quantum.c **** 
 614:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 615:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 616:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 617:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 618:quantum/quantum.c ****         shifted = 0;
 619:quantum/quantum.c ****       }
 620:quantum/quantum.c **** #endif
 621:quantum/quantum.c **** 
 622:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 623:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 624:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 625:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 626:quantum/quantum.c ****         shifted = 0;
 627:quantum/quantum.c ****       }
 628:quantum/quantum.c **** #endif
 629:quantum/quantum.c **** 
 630:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 631:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 632:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 633:quantum/quantum.c ****         shifted = 0;
 634:quantum/quantum.c ****       }
 635:quantum/quantum.c **** #endif
 636:quantum/quantum.c **** 
 637:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 638:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 639:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 640:quantum/quantum.c ****         shifted = 0;
 641:quantum/quantum.c ****       }
 642:quantum/quantum.c **** #endif
 643:quantum/quantum.c **** 
 644:quantum/quantum.c ****       if (record->event.pressed) {
 645:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 646:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 647:quantum/quantum.c ****       }
 648:quantum/quantum.c ****       else {
 649:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 650:quantum/quantum.c ****       }
 651:quantum/quantum.c **** 
 652:quantum/quantum.c ****       send_keyboard_report();
 653:quantum/quantum.c ****       return false;
 654:quantum/quantum.c ****     }
 655:quantum/quantum.c **** 
 656:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 657:quantum/quantum.c ****     case BL_BRTG: {
 658:quantum/quantum.c ****       if (record->event.pressed)
 659:quantum/quantum.c ****         breathing_toggle();
 660:quantum/quantum.c ****       return false;
 661:quantum/quantum.c ****     }
 662:quantum/quantum.c **** #endif
 663:quantum/quantum.c **** 
 664:quantum/quantum.c ****     default: {
 665:quantum/quantum.c ****       shift_interrupted[0] = true;
 813               		.loc 1 665 0
 814 01de 81E0      		ldi r24,lo8(1)
 815 01e0 8093 0000 		sts shift_interrupted,r24
 666:quantum/quantum.c ****       shift_interrupted[1] = true;
 816               		.loc 1 666 0
 817 01e4 8093 0000 		sts shift_interrupted+1,r24
 818               	.L74:
 667:quantum/quantum.c ****       break;
 668:quantum/quantum.c ****     }
 669:quantum/quantum.c ****   }
 670:quantum/quantum.c **** 
 671:quantum/quantum.c ****   return process_action_kb(record);
 819               		.loc 1 671 0
 820 01e8 C801      		movw r24,r16
 821               	/* epilogue start */
 672:quantum/quantum.c **** }
 822               		.loc 1 672 0
 823 01ea DF91      		pop r29
 824 01ec CF91      		pop r28
 825               	.LVL71:
 826 01ee 1F91      		pop r17
 827 01f0 0F91      		pop r16
 828               	.LVL72:
 671:quantum/quantum.c ****   return process_action_kb(record);
 829               		.loc 1 671 0
 830 01f2 0C94 0000 		jmp process_action_kb
 831               	.LVL73:
 832               	.L41:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 833               		.loc 1 286 0
 834 01f6 F801      		movw r30,r16
 835 01f8 8281      		ldd r24,Z+2
 836 01fa 8823      		tst r24
 837 01fc 01F4      		brne .+2
 838 01fe 00C0      		rjmp .L152
 287:quantum/quantum.c ****         reset_keyboard();
 839               		.loc 1 287 0
 840 0200 0E94 0000 		call reset_keyboard
 841               	.LVL74:
 842 0204 00C0      		rjmp .L152
 843               	.L43:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 844               		.loc 1 291 0
 845 0206 F801      		movw r30,r16
 846 0208 8281      		ldd r24,Z+2
 847 020a 8823      		tst r24
 848 020c 01F4      		brne .+2
 849 020e 00C0      		rjmp .L152
 292:quantum/quantum.c ****           debug_enable = true;
 850               		.loc 1 292 0
 851 0210 8091 0000 		lds r24,debug_config
 852 0214 8160      		ori r24,lo8(1<<0)
 853 0216 8093 0000 		sts debug_config,r24
 854 021a 00C0      		rjmp .L152
 855               	.L118:
 284:quantum/quantum.c ****   switch(keycode) {
 856               		.loc 1 284 0
 857 021c C531      		cpi r28,21
 858 021e FCE5      		ldi r31,92
 859 0220 DF07      		cpc r29,r31
 860 0222 01F4      		brne .L223
 861               	.LBB34:
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 862               		.loc 1 611 0
 863 0224 0E94 0000 		call get_mods
 864               	.LVL75:
 865 0228 382F      		mov r19,r24
 866               	.LVL76:
 644:quantum/quantum.c ****       if (record->event.pressed) {
 867               		.loc 1 644 0
 868 022a F801      		movw r30,r16
 869 022c 2281      		ldd r18,Z+2
 870 022e 8091 0000 		lds r24,keyboard_report
 871 0232 9091 0000 		lds r25,keyboard_report+1
 872 0236 2223      		tst r18
 873 0238 01F0      		breq .L110
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 874               		.loc 1 611 0
 875 023a 3A7A      		andi r19,lo8(-86)
 876               	.LVL77:
 645:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 877               		.loc 1 645 0
 878 023c 21E0      		ldi r18,lo8(1)
 879 023e 01F4      		brne .L111
 880 0240 20E0      		ldi r18,0
 881               	.L111:
 882 0242 2093 0000 		sts grave_esc_was_shifted,r18
 646:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 883               		.loc 1 646 0
 884 0246 2223      		tst r18
 885 0248 01F0      		breq .L123
 886 024a 65E3      		ldi r22,lo8(53)
 887 024c 00C0      		rjmp .L112
 888               	.L123:
 889 024e 69E2      		ldi r22,lo8(41)
 890               	.L112:
 891               	.LVL78:
 892               	.LBB35:
 893               	.LBB36:
 894               		.file 3 "./tmk_core/common/action_util.h"
   1:./tmk_core/common/action_util.h **** /*
   2:./tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action_util.h **** 
   4:./tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action_util.h **** (at your option) any later version.
   8:./tmk_core/common/action_util.h **** 
   9:./tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:./tmk_core/common/action_util.h **** 
  14:./tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action_util.h **** */
  17:./tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:./tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:./tmk_core/common/action_util.h **** 
  20:./tmk_core/common/action_util.h **** #include <stdint.h>
  21:./tmk_core/common/action_util.h **** #include "report.h"
  22:./tmk_core/common/action_util.h **** 
  23:./tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:./tmk_core/common/action_util.h **** extern "C" {
  25:./tmk_core/common/action_util.h **** #endif
  26:./tmk_core/common/action_util.h **** 
  27:./tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:./tmk_core/common/action_util.h **** 
  29:./tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:./tmk_core/common/action_util.h **** 
  31:./tmk_core/common/action_util.h **** /* key */
  32:./tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 895               		.loc 3 33 0 discriminator 1
 896 0250 0E94 0000 		call add_key_to_report
 897               	.LVL79:
 898 0254 00C0      		rjmp .L113
 899               	.LVL80:
 900               	.L110:
 901               	.LBE36:
 902               	.LBE35:
 649:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 903               		.loc 1 649 0
 904 0256 2091 0000 		lds r18,grave_esc_was_shifted
 905 025a 2223      		tst r18
 906 025c 01F0      		breq .L124
 907 025e 65E3      		ldi r22,lo8(53)
 908 0260 00C0      		rjmp .L114
 909               	.L124:
 910 0262 69E2      		ldi r22,lo8(41)
 911               	.L114:
 912               	.LVL81:
 913               	.LBB37:
 914               	.LBB38:
  34:./tmk_core/common/action_util.h **** }
  35:./tmk_core/common/action_util.h **** 
  36:./tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:./tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 915               		.loc 3 37 0 discriminator 3
 916 0264 0E94 0000 		call del_key_from_report
 917               	.LVL82:
 918               	.L113:
 919               	.LBE38:
 920               	.LBE37:
 652:quantum/quantum.c ****       send_keyboard_report();
 921               		.loc 1 652 0
 922 0268 0E94 0000 		call send_keyboard_report
 923               	.LVL83:
 653:quantum/quantum.c ****       return false;
 924               		.loc 1 653 0
 925 026c 00C0      		rjmp .L152
 926               	.L223:
 927               	.LBE34:
 284:quantum/quantum.c ****   switch(keycode) {
 928               		.loc 1 284 0
 929 026e C03C      		cpi r28,-64
 930 0270 DC45      		sbci r29,92
 931 0272 01F0      		breq .+2
 932 0274 00C0      		rjmp .L115
 315:quantum/quantum.c ****     if (record->event.pressed) {
 933               		.loc 1 315 0
 934 0276 F801      		movw r30,r16
 935 0278 8281      		ldd r24,Z+2
 936 027a 8823      		tst r24
 937 027c 01F4      		brne .+2
 938 027e 00C0      		rjmp .L152
 316:quantum/quantum.c ****       rgblight_toggle();
 939               		.loc 1 316 0
 940 0280 0E94 0000 		call rgblight_toggle
 941               	.LVL84:
 942 0284 00C0      		rjmp .L152
 943               	.L51:
 352:quantum/quantum.c ****     if (record->event.pressed) {
 944               		.loc 1 352 0
 945 0286 8823      		tst r24
 946 0288 01F4      		brne .+2
 947 028a 00C0      		rjmp .L152
 353:quantum/quantum.c ****       rgblight_increase_sat();
 948               		.loc 1 353 0
 949 028c 0E94 0000 		call rgblight_increase_sat
 950               	.LVL85:
 951 0290 00C0      		rjmp .L152
 952               	.L49:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 953               		.loc 1 342 0
 954 0292 8823      		tst r24
 955 0294 01F4      		brne .+2
 956 0296 00C0      		rjmp .L152
 343:quantum/quantum.c ****       rgblight_increase_hue();
 957               		.loc 1 343 0
 958 0298 0E94 0000 		call rgblight_increase_hue
 959               	.LVL86:
 960 029c 00C0      		rjmp .L152
 961               	.L221:
 347:quantum/quantum.c ****     if (record->event.pressed) {
 962               		.loc 1 347 0
 963 029e 8823      		tst r24
 964 02a0 01F4      		brne .+2
 965 02a2 00C0      		rjmp .L152
 348:quantum/quantum.c ****       rgblight_decrease_hue();
 966               		.loc 1 348 0
 967 02a4 0E94 0000 		call rgblight_decrease_hue
 968               	.LVL87:
 969 02a8 00C0      		rjmp .L152
 970               	.L119:
 284:quantum/quantum.c ****   switch(keycode) {
 971               		.loc 1 284 0
 972 02aa C73C      		cpi r28,-57
 973 02ac 9CE5      		ldi r25,92
 974 02ae D907      		cpc r29,r25
 975 02b0 01F4      		brne .L224
 362:quantum/quantum.c ****     if (record->event.pressed) {
 976               		.loc 1 362 0
 977 02b2 8823      		tst r24
 978 02b4 01F4      		brne .+2
 979 02b6 00C0      		rjmp .L152
 363:quantum/quantum.c ****       rgblight_increase_val();
 980               		.loc 1 363 0
 981 02b8 0E94 0000 		call rgblight_increase_val
 982               	.LVL88:
 983 02bc 00C0      		rjmp .L152
 984               	.L224:
 284:quantum/quantum.c ****   switch(keycode) {
 985               		.loc 1 284 0
 986 02be C83C      		cpi r28,-56
 987 02c0 DC45      		sbci r29,92
 988 02c2 00F4      		brsh .L225
 357:quantum/quantum.c ****     if (record->event.pressed) {
 989               		.loc 1 357 0
 990 02c4 8823      		tst r24
 991 02c6 01F4      		brne .+2
 992 02c8 00C0      		rjmp .L152
 358:quantum/quantum.c ****       rgblight_decrease_sat();
 993               		.loc 1 358 0
 994 02ca 0E94 0000 		call rgblight_decrease_sat
 995               	.LVL89:
 996 02ce 00C0      		rjmp .L152
 997               	.L225:
 367:quantum/quantum.c ****     if (record->event.pressed) {
 998               		.loc 1 367 0
 999 02d0 8823      		tst r24
 1000 02d2 01F4      		brne .+2
 1001 02d4 00C0      		rjmp .L152
 368:quantum/quantum.c ****       rgblight_decrease_val();
 1002               		.loc 1 368 0
 1003 02d6 0E94 0000 		call rgblight_decrease_val
 1004               	.LVL90:
 1005 02da 00C0      		rjmp .L152
 1006               	.L116:
 284:quantum/quantum.c ****   switch(keycode) {
 1007               		.loc 1 284 0
 1008 02dc C03D      		cpi r28,-48
 1009 02de FCE5      		ldi r31,92
 1010 02e0 DF07      		cpc r29,r31
 1011 02e2 01F4      		brne .L226
 423:quantum/quantum.c ****     if (record->event.pressed) {
 1012               		.loc 1 423 0
 1013 02e4 F801      		movw r30,r16
 1014 02e6 8281      		ldd r24,Z+2
 1015 02e8 8823      		tst r24
 1016 02ea 01F4      		brne .+2
 1017 02ec 00C0      		rjmp .L152
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 1018               		.loc 1 424 0
 1019 02ee 0E94 0000 		call rgblight_get_mode
 1020               	.LVL91:
 1021 02f2 6531      		cpi r22,21
 1022 02f4 7105      		cpc r23,__zero_reg__
 1023 02f6 8105      		cpc r24,__zero_reg__
 1024 02f8 9105      		cpc r25,__zero_reg__
 1025 02fa 00F0      		brlo .L67
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 1026               		.loc 1 424 0 is_stmt 0 discriminator 1
 1027 02fc 0E94 0000 		call rgblight_get_mode
 1028               	.LVL92:
 1029 0300 6731      		cpi r22,23
 1030 0302 7105      		cpc r23,__zero_reg__
 1031 0304 8105      		cpc r24,__zero_reg__
 1032 0306 9105      		cpc r25,__zero_reg__
 1033 0308 00F4      		brsh .+2
 1034 030a 00C0      		rjmp .L46
 1035               	.L67:
 427:quantum/quantum.c ****         rgblight_mode(21);
 1036               		.loc 1 427 0 is_stmt 1
 1037 030c 85E1      		ldi r24,lo8(21)
 1038               	.L212:
 391:quantum/quantum.c ****         rgblight_mode(2);
 1039               		.loc 1 391 0
 1040 030e 0E94 0000 		call rgblight_mode
 1041               	.LVL93:
 1042 0312 00C0      		rjmp .L152
 1043               	.L226:
 284:quantum/quantum.c ****   switch(keycode) {
 1044               		.loc 1 284 0
 1045 0314 C13D      		cpi r28,-47
 1046 0316 8CE5      		ldi r24,92
 1047 0318 D807      		cpc r29,r24
 1048 031a 00F0      		brlo .+2
 1049 031c 00C0      		rjmp .L120
 1050 031e CC3C      		cpi r28,-52
 1051 0320 9CE5      		ldi r25,92
 1052 0322 D907      		cpc r29,r25
 1053 0324 01F4      		brne .L227
 387:quantum/quantum.c ****     if (record->event.pressed) {
 1054               		.loc 1 387 0
 1055 0326 F801      		movw r30,r16
 1056 0328 8281      		ldd r24,Z+2
 1057 032a 8823      		tst r24
 1058 032c 01F4      		brne .+2
 1059 032e 00C0      		rjmp .L152
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 1060               		.loc 1 388 0
 1061 0330 0E94 0000 		call rgblight_get_mode
 1062               	.LVL94:
 1063 0334 6230      		cpi r22,2
 1064 0336 7105      		cpc r23,__zero_reg__
 1065 0338 8105      		cpc r24,__zero_reg__
 1066 033a 9105      		cpc r25,__zero_reg__
 1067 033c 00F0      		brlo .L59
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 1068               		.loc 1 388 0 is_stmt 0 discriminator 1
 1069 033e 0E94 0000 		call rgblight_get_mode
 1070               	.LVL95:
 1071 0342 6530      		cpi r22,5
 1072 0344 7105      		cpc r23,__zero_reg__
 1073 0346 8105      		cpc r24,__zero_reg__
 1074 0348 9105      		cpc r25,__zero_reg__
 1075 034a 00F4      		brsh .+2
 1076 034c 00C0      		rjmp .L46
 1077               	.L59:
 391:quantum/quantum.c ****         rgblight_mode(2);
 1078               		.loc 1 391 0 is_stmt 1
 1079 034e 82E0      		ldi r24,lo8(2)
 1080 0350 00C0      		rjmp .L212
 1081               	.L227:
 284:quantum/quantum.c ****   switch(keycode) {
 1082               		.loc 1 284 0
 1083 0352 CD3C      		cpi r28,-51
 1084 0354 ECE5      		ldi r30,92
 1085 0356 DE07      		cpc r29,r30
 1086 0358 00F4      		brsh .L121
 1087 035a CA3C      		cpi r28,-54
 1088 035c FCE5      		ldi r31,92
 1089 035e DF07      		cpc r29,r31
 1090 0360 01F4      		brne .L228
 377:quantum/quantum.c ****     if (record->event.pressed) {
 1091               		.loc 1 377 0
 1092 0362 F801      		movw r30,r16
 1093 0364 8281      		ldd r24,Z+2
 1094 0366 8823      		tst r24
 1095 0368 01F4      		brne .+2
 1096 036a 00C0      		rjmp .L152
 378:quantum/quantum.c ****       rgblight_decrease_speed();
 1097               		.loc 1 378 0
 1098 036c 0E94 0000 		call rgblight_decrease_speed
 1099               	.LVL96:
 1100 0370 00C0      		rjmp .L152
 1101               	.L228:
 284:quantum/quantum.c ****   switch(keycode) {
 1102               		.loc 1 284 0
 1103 0372 CB3C      		cpi r28,-53
 1104 0374 DC45      		sbci r29,92
 1105 0376 01F0      		breq .+2
 1106 0378 00C0      		rjmp .L115
 382:quantum/quantum.c ****     if (record->event.pressed) {
 1107               		.loc 1 382 0
 1108 037a F801      		movw r30,r16
 1109 037c 8281      		ldd r24,Z+2
 1110 037e 8823      		tst r24
 1111 0380 01F4      		brne .+2
 1112 0382 00C0      		rjmp .L152
 383:quantum/quantum.c ****       rgblight_mode(1);
 1113               		.loc 1 383 0
 1114 0384 81E0      		ldi r24,lo8(1)
 1115 0386 00C0      		rjmp .L212
 1116               	.L121:
 1117 0388 F801      		movw r30,r16
 1118 038a 8281      		ldd r24,Z+2
 284:quantum/quantum.c ****   switch(keycode) {
 1119               		.loc 1 284 0
 1120 038c CE3C      		cpi r28,-50
 1121 038e FCE5      		ldi r31,92
 1122 0390 DF07      		cpc r29,r31
 1123 0392 01F4      		brne .L229
 405:quantum/quantum.c ****     if (record->event.pressed) {
 1124               		.loc 1 405 0
 1125 0394 8823      		tst r24
 1126 0396 01F4      		brne .+2
 1127 0398 00C0      		rjmp .L152
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 1128               		.loc 1 406 0
 1129 039a 0E94 0000 		call rgblight_get_mode
 1130               	.LVL97:
 1131 039e 6930      		cpi r22,9
 1132 03a0 7105      		cpc r23,__zero_reg__
 1133 03a2 8105      		cpc r24,__zero_reg__
 1134 03a4 9105      		cpc r25,__zero_reg__
 1135 03a6 00F0      		brlo .L63
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 1136               		.loc 1 406 0 is_stmt 0 discriminator 1
 1137 03a8 0E94 0000 		call rgblight_get_mode
 1138               	.LVL98:
 1139 03ac 6E30      		cpi r22,14
 1140 03ae 7105      		cpc r23,__zero_reg__
 1141 03b0 8105      		cpc r24,__zero_reg__
 1142 03b2 9105      		cpc r25,__zero_reg__
 1143 03b4 00F4      		brsh .+2
 1144 03b6 00C0      		rjmp .L46
 1145               	.L63:
 409:quantum/quantum.c ****         rgblight_mode(9);
 1146               		.loc 1 409 0 is_stmt 1
 1147 03b8 89E0      		ldi r24,lo8(9)
 1148 03ba 00C0      		rjmp .L212
 1149               	.L229:
 284:quantum/quantum.c ****   switch(keycode) {
 1150               		.loc 1 284 0
 1151 03bc CF3C      		cpi r28,-49
 1152 03be DC45      		sbci r29,92
 1153 03c0 00F4      		brsh .L230
 396:quantum/quantum.c ****     if (record->event.pressed) {
 1154               		.loc 1 396 0
 1155 03c2 8823      		tst r24
 1156 03c4 01F4      		brne .+2
 1157 03c6 00C0      		rjmp .L152
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 1158               		.loc 1 397 0
 1159 03c8 0E94 0000 		call rgblight_get_mode
 1160               	.LVL99:
 1161 03cc 6630      		cpi r22,6
 1162 03ce 7105      		cpc r23,__zero_reg__
 1163 03d0 8105      		cpc r24,__zero_reg__
 1164 03d2 9105      		cpc r25,__zero_reg__
 1165 03d4 00F0      		brlo .L61
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 1166               		.loc 1 397 0 is_stmt 0 discriminator 1
 1167 03d6 0E94 0000 		call rgblight_get_mode
 1168               	.LVL100:
 1169 03da 6830      		cpi r22,8
 1170 03dc 7105      		cpc r23,__zero_reg__
 1171 03de 8105      		cpc r24,__zero_reg__
 1172 03e0 9105      		cpc r25,__zero_reg__
 1173 03e2 00F4      		brsh .+2
 1174 03e4 00C0      		rjmp .L46
 1175               	.L61:
 400:quantum/quantum.c ****         rgblight_mode(6);
 1176               		.loc 1 400 0 is_stmt 1
 1177 03e6 86E0      		ldi r24,lo8(6)
 1178 03e8 00C0      		rjmp .L212
 1179               	.L230:
 414:quantum/quantum.c ****     if (record->event.pressed) {
 1180               		.loc 1 414 0
 1181 03ea 8823      		tst r24
 1182 03ec 01F4      		brne .+2
 1183 03ee 00C0      		rjmp .L152
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 1184               		.loc 1 415 0
 1185 03f0 0E94 0000 		call rgblight_get_mode
 1186               	.LVL101:
 1187 03f4 6F30      		cpi r22,15
 1188 03f6 7105      		cpc r23,__zero_reg__
 1189 03f8 8105      		cpc r24,__zero_reg__
 1190 03fa 9105      		cpc r25,__zero_reg__
 1191 03fc 00F0      		brlo .L65
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 1192               		.loc 1 415 0 is_stmt 0 discriminator 1
 1193 03fe 0E94 0000 		call rgblight_get_mode
 1194               	.LVL102:
 1195 0402 6431      		cpi r22,20
 1196 0404 7105      		cpc r23,__zero_reg__
 1197 0406 8105      		cpc r24,__zero_reg__
 1198 0408 9105      		cpc r25,__zero_reg__
 1199 040a 00F4      		brsh .+2
 1200 040c 00C0      		rjmp .L46
 1201               	.L65:
 418:quantum/quantum.c ****         rgblight_mode(15);
 1202               		.loc 1 418 0 is_stmt 1
 1203 040e 8FE0      		ldi r24,lo8(15)
 1204 0410 00C0      		rjmp .L212
 1205               	.L120:
 284:quantum/quantum.c ****   switch(keycode) {
 1206               		.loc 1 284 0
 1207 0412 C43D      		cpi r28,-44
 1208 0414 ECE5      		ldi r30,92
 1209 0416 DE07      		cpc r29,r30
 1210 0418 01F4      		brne .L231
 572:quantum/quantum.c ****       if (record->event.pressed) {
 1211               		.loc 1 572 0
 1212 041a F801      		movw r30,r16
 1213 041c 8281      		ldd r24,Z+2
 1214 041e 8823      		tst r24
 1215 0420 01F0      		breq .L103
 1216               	.L108:
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 1217               		.loc 1 573 0
 1218 0422 1092 0000 		sts shift_interrupted+1,__zero_reg__
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 1219               		.loc 1 574 0
 1220 0426 0E94 0000 		call timer_read
 1221               	.LVL103:
 1222 042a 9093 0000 		sts scs_timer+2+1,r25
 1223 042e 8093 0000 		sts scs_timer+2,r24
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 1224               		.loc 1 575 0
 1225 0432 80E2      		ldi r24,lo8(32)
 1226               	.L214:
 1227 0434 0E94 0000 		call register_mods
 1228               	.LVL104:
 1229 0438 00C0      		rjmp .L152
 1230               	.L103:
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1231               		.loc 1 584 0
 1232 043a 8091 0000 		lds r24,shift_interrupted+1
 1233 043e 8111      		cpse r24,__zero_reg__
 1234 0440 00C0      		rjmp .L105
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1235               		.loc 1 584 0 is_stmt 0 discriminator 1
 1236 0442 8091 0000 		lds r24,scs_timer+2
 1237 0446 9091 0000 		lds r25,scs_timer+2+1
 1238 044a 0E94 0000 		call timer_elapsed
 1239               	.LVL105:
 1240 044e 8639      		cpi r24,-106
 1241 0450 9105      		cpc r25,__zero_reg__
 1242 0452 00F4      		brsh .L105
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 1243               		.loc 1 585 0 is_stmt 1
 1244 0454 87E2      		ldi r24,lo8(39)
 1245 0456 0E94 0000 		call register_code
 1246               	.LVL106:
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 1247               		.loc 1 586 0
 1248 045a 87E2      		ldi r24,lo8(39)
 1249 045c 0E94 0000 		call unregister_code
 1250               	.LVL107:
 1251               	.L105:
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1252               		.loc 1 588 0
 1253 0460 80E2      		ldi r24,lo8(32)
 1254               	.L213:
 1255 0462 0E94 0000 		call unregister_mods
 1256               	.LVL108:
 1257 0466 00C0      		rjmp .L152
 1258               	.L231:
 284:quantum/quantum.c ****   switch(keycode) {
 1259               		.loc 1 284 0
 1260 0468 C53D      		cpi r28,-43
 1261 046a FCE5      		ldi r31,92
 1262 046c DF07      		cpc r29,r31
 1263 046e 00F0      		brlo .+2
 1264 0470 00C0      		rjmp .L122
 1265 0472 F801      		movw r30,r16
 1266 0474 8281      		ldd r24,Z+2
 1267 0476 C23D      		cpi r28,-46
 1268 0478 FCE5      		ldi r31,92
 1269 047a DF07      		cpc r29,r31
 1270 047c 01F4      		brne .L232
 437:quantum/quantum.c ****     if (record->event.pressed) {
 1271               		.loc 1 437 0
 1272 047e 8823      		tst r24
 1273 0480 01F4      		brne .+2
 1274 0482 00C0      		rjmp .L152
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 1275               		.loc 1 438 0
 1276 0484 0E94 0000 		call rgblight_get_mode
 1277               	.LVL109:
 1278 0488 6931      		cpi r22,25
 1279 048a 7105      		cpc r23,__zero_reg__
 1280 048c 8105      		cpc r24,__zero_reg__
 1281 048e 9105      		cpc r25,__zero_reg__
 1282 0490 00F0      		brlo .L70
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 1283               		.loc 1 438 0 is_stmt 0 discriminator 1
 1284 0492 0E94 0000 		call rgblight_get_mode
 1285               	.LVL110:
 1286 0496 6232      		cpi r22,34
 1287 0498 7105      		cpc r23,__zero_reg__
 1288 049a 8105      		cpc r24,__zero_reg__
 1289 049c 9105      		cpc r25,__zero_reg__
 1290 049e 00F4      		brsh .+2
 1291 04a0 00C0      		rjmp .L46
 1292               	.L70:
 441:quantum/quantum.c ****         rgblight_mode(25);
 1293               		.loc 1 441 0 is_stmt 1
 1294 04a2 89E1      		ldi r24,lo8(25)
 1295 04a4 00C0      		rjmp .L212
 1296               	.L232:
 284:quantum/quantum.c ****   switch(keycode) {
 1297               		.loc 1 284 0
 1298 04a6 C33D      		cpi r28,-45
 1299 04a8 DC45      		sbci r29,92
 1300 04aa 00F4      		brsh .L233
 432:quantum/quantum.c ****     if (record->event.pressed) {
 1301               		.loc 1 432 0
 1302 04ac 8823      		tst r24
 1303 04ae 01F4      		brne .+2
 1304 04b0 00C0      		rjmp .L152
 433:quantum/quantum.c ****       rgblight_mode(24);
 1305               		.loc 1 433 0
 1306 04b2 88E1      		ldi r24,lo8(24)
 1307 04b4 00C0      		rjmp .L212
 1308               	.L233:
 550:quantum/quantum.c ****       if (record->event.pressed) {
 1309               		.loc 1 550 0
 1310 04b6 8823      		tst r24
 1311 04b8 01F0      		breq .L98
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 1312               		.loc 1 551 0
 1313 04ba 1092 0000 		sts shift_interrupted,__zero_reg__
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 1314               		.loc 1 552 0
 1315 04be 0E94 0000 		call timer_read
 1316               	.LVL111:
 1317 04c2 9093 0000 		sts scs_timer+1,r25
 1318 04c6 8093 0000 		sts scs_timer,r24
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 1319               		.loc 1 553 0
 1320 04ca 82E0      		ldi r24,lo8(2)
 1321 04cc 00C0      		rjmp .L214
 1322               	.L98:
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 1323               		.loc 1 562 0
 1324 04ce 8091 0000 		lds r24,shift_interrupted
 1325 04d2 8111      		cpse r24,__zero_reg__
 1326 04d4 00C0      		rjmp .L100
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 1327               		.loc 1 562 0 is_stmt 0 discriminator 1
 1328 04d6 8091 0000 		lds r24,scs_timer
 1329 04da 9091 0000 		lds r25,scs_timer+1
 1330 04de 0E94 0000 		call timer_elapsed
 1331               	.LVL112:
 1332 04e2 8639      		cpi r24,-106
 1333 04e4 9105      		cpc r25,__zero_reg__
 1334 04e6 00F4      		brsh .L100
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 1335               		.loc 1 563 0 is_stmt 1
 1336 04e8 86E2      		ldi r24,lo8(38)
 1337 04ea 0E94 0000 		call register_code
 1338               	.LVL113:
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 1339               		.loc 1 564 0
 1340 04ee 86E2      		ldi r24,lo8(38)
 1341 04f0 0E94 0000 		call unregister_code
 1342               	.LVL114:
 1343               	.L100:
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 1344               		.loc 1 566 0
 1345 04f4 82E0      		ldi r24,lo8(2)
 1346 04f6 00C0      		rjmp .L213
 1347               	.L122:
 284:quantum/quantum.c ****   switch(keycode) {
 1348               		.loc 1 284 0
 1349 04f8 C83D      		cpi r28,-40
 1350 04fa ECE5      		ldi r30,92
 1351 04fc DE07      		cpc r29,r30
 1352 04fe 01F4      		brne .L234
 448:quantum/quantum.c ****       if (record->event.pressed) {
 1353               		.loc 1 448 0
 1354 0500 F801      		movw r30,r16
 1355 0502 8281      		ldd r24,Z+2
 1356 0504 8823      		tst r24
 1357 0506 01F0      		breq .L152
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 1358               		.loc 1 449 0
 1359 0508 80E0      		ldi r24,0
 1360 050a 00C0      		rjmp .L215
 1361               	.L234:
 284:quantum/quantum.c ****   switch(keycode) {
 1362               		.loc 1 284 0
 1363 050c C93D      		cpi r28,-39
 1364 050e FCE5      		ldi r31,92
 1365 0510 DF07      		cpc r29,r31
 1366 0512 01F4      		brne .L235
 453:quantum/quantum.c ****       if (record->event.pressed) {
 1367               		.loc 1 453 0
 1368 0514 F801      		movw r30,r16
 1369 0516 8281      		ldd r24,Z+2
 1370 0518 8823      		tst r24
 1371 051a 01F0      		breq .L152
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 1372               		.loc 1 454 0
 1373 051c 82E0      		ldi r24,lo8(2)
 1374               	.L215:
 1375 051e 0E94 0000 		call set_output
 1376               	.LVL115:
 1377 0522 00C0      		rjmp .L152
 1378               	.L235:
 284:quantum/quantum.c ****   switch(keycode) {
 1379               		.loc 1 284 0
 1380 0524 C53D      		cpi r28,-43
 1381 0526 DC45      		sbci r29,92
 1382 0528 01F0      		breq .+2
 1383 052a 00C0      		rjmp .L115
 594:quantum/quantum.c ****       if (record->event.pressed) {
 1384               		.loc 1 594 0
 1385 052c F801      		movw r30,r16
 1386 052e 8281      		ldd r24,Z+2
 1387 0530 8111      		cpse r24,__zero_reg__
 1388 0532 00C0      		rjmp .L108
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1389               		.loc 1 599 0
 1390 0534 8091 0000 		lds r24,shift_interrupted+1
 1391 0538 8111      		cpse r24,__zero_reg__
 1392 053a 00C0      		rjmp .L105
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1393               		.loc 1 599 0 is_stmt 0 discriminator 1
 1394 053c 8091 0000 		lds r24,scs_timer+2
 1395 0540 9091 0000 		lds r25,scs_timer+2+1
 1396 0544 0E94 0000 		call timer_elapsed
 1397               	.LVL116:
 1398 0548 8639      		cpi r24,-106
 1399 054a 9105      		cpc r25,__zero_reg__
 1400 054c 00F0      		brlo .+2
 1401 054e 00C0      		rjmp .L105
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1402               		.loc 1 600 0 is_stmt 1
 1403 0550 80E2      		ldi r24,lo8(32)
 1404 0552 0E94 0000 		call unregister_mods
 1405               	.LVL117:
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 1406               		.loc 1 601 0
 1407 0556 88E2      		ldi r24,lo8(40)
 1408 0558 0E94 0000 		call register_code
 1409               	.LVL118:
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 1410               		.loc 1 602 0
 1411 055c 88E2      		ldi r24,lo8(40)
 1412 055e 0E94 0000 		call unregister_code
 1413               	.LVL119:
 1414               	.L152:
 1415               		.loc 1 672 0
 1416 0562 80E0      		ldi r24,0
 1417               	/* epilogue start */
 1418 0564 DF91      		pop r29
 1419 0566 CF91      		pop r28
 1420               	.LVL120:
 1421 0568 1F91      		pop r17
 1422 056a 0F91      		pop r16
 1423               	.LVL121:
 1424 056c 0895      		ret
 1425               		.cfi_endproc
 1426               	.LFE24:
 1428               		.section	.text.send_char,"ax",@progbits
 1429               	.global	send_char
 1431               	send_char:
 1432               	.LFB29:
 673:quantum/quantum.c **** 
 674:quantum/quantum.c **** __attribute__ ((weak))
 675:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 676:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 677:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 678:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 679:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 680:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 681:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 682:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 683:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 684:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 685:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 686:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 687:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 688:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 689:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 690:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 691:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 692:quantum/quantum.c **** };
 693:quantum/quantum.c **** 
 694:quantum/quantum.c **** __attribute__ ((weak))
 695:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 696:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 697:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 698:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 699:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 700:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 701:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 702:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 703:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 704:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 705:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 706:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 707:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 708:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 709:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 710:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 711:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 712:quantum/quantum.c **** };
 713:quantum/quantum.c **** 
 714:quantum/quantum.c **** void send_string(const char *str) {
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 716:quantum/quantum.c **** }
 717:quantum/quantum.c **** 
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 720:quantum/quantum.c **** }
 721:quantum/quantum.c **** 
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 723:quantum/quantum.c ****     while (1) {
 724:quantum/quantum.c ****         char ascii_code = *str;
 725:quantum/quantum.c ****         if (!ascii_code) break;
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 727:quantum/quantum.c ****           // tap
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 729:quantum/quantum.c ****           register_code(keycode);
 730:quantum/quantum.c ****           unregister_code(keycode);
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 732:quantum/quantum.c ****           // down
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 734:quantum/quantum.c ****           register_code(keycode);
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 736:quantum/quantum.c ****           // up
 737:quantum/quantum.c ****           uint8_t keycode = *(++str);
 738:quantum/quantum.c ****           unregister_code(keycode);
 739:quantum/quantum.c ****         } else {
 740:quantum/quantum.c ****           send_char(ascii_code);
 741:quantum/quantum.c ****         }
 742:quantum/quantum.c ****         ++str;
 743:quantum/quantum.c ****         // interval
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 745:quantum/quantum.c ****     }
 746:quantum/quantum.c **** }
 747:quantum/quantum.c **** 
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 749:quantum/quantum.c ****     while (1) {
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 751:quantum/quantum.c ****         if (!ascii_code) break;
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 753:quantum/quantum.c ****           // tap
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 755:quantum/quantum.c ****           register_code(keycode);
 756:quantum/quantum.c ****           unregister_code(keycode);
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 758:quantum/quantum.c ****           // down
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 760:quantum/quantum.c ****           register_code(keycode);
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 762:quantum/quantum.c ****           // up
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 764:quantum/quantum.c ****           unregister_code(keycode);
 765:quantum/quantum.c ****         } else {
 766:quantum/quantum.c ****           send_char(ascii_code);
 767:quantum/quantum.c ****         }
 768:quantum/quantum.c ****         ++str;
 769:quantum/quantum.c ****         // interval
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 771:quantum/quantum.c ****     }
 772:quantum/quantum.c **** }
 773:quantum/quantum.c **** 
 774:quantum/quantum.c **** void send_char(char ascii_code) {
 1433               		.loc 1 774 0
 1434               		.cfi_startproc
 1435               	.LVL122:
 1436 0000 CF93      		push r28
 1437               	.LCFI12:
 1438               		.cfi_def_cfa_offset 3
 1439               		.cfi_offset 28, -2
 1440               	/* prologue: function */
 1441               	/* frame size = 0 */
 1442               	/* stack size = 1 */
 1443               	.L__stack_usage = 1
 1444               	.LBB39:
 775:quantum/quantum.c ****   uint8_t keycode;
 776:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 1445               		.loc 1 776 0
 1446 0002 282F      		mov r18,r24
 1447 0004 30E0      		ldi r19,0
 1448               	.LVL123:
 1449 0006 F901      		movw r30,r18
 1450 0008 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 1451 000a F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 1452               	.LVL124:
 1453               	/* #APP */
 1454               	 ;  776 "quantum/quantum.c" 1
 1455 000c C491      		lpm r28, Z
 1456               		
 1457               	 ;  0 "" 2
 1458               	.LVL125:
 1459               	/* #NOAPP */
 1460               	.LBE39:
 1461               	.LBB40:
 777:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 1462               		.loc 1 777 0
 1463 000e F901      		movw r30,r18
 1464               	.LVL126:
 1465 0010 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 1466 0012 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 1467               	.LVL127:
 1468               	/* #APP */
 1469               	 ;  777 "quantum/quantum.c" 1
 1470 0014 2491      		lpm r18, Z
 1471               		
 1472               	 ;  0 "" 2
 1473               	.LVL128:
 1474               	/* #NOAPP */
 1475               	.LBE40:
 1476 0016 2223      		tst r18
 1477 0018 01F0      		breq .L237
 778:quantum/quantum.c ****       register_code(KC_LSFT);
 1478               		.loc 1 778 0
 1479 001a 81EE      		ldi r24,lo8(-31)
 1480               	.LVL129:
 1481 001c 0E94 0000 		call register_code
 1482               	.LVL130:
 779:quantum/quantum.c ****       register_code(keycode);
 1483               		.loc 1 779 0
 1484 0020 8C2F      		mov r24,r28
 1485 0022 0E94 0000 		call register_code
 1486               	.LVL131:
 780:quantum/quantum.c ****       unregister_code(keycode);
 1487               		.loc 1 780 0
 1488 0026 8C2F      		mov r24,r28
 1489 0028 0E94 0000 		call unregister_code
 1490               	.LVL132:
 781:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1491               		.loc 1 781 0
 1492 002c 81EE      		ldi r24,lo8(-31)
 1493 002e 00C0      		rjmp .L238
 1494               	.LVL133:
 1495               	.L237:
 782:quantum/quantum.c ****   } else {
 783:quantum/quantum.c ****       register_code(keycode);
 1496               		.loc 1 783 0
 1497 0030 8C2F      		mov r24,r28
 1498               	.LVL134:
 1499 0032 0E94 0000 		call register_code
 1500               	.LVL135:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1501               		.loc 1 784 0
 1502 0036 8C2F      		mov r24,r28
 1503               	.L238:
 1504               	/* epilogue start */
 785:quantum/quantum.c ****   }
 786:quantum/quantum.c **** }
 1505               		.loc 1 786 0
 1506 0038 CF91      		pop r28
 1507               	.LVL136:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1508               		.loc 1 784 0
 1509 003a 0C94 0000 		jmp unregister_code
 1510               	.LVL137:
 1511               		.cfi_endproc
 1512               	.LFE29:
 1514               		.section	.text.send_string_with_delay,"ax",@progbits
 1515               	.global	send_string_with_delay
 1517               	send_string_with_delay:
 1518               	.LFB27:
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 1519               		.loc 1 722 0
 1520               		.cfi_startproc
 1521               	.LVL138:
 1522 0000 FF92      		push r15
 1523               	.LCFI13:
 1524               		.cfi_def_cfa_offset 3
 1525               		.cfi_offset 15, -2
 1526 0002 0F93      		push r16
 1527               	.LCFI14:
 1528               		.cfi_def_cfa_offset 4
 1529               		.cfi_offset 16, -3
 1530 0004 1F93      		push r17
 1531               	.LCFI15:
 1532               		.cfi_def_cfa_offset 5
 1533               		.cfi_offset 17, -4
 1534 0006 CF93      		push r28
 1535               	.LCFI16:
 1536               		.cfi_def_cfa_offset 6
 1537               		.cfi_offset 28, -5
 1538 0008 DF93      		push r29
 1539               	.LCFI17:
 1540               		.cfi_def_cfa_offset 7
 1541               		.cfi_offset 29, -6
 1542               	/* prologue: function */
 1543               	/* frame size = 0 */
 1544               	/* stack size = 5 */
 1545               	.L__stack_usage = 5
 1546 000a EC01      		movw r28,r24
 1547 000c F62E      		mov r15,r22
 1548               	.LVL139:
 1549               	.L247:
 1550               	.LBB41:
 724:quantum/quantum.c ****         char ascii_code = *str;
 1551               		.loc 1 724 0
 1552 000e 8881      		ld r24,Y
 1553               	.LVL140:
 725:quantum/quantum.c ****         if (!ascii_code) break;
 1554               		.loc 1 725 0
 1555 0010 8823      		tst r24
 1556 0012 01F0      		breq .L239
 1557 0014 8E01      		movw r16,r28
 1558 0016 0F5F      		subi r16,-1
 1559 0018 1F4F      		sbci r17,-1
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 1560               		.loc 1 726 0
 1561 001a 8130      		cpi r24,lo8(1)
 1562 001c 01F4      		brne .L241
 1563               	.LVL141:
 1564               	.LBB42:
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 1565               		.loc 1 728 0
 1566 001e C981      		ldd r28,Y+1
 1567               	.LVL142:
 729:quantum/quantum.c ****           register_code(keycode);
 1568               		.loc 1 729 0
 1569 0020 8C2F      		mov r24,r28
 1570               	.LVL143:
 1571 0022 0E94 0000 		call register_code
 1572               	.LVL144:
 730:quantum/quantum.c ****           unregister_code(keycode);
 1573               		.loc 1 730 0
 1574 0026 8C2F      		mov r24,r28
 1575 0028 00C0      		rjmp .L249
 1576               	.LVL145:
 1577               	.L241:
 1578               	.LBE42:
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1579               		.loc 1 731 0
 1580 002a 8230      		cpi r24,lo8(2)
 1581 002c 01F4      		brne .L243
 1582               	.LVL146:
 1583               	.LBB43:
 734:quantum/quantum.c ****           register_code(keycode);
 1584               		.loc 1 734 0
 1585 002e 8981      		ldd r24,Y+1
 1586               	.LVL147:
 1587 0030 0E94 0000 		call register_code
 1588               	.LVL148:
 1589               	.L248:
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 1590               		.loc 1 733 0
 1591 0034 E801      		movw r28,r16
 1592               	.LBE43:
 1593 0036 00C0      		rjmp .L242
 1594               	.LVL149:
 1595               	.L243:
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1596               		.loc 1 735 0
 1597 0038 8330      		cpi r24,lo8(3)
 1598 003a 01F4      		brne .L244
 1599               	.LVL150:
 1600               	.LBB44:
 738:quantum/quantum.c ****           unregister_code(keycode);
 1601               		.loc 1 738 0
 1602 003c 8981      		ldd r24,Y+1
 1603               	.LVL151:
 1604               	.L249:
 1605 003e 0E94 0000 		call unregister_code
 1606               	.LVL152:
 1607 0042 00C0      		rjmp .L248
 1608               	.LVL153:
 1609               	.L244:
 1610               	.LBE44:
 740:quantum/quantum.c ****           send_char(ascii_code);
 1611               		.loc 1 740 0
 1612 0044 0E94 0000 		call send_char
 1613               	.LVL154:
 1614               	.L242:
 742:quantum/quantum.c ****         ++str;
 1615               		.loc 1 742 0
 1616 0048 2196      		adiw r28,1
 1617               	.LVL155:
 1618               	.LBB45:
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1619               		.loc 1 744 0
 1620 004a 8F2D      		mov r24,r15
 1621               	.LVL156:
 1622               	.L245:
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1623               		.loc 1 744 0 is_stmt 0 discriminator 1
 1624 004c 8823      		tst r24
 1625 004e 01F0      		breq .L247
 1626               	.LVL157:
 1627               	.LBB46:
 1628               	.LBB47:
 1629               		.loc 2 164 0 is_stmt 1
 1630 0050 EFE9      		ldi r30,lo8(3999)
 1631 0052 FFE0      		ldi r31,hi8(3999)
 1632 0054 3197      		1: sbiw r30,1
 1633 0056 01F4      		brne 1b
 1634 0058 00C0      		rjmp .
 1635 005a 0000      		nop
 1636 005c 8150      		subi r24,lo8(-(-1))
 1637               	.LVL158:
 1638 005e 00C0      		rjmp .L245
 1639               	.LVL159:
 1640               	.L239:
 1641               	/* epilogue start */
 1642               	.LBE47:
 1643               	.LBE46:
 1644               	.LBE45:
 1645               	.LBE41:
 746:quantum/quantum.c **** }
 1646               		.loc 1 746 0
 1647 0060 DF91      		pop r29
 1648 0062 CF91      		pop r28
 1649               	.LVL160:
 1650 0064 1F91      		pop r17
 1651 0066 0F91      		pop r16
 1652 0068 FF90      		pop r15
 1653               	.LVL161:
 1654 006a 0895      		ret
 1655               		.cfi_endproc
 1656               	.LFE27:
 1658               		.section	.text.send_string,"ax",@progbits
 1659               	.global	send_string
 1661               	send_string:
 1662               	.LFB25:
 714:quantum/quantum.c **** void send_string(const char *str) {
 1663               		.loc 1 714 0
 1664               		.cfi_startproc
 1665               	.LVL162:
 1666               	/* prologue: function */
 1667               	/* frame size = 0 */
 1668               	/* stack size = 0 */
 1669               	.L__stack_usage = 0
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 1670               		.loc 1 715 0
 1671 0000 60E0      		ldi r22,0
 1672 0002 0C94 0000 		jmp send_string_with_delay
 1673               	.LVL163:
 1674               		.cfi_endproc
 1675               	.LFE25:
 1677               		.section	.text.send_string_with_delay_P,"ax",@progbits
 1678               	.global	send_string_with_delay_P
 1680               	send_string_with_delay_P:
 1681               	.LFB28:
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 1682               		.loc 1 748 0
 1683               		.cfi_startproc
 1684               	.LVL164:
 1685 0000 0F93      		push r16
 1686               	.LCFI18:
 1687               		.cfi_def_cfa_offset 3
 1688               		.cfi_offset 16, -2
 1689 0002 1F93      		push r17
 1690               	.LCFI19:
 1691               		.cfi_def_cfa_offset 4
 1692               		.cfi_offset 17, -3
 1693 0004 CF93      		push r28
 1694               	.LCFI20:
 1695               		.cfi_def_cfa_offset 5
 1696               		.cfi_offset 28, -4
 1697 0006 DF93      		push r29
 1698               	.LCFI21:
 1699               		.cfi_def_cfa_offset 6
 1700               		.cfi_offset 29, -5
 1701               	/* prologue: function */
 1702               	/* frame size = 0 */
 1703               	/* stack size = 4 */
 1704               	.L__stack_usage = 4
 1705 0008 EC01      		movw r28,r24
 1706 000a 062F      		mov r16,r22
 1707               	.LVL165:
 1708               	.L259:
 1709               	.LBB48:
 1710               	.LBB49:
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 1711               		.loc 1 750 0
 1712 000c FE01      		movw r30,r28
 1713               	/* #APP */
 1714               	 ;  750 "quantum/quantum.c" 1
 1715 000e 8491      		lpm r24, Z
 1716               		
 1717               	 ;  0 "" 2
 1718               	.LVL166:
 1719               	/* #NOAPP */
 1720               	.LBE49:
 751:quantum/quantum.c ****         if (!ascii_code) break;
 1721               		.loc 1 751 0
 1722 0010 8823      		tst r24
 1723 0012 01F0      		breq .L251
 1724 0014 9E01      		movw r18,r28
 1725 0016 2F5F      		subi r18,-1
 1726 0018 3F4F      		sbci r19,-1
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 1727               		.loc 1 752 0
 1728 001a 8130      		cpi r24,lo8(1)
 1729 001c 01F4      		brne .L253
 1730               	.LBB50:
 1731               	.LBB51:
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1732               		.loc 1 754 0
 1733 001e E901      		movw r28,r18
 1734               	.LVL167:
 1735 0020 F901      		movw r30,r18
 1736               	.LVL168:
 1737               	/* #APP */
 1738               	 ;  754 "quantum/quantum.c" 1
 1739 0022 1491      		lpm r17, Z
 1740               		
 1741               	 ;  0 "" 2
 1742               	.LVL169:
 1743               	/* #NOAPP */
 1744               	.LBE51:
 755:quantum/quantum.c ****           register_code(keycode);
 1745               		.loc 1 755 0
 1746 0024 812F      		mov r24,r17
 1747               	.LVL170:
 1748 0026 0E94 0000 		call register_code
 1749               	.LVL171:
 756:quantum/quantum.c ****           unregister_code(keycode);
 1750               		.loc 1 756 0
 1751 002a 812F      		mov r24,r17
 1752 002c 00C0      		rjmp .L260
 1753               	.LVL172:
 1754               	.L253:
 1755               	.LBE50:
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1756               		.loc 1 757 0
 1757 002e 8230      		cpi r24,lo8(2)
 1758 0030 01F4      		brne .L255
 1759               	.LBB52:
 1760               	.LBB53:
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1761               		.loc 1 759 0
 1762 0032 E901      		movw r28,r18
 1763               	.LVL173:
 1764 0034 F901      		movw r30,r18
 1765               	.LVL174:
 1766               	/* #APP */
 1767               	 ;  759 "quantum/quantum.c" 1
 1768 0036 8491      		lpm r24, Z
 1769               		
 1770               	 ;  0 "" 2
 1771               	.LVL175:
 1772               	/* #NOAPP */
 1773               	.LBE53:
 760:quantum/quantum.c ****           register_code(keycode);
 1774               		.loc 1 760 0
 1775 0038 0E94 0000 		call register_code
 1776               	.LVL176:
 1777               	.LBE52:
 1778 003c 00C0      		rjmp .L254
 1779               	.LVL177:
 1780               	.L255:
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1781               		.loc 1 761 0
 1782 003e 8330      		cpi r24,lo8(3)
 1783 0040 01F4      		brne .L256
 1784               	.LBB54:
 1785               	.LBB55:
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1786               		.loc 1 763 0
 1787 0042 E901      		movw r28,r18
 1788               	.LVL178:
 1789 0044 F901      		movw r30,r18
 1790               	.LVL179:
 1791               	/* #APP */
 1792               	 ;  763 "quantum/quantum.c" 1
 1793 0046 8491      		lpm r24, Z
 1794               		
 1795               	 ;  0 "" 2
 1796               	.LVL180:
 1797               	/* #NOAPP */
 1798               	.L260:
 1799               	.LBE55:
 764:quantum/quantum.c ****           unregister_code(keycode);
 1800               		.loc 1 764 0
 1801 0048 0E94 0000 		call unregister_code
 1802               	.LVL181:
 1803               	.LBE54:
 1804 004c 00C0      		rjmp .L254
 1805               	.LVL182:
 1806               	.L256:
 766:quantum/quantum.c ****           send_char(ascii_code);
 1807               		.loc 1 766 0
 1808 004e 0E94 0000 		call send_char
 1809               	.LVL183:
 1810               	.L254:
 768:quantum/quantum.c ****         ++str;
 1811               		.loc 1 768 0
 1812 0052 2196      		adiw r28,1
 1813               	.LVL184:
 1814               	.LBB56:
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1815               		.loc 1 770 0
 1816 0054 802F      		mov r24,r16
 1817               	.LVL185:
 1818               	.L257:
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1819               		.loc 1 770 0 is_stmt 0 discriminator 1
 1820 0056 8823      		tst r24
 1821 0058 01F0      		breq .L259
 1822               	.LVL186:
 1823               	.LBB57:
 1824               	.LBB58:
 1825               		.loc 2 164 0 is_stmt 1
 1826 005a EFE9      		ldi r30,lo8(3999)
 1827 005c FFE0      		ldi r31,hi8(3999)
 1828 005e 3197      		1: sbiw r30,1
 1829 0060 01F4      		brne 1b
 1830 0062 00C0      		rjmp .
 1831 0064 0000      		nop
 1832 0066 8150      		subi r24,lo8(-(-1))
 1833               	.LVL187:
 1834 0068 00C0      		rjmp .L257
 1835               	.LVL188:
 1836               	.L251:
 1837               	/* epilogue start */
 1838               	.LBE58:
 1839               	.LBE57:
 1840               	.LBE56:
 1841               	.LBE48:
 772:quantum/quantum.c **** }
 1842               		.loc 1 772 0
 1843 006a DF91      		pop r29
 1844 006c CF91      		pop r28
 1845               	.LVL189:
 1846 006e 1F91      		pop r17
 1847 0070 0F91      		pop r16
 1848               	.LVL190:
 1849 0072 0895      		ret
 1850               		.cfi_endproc
 1851               	.LFE28:
 1853               		.section	.text.send_string_P,"ax",@progbits
 1854               	.global	send_string_P
 1856               	send_string_P:
 1857               	.LFB26:
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 1858               		.loc 1 718 0
 1859               		.cfi_startproc
 1860               	.LVL191:
 1861               	/* prologue: function */
 1862               	/* frame size = 0 */
 1863               	/* stack size = 0 */
 1864               	.L__stack_usage = 0
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1865               		.loc 1 719 0
 1866 0000 60E0      		ldi r22,0
 1867 0002 0C94 0000 		jmp send_string_with_delay_P
 1868               	.LVL192:
 1869               		.cfi_endproc
 1870               	.LFE26:
 1872               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1873               	.global	set_single_persistent_default_layer
 1875               	set_single_persistent_default_layer:
 1876               	.LFB30:
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1877               		.loc 1 788 0
 1878               		.cfi_startproc
 1879               	.LVL193:
 1880 0000 CF93      		push r28
 1881               	.LCFI22:
 1882               		.cfi_def_cfa_offset 3
 1883               		.cfi_offset 28, -2
 1884 0002 DF93      		push r29
 1885               	.LCFI23:
 1886               		.cfi_def_cfa_offset 4
 1887               		.cfi_offset 29, -3
 1888               	/* prologue: function */
 1889               	/* frame size = 0 */
 1890               	/* stack size = 2 */
 1891               	.L__stack_usage = 2
 789:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 790:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 791:quantum/quantum.c ****   #endif
 792:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1892               		.loc 1 792 0
 1893 0004 C1E0      		ldi r28,lo8(1)
 1894 0006 D0E0      		ldi r29,0
 1895 0008 00C0      		rjmp 2f
 1896               		1:
 1897 000a CC0F      		lsl r28
 1898 000c DD1F      		rol r29
 1899               		2:
 1900 000e 8A95      		dec r24
 1901 0010 02F4      		brpl 1b
 1902 0012 8C2F      		mov r24,r28
 1903               	.LVL194:
 1904 0014 0E94 0000 		call eeconfig_update_default_layer
 1905               	.LVL195:
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1906               		.loc 1 793 0
 1907 0018 BE01      		movw r22,r28
 1908 001a 80E0      		ldi r24,0
 1909 001c 90E0      		ldi r25,0
 1910               	/* epilogue start */
 794:quantum/quantum.c **** }
 1911               		.loc 1 794 0
 1912 001e DF91      		pop r29
 1913 0020 CF91      		pop r28
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1914               		.loc 1 793 0
 1915 0022 0C94 0000 		jmp default_layer_set
 1916               	.LVL196:
 1917               		.cfi_endproc
 1918               	.LFE30:
 1920               		.section	.text.update_tri_layer_state,"ax",@progbits
 1921               	.global	update_tri_layer_state
 1923               	update_tri_layer_state:
 1924               	.LFB31:
 795:quantum/quantum.c **** 
 796:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1925               		.loc 1 796 0
 1926               		.cfi_startproc
 1927               	.LVL197:
 1928 0000 4F92      		push r4
 1929               	.LCFI24:
 1930               		.cfi_def_cfa_offset 3
 1931               		.cfi_offset 4, -2
 1932 0002 5F92      		push r5
 1933               	.LCFI25:
 1934               		.cfi_def_cfa_offset 4
 1935               		.cfi_offset 5, -3
 1936 0004 6F92      		push r6
 1937               	.LCFI26:
 1938               		.cfi_def_cfa_offset 5
 1939               		.cfi_offset 6, -4
 1940 0006 7F92      		push r7
 1941               	.LCFI27:
 1942               		.cfi_def_cfa_offset 6
 1943               		.cfi_offset 7, -5
 1944 0008 8F92      		push r8
 1945               	.LCFI28:
 1946               		.cfi_def_cfa_offset 7
 1947               		.cfi_offset 8, -6
 1948 000a 9F92      		push r9
 1949               	.LCFI29:
 1950               		.cfi_def_cfa_offset 8
 1951               		.cfi_offset 9, -7
 1952 000c AF92      		push r10
 1953               	.LCFI30:
 1954               		.cfi_def_cfa_offset 9
 1955               		.cfi_offset 10, -8
 1956 000e BF92      		push r11
 1957               	.LCFI31:
 1958               		.cfi_def_cfa_offset 10
 1959               		.cfi_offset 11, -9
 1960 0010 CF92      		push r12
 1961               	.LCFI32:
 1962               		.cfi_def_cfa_offset 11
 1963               		.cfi_offset 12, -10
 1964 0012 DF92      		push r13
 1965               	.LCFI33:
 1966               		.cfi_def_cfa_offset 12
 1967               		.cfi_offset 13, -11
 1968 0014 EF92      		push r14
 1969               	.LCFI34:
 1970               		.cfi_def_cfa_offset 13
 1971               		.cfi_offset 14, -12
 1972 0016 FF92      		push r15
 1973               	.LCFI35:
 1974               		.cfi_def_cfa_offset 14
 1975               		.cfi_offset 15, -13
 1976 0018 0F93      		push r16
 1977               	.LCFI36:
 1978               		.cfi_def_cfa_offset 15
 1979               		.cfi_offset 16, -14
 1980 001a 1F93      		push r17
 1981               	.LCFI37:
 1982               		.cfi_def_cfa_offset 16
 1983               		.cfi_offset 17, -15
 1984               	/* prologue: function */
 1985               	/* frame size = 0 */
 1986               	/* stack size = 14 */
 1987               	.L__stack_usage = 14
 1988 001c 2B01      		movw r4,r22
 1989 001e 3C01      		movw r6,r24
 797:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 1990               		.loc 1 797 0
 1991 0020 C12C      		mov r12,__zero_reg__
 1992 0022 D12C      		mov r13,__zero_reg__
 1993 0024 7601      		movw r14,r12
 1994 0026 C394      		inc r12
 1995 0028 D701      		movw r26,r14
 1996 002a C601      		movw r24,r12
 1997 002c 00C0      		rjmp 2f
 1998               		1:
 1999 002e 880F      		lsl r24
 2000 0030 991F      		rol r25
 2001 0032 AA1F      		rol r26
 2002 0034 BB1F      		rol r27
 2003               		2:
 2004 0036 4A95      		dec r20
 2005 0038 02F4      		brpl 1b
 2006 003a AC01      		movw r20,r24
 2007 003c BD01      		movw r22,r26
 2008               	.LVL198:
 2009 003e 4601      		movw r8,r12
 2010 0040 5701      		movw r10,r14
 2011 0042 00C0      		rjmp 2f
 2012               		1:
 2013 0044 880C      		lsl r8
 2014 0046 991C      		rol r9
 2015 0048 AA1C      		rol r10
 2016 004a BB1C      		rol r11
 2017               		2:
 2018 004c 2A95      		dec r18
 2019 004e 02F4      		brpl 1b
 2020 0050 4829      		or r20,r8
 2021 0052 5929      		or r21,r9
 2022 0054 6A29      		or r22,r10
 2023 0056 7B29      		or r23,r11
 2024               	.LVL199:
 798:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 2025               		.loc 1 798 0
 2026 0058 D701      		movw r26,r14
 2027 005a C601      		movw r24,r12
 2028 005c 00C0      		rjmp 2f
 2029               		1:
 2030 005e 880F      		lsl r24
 2031 0060 991F      		rol r25
 2032 0062 AA1F      		rol r26
 2033 0064 BB1F      		rol r27
 2034               		2:
 2035 0066 0A95      		dec r16
 2036 0068 02F4      		brpl 1b
 2037               	.LVL200:
 799:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 2038               		.loc 1 799 0
 2039 006a 6A01      		movw r12,r20
 2040 006c 7B01      		movw r14,r22
 2041 006e C420      		and r12,r4
 2042 0070 D520      		and r13,r5
 2043 0072 E620      		and r14,r6
 2044 0074 F720      		and r15,r7
 2045 0076 C416      		cp r12,r20
 2046 0078 D506      		cpc r13,r21
 2047 007a E606      		cpc r14,r22
 2048 007c F706      		cpc r15,r23
 2049 007e 01F4      		brne .L264
 2050               		.loc 1 799 0 is_stmt 0 discriminator 1
 2051 0080 BC01      		movw r22,r24
 2052 0082 CD01      		movw r24,r26
 2053               	.LVL201:
 2054 0084 6429      		or r22,r4
 2055 0086 7529      		or r23,r5
 2056 0088 8629      		or r24,r6
 2057 008a 9729      		or r25,r7
 2058 008c 00C0      		rjmp .L265
 2059               	.L264:
 2060               		.loc 1 799 0 discriminator 2
 2061 008e BC01      		movw r22,r24
 2062 0090 CD01      		movw r24,r26
 2063 0092 6095      		com r22
 2064 0094 7095      		com r23
 2065 0096 8095      		com r24
 2066 0098 9095      		com r25
 2067 009a 6421      		and r22,r4
 2068 009c 7521      		and r23,r5
 2069 009e 8621      		and r24,r6
 2070 00a0 9721      		and r25,r7
 2071               	.L265:
 2072               	/* epilogue start */
 800:quantum/quantum.c **** }
 2073               		.loc 1 800 0 is_stmt 1 discriminator 3
 2074 00a2 1F91      		pop r17
 2075 00a4 0F91      		pop r16
 2076               	.LVL202:
 2077 00a6 FF90      		pop r15
 2078               	.LVL203:
 2079 00a8 EF90      		pop r14
 2080               	.LVL204:
 2081 00aa DF90      		pop r13
 2082               	.LVL205:
 2083 00ac CF90      		pop r12
 2084               	.LVL206:
 2085 00ae BF90      		pop r11
 2086               	.LVL207:
 2087 00b0 AF90      		pop r10
 2088               	.LVL208:
 2089 00b2 9F90      		pop r9
 2090               	.LVL209:
 2091 00b4 8F90      		pop r8
 2092               	.LVL210:
 2093 00b6 7F90      		pop r7
 2094               	.LVL211:
 2095 00b8 6F90      		pop r6
 2096               	.LVL212:
 2097 00ba 5F90      		pop r5
 2098               	.LVL213:
 2099 00bc 4F90      		pop r4
 2100               	.LVL214:
 2101 00be 0895      		ret
 2102               		.cfi_endproc
 2103               	.LFE31:
 2105               		.section	.text.update_tri_layer,"ax",@progbits
 2106               	.global	update_tri_layer
 2108               	update_tri_layer:
 2109               	.LFB32:
 801:quantum/quantum.c **** 
 802:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 2110               		.loc 1 802 0
 2111               		.cfi_startproc
 2112               	.LVL215:
 2113 0000 0F93      		push r16
 2114               	.LCFI38:
 2115               		.cfi_def_cfa_offset 3
 2116               		.cfi_offset 16, -2
 2117               	/* prologue: function */
 2118               	/* frame size = 0 */
 2119               	/* stack size = 1 */
 2120               	.L__stack_usage = 1
 2121 0002 382F      		mov r19,r24
 2122 0004 262F      		mov r18,r22
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 2123               		.loc 1 803 0
 2124 0006 6091 0000 		lds r22,layer_state
 2125 000a 7091 0000 		lds r23,layer_state+1
 2126 000e 8091 0000 		lds r24,layer_state+2
 2127 0012 9091 0000 		lds r25,layer_state+3
 2128               	.LVL216:
 2129 0016 042F      		mov r16,r20
 2130 0018 432F      		mov r20,r19
 2131               	.LVL217:
 2132 001a 0E94 0000 		call update_tri_layer_state
 2133               	.LVL218:
 2134               	/* epilogue start */
 804:quantum/quantum.c **** }
 2135               		.loc 1 804 0
 2136 001e 0F91      		pop r16
 2137               	.LVL219:
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 2138               		.loc 1 803 0
 2139 0020 0C94 0000 		jmp layer_state_set
 2140               	.LVL220:
 2141               		.cfi_endproc
 2142               	.LFE32:
 2144               		.section	.text.tap_random_base64,"ax",@progbits
 2145               	.global	tap_random_base64
 2147               	tap_random_base64:
 2148               	.LFB33:
 805:quantum/quantum.c **** 
 806:quantum/quantum.c **** void tap_random_base64(void) {
 2149               		.loc 1 806 0
 2150               		.cfi_startproc
 2151 0000 CF93      		push r28
 2152               	.LCFI39:
 2153               		.cfi_def_cfa_offset 3
 2154               		.cfi_offset 28, -2
 2155               	/* prologue: function */
 2156               	/* frame size = 0 */
 2157               	/* stack size = 1 */
 2158               	.L__stack_usage = 1
 807:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 808:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 2159               		.loc 1 808 0
 2160 0002 66B5      		in r22,0x26
 2161 0004 4091 8400 		lds r20,132
 2162 0008 5091 8500 		lds r21,132+1
 2163 000c 8091 9400 		lds r24,148
 2164 0010 9091 9500 		lds r25,148+1
 2165 0014 2091 BE00 		lds r18,190
 2166 0018 3091 BF00 		lds r19,190+1
 2167 001c C42F      		mov r28,r20
 2168 001e C80F      		add r28,r24
 2169 0020 C60F      		add r28,r22
 2170 0022 C20F      		add r28,r18
 2171 0024 CF73      		andi r28,lo8(63)
 2172               	.LVL221:
 809:quantum/quantum.c ****   #else
 810:quantum/quantum.c ****     uint8_t key = rand() % 64;
 811:quantum/quantum.c ****   #endif
 812:quantum/quantum.c ****   switch (key) {
 2173               		.loc 1 812 0
 2174 0026 CE33      		cpi r28,lo8(62)
 2175 0028 00F4      		brsh .L269
 2176 002a C533      		cpi r28,lo8(53)
 2177 002c 00F4      		brsh .L270
 2178 002e CA31      		cpi r28,lo8(26)
 2179 0030 00F0      		brlo .L268
 2180 0032 C433      		cpi r28,lo8(52)
 2181 0034 00F4      		brsh .L275
 813:quantum/quantum.c ****     case 0 ... 25:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 815:quantum/quantum.c ****       register_code(key + KC_A);
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 817:quantum/quantum.c ****       unregister_code(KC_LSFT);
 818:quantum/quantum.c ****       break;
 819:quantum/quantum.c ****     case 26 ... 51:
 820:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 2182               		.loc 1 820 0
 2183 0036 C651      		subi r28,lo8(-(-22))
 2184               	.LVL222:
 2185 0038 00C0      		rjmp .L278
 2186               	.LVL223:
 2187               	.L269:
 812:quantum/quantum.c ****   switch (key) {
 2188               		.loc 1 812 0
 2189 003a CE33      		cpi r28,lo8(62)
 2190 003c 01F0      		breq .L273
 2191 003e CF33      		cpi r28,lo8(63)
 2192 0040 01F0      		breq .L274
 2193               	.L268:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 2194               		.loc 1 814 0
 2195 0042 81EE      		ldi r24,lo8(-31)
 2196 0044 0E94 0000 		call register_code
 2197               	.LVL224:
 815:quantum/quantum.c ****       register_code(key + KC_A);
 2198               		.loc 1 815 0
 2199 0048 CC5F      		subi r28,lo8(-(4))
 2200               	.LVL225:
 2201 004a 8C2F      		mov r24,r28
 2202 004c 0E94 0000 		call register_code
 2203               	.LVL226:
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 2204               		.loc 1 816 0
 2205 0050 8C2F      		mov r24,r28
 2206 0052 00C0      		rjmp .L277
 2207               	.LVL227:
 2208               	.L275:
 821:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 822:quantum/quantum.c ****       break;
 823:quantum/quantum.c ****     case 52:
 824:quantum/quantum.c ****       register_code(KC_0);
 2209               		.loc 1 824 0
 2210 0054 87E2      		ldi r24,lo8(39)
 2211 0056 0E94 0000 		call register_code
 2212               	.LVL228:
 825:quantum/quantum.c ****       unregister_code(KC_0);
 2213               		.loc 1 825 0
 2214 005a 87E2      		ldi r24,lo8(39)
 2215 005c 00C0      		rjmp .L276
 2216               	.L270:
 826:quantum/quantum.c ****       break;
 827:quantum/quantum.c ****     case 53 ... 61:
 828:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 2217               		.loc 1 828 0
 2218 005e C751      		subi r28,lo8(-(-23))
 2219               	.LVL229:
 2220               	.L278:
 2221 0060 8C2F      		mov r24,r28
 2222               	.LVL230:
 2223 0062 0E94 0000 		call register_code
 2224               	.LVL231:
 829:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 2225               		.loc 1 829 0
 2226 0066 8C2F      		mov r24,r28
 2227 0068 00C0      		rjmp .L276
 2228               	.LVL232:
 2229               	.L273:
 830:quantum/quantum.c ****       break;
 831:quantum/quantum.c ****     case 62:
 832:quantum/quantum.c ****       register_code(KC_LSFT);
 2230               		.loc 1 832 0
 2231 006a 81EE      		ldi r24,lo8(-31)
 2232 006c 0E94 0000 		call register_code
 2233               	.LVL233:
 833:quantum/quantum.c ****       register_code(KC_EQL);
 2234               		.loc 1 833 0
 2235 0070 8EE2      		ldi r24,lo8(46)
 2236 0072 0E94 0000 		call register_code
 2237               	.LVL234:
 834:quantum/quantum.c ****       unregister_code(KC_EQL);
 2238               		.loc 1 834 0
 2239 0076 8EE2      		ldi r24,lo8(46)
 2240               	.LVL235:
 2241               	.L277:
 2242 0078 0E94 0000 		call unregister_code
 2243               	.LVL236:
 835:quantum/quantum.c ****       unregister_code(KC_LSFT);
 2244               		.loc 1 835 0
 2245 007c 81EE      		ldi r24,lo8(-31)
 2246 007e 00C0      		rjmp .L276
 2247               	.LVL237:
 2248               	.L274:
 836:quantum/quantum.c ****       break;
 837:quantum/quantum.c ****     case 63:
 838:quantum/quantum.c ****       register_code(KC_SLSH);
 2249               		.loc 1 838 0
 2250 0080 88E3      		ldi r24,lo8(56)
 2251 0082 0E94 0000 		call register_code
 2252               	.LVL238:
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2253               		.loc 1 839 0
 2254 0086 88E3      		ldi r24,lo8(56)
 2255               	.LVL239:
 2256               	.L276:
 2257               	/* epilogue start */
 840:quantum/quantum.c ****       break;
 841:quantum/quantum.c ****   }
 842:quantum/quantum.c **** }
 2258               		.loc 1 842 0
 2259 0088 CF91      		pop r28
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2260               		.loc 1 839 0
 2261 008a 0C94 0000 		jmp unregister_code
 2262               	.LVL240:
 2263               		.cfi_endproc
 2264               	.LFE33:
 2266               		.section	.text.matrix_init_quantum,"ax",@progbits
 2267               	.global	matrix_init_quantum
 2269               	matrix_init_quantum:
 2270               	.LFB34:
 843:quantum/quantum.c **** 
 844:quantum/quantum.c **** void matrix_init_quantum() {
 2271               		.loc 1 844 0
 2272               		.cfi_startproc
 2273               	/* prologue: function */
 2274               	/* frame size = 0 */
 2275               	/* stack size = 0 */
 2276               	.L__stack_usage = 0
 845:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 846:quantum/quantum.c ****     backlight_init_ports();
 847:quantum/quantum.c ****   #endif
 848:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 849:quantum/quantum.c ****     audio_init();
 850:quantum/quantum.c ****   #endif
 851:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 852:quantum/quantum.c ****     rgb_matrix_init_drivers();
 853:quantum/quantum.c ****   #endif
 854:quantum/quantum.c ****   matrix_init_kb();
 2277               		.loc 1 854 0
 2278 0000 0C94 0000 		jmp matrix_init_kb
 2279               	.LVL241:
 2280               		.cfi_endproc
 2281               	.LFE34:
 2283               		.section	.text.matrix_scan_quantum,"ax",@progbits
 2284               	.global	matrix_scan_quantum
 2286               	matrix_scan_quantum:
 2287               	.LFB35:
 855:quantum/quantum.c **** }
 856:quantum/quantum.c **** 
 857:quantum/quantum.c **** uint8_t rgb_matrix_task_counter = 0;
 858:quantum/quantum.c **** 
 859:quantum/quantum.c **** #ifndef RGB_MATRIX_SKIP_FRAMES
 860:quantum/quantum.c ****   #define RGB_MATRIX_SKIP_FRAMES 1
 861:quantum/quantum.c **** #endif
 862:quantum/quantum.c **** 
 863:quantum/quantum.c **** void matrix_scan_quantum() {
 2288               		.loc 1 863 0
 2289               		.cfi_startproc
 2290               	/* prologue: function */
 2291               	/* frame size = 0 */
 2292               	/* stack size = 0 */
 2293               	.L__stack_usage = 0
 864:quantum/quantum.c ****   #if defined(AUDIO_ENABLE)
 865:quantum/quantum.c ****     matrix_scan_music();
 866:quantum/quantum.c ****   #endif
 867:quantum/quantum.c **** 
 868:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 869:quantum/quantum.c ****     matrix_scan_tap_dance();
 2294               		.loc 1 869 0
 2295 0000 0E94 0000 		call matrix_scan_tap_dance
 2296               	.LVL242:
 870:quantum/quantum.c ****   #endif
 871:quantum/quantum.c **** 
 872:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 873:quantum/quantum.c ****     matrix_scan_combo();
 874:quantum/quantum.c ****   #endif
 875:quantum/quantum.c **** 
 876:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 877:quantum/quantum.c ****     backlight_task();
 878:quantum/quantum.c ****   #endif
 879:quantum/quantum.c **** 
 880:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 881:quantum/quantum.c ****     rgb_matrix_task();
 882:quantum/quantum.c ****     if (rgb_matrix_task_counter == 0) {
 883:quantum/quantum.c ****       rgb_matrix_update_pwm_buffers();
 884:quantum/quantum.c ****     }
 885:quantum/quantum.c ****     rgb_matrix_task_counter = ((rgb_matrix_task_counter + 1) % (RGB_MATRIX_SKIP_FRAMES + 1));
 886:quantum/quantum.c ****   #endif
 887:quantum/quantum.c **** 
 888:quantum/quantum.c ****   matrix_scan_kb();
 2297               		.loc 1 888 0
 2298 0004 0C94 0000 		jmp matrix_scan_kb
 2299               	.LVL243:
 2300               		.cfi_endproc
 2301               	.LFE35:
 2303               		.section	.text.backlight_init_ports,"ax",@progbits
 2304               		.weak	backlight_init_ports
 2306               	backlight_init_ports:
 2307               	.LFB36:
 889:quantum/quantum.c **** }
 890:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 891:quantum/quantum.c **** 
 892:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 893:quantum/quantum.c **** 
 894:quantum/quantum.c **** // depending on the pin, we use a different output compare unit
 895:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 896:quantum/quantum.c **** #  define COM1x1 COM1C1
 897:quantum/quantum.c **** #  define OCR1x  OCR1C
 898:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 899:quantum/quantum.c **** #  define COM1x1 COM1B1
 900:quantum/quantum.c **** #  define OCR1x  OCR1B
 901:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 902:quantum/quantum.c **** #  define COM1x1 COM1A1
 903:quantum/quantum.c **** #  define OCR1x  OCR1A
 904:quantum/quantum.c **** #else
 905:quantum/quantum.c **** #  define NO_HARDWARE_PWM
 906:quantum/quantum.c **** #endif
 907:quantum/quantum.c **** 
 908:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
 909:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
 910:quantum/quantum.c **** #endif
 911:quantum/quantum.c **** 
 912:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM // pwm through software
 913:quantum/quantum.c **** 
 914:quantum/quantum.c **** __attribute__ ((weak))
 915:quantum/quantum.c **** void backlight_init_ports(void)
 916:quantum/quantum.c **** {
 917:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
 918:quantum/quantum.c ****   // DDRx |= n
 919:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 920:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
 921:quantum/quantum.c ****     // PORTx &= ~n
 922:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 923:quantum/quantum.c ****   #else
 924:quantum/quantum.c ****     // PORTx |= n
 925:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 926:quantum/quantum.c ****   #endif
 927:quantum/quantum.c **** }
 928:quantum/quantum.c **** 
 929:quantum/quantum.c **** __attribute__ ((weak))
 930:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 931:quantum/quantum.c **** 
 932:quantum/quantum.c **** uint8_t backlight_tick = 0;
 933:quantum/quantum.c **** 
 934:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 935:quantum/quantum.c **** void backlight_task(void) {
 936:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
 937:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 938:quantum/quantum.c ****       // PORTx &= ~n
 939:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 940:quantum/quantum.c ****     #else
 941:quantum/quantum.c ****       // PORTx |= n
 942:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 943:quantum/quantum.c ****     #endif
 944:quantum/quantum.c ****   } else {
 945:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 946:quantum/quantum.c ****       // PORTx |= n
 947:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 948:quantum/quantum.c ****     #else
 949:quantum/quantum.c ****       // PORTx &= ~n
 950:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 951:quantum/quantum.c ****     #endif
 952:quantum/quantum.c ****   }
 953:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
 954:quantum/quantum.c **** }
 955:quantum/quantum.c **** #endif
 956:quantum/quantum.c **** 
 957:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 958:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
 959:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
 960:quantum/quantum.c ****   #endif
 961:quantum/quantum.c **** #endif
 962:quantum/quantum.c **** 
 963:quantum/quantum.c **** #else // pwm through timer
 964:quantum/quantum.c **** 
 965:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
 966:quantum/quantum.c **** 
 967:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
 968:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
 969:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
 970:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 971:quantum/quantum.c ****   else {
 972:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
 973:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
 974:quantum/quantum.c ****     // and revert what we've done again after squaring.
 975:quantum/quantum.c ****     y = y * y * y >> 8;
 976:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 977:quantum/quantum.c ****       return 0xFFFFU;
 978:quantum/quantum.c ****     else
 979:quantum/quantum.c ****       return (uint16_t) y;
 980:quantum/quantum.c ****   }
 981:quantum/quantum.c **** }
 982:quantum/quantum.c **** 
 983:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
 984:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
 985:quantum/quantum.c ****   OCR1x = val;
 986:quantum/quantum.c **** }
 987:quantum/quantum.c **** 
 988:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 989:quantum/quantum.c **** __attribute__ ((weak))
 990:quantum/quantum.c **** void backlight_set(uint8_t level) {
 991:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
 992:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 993:quantum/quantum.c **** 
 994:quantum/quantum.c ****   if (level == 0) {
 995:quantum/quantum.c ****     // Turn off PWM control on backlight pin
 996:quantum/quantum.c ****     TCCR1A &= ~(_BV(COM1x1));
 997:quantum/quantum.c ****   } else {
 998:quantum/quantum.c ****     // Turn on PWM control of backlight pin
 999:quantum/quantum.c ****     TCCR1A |= _BV(COM1x1);
1000:quantum/quantum.c ****   }
1001:quantum/quantum.c ****   // Set the brightness
1002:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
1003:quantum/quantum.c **** }
1004:quantum/quantum.c **** 
1005:quantum/quantum.c **** void backlight_task(void) {}
1006:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1007:quantum/quantum.c **** 
1008:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1009:quantum/quantum.c **** 
1010:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1011:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1012:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1013:quantum/quantum.c **** #define BREATHING_STEPS 128
1014:quantum/quantum.c **** 
1015:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1016:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1017:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1018:quantum/quantum.c **** 
1019:quantum/quantum.c **** bool is_breathing(void) {
1020:quantum/quantum.c ****     return !!(TIMSK1 & _BV(TOIE1));
1021:quantum/quantum.c **** }
1022:quantum/quantum.c **** 
1023:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSK1 |= _BV(TOIE1);} while (0)
1024:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSK1 &= ~_BV(TOIE1);} while (0)
1025:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1026:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1027:quantum/quantum.c **** 
1028:quantum/quantum.c **** void breathing_enable(void)
1029:quantum/quantum.c **** {
1030:quantum/quantum.c ****   breathing_counter = 0;
1031:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1032:quantum/quantum.c ****   breathing_interrupt_enable();
1033:quantum/quantum.c **** }
1034:quantum/quantum.c **** 
1035:quantum/quantum.c **** void breathing_pulse(void)
1036:quantum/quantum.c **** {
1037:quantum/quantum.c ****     if (get_backlight_level() == 0)
1038:quantum/quantum.c ****       breathing_min();
1039:quantum/quantum.c ****     else
1040:quantum/quantum.c ****       breathing_max();
1041:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1042:quantum/quantum.c ****     breathing_interrupt_enable();
1043:quantum/quantum.c **** }
1044:quantum/quantum.c **** 
1045:quantum/quantum.c **** void breathing_disable(void)
1046:quantum/quantum.c **** {
1047:quantum/quantum.c ****     breathing_interrupt_disable();
1048:quantum/quantum.c ****     // Restore backlight level
1049:quantum/quantum.c ****     backlight_set(get_backlight_level());
1050:quantum/quantum.c **** }
1051:quantum/quantum.c **** 
1052:quantum/quantum.c **** void breathing_self_disable(void)
1053:quantum/quantum.c **** {
1054:quantum/quantum.c ****   if (get_backlight_level() == 0)
1055:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1056:quantum/quantum.c ****   else
1057:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1058:quantum/quantum.c **** }
1059:quantum/quantum.c **** 
1060:quantum/quantum.c **** void breathing_toggle(void) {
1061:quantum/quantum.c ****   if (is_breathing())
1062:quantum/quantum.c ****     breathing_disable();
1063:quantum/quantum.c ****   else
1064:quantum/quantum.c ****     breathing_enable();
1065:quantum/quantum.c **** }
1066:quantum/quantum.c **** 
1067:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1068:quantum/quantum.c **** {
1069:quantum/quantum.c ****   if (!value)
1070:quantum/quantum.c ****     value = 1;
1071:quantum/quantum.c ****   breathing_period = value;
1072:quantum/quantum.c **** }
1073:quantum/quantum.c **** 
1074:quantum/quantum.c **** void breathing_period_default(void) {
1075:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1076:quantum/quantum.c **** }
1077:quantum/quantum.c **** 
1078:quantum/quantum.c **** void breathing_period_inc(void)
1079:quantum/quantum.c **** {
1080:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1081:quantum/quantum.c **** }
1082:quantum/quantum.c **** 
1083:quantum/quantum.c **** void breathing_period_dec(void)
1084:quantum/quantum.c **** {
1085:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1086:quantum/quantum.c **** }
1087:quantum/quantum.c **** 
1088:quantum/quantum.c **** /* To generate breathing curve in python:
1089:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1090:quantum/quantum.c ****  */
1091:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1092:quantum/quantum.c **** 
1093:quantum/quantum.c **** // Use this before the cie_lightness function.
1094:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1095:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1096:quantum/quantum.c **** }
1097:quantum/quantum.c **** 
1098:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1099:quantum/quantum.c ****  * about 244 times per second.
1100:quantum/quantum.c ****  */
1101:quantum/quantum.c **** ISR(TIMER1_OVF_vect)
1102:quantum/quantum.c **** {
1103:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1104:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1105:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1106:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1107:quantum/quantum.c **** 
1108:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1109:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1110:quantum/quantum.c ****   {
1111:quantum/quantum.c ****       breathing_interrupt_disable();
1112:quantum/quantum.c ****   }
1113:quantum/quantum.c **** 
1114:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1115:quantum/quantum.c **** }
1116:quantum/quantum.c **** 
1117:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1118:quantum/quantum.c **** 
1119:quantum/quantum.c **** __attribute__ ((weak))
1120:quantum/quantum.c **** void backlight_init_ports(void)
1121:quantum/quantum.c **** {
1122:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1123:quantum/quantum.c ****   // DDRx |= n
1124:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
1125:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1126:quantum/quantum.c ****     // PORTx &= ~n
1127:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1128:quantum/quantum.c ****   #else
1129:quantum/quantum.c ****     // PORTx |= n
1130:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1131:quantum/quantum.c ****   #endif
1132:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1133:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1134:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1135:quantum/quantum.c **** 
1136:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1137:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1138:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1139:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1140:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1141:quantum/quantum.c **** 
1142:quantum/quantum.c ****   /*
1143:quantum/quantum.c ****   14.8.3:
1144:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1145:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1146:quantum/quantum.c ****   */
1147:quantum/quantum.c **** 
1148:quantum/quantum.c ****   TCCR1A = _BV(COM1x1) | _BV(WGM11); // = 0b00001010;
1149:quantum/quantum.c ****   TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1150:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1151:quantum/quantum.c ****   ICR1 = TIMER_TOP;
1152:quantum/quantum.c **** 
1153:quantum/quantum.c ****   backlight_init();
1154:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1155:quantum/quantum.c ****     breathing_enable();
1156:quantum/quantum.c ****   #endif
1157:quantum/quantum.c **** }
1158:quantum/quantum.c **** 
1159:quantum/quantum.c **** #endif // NO_HARDWARE_PWM
1160:quantum/quantum.c **** 
1161:quantum/quantum.c **** #else // backlight
1162:quantum/quantum.c **** 
1163:quantum/quantum.c **** __attribute__ ((weak))
1164:quantum/quantum.c **** void backlight_init_ports(void) {}
 2308               		.loc 1 1164 0
 2309               		.cfi_startproc
 2310               	/* prologue: function */
 2311               	/* frame size = 0 */
 2312               	/* stack size = 0 */
 2313               	.L__stack_usage = 0
 2314 0000 0895      		ret
 2315               		.cfi_endproc
 2316               	.LFE36:
 2318               		.section	.text.backlight_set,"ax",@progbits
 2319               		.weak	backlight_set
 2321               	backlight_set:
 2322               	.LFB37:
1165:quantum/quantum.c **** 
1166:quantum/quantum.c **** __attribute__ ((weak))
1167:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 2323               		.loc 1 1167 0
 2324               		.cfi_startproc
 2325               	.LVL244:
 2326               	/* prologue: function */
 2327               	/* frame size = 0 */
 2328               	/* stack size = 0 */
 2329               	.L__stack_usage = 0
 2330 0000 0895      		ret
 2331               		.cfi_endproc
 2332               	.LFE37:
 2334               		.section	.text.send_nibble,"ax",@progbits
 2335               	.global	send_nibble
 2337               	send_nibble:
 2338               	.LFB41:
1168:quantum/quantum.c **** 
1169:quantum/quantum.c **** #endif // backlight
1170:quantum/quantum.c **** 
1171:quantum/quantum.c **** 
1172:quantum/quantum.c **** // Functions for spitting out values
1173:quantum/quantum.c **** //
1174:quantum/quantum.c **** 
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1176:quantum/quantum.c ****     uint16_t word = (number >> 16);
1177:quantum/quantum.c ****     send_word(word);
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1179:quantum/quantum.c **** }
1180:quantum/quantum.c **** 
1181:quantum/quantum.c **** void send_word(uint16_t number) {
1182:quantum/quantum.c ****     uint8_t byte = number >> 8;
1183:quantum/quantum.c ****     send_byte(byte);
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
1185:quantum/quantum.c **** }
1186:quantum/quantum.c **** 
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
1188:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1189:quantum/quantum.c ****     send_nibble(nibble);
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
1191:quantum/quantum.c **** }
1192:quantum/quantum.c **** 
1193:quantum/quantum.c **** void send_nibble(uint8_t number) {
 2339               		.loc 1 1193 0
 2340               		.cfi_startproc
 2341               	.LVL245:
 2342               		.loc 1 1193 0
 2343 0000 CF93      		push r28
 2344               	.LCFI40:
 2345               		.cfi_def_cfa_offset 3
 2346               		.cfi_offset 28, -2
 2347               	/* prologue: function */
 2348               	/* frame size = 0 */
 2349               	/* stack size = 1 */
 2350               	.L__stack_usage = 1
1194:quantum/quantum.c ****     switch (number) {
 2351               		.loc 1 1194 0
 2352 0002 8A30      		cpi r24,lo8(10)
 2353 0004 00F4      		brsh .L285
 2354 0006 8130      		cpi r24,lo8(1)
 2355 0008 00F4      		brsh .L293
1195:quantum/quantum.c ****         case 0:
1196:quantum/quantum.c ****             register_code(KC_0);
 2356               		.loc 1 1196 0
 2357 000a 87E2      		ldi r24,lo8(39)
 2358               	.LVL246:
 2359 000c 0E94 0000 		call register_code
 2360               	.LVL247:
1197:quantum/quantum.c ****             unregister_code(KC_0);
 2361               		.loc 1 1197 0
 2362 0010 87E2      		ldi r24,lo8(39)
 2363 0012 00C0      		rjmp .L291
 2364               	.LVL248:
 2365               	.L285:
1194:quantum/quantum.c ****     switch (number) {
 2366               		.loc 1 1194 0
 2367 0014 8031      		cpi r24,lo8(16)
 2368 0016 00F4      		brsh .L294
1198:quantum/quantum.c ****             break;
1199:quantum/quantum.c ****         case 1 ... 9:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1201:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1202:quantum/quantum.c ****             break;
1203:quantum/quantum.c ****         case 0xA ... 0xF:
1204:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 2369               		.loc 1 1204 0
 2370 0018 CAEF      		ldi r28,lo8(-6)
 2371 001a 00C0      		rjmp .L292
 2372               	.L293:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
 2373               		.loc 1 1200 0
 2374 001c CDE1      		ldi r28,lo8(29)
 2375               	.L292:
 2376               		.loc 1 1204 0
 2377 001e C80F      		add r28,r24
 2378 0020 8C2F      		mov r24,r28
 2379               	.LVL249:
 2380 0022 0E94 0000 		call register_code
 2381               	.LVL250:
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2382               		.loc 1 1205 0
 2383 0026 8C2F      		mov r24,r28
 2384               	.L291:
 2385               	/* epilogue start */
1206:quantum/quantum.c ****             break;
1207:quantum/quantum.c ****     }
1208:quantum/quantum.c **** }
 2386               		.loc 1 1208 0
 2387 0028 CF91      		pop r28
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2388               		.loc 1 1205 0
 2389 002a 0C94 0000 		jmp unregister_code
 2390               	.LVL251:
 2391               	.L294:
 2392               	/* epilogue start */
 2393               		.loc 1 1208 0
 2394 002e CF91      		pop r28
 2395 0030 0895      		ret
 2396               		.cfi_endproc
 2397               	.LFE41:
 2399               		.section	.text.send_byte,"ax",@progbits
 2400               	.global	send_byte
 2402               	send_byte:
 2403               	.LFB40:
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
 2404               		.loc 1 1187 0
 2405               		.cfi_startproc
 2406               	.LVL252:
 2407 0000 CF93      		push r28
 2408               	.LCFI41:
 2409               		.cfi_def_cfa_offset 3
 2410               		.cfi_offset 28, -2
 2411               	/* prologue: function */
 2412               	/* frame size = 0 */
 2413               	/* stack size = 1 */
 2414               	.L__stack_usage = 1
 2415 0002 C82F      		mov r28,r24
 2416               	.LVL253:
1189:quantum/quantum.c ****     send_nibble(nibble);
 2417               		.loc 1 1189 0
 2418 0004 8295      		swap r24
 2419               	.LVL254:
 2420 0006 8F70      		andi r24,lo8(15)
 2421 0008 0E94 0000 		call send_nibble
 2422               	.LVL255:
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
 2423               		.loc 1 1190 0
 2424 000c 8C2F      		mov r24,r28
 2425 000e 8F70      		andi r24,lo8(15)
 2426               	/* epilogue start */
1191:quantum/quantum.c **** }
 2427               		.loc 1 1191 0
 2428 0010 CF91      		pop r28
 2429               	.LVL256:
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
 2430               		.loc 1 1190 0
 2431 0012 0C94 0000 		jmp send_nibble
 2432               	.LVL257:
 2433               		.cfi_endproc
 2434               	.LFE40:
 2436               		.section	.text.send_word,"ax",@progbits
 2437               	.global	send_word
 2439               	send_word:
 2440               	.LFB39:
1181:quantum/quantum.c **** void send_word(uint16_t number) {
 2441               		.loc 1 1181 0
 2442               		.cfi_startproc
 2443               	.LVL258:
 2444 0000 CF93      		push r28
 2445               	.LCFI42:
 2446               		.cfi_def_cfa_offset 3
 2447               		.cfi_offset 28, -2
 2448               	/* prologue: function */
 2449               	/* frame size = 0 */
 2450               	/* stack size = 1 */
 2451               	.L__stack_usage = 1
 2452 0002 C82F      		mov r28,r24
 2453               	.LVL259:
1183:quantum/quantum.c ****     send_byte(byte);
 2454               		.loc 1 1183 0
 2455 0004 892F      		mov r24,r25
 2456               	.LVL260:
 2457 0006 0E94 0000 		call send_byte
 2458               	.LVL261:
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
 2459               		.loc 1 1184 0
 2460 000a 8C2F      		mov r24,r28
 2461               	/* epilogue start */
1185:quantum/quantum.c **** }
 2462               		.loc 1 1185 0
 2463 000c CF91      		pop r28
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
 2464               		.loc 1 1184 0
 2465 000e 0C94 0000 		jmp send_byte
 2466               	.LVL262:
 2467               		.cfi_endproc
 2468               	.LFE39:
 2470               		.section	.text.send_dword,"ax",@progbits
 2471               	.global	send_dword
 2473               	send_dword:
 2474               	.LFB38:
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
 2475               		.loc 1 1175 0
 2476               		.cfi_startproc
 2477               	.LVL263:
 2478 0000 CF92      		push r12
 2479               	.LCFI43:
 2480               		.cfi_def_cfa_offset 3
 2481               		.cfi_offset 12, -2
 2482 0002 DF92      		push r13
 2483               	.LCFI44:
 2484               		.cfi_def_cfa_offset 4
 2485               		.cfi_offset 13, -3
 2486 0004 EF92      		push r14
 2487               	.LCFI45:
 2488               		.cfi_def_cfa_offset 5
 2489               		.cfi_offset 14, -4
 2490 0006 FF92      		push r15
 2491               	.LCFI46:
 2492               		.cfi_def_cfa_offset 6
 2493               		.cfi_offset 15, -5
 2494               	/* prologue: function */
 2495               	/* frame size = 0 */
 2496               	/* stack size = 4 */
 2497               	.L__stack_usage = 4
 2498 0008 6B01      		movw r12,r22
 2499 000a 7C01      		movw r14,r24
 2500               	.LVL264:
1177:quantum/quantum.c ****     send_word(word);
 2501               		.loc 1 1177 0
 2502 000c C701      		movw r24,r14
 2503 000e 0E94 0000 		call send_word
 2504               	.LVL265:
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2505               		.loc 1 1178 0
 2506 0012 C601      		movw r24,r12
 2507               	/* epilogue start */
1179:quantum/quantum.c **** }
 2508               		.loc 1 1179 0
 2509 0014 FF90      		pop r15
 2510 0016 EF90      		pop r14
 2511 0018 DF90      		pop r13
 2512 001a CF90      		pop r12
 2513               	.LVL266:
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2514               		.loc 1 1178 0
 2515 001c 0C94 0000 		jmp send_word
 2516               	.LVL267:
 2517               		.cfi_endproc
 2518               	.LFE38:
 2520               		.section	.text.hex_to_keycode,"ax",@progbits
 2521               		.weak	hex_to_keycode
 2523               	hex_to_keycode:
 2524               	.LFB42:
1209:quantum/quantum.c **** 
1210:quantum/quantum.c **** 
1211:quantum/quantum.c **** __attribute__((weak))
1212:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1213:quantum/quantum.c **** {
 2525               		.loc 1 1213 0
 2526               		.cfi_startproc
 2527               	.LVL268:
 2528               	/* prologue: function */
 2529               	/* frame size = 0 */
 2530               	/* stack size = 0 */
 2531               	.L__stack_usage = 0
1214:quantum/quantum.c ****   hex = hex & 0xF;
 2532               		.loc 1 1214 0
 2533 0000 282F      		mov r18,r24
 2534 0002 2F70      		andi r18,lo8(15)
 2535               	.LVL269:
1215:quantum/quantum.c ****   if (hex == 0x0) {
 2536               		.loc 1 1215 0
 2537 0004 01F0      		breq .L301
 2538 0006 822F      		mov r24,r18
 2539 0008 90E0      		ldi r25,0
1216:quantum/quantum.c ****     return KC_0;
1217:quantum/quantum.c ****   } else if (hex < 0xA) {
 2540               		.loc 1 1217 0
 2541 000a 2A30      		cpi r18,lo8(10)
 2542 000c 00F4      		brsh .L300
1218:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 2543               		.loc 1 1218 0
 2544 000e 4D96      		adiw r24,29
 2545 0010 0895      		ret
 2546               	.L300:
1219:quantum/quantum.c ****   } else {
1220:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 2547               		.loc 1 1220 0
 2548 0012 0697      		sbiw r24,6
 2549 0014 0895      		ret
 2550               	.L301:
1216:quantum/quantum.c ****     return KC_0;
 2551               		.loc 1 1216 0
 2552 0016 87E2      		ldi r24,lo8(39)
 2553 0018 90E0      		ldi r25,0
1221:quantum/quantum.c ****   }
1222:quantum/quantum.c **** }
 2554               		.loc 1 1222 0
 2555 001a 0895      		ret
 2556               		.cfi_endproc
 2557               	.LFE42:
 2559               		.section	.text.api_send_unicode,"ax",@progbits
 2560               	.global	api_send_unicode
 2562               	api_send_unicode:
 2563               	.LFB43:
1223:quantum/quantum.c **** 
1224:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 2564               		.loc 1 1224 0
 2565               		.cfi_startproc
 2566               	.LVL270:
 2567               	/* prologue: function */
 2568               	/* frame size = 0 */
 2569               	/* stack size = 0 */
 2570               	.L__stack_usage = 0
 2571 0000 0895      		ret
 2572               		.cfi_endproc
 2573               	.LFE43:
 2575               		.section	.text.led_set_user,"ax",@progbits
 2576               		.weak	led_set_user
 2578               	led_set_user:
 2579               	.LFB44:
1225:quantum/quantum.c **** #ifdef API_ENABLE
1226:quantum/quantum.c ****     uint8_t chunk[4];
1227:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1228:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1229:quantum/quantum.c **** #endif
1230:quantum/quantum.c **** }
1231:quantum/quantum.c **** 
1232:quantum/quantum.c **** __attribute__ ((weak))
1233:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 2580               		.loc 1 1233 0
 2581               		.cfi_startproc
 2582               	.LVL271:
 2583               	/* prologue: function */
 2584               	/* frame size = 0 */
 2585               	/* stack size = 0 */
 2586               	.L__stack_usage = 0
 2587 0000 0895      		ret
 2588               		.cfi_endproc
 2589               	.LFE44:
 2591               		.section	.text.led_set_kb,"ax",@progbits
 2592               		.weak	led_set_kb
 2594               	led_set_kb:
 2595               	.LFB45:
1234:quantum/quantum.c **** 
1235:quantum/quantum.c **** }
1236:quantum/quantum.c **** 
1237:quantum/quantum.c **** __attribute__ ((weak))
1238:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 2596               		.loc 1 1238 0
 2597               		.cfi_startproc
 2598               	.LVL272:
 2599               	/* prologue: function */
 2600               	/* frame size = 0 */
 2601               	/* stack size = 0 */
 2602               	.L__stack_usage = 0
1239:quantum/quantum.c ****     led_set_user(usb_led);
 2603               		.loc 1 1239 0
 2604 0000 0C94 0000 		jmp led_set_user
 2605               	.LVL273:
 2606               		.cfi_endproc
 2607               	.LFE45:
 2609               		.section	.text.led_init_ports,"ax",@progbits
 2610               		.weak	led_init_ports
 2612               	led_init_ports:
 2613               	.LFB46:
1240:quantum/quantum.c **** }
1241:quantum/quantum.c **** 
1242:quantum/quantum.c **** __attribute__ ((weak))
1243:quantum/quantum.c **** void led_init_ports(void)
1244:quantum/quantum.c **** {
 2614               		.loc 1 1244 0
 2615               		.cfi_startproc
 2616               	/* prologue: function */
 2617               	/* frame size = 0 */
 2618               	/* stack size = 0 */
 2619               	.L__stack_usage = 0
 2620 0000 0895      		ret
 2621               		.cfi_endproc
 2622               	.LFE46:
 2624               		.section	.text.led_set,"ax",@progbits
 2625               		.weak	led_set
 2627               	led_set:
 2628               	.LFB47:
1245:quantum/quantum.c **** 
1246:quantum/quantum.c **** }
1247:quantum/quantum.c **** 
1248:quantum/quantum.c **** __attribute__ ((weak))
1249:quantum/quantum.c **** void led_set(uint8_t usb_led)
1250:quantum/quantum.c **** {
 2629               		.loc 1 1250 0
 2630               		.cfi_startproc
 2631               	.LVL274:
 2632               	/* prologue: function */
 2633               	/* frame size = 0 */
 2634               	/* stack size = 0 */
 2635               	.L__stack_usage = 0
1251:quantum/quantum.c **** 
1252:quantum/quantum.c ****   // Example LED Code
1253:quantum/quantum.c ****   //
1254:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1255:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1256:quantum/quantum.c ****     // {
1257:quantum/quantum.c ****     //     // Output high.
1258:quantum/quantum.c ****     //     DDRE |= (1<<6);
1259:quantum/quantum.c ****     //     PORTE |= (1<<6);
1260:quantum/quantum.c ****     // }
1261:quantum/quantum.c ****     // else
1262:quantum/quantum.c ****     // {
1263:quantum/quantum.c ****     //     // Output low.
1264:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1265:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1266:quantum/quantum.c ****     // }
1267:quantum/quantum.c **** 
1268:quantum/quantum.c ****   led_set_kb(usb_led);
 2636               		.loc 1 1268 0
 2637 0000 0C94 0000 		jmp led_set_kb
 2638               	.LVL275:
 2639               		.cfi_endproc
 2640               	.LFE47:
 2642               		.section	.text.startup_user,"ax",@progbits
 2643               		.weak	startup_user
 2645               	startup_user:
 2646               	.LFB48:
1269:quantum/quantum.c **** }
1270:quantum/quantum.c **** 
1271:quantum/quantum.c **** 
1272:quantum/quantum.c **** //------------------------------------------------------------------------------
1273:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1274:quantum/quantum.c **** // different events such as startup and bootloader jump
1275:quantum/quantum.c **** 
1276:quantum/quantum.c **** __attribute__ ((weak))
1277:quantum/quantum.c **** void startup_user() {}
 2647               		.loc 1 1277 0
 2648               		.cfi_startproc
 2649               	/* prologue: function */
 2650               	/* frame size = 0 */
 2651               	/* stack size = 0 */
 2652               	.L__stack_usage = 0
 2653 0000 0895      		ret
 2654               		.cfi_endproc
 2655               	.LFE48:
 2657               		.section	.text.shutdown_user,"ax",@progbits
 2658               		.weak	shutdown_user
 2660               	shutdown_user:
 2661               	.LFB49:
1278:quantum/quantum.c **** 
1279:quantum/quantum.c **** __attribute__ ((weak))
1280:quantum/quantum.c **** void shutdown_user() {}
 2662               		.loc 1 1280 0
 2663               		.cfi_startproc
 2664               	/* prologue: function */
 2665               	/* frame size = 0 */
 2666               	/* stack size = 0 */
 2667               	.L__stack_usage = 0
 2668 0000 0895      		ret
 2669               		.cfi_endproc
 2670               	.LFE49:
 2672               	.global	rgb_matrix_task_counter
 2673               		.section	.bss.rgb_matrix_task_counter,"aw",@nobits
 2676               	rgb_matrix_task_counter:
 2677 0000 00        		.zero	1
 2678               		.weak	ascii_to_keycode_lut
 2679               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2682               	ascii_to_keycode_lut:
 2683 0000 00        		.byte	0
 2684 0001 00        		.byte	0
 2685 0002 00        		.byte	0
 2686 0003 00        		.byte	0
 2687 0004 00        		.byte	0
 2688 0005 00        		.byte	0
 2689 0006 00        		.byte	0
 2690 0007 00        		.byte	0
 2691 0008 2A        		.byte	42
 2692 0009 2B        		.byte	43
 2693 000a 28        		.byte	40
 2694 000b 00        		.byte	0
 2695 000c 00        		.byte	0
 2696 000d 00        		.byte	0
 2697 000e 00        		.byte	0
 2698 000f 00        		.byte	0
 2699 0010 00        		.byte	0
 2700 0011 00        		.byte	0
 2701 0012 00        		.byte	0
 2702 0013 00        		.byte	0
 2703 0014 00        		.byte	0
 2704 0015 00        		.byte	0
 2705 0016 00        		.byte	0
 2706 0017 00        		.byte	0
 2707 0018 00        		.byte	0
 2708 0019 00        		.byte	0
 2709 001a 00        		.byte	0
 2710 001b 29        		.byte	41
 2711 001c 00        		.byte	0
 2712 001d 00        		.byte	0
 2713 001e 00        		.byte	0
 2714 001f 00        		.byte	0
 2715 0020 2C        		.byte	44
 2716 0021 1E        		.byte	30
 2717 0022 34        		.byte	52
 2718 0023 20        		.byte	32
 2719 0024 21        		.byte	33
 2720 0025 22        		.byte	34
 2721 0026 24        		.byte	36
 2722 0027 34        		.byte	52
 2723 0028 26        		.byte	38
 2724 0029 27        		.byte	39
 2725 002a 25        		.byte	37
 2726 002b 2E        		.byte	46
 2727 002c 36        		.byte	54
 2728 002d 2D        		.byte	45
 2729 002e 37        		.byte	55
 2730 002f 38        		.byte	56
 2731 0030 27        		.byte	39
 2732 0031 1E        		.byte	30
 2733 0032 1F        		.byte	31
 2734 0033 20        		.byte	32
 2735 0034 21        		.byte	33
 2736 0035 22        		.byte	34
 2737 0036 23        		.byte	35
 2738 0037 24        		.byte	36
 2739 0038 25        		.byte	37
 2740 0039 26        		.byte	38
 2741 003a 33        		.byte	51
 2742 003b 33        		.byte	51
 2743 003c 36        		.byte	54
 2744 003d 2E        		.byte	46
 2745 003e 37        		.byte	55
 2746 003f 38        		.byte	56
 2747 0040 1F        		.byte	31
 2748 0041 04        		.byte	4
 2749 0042 05        		.byte	5
 2750 0043 06        		.byte	6
 2751 0044 07        		.byte	7
 2752 0045 08        		.byte	8
 2753 0046 09        		.byte	9
 2754 0047 0A        		.byte	10
 2755 0048 0B        		.byte	11
 2756 0049 0C        		.byte	12
 2757 004a 0D        		.byte	13
 2758 004b 0E        		.byte	14
 2759 004c 0F        		.byte	15
 2760 004d 10        		.byte	16
 2761 004e 11        		.byte	17
 2762 004f 12        		.byte	18
 2763 0050 13        		.byte	19
 2764 0051 14        		.byte	20
 2765 0052 15        		.byte	21
 2766 0053 16        		.byte	22
 2767 0054 17        		.byte	23
 2768 0055 18        		.byte	24
 2769 0056 19        		.byte	25
 2770 0057 1A        		.byte	26
 2771 0058 1B        		.byte	27
 2772 0059 1C        		.byte	28
 2773 005a 1D        		.byte	29
 2774 005b 2F        		.byte	47
 2775 005c 31        		.byte	49
 2776 005d 30        		.byte	48
 2777 005e 23        		.byte	35
 2778 005f 2D        		.byte	45
 2779 0060 35        		.byte	53
 2780 0061 04        		.byte	4
 2781 0062 05        		.byte	5
 2782 0063 06        		.byte	6
 2783 0064 07        		.byte	7
 2784 0065 08        		.byte	8
 2785 0066 09        		.byte	9
 2786 0067 0A        		.byte	10
 2787 0068 0B        		.byte	11
 2788 0069 0C        		.byte	12
 2789 006a 0D        		.byte	13
 2790 006b 0E        		.byte	14
 2791 006c 0F        		.byte	15
 2792 006d 10        		.byte	16
 2793 006e 11        		.byte	17
 2794 006f 12        		.byte	18
 2795 0070 13        		.byte	19
 2796 0071 14        		.byte	20
 2797 0072 15        		.byte	21
 2798 0073 16        		.byte	22
 2799 0074 17        		.byte	23
 2800 0075 18        		.byte	24
 2801 0076 19        		.byte	25
 2802 0077 1A        		.byte	26
 2803 0078 1B        		.byte	27
 2804 0079 1C        		.byte	28
 2805 007a 1D        		.byte	29
 2806 007b 2F        		.byte	47
 2807 007c 31        		.byte	49
 2808 007d 30        		.byte	48
 2809 007e 35        		.byte	53
 2810 007f 4C        		.byte	76
 2811               		.weak	ascii_to_shift_lut
 2812               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2815               	ascii_to_shift_lut:
 2816 0000 00        		.byte	0
 2817 0001 00        		.byte	0
 2818 0002 00        		.byte	0
 2819 0003 00        		.byte	0
 2820 0004 00        		.byte	0
 2821 0005 00        		.byte	0
 2822 0006 00        		.byte	0
 2823 0007 00        		.byte	0
 2824 0008 00        		.byte	0
 2825 0009 00        		.byte	0
 2826 000a 00        		.byte	0
 2827 000b 00        		.byte	0
 2828 000c 00        		.byte	0
 2829 000d 00        		.byte	0
 2830 000e 00        		.byte	0
 2831 000f 00        		.byte	0
 2832 0010 00        		.byte	0
 2833 0011 00        		.byte	0
 2834 0012 00        		.byte	0
 2835 0013 00        		.byte	0
 2836 0014 00        		.byte	0
 2837 0015 00        		.byte	0
 2838 0016 00        		.byte	0
 2839 0017 00        		.byte	0
 2840 0018 00        		.byte	0
 2841 0019 00        		.byte	0
 2842 001a 00        		.byte	0
 2843 001b 00        		.byte	0
 2844 001c 00        		.byte	0
 2845 001d 00        		.byte	0
 2846 001e 00        		.byte	0
 2847 001f 00        		.byte	0
 2848 0020 00        		.byte	0
 2849 0021 01        		.byte	1
 2850 0022 01        		.byte	1
 2851 0023 01        		.byte	1
 2852 0024 01        		.byte	1
 2853 0025 01        		.byte	1
 2854 0026 01        		.byte	1
 2855 0027 00        		.byte	0
 2856 0028 01        		.byte	1
 2857 0029 01        		.byte	1
 2858 002a 01        		.byte	1
 2859 002b 01        		.byte	1
 2860 002c 00        		.byte	0
 2861 002d 00        		.byte	0
 2862 002e 00        		.byte	0
 2863 002f 00        		.byte	0
 2864 0030 00        		.byte	0
 2865 0031 00        		.byte	0
 2866 0032 00        		.byte	0
 2867 0033 00        		.byte	0
 2868 0034 00        		.byte	0
 2869 0035 00        		.byte	0
 2870 0036 00        		.byte	0
 2871 0037 00        		.byte	0
 2872 0038 00        		.byte	0
 2873 0039 00        		.byte	0
 2874 003a 01        		.byte	1
 2875 003b 00        		.byte	0
 2876 003c 01        		.byte	1
 2877 003d 00        		.byte	0
 2878 003e 01        		.byte	1
 2879 003f 01        		.byte	1
 2880 0040 01        		.byte	1
 2881 0041 01        		.byte	1
 2882 0042 01        		.byte	1
 2883 0043 01        		.byte	1
 2884 0044 01        		.byte	1
 2885 0045 01        		.byte	1
 2886 0046 01        		.byte	1
 2887 0047 01        		.byte	1
 2888 0048 01        		.byte	1
 2889 0049 01        		.byte	1
 2890 004a 01        		.byte	1
 2891 004b 01        		.byte	1
 2892 004c 01        		.byte	1
 2893 004d 01        		.byte	1
 2894 004e 01        		.byte	1
 2895 004f 01        		.byte	1
 2896 0050 01        		.byte	1
 2897 0051 01        		.byte	1
 2898 0052 01        		.byte	1
 2899 0053 01        		.byte	1
 2900 0054 01        		.byte	1
 2901 0055 01        		.byte	1
 2902 0056 01        		.byte	1
 2903 0057 01        		.byte	1
 2904 0058 01        		.byte	1
 2905 0059 01        		.byte	1
 2906 005a 01        		.byte	1
 2907 005b 00        		.byte	0
 2908 005c 00        		.byte	0
 2909 005d 00        		.byte	0
 2910 005e 01        		.byte	1
 2911 005f 01        		.byte	1
 2912 0060 00        		.byte	0
 2913 0061 00        		.byte	0
 2914 0062 00        		.byte	0
 2915 0063 00        		.byte	0
 2916 0064 00        		.byte	0
 2917 0065 00        		.byte	0
 2918 0066 00        		.byte	0
 2919 0067 00        		.byte	0
 2920 0068 00        		.byte	0
 2921 0069 00        		.byte	0
 2922 006a 00        		.byte	0
 2923 006b 00        		.byte	0
 2924 006c 00        		.byte	0
 2925 006d 00        		.byte	0
 2926 006e 00        		.byte	0
 2927 006f 00        		.byte	0
 2928 0070 00        		.byte	0
 2929 0071 00        		.byte	0
 2930 0072 00        		.byte	0
 2931 0073 00        		.byte	0
 2932 0074 00        		.byte	0
 2933 0075 00        		.byte	0
 2934 0076 00        		.byte	0
 2935 0077 00        		.byte	0
 2936 0078 00        		.byte	0
 2937 0079 00        		.byte	0
 2938 007a 00        		.byte	0
 2939 007b 01        		.byte	1
 2940 007c 01        		.byte	1
 2941 007d 01        		.byte	1
 2942 007e 01        		.byte	1
 2943 007f 00        		.byte	0
 2944               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2947               	grave_esc_was_shifted:
 2948 0000 00        		.zero	1
 2949               		.section	.bss.scs_timer,"aw",@nobits
 2952               	scs_timer:
 2953 0000 0000 0000 		.zero	4
 2954               		.section	.bss.shift_interrupted,"aw",@nobits
 2957               	shift_interrupted:
 2958 0000 0000      		.zero	2
 2959               		.text
 2960               	.Letext0:
 2961               		.file 4 "/usr/lib/avr/include/stdint.h"
 2962               		.file 5 "./tmk_core/common/keyboard.h"
 2963               		.file 6 "./tmk_core/common/action.h"
 2964               		.file 7 "./tmk_core/common/report.h"
 2965               		.file 8 "./tmk_core/common/debug.h"
 2966               		.file 9 "quantum/keycode_config.h"
 2967               		.file 10 "./tmk_core/common/keycode.h"
 2968               		.file 11 "quantum/quantum_keycodes.h"
 2969               		.file 12 "./tmk_core/protocol/lufa/outputselect.h"
 2970               		.file 13 "quantum/quantum.h"
 2971               		.file 14 "./tmk_core/common/bootloader.h"
 2972               		.file 15 "quantum/rgblight.h"
 2973               		.file 16 "./tmk_core/common/action_layer.h"
 2974               		.file 17 "quantum/keymap.h"
 2975               		.file 18 "./quantum/process_keycode/process_tap_dance.h"
 2976               		.file 19 "./quantum/process_keycode/process_leader.h"
 2977               		.file 20 "./tmk_core/common/eeconfig.h"
 2978               		.file 21 "./tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/ccnonnqB.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccnonnqB.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccnonnqB.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccnonnqB.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccnonnqB.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccnonnqB.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/ccnonnqB.s:130    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
     /tmp/ccnonnqB.s:160    .text.qk_register_mods:0000000000000000 qk_register_mods
     /tmp/ccnonnqB.s:190    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
     /tmp/ccnonnqB.s:220    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
     /tmp/ccnonnqB.s:251    .text.register_code16:0000000000000000 register_code16
     /tmp/ccnonnqB.s:307    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/ccnonnqB.s:362    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/ccnonnqB.s:381    .text.process_record_user:0000000000000000 process_record_user
     /tmp/ccnonnqB.s:400    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/ccnonnqB.s:418    .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/ccnonnqB.s:458    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccnonnqB.s:2957   .bss.shift_interrupted:0000000000000000 shift_interrupted
     /tmp/ccnonnqB.s:2947   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted
     /tmp/ccnonnqB.s:2952   .bss.scs_timer:0000000000000000 scs_timer
     /tmp/ccnonnqB.s:1431   .text.send_char:0000000000000000 send_char
     /tmp/ccnonnqB.s:2682   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
     /tmp/ccnonnqB.s:2815   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
     /tmp/ccnonnqB.s:1517   .text.send_string_with_delay:0000000000000000 send_string_with_delay
     /tmp/ccnonnqB.s:1661   .text.send_string:0000000000000000 send_string
     /tmp/ccnonnqB.s:1680   .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
     /tmp/ccnonnqB.s:1856   .text.send_string_P:0000000000000000 send_string_P
     /tmp/ccnonnqB.s:1875   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/ccnonnqB.s:1923   .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
     /tmp/ccnonnqB.s:2108   .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/ccnonnqB.s:2147   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/ccnonnqB.s:2269   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccnonnqB.s:2286   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccnonnqB.s:2306   .text.backlight_init_ports:0000000000000000 backlight_init_ports
     /tmp/ccnonnqB.s:2321   .text.backlight_set:0000000000000000 backlight_set
     /tmp/ccnonnqB.s:2337   .text.send_nibble:0000000000000000 send_nibble
     /tmp/ccnonnqB.s:2402   .text.send_byte:0000000000000000 send_byte
     /tmp/ccnonnqB.s:2439   .text.send_word:0000000000000000 send_word
     /tmp/ccnonnqB.s:2473   .text.send_dword:0000000000000000 send_dword
     /tmp/ccnonnqB.s:2523   .text.hex_to_keycode:0000000000000000 hex_to_keycode
     /tmp/ccnonnqB.s:2562   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/ccnonnqB.s:2578   .text.led_set_user:0000000000000000 led_set_user
     /tmp/ccnonnqB.s:2594   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/ccnonnqB.s:2612   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/ccnonnqB.s:2627   .text.led_set:0000000000000000 led_set
     /tmp/ccnonnqB.s:2645   .text.startup_user:0000000000000000 startup_user
     /tmp/ccnonnqB.s:2660   .text.shutdown_user:0000000000000000 shutdown_user
     /tmp/ccnonnqB.s:2676   .bss.rgb_matrix_task_counter:0000000000000000 rgb_matrix_task_counter

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
clear_keyboard
bootloader_jump
layer_switch_get_layer
keymap_key_to_keycode
preprocess_tap_dance
process_tap_dance
process_leader
rgblight_increase_speed
get_mods
rgblight_step_reverse
rgblight_step
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
debug_config
keyboard_report
add_key_to_report
del_key_from_report
rgblight_toggle
rgblight_increase_sat
rgblight_increase_hue
rgblight_decrease_hue
rgblight_increase_val
rgblight_decrease_sat
rgblight_decrease_val
rgblight_get_mode
rgblight_mode
rgblight_decrease_speed
timer_read
register_mods
timer_elapsed
unregister_mods
set_output
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_init_kb
matrix_scan_tap_dance
matrix_scan_kb
__do_clear_bss
