   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB24:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  19:quantum/quantum.c **** #include "outputselect.h"
  20:quantum/quantum.c **** #endif
  21:quantum/quantum.c **** 
  22:quantum/quantum.c **** #ifndef TAPPING_TERM
  23:quantum/quantum.c **** #define TAPPING_TERM 200
  24:quantum/quantum.c **** #endif
  25:quantum/quantum.c **** 
  26:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  27:quantum/quantum.c **** #define BREATHING_PERIOD 6
  28:quantum/quantum.c **** #endif
  29:quantum/quantum.c **** 
  30:quantum/quantum.c **** #include "backlight.h"
  31:quantum/quantum.c **** extern backlight_config_t backlight_config;
  32:quantum/quantum.c **** 
  33:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  34:quantum/quantum.c **** #include "fauxclicky.h"
  35:quantum/quantum.c **** #endif
  36:quantum/quantum.c **** 
  37:quantum/quantum.c **** #ifdef API_ENABLE
  38:quantum/quantum.c **** #include "api.h"
  39:quantum/quantum.c **** #endif
  40:quantum/quantum.c **** 
  41:quantum/quantum.c **** #ifdef MIDI_ENABLE
  42:quantum/quantum.c **** #include "process_midi.h"
  43:quantum/quantum.c **** #endif
  44:quantum/quantum.c **** 
  45:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  46:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  47:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  48:quantum/quantum.c ****   #endif
  49:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  50:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  51:quantum/quantum.c ****   #endif
  52:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  53:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  54:quantum/quantum.c ****   #endif
  55:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  56:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  57:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  58:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  59:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  60:quantum/quantum.c ****   #endif
  61:quantum/quantum.c **** #endif
  62:quantum/quantum.c **** 
  63:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 63 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  38 0008 8C01      		movw r16,r24
  39 000a EB01      		movw r28,r22
  64:quantum/quantum.c ****   switch (code) {
  40               		.loc 1 64 0
  41 000c 9A95      		dec r25
  42               	.LVL1:
  43 000e 8115      		cp r24,__zero_reg__
  44 0010 9F41      		sbci r25,31
  45 0012 00F4      		brsh .L1
  65:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  66:quantum/quantum.c ****     break;
  67:quantum/quantum.c ****   default:
  68:quantum/quantum.c ****     return;
  69:quantum/quantum.c ****   }
  70:quantum/quantum.c **** 
  71:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 71 0
  47 0014 10FF      		sbrs r17,0
  48 0016 00C0      		rjmp .L4
  72:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 72 0
  50 0018 80EE      		ldi r24,lo8(-32)
  51 001a FB01      		movw r30,r22
  52 001c 0995      		icall
  53               	.LVL2:
  54               	.L4:
  73:quantum/quantum.c ****   if (code & QK_LSFT)
  55               		.loc 1 73 0
  56 001e 11FF      		sbrs r17,1
  57 0020 00C0      		rjmp .L5
  74:quantum/quantum.c ****     f(KC_LSFT);
  58               		.loc 1 74 0
  59 0022 81EE      		ldi r24,lo8(-31)
  60 0024 FE01      		movw r30,r28
  61 0026 0995      		icall
  62               	.LVL3:
  63               	.L5:
  75:quantum/quantum.c ****   if (code & QK_LALT)
  64               		.loc 1 75 0
  65 0028 12FF      		sbrs r17,2
  66 002a 00C0      		rjmp .L6
  76:quantum/quantum.c ****     f(KC_LALT);
  67               		.loc 1 76 0
  68 002c 82EE      		ldi r24,lo8(-30)
  69 002e FE01      		movw r30,r28
  70 0030 0995      		icall
  71               	.LVL4:
  72               	.L6:
  77:quantum/quantum.c ****   if (code & QK_LGUI)
  73               		.loc 1 77 0
  74 0032 13FF      		sbrs r17,3
  75 0034 00C0      		rjmp .L7
  78:quantum/quantum.c ****     f(KC_LGUI);
  76               		.loc 1 78 0
  77 0036 83EE      		ldi r24,lo8(-29)
  78 0038 FE01      		movw r30,r28
  79 003a 0995      		icall
  80               	.LVL5:
  81               	.L7:
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  82               		.loc 1 80 0
  83 003c 0115      		cp r16,__zero_reg__
  84 003e 1041      		sbci r17,16
  85 0040 00F0      		brlo .L1
  81:quantum/quantum.c **** 
  82:quantum/quantum.c ****   if (code & QK_RCTL)
  83:quantum/quantum.c ****     f(KC_RCTL);
  86               		.loc 1 83 0
  87 0042 84EE      		ldi r24,lo8(-28)
  88 0044 FE01      		movw r30,r28
  89 0046 0995      		icall
  90               	.LVL6:
  84:quantum/quantum.c ****   if (code & QK_RSFT)
  85:quantum/quantum.c ****     f(KC_RSFT);
  91               		.loc 1 85 0
  92 0048 85EE      		ldi r24,lo8(-27)
  93 004a FE01      		movw r30,r28
  94 004c 0995      		icall
  95               	.LVL7:
  86:quantum/quantum.c ****   if (code & QK_RALT)
  87:quantum/quantum.c ****     f(KC_RALT);
  96               		.loc 1 87 0
  97 004e 86EE      		ldi r24,lo8(-26)
  98 0050 FE01      		movw r30,r28
  99 0052 0995      		icall
 100               	.LVL8:
  88:quantum/quantum.c ****   if (code & QK_RGUI)
  89:quantum/quantum.c ****     f(KC_RGUI);
 101               		.loc 1 89 0
 102 0054 87EE      		ldi r24,lo8(-25)
 103 0056 FE01      		movw r30,r28
 104               	/* epilogue start */
  90:quantum/quantum.c **** }
 105               		.loc 1 90 0
 106 0058 DF91      		pop r29
 107 005a CF91      		pop r28
 108               	.LVL9:
 109 005c 1F91      		pop r17
 110 005e 0F91      		pop r16
 111               	.LVL10:
  89:quantum/quantum.c ****     f(KC_RGUI);
 112               		.loc 1 89 0
 113 0060 0994      		ijmp
 114               	.LVL11:
 115               	.L1:
 116               	/* epilogue start */
 117               		.loc 1 90 0
 118 0062 DF91      		pop r29
 119 0064 CF91      		pop r28
 120               	.LVL12:
 121 0066 1F91      		pop r17
 122 0068 0F91      		pop r16
 123               	.LVL13:
 124 006a 0895      		ret
 125               		.cfi_endproc
 126               	.LFE24:
 128               		.section	.text.qk_register_weak_mods,"ax",@progbits
 130               	qk_register_weak_mods:
 131               	.LFB25:
  91:quantum/quantum.c **** 
  92:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 132               		.loc 1 92 0
 133               		.cfi_startproc
 134               	.LVL14:
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  93:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 139               		.loc 1 93 0
 140 0000 8770      		andi r24,lo8(7)
 141               	.LVL15:
 142 0002 91E0      		ldi r25,lo8(1)
 143 0004 00C0      		rjmp 2f
 144               		1:
 145 0006 990F      		lsl r25
 146               		2:
 147 0008 8A95      		dec r24
 148 000a 02F4      		brpl 1b
 149 000c 892F      		mov r24,r25
 150 000e 0E94 0000 		call add_weak_mods
 151               	.LVL16:
  94:quantum/quantum.c ****     send_keyboard_report();
 152               		.loc 1 94 0
 153 0012 0C94 0000 		jmp send_keyboard_report
 154               	.LVL17:
 155               		.cfi_endproc
 156               	.LFE25:
 158               		.section	.text.qk_register_mods,"ax",@progbits
 160               	qk_register_mods:
 161               	.LFB27:
  95:quantum/quantum.c **** }
  96:quantum/quantum.c **** 
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
  99:quantum/quantum.c ****     send_keyboard_report();
 100:quantum/quantum.c **** }
 101:quantum/quantum.c **** 
 102:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 162               		.loc 1 102 0
 163               		.cfi_startproc
 164               	.LVL18:
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 103:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 169               		.loc 1 103 0
 170 0000 8770      		andi r24,lo8(7)
 171               	.LVL19:
 172 0002 91E0      		ldi r25,lo8(1)
 173 0004 00C0      		rjmp 2f
 174               		1:
 175 0006 990F      		lsl r25
 176               		2:
 177 0008 8A95      		dec r24
 178 000a 02F4      		brpl 1b
 179 000c 892F      		mov r24,r25
 180 000e 0E94 0000 		call add_weak_mods
 181               	.LVL20:
 104:quantum/quantum.c ****     send_keyboard_report();
 182               		.loc 1 104 0
 183 0012 0C94 0000 		jmp send_keyboard_report
 184               	.LVL21:
 185               		.cfi_endproc
 186               	.LFE27:
 188               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 190               	qk_unregister_weak_mods:
 191               	.LFB26:
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
 192               		.loc 1 97 0
 193               		.cfi_startproc
 194               	.LVL22:
 195               	/* prologue: function */
 196               	/* frame size = 0 */
 197               	/* stack size = 0 */
 198               	.L__stack_usage = 0
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 199               		.loc 1 98 0
 200 0000 8770      		andi r24,lo8(7)
 201               	.LVL23:
 202 0002 91E0      		ldi r25,lo8(1)
 203 0004 00C0      		rjmp 2f
 204               		1:
 205 0006 990F      		lsl r25
 206               		2:
 207 0008 8A95      		dec r24
 208 000a 02F4      		brpl 1b
 209 000c 892F      		mov r24,r25
 210 000e 0E94 0000 		call del_weak_mods
 211               	.LVL24:
  99:quantum/quantum.c ****     send_keyboard_report();
 212               		.loc 1 99 0
 213 0012 0C94 0000 		jmp send_keyboard_report
 214               	.LVL25:
 215               		.cfi_endproc
 216               	.LFE26:
 218               		.section	.text.qk_unregister_mods,"ax",@progbits
 220               	qk_unregister_mods:
 221               	.LFB28:
 105:quantum/quantum.c **** }
 106:quantum/quantum.c **** 
 107:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 222               		.loc 1 107 0
 223               		.cfi_startproc
 224               	.LVL26:
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 227               	/* stack size = 0 */
 228               	.L__stack_usage = 0
 108:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 229               		.loc 1 108 0
 230 0000 8770      		andi r24,lo8(7)
 231               	.LVL27:
 232 0002 91E0      		ldi r25,lo8(1)
 233 0004 00C0      		rjmp 2f
 234               		1:
 235 0006 990F      		lsl r25
 236               		2:
 237 0008 8A95      		dec r24
 238 000a 02F4      		brpl 1b
 239 000c 892F      		mov r24,r25
 240 000e 0E94 0000 		call del_weak_mods
 241               	.LVL28:
 109:quantum/quantum.c ****     send_keyboard_report();
 242               		.loc 1 109 0
 243 0012 0C94 0000 		jmp send_keyboard_report
 244               	.LVL29:
 245               		.cfi_endproc
 246               	.LFE28:
 248               		.section	.text.rgblight_toggle,"ax",@progbits
 249               		.weak	rgblight_toggle
 251               	rgblight_toggle:
 252               	.LFB10:
 253               		.file 2 "quantum/rgb.h"
   1:quantum/rgb.h **** /* Copyright 2017 Jack Humbert
   2:quantum/rgb.h ****  *
   3:quantum/rgb.h ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/rgb.h ****  * it under the terms of the GNU General Public License as published by
   5:quantum/rgb.h ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/rgb.h ****  * (at your option) any later version.
   7:quantum/rgb.h ****  *
   8:quantum/rgb.h ****  * This program is distributed in the hope that it will be useful,
   9:quantum/rgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/rgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/rgb.h ****  * GNU General Public License for more details.
  12:quantum/rgb.h ****  *
  13:quantum/rgb.h ****  * You should have received a copy of the GNU General Public License
  14:quantum/rgb.h ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/rgb.h ****  */
  16:quantum/rgb.h **** 
  17:quantum/rgb.h **** #ifndef RGB_H
  18:quantum/rgb.h **** #define RGB_H
  19:quantum/rgb.h **** 
  20:quantum/rgb.h **** __attribute__((weak))
  21:quantum/rgb.h **** void rgblight_toggle(void) {};
 254               		.loc 2 21 0
 255               		.cfi_startproc
 256               	/* prologue: function */
 257               	/* frame size = 0 */
 258               	/* stack size = 0 */
 259               	.L__stack_usage = 0
 260 0000 0895      		ret
 261               		.cfi_endproc
 262               	.LFE10:
 264               		.section	.text.rgblight_step,"ax",@progbits
 265               		.weak	rgblight_step
 267               	rgblight_step:
 268               	.LFB11:
  22:quantum/rgb.h **** 
  23:quantum/rgb.h **** __attribute__((weak))
  24:quantum/rgb.h **** void rgblight_step(void) {};
 269               		.loc 2 24 0
 270               		.cfi_startproc
 271               	/* prologue: function */
 272               	/* frame size = 0 */
 273               	/* stack size = 0 */
 274               	.L__stack_usage = 0
 275 0000 0895      		ret
 276               		.cfi_endproc
 277               	.LFE11:
 279               		.section	.text.rgblight_step_reverse,"ax",@progbits
 280               		.weak	rgblight_step_reverse
 282               	rgblight_step_reverse:
 283               	.LFB12:
  25:quantum/rgb.h **** 
  26:quantum/rgb.h **** __attribute__((weak))
  27:quantum/rgb.h **** void rgblight_step_reverse(void) {};
 284               		.loc 2 27 0
 285               		.cfi_startproc
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 288               	/* stack size = 0 */
 289               	.L__stack_usage = 0
 290 0000 0895      		ret
 291               		.cfi_endproc
 292               	.LFE12:
 294               		.section	.text.rgblight_increase_hue,"ax",@progbits
 295               		.weak	rgblight_increase_hue
 297               	rgblight_increase_hue:
 298               	.LFB13:
  28:quantum/rgb.h **** 
  29:quantum/rgb.h **** __attribute__((weak))
  30:quantum/rgb.h **** void rgblight_increase_hue(void) {};
 299               		.loc 2 30 0
 300               		.cfi_startproc
 301               	/* prologue: function */
 302               	/* frame size = 0 */
 303               	/* stack size = 0 */
 304               	.L__stack_usage = 0
 305 0000 0895      		ret
 306               		.cfi_endproc
 307               	.LFE13:
 309               		.section	.text.rgblight_decrease_hue,"ax",@progbits
 310               		.weak	rgblight_decrease_hue
 312               	rgblight_decrease_hue:
 313               	.LFB14:
  31:quantum/rgb.h **** 
  32:quantum/rgb.h **** __attribute__((weak))
  33:quantum/rgb.h **** void rgblight_decrease_hue(void) {};
 314               		.loc 2 33 0
 315               		.cfi_startproc
 316               	/* prologue: function */
 317               	/* frame size = 0 */
 318               	/* stack size = 0 */
 319               	.L__stack_usage = 0
 320 0000 0895      		ret
 321               		.cfi_endproc
 322               	.LFE14:
 324               		.section	.text.rgblight_increase_sat,"ax",@progbits
 325               		.weak	rgblight_increase_sat
 327               	rgblight_increase_sat:
 328               	.LFB15:
  34:quantum/rgb.h **** 
  35:quantum/rgb.h **** __attribute__((weak))
  36:quantum/rgb.h **** void rgblight_increase_sat(void) {};
 329               		.loc 2 36 0
 330               		.cfi_startproc
 331               	/* prologue: function */
 332               	/* frame size = 0 */
 333               	/* stack size = 0 */
 334               	.L__stack_usage = 0
 335 0000 0895      		ret
 336               		.cfi_endproc
 337               	.LFE15:
 339               		.section	.text.rgblight_decrease_sat,"ax",@progbits
 340               		.weak	rgblight_decrease_sat
 342               	rgblight_decrease_sat:
 343               	.LFB16:
  37:quantum/rgb.h **** 
  38:quantum/rgb.h **** __attribute__((weak))
  39:quantum/rgb.h **** void rgblight_decrease_sat(void) {};
 344               		.loc 2 39 0
 345               		.cfi_startproc
 346               	/* prologue: function */
 347               	/* frame size = 0 */
 348               	/* stack size = 0 */
 349               	.L__stack_usage = 0
 350 0000 0895      		ret
 351               		.cfi_endproc
 352               	.LFE16:
 354               		.section	.text.rgblight_increase_val,"ax",@progbits
 355               		.weak	rgblight_increase_val
 357               	rgblight_increase_val:
 358               	.LFB17:
  40:quantum/rgb.h **** 
  41:quantum/rgb.h **** __attribute__((weak))
  42:quantum/rgb.h **** void rgblight_increase_val(void) {};
 359               		.loc 2 42 0
 360               		.cfi_startproc
 361               	/* prologue: function */
 362               	/* frame size = 0 */
 363               	/* stack size = 0 */
 364               	.L__stack_usage = 0
 365 0000 0895      		ret
 366               		.cfi_endproc
 367               	.LFE17:
 369               		.section	.text.rgblight_decrease_val,"ax",@progbits
 370               		.weak	rgblight_decrease_val
 372               	rgblight_decrease_val:
 373               	.LFB18:
  43:quantum/rgb.h **** 
  44:quantum/rgb.h **** __attribute__((weak))
  45:quantum/rgb.h **** void rgblight_decrease_val(void) {};
 374               		.loc 2 45 0
 375               		.cfi_startproc
 376               	/* prologue: function */
 377               	/* frame size = 0 */
 378               	/* stack size = 0 */
 379               	.L__stack_usage = 0
 380 0000 0895      		ret
 381               		.cfi_endproc
 382               	.LFE18:
 384               		.section	.text.rgblight_increase_speed,"ax",@progbits
 385               		.weak	rgblight_increase_speed
 387               	rgblight_increase_speed:
 388               	.LFB19:
  46:quantum/rgb.h **** 
  47:quantum/rgb.h **** __attribute__((weak))
  48:quantum/rgb.h **** void rgblight_increase_speed(void) {};
 389               		.loc 2 48 0
 390               		.cfi_startproc
 391               	/* prologue: function */
 392               	/* frame size = 0 */
 393               	/* stack size = 0 */
 394               	.L__stack_usage = 0
 395 0000 0895      		ret
 396               		.cfi_endproc
 397               	.LFE19:
 399               		.section	.text.rgblight_decrease_speed,"ax",@progbits
 400               		.weak	rgblight_decrease_speed
 402               	rgblight_decrease_speed:
 403               	.LFB20:
  49:quantum/rgb.h **** 
  50:quantum/rgb.h **** __attribute__((weak))
  51:quantum/rgb.h **** void rgblight_decrease_speed(void) {};
 404               		.loc 2 51 0
 405               		.cfi_startproc
 406               	/* prologue: function */
 407               	/* frame size = 0 */
 408               	/* stack size = 0 */
 409               	.L__stack_usage = 0
 410 0000 0895      		ret
 411               		.cfi_endproc
 412               	.LFE20:
 414               		.section	.text.register_code16,"ax",@progbits
 415               	.global	register_code16
 417               	register_code16:
 418               	.LFB29:
 110:quantum/quantum.c **** }
 111:quantum/quantum.c **** 
 112:quantum/quantum.c **** void register_code16 (uint16_t code) {
 419               		.loc 1 112 0
 420               		.cfi_startproc
 421               	.LVL30:
 422               		.loc 1 112 0
 423 0000 CF93      		push r28
 424               	.LCFI4:
 425               		.cfi_def_cfa_offset 3
 426               		.cfi_offset 28, -2
 427 0002 DF93      		push r29
 428               	.LCFI5:
 429               		.cfi_def_cfa_offset 4
 430               		.cfi_offset 29, -3
 431               	/* prologue: function */
 432               	/* frame size = 0 */
 433               	/* stack size = 2 */
 434               	.L__stack_usage = 2
 435 0004 EC01      		movw r28,r24
 113:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 436               		.loc 1 113 0
 437 0006 805E      		subi r24,-32
 438 0008 9109      		sbc r25,__zero_reg__
 439               	.LVL31:
 440 000a 0897      		sbiw r24,8
 441 000c 00F0      		brlo .L37
 442               		.loc 1 113 0 is_stmt 0 discriminator 1
 443 000e 2097      		sbiw r28,0
 444 0010 01F4      		brne .L38
 445               	.L37:
 114:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 446               		.loc 1 114 0 is_stmt 1
 447 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 448 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 449 0016 00C0      		rjmp .L40
 450               	.L38:
 115:quantum/quantum.c ****   } else {
 116:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 451               		.loc 1 116 0
 452 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 453 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 454               	.L40:
 455 001c CE01      		movw r24,r28
 456 001e 0E94 0000 		call do_code16
 457               	.LVL32:
 117:quantum/quantum.c ****   }
 118:quantum/quantum.c ****   register_code (code);
 458               		.loc 1 118 0
 459 0022 8C2F      		mov r24,r28
 460               	/* epilogue start */
 119:quantum/quantum.c **** }
 461               		.loc 1 119 0
 462 0024 DF91      		pop r29
 463 0026 CF91      		pop r28
 464               	.LVL33:
 118:quantum/quantum.c ****   register_code (code);
 465               		.loc 1 118 0
 466 0028 0C94 0000 		jmp register_code
 467               	.LVL34:
 468               		.cfi_endproc
 469               	.LFE29:
 471               		.section	.text.unregister_code16,"ax",@progbits
 472               	.global	unregister_code16
 474               	unregister_code16:
 475               	.LFB30:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 476               		.loc 1 121 0
 477               		.cfi_startproc
 478               	.LVL35:
 479 0000 CF93      		push r28
 480               	.LCFI6:
 481               		.cfi_def_cfa_offset 3
 482               		.cfi_offset 28, -2
 483 0002 DF93      		push r29
 484               	.LCFI7:
 485               		.cfi_def_cfa_offset 4
 486               		.cfi_offset 29, -3
 487               	/* prologue: function */
 488               	/* frame size = 0 */
 489               	/* stack size = 2 */
 490               	.L__stack_usage = 2
 491 0004 EC01      		movw r28,r24
 122:quantum/quantum.c ****   unregister_code (code);
 492               		.loc 1 122 0
 493 0006 0E94 0000 		call unregister_code
 494               	.LVL36:
 123:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 495               		.loc 1 123 0
 496 000a CE01      		movw r24,r28
 497 000c 805E      		subi r24,-32
 498 000e 9109      		sbc r25,__zero_reg__
 499 0010 0897      		sbiw r24,8
 500 0012 00F0      		brlo .L42
 501               		.loc 1 123 0 is_stmt 0 discriminator 1
 502 0014 2097      		sbiw r28,0
 503 0016 01F4      		brne .L43
 504               	.L42:
 124:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 505               		.loc 1 124 0 is_stmt 1
 506 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 507 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 508 001c 00C0      		rjmp .L44
 509               	.L43:
 125:quantum/quantum.c ****   } else {
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 510               		.loc 1 126 0
 511 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 512 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 513               	.L44:
 514 0022 CE01      		movw r24,r28
 515               	/* epilogue start */
 127:quantum/quantum.c ****   }
 128:quantum/quantum.c **** }
 516               		.loc 1 128 0
 517 0024 DF91      		pop r29
 518 0026 CF91      		pop r28
 519               	.LVL37:
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 520               		.loc 1 126 0
 521 0028 0C94 0000 		jmp do_code16
 522               	.LVL38:
 523               		.cfi_endproc
 524               	.LFE30:
 526               		.section	.text.process_action_kb,"ax",@progbits
 527               		.weak	process_action_kb
 529               	process_action_kb:
 530               	.LFB31:
 129:quantum/quantum.c **** 
 130:quantum/quantum.c **** __attribute__ ((weak))
 131:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 531               		.loc 1 131 0
 532               		.cfi_startproc
 533               	.LVL39:
 534               	/* prologue: function */
 535               	/* frame size = 0 */
 536               	/* stack size = 0 */
 537               	.L__stack_usage = 0
 132:quantum/quantum.c ****   return true;
 133:quantum/quantum.c **** }
 538               		.loc 1 133 0
 539 0000 81E0      		ldi r24,lo8(1)
 540               	.LVL40:
 541 0002 0895      		ret
 542               		.cfi_endproc
 543               	.LFE31:
 545               		.section	.text.process_record_user,"ax",@progbits
 546               		.weak	process_record_user
 548               	process_record_user:
 549               	.LFB33:
 134:quantum/quantum.c **** 
 135:quantum/quantum.c **** __attribute__ ((weak))
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 138:quantum/quantum.c **** }
 139:quantum/quantum.c **** 
 140:quantum/quantum.c **** __attribute__ ((weak))
 141:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 550               		.loc 1 141 0
 551               		.cfi_startproc
 552               	.LVL41:
 553               	/* prologue: function */
 554               	/* frame size = 0 */
 555               	/* stack size = 0 */
 556               	.L__stack_usage = 0
 142:quantum/quantum.c ****   return true;
 143:quantum/quantum.c **** }
 557               		.loc 1 143 0
 558 0000 81E0      		ldi r24,lo8(1)
 559               	.LVL42:
 560 0002 0895      		ret
 561               		.cfi_endproc
 562               	.LFE33:
 564               		.section	.text.process_record_kb,"ax",@progbits
 565               		.weak	process_record_kb
 567               	process_record_kb:
 568               	.LFB32:
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 569               		.loc 1 136 0
 570               		.cfi_startproc
 571               	.LVL43:
 572               	/* prologue: function */
 573               	/* frame size = 0 */
 574               	/* stack size = 0 */
 575               	.L__stack_usage = 0
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 576               		.loc 1 137 0
 577 0000 0C94 0000 		jmp process_record_user
 578               	.LVL44:
 579               		.cfi_endproc
 580               	.LFE32:
 582               		.section	.text.reset_keyboard,"ax",@progbits
 583               	.global	reset_keyboard
 585               	reset_keyboard:
 586               	.LFB34:
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** void reset_keyboard(void) {
 587               		.loc 1 145 0
 588               		.cfi_startproc
 589               	/* prologue: function */
 590               	/* frame size = 0 */
 591               	/* stack size = 0 */
 592               	.L__stack_usage = 0
 146:quantum/quantum.c ****   clear_keyboard();
 593               		.loc 1 146 0
 594 0000 0E94 0000 		call clear_keyboard
 595               	.LVL45:
 596               	.LBB27:
 597               	.LBB28:
 598               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 599               		.loc 3 164 0
 600 0004 2FEF      		ldi r18,lo8(799999)
 601 0006 84E3      		ldi r24,hi8(799999)
 602 0008 9CE0      		ldi r25,hlo8(799999)
 603 000a 2150      		1: subi r18,1
 604 000c 8040      		sbci r24,0
 605 000e 9040      		sbci r25,0
 606 0010 01F4      		brne 1b
 607 0012 00C0      		rjmp .
 608 0014 0000      		nop
 609               	.LBE28:
 610               	.LBE27:
 147:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 148:quantum/quantum.c ****   process_midi_all_notes_off();
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 151:quantum/quantum.c ****   music_all_notes_off();
 152:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 153:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 154:quantum/quantum.c ****   shutdown_user();
 155:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 156:quantum/quantum.c ****     wait_ms(1);
 157:quantum/quantum.c ****   stop_all_notes();
 158:quantum/quantum.c **** #else
 159:quantum/quantum.c ****   wait_ms(250);
 160:quantum/quantum.c **** #endif
 161:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 162:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 163:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 611               		.loc 1 163 0
 612 0016 87E7      		ldi r24,lo8(119)
 613 0018 97E7      		ldi r25,lo8(119)
 614 001a 9093 0108 		sts 2048+1,r25
 615 001e 8093 0008 		sts 2048,r24
 164:quantum/quantum.c **** #endif
 165:quantum/quantum.c ****   bootloader_jump();
 616               		.loc 1 165 0
 617 0022 0C94 0000 		jmp bootloader_jump
 618               	.LVL46:
 619               		.cfi_endproc
 620               	.LFE34:
 622               		.section	.text.process_record_quantum,"ax",@progbits
 623               	.global	process_record_quantum
 625               	process_record_quantum:
 626               	.LFB35:
 166:quantum/quantum.c **** }
 167:quantum/quantum.c **** 
 168:quantum/quantum.c **** // Shift / paren setup
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** #ifndef LSPO_KEY
 171:quantum/quantum.c ****   #define LSPO_KEY KC_9
 172:quantum/quantum.c **** #endif
 173:quantum/quantum.c **** #ifndef RSPC_KEY
 174:quantum/quantum.c ****   #define RSPC_KEY KC_0
 175:quantum/quantum.c **** #endif
 176:quantum/quantum.c **** 
 177:quantum/quantum.c **** // Shift / Enter setup
 178:quantum/quantum.c **** #ifndef SFTENT_KEY
 179:quantum/quantum.c ****   #define SFTENT_KEY KC_ENT
 180:quantum/quantum.c **** #endif
 181:quantum/quantum.c **** 
 182:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 183:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 184:quantum/quantum.c **** 
 185:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 186:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 187:quantum/quantum.c ****  */
 188:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 627               		.loc 1 190 0
 628               		.cfi_startproc
 629               	.LVL47:
 630 0000 0F93      		push r16
 631               	.LCFI8:
 632               		.cfi_def_cfa_offset 3
 633               		.cfi_offset 16, -2
 634 0002 1F93      		push r17
 635               	.LCFI9:
 636               		.cfi_def_cfa_offset 4
 637               		.cfi_offset 17, -3
 638 0004 CF93      		push r28
 639               	.LCFI10:
 640               		.cfi_def_cfa_offset 5
 641               		.cfi_offset 28, -4
 642 0006 DF93      		push r29
 643               	.LCFI11:
 644               		.cfi_def_cfa_offset 6
 645               		.cfi_offset 29, -5
 646               	/* prologue: function */
 647               	/* frame size = 0 */
 648               	/* stack size = 4 */
 649               	.L__stack_usage = 4
 650 0008 8C01      		movw r16,r24
 191:quantum/quantum.c **** 
 192:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 193:quantum/quantum.c ****   keypos_t key = record->event.key;
 651               		.loc 1 193 0
 652 000a FC01      		movw r30,r24
 653 000c C081      		ld r28,Z
 654 000e D181      		ldd r29,Z+1
 655               	.LVL48:
 194:quantum/quantum.c ****   uint16_t keycode;
 195:quantum/quantum.c **** 
 196:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 197:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 198:quantum/quantum.c ****     if (!disable_action_cache) {
 199:quantum/quantum.c ****       uint8_t layer;
 200:quantum/quantum.c **** 
 201:quantum/quantum.c ****       if (record->event.pressed) {
 202:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 203:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 204:quantum/quantum.c ****       } else {
 205:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 206:quantum/quantum.c ****       }
 207:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 208:quantum/quantum.c ****     } else
 209:quantum/quantum.c ****   #endif
 210:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 656               		.loc 1 210 0
 657 0010 CE01      		movw r24,r28
 658               	.LVL49:
 659 0012 0E94 0000 		call layer_switch_get_layer
 660               	.LVL50:
 661 0016 BE01      		movw r22,r28
 662 0018 0E94 0000 		call keymap_key_to_keycode
 663               	.LVL51:
 664 001c EC01      		movw r28,r24
 665               	.LVL52:
 211:quantum/quantum.c **** 
 212:quantum/quantum.c ****     // This is how you use actions here
 213:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 214:quantum/quantum.c ****     //   action_t action;
 215:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 216:quantum/quantum.c ****     //   process_action(record, action);
 217:quantum/quantum.c ****     //   return false;
 218:quantum/quantum.c ****     // }
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 221:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 666               		.loc 1 221 0
 667 001e B801      		movw r22,r16
 668 0020 0E94 0000 		call preprocess_tap_dance
 669               	.LVL53:
 222:quantum/quantum.c ****   #endif
 223:quantum/quantum.c **** 
 224:quantum/quantum.c ****   if (!(
 225:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 226:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 227:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 228:quantum/quantum.c ****   #endif
 229:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 230:quantum/quantum.c ****       process_clicky(keycode, record) &&
 231:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 670               		.loc 1 232 0
 671 0024 B801      		movw r22,r16
 672 0026 CE01      		movw r24,r28
 673 0028 0E94 0000 		call process_record_kb
 674               	.LVL54:
 233:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 234:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 235:quantum/quantum.c ****   #endif
 236:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 237:quantum/quantum.c ****     process_midi(keycode, record) &&
 238:quantum/quantum.c ****   #endif
 239:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 240:quantum/quantum.c ****     process_audio(keycode, record) &&
 241:quantum/quantum.c ****   #endif
 242:quantum/quantum.c ****   #ifdef STENO_ENABLE
 243:quantum/quantum.c ****     process_steno(keycode, record) &&
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c ****   #if ( defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSI
 246:quantum/quantum.c ****     process_music(keycode, record) &&
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 675               		.loc 1 249 0
 676 002c 8823      		tst r24
 677 002e 01F4      		brne .+2
 678 0030 00C0      		rjmp .L111
 679               		.loc 1 249 0 is_stmt 0 discriminator 2
 680 0032 B801      		movw r22,r16
 681 0034 CE01      		movw r24,r28
 682 0036 0E94 0000 		call process_tap_dance
 683               	.LVL55:
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 684               		.loc 1 232 0 is_stmt 1 discriminator 2
 685 003a 8823      		tst r24
 686 003c 01F4      		brne .+2
 687 003e 00C0      		rjmp .L111
 250:quantum/quantum.c ****   #endif
 251:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 252:quantum/quantum.c ****     process_leader(keycode, record) &&
 688               		.loc 1 252 0
 689 0040 B801      		movw r22,r16
 690 0042 CE01      		movw r24,r28
 691 0044 0E94 0000 		call process_leader
 692               	.LVL56:
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 693               		.loc 1 249 0
 694 0048 8823      		tst r24
 695 004a 01F4      		brne .+2
 696 004c 00C0      		rjmp .L111
 253:quantum/quantum.c ****   #endif
 254:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 255:quantum/quantum.c ****     process_chording(keycode, record) &&
 256:quantum/quantum.c ****   #endif
 257:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 258:quantum/quantum.c ****     process_combo(keycode, record) &&
 259:quantum/quantum.c ****   #endif
 260:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 261:quantum/quantum.c ****     process_unicode(keycode, record) &&
 262:quantum/quantum.c ****   #endif
 263:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 264:quantum/quantum.c ****     process_ucis(keycode, record) &&
 265:quantum/quantum.c ****   #endif
 266:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 267:quantum/quantum.c ****     process_printer(keycode, record) &&
 268:quantum/quantum.c ****   #endif
 269:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 270:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 271:quantum/quantum.c ****   #endif
 272:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 273:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 274:quantum/quantum.c ****   #endif
 275:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 276:quantum/quantum.c ****     process_terminal(keycode, record) &&
 277:quantum/quantum.c ****   #endif
 278:quantum/quantum.c ****       true)) {
 279:quantum/quantum.c ****     return false;
 280:quantum/quantum.c ****   }
 281:quantum/quantum.c **** 
 282:quantum/quantum.c ****   // Shift / paren setup
 283:quantum/quantum.c **** 
 284:quantum/quantum.c ****   switch(keycode) {
 697               		.loc 1 284 0
 698 004e C531      		cpi r28,21
 699 0050 FCE5      		ldi r31,92
 700 0052 DF07      		cpc r29,r31
 701 0054 01F4      		brne .L132
 702               	.LBB29:
 285:quantum/quantum.c ****     case RESET:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 287:quantum/quantum.c ****         reset_keyboard();
 288:quantum/quantum.c ****       }
 289:quantum/quantum.c ****     return false;
 290:quantum/quantum.c ****     case DEBUG:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 292:quantum/quantum.c ****           debug_enable = true;
 293:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 294:quantum/quantum.c ****       }
 295:quantum/quantum.c ****     return false;
 296:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 297:quantum/quantum.c ****   case FC_TOG:
 298:quantum/quantum.c ****     if (record->event.pressed) {
 299:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 300:quantum/quantum.c ****     }
 301:quantum/quantum.c ****     return false;
 302:quantum/quantum.c ****   case FC_ON:
 303:quantum/quantum.c ****     if (record->event.pressed) {
 304:quantum/quantum.c ****       FAUXCLICKY_ON;
 305:quantum/quantum.c ****     }
 306:quantum/quantum.c ****     return false;
 307:quantum/quantum.c ****   case FC_OFF:
 308:quantum/quantum.c ****     if (record->event.pressed) {
 309:quantum/quantum.c ****       FAUXCLICKY_OFF;
 310:quantum/quantum.c ****     }
 311:quantum/quantum.c ****     return false;
 312:quantum/quantum.c ****   #endif
 313:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 314:quantum/quantum.c ****   case RGB_TOG:
 315:quantum/quantum.c ****     if (record->event.pressed) {
 316:quantum/quantum.c ****       rgblight_toggle();
 317:quantum/quantum.c ****     }
 318:quantum/quantum.c ****     return false;
 319:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 320:quantum/quantum.c ****     if (record->event.pressed) {
 321:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 322:quantum/quantum.c ****       if(shifted) {
 323:quantum/quantum.c ****         rgblight_step_reverse();
 324:quantum/quantum.c ****       }
 325:quantum/quantum.c ****       else {
 326:quantum/quantum.c ****         rgblight_step();
 327:quantum/quantum.c ****       }
 328:quantum/quantum.c ****     }
 329:quantum/quantum.c ****     return false;
 330:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 331:quantum/quantum.c ****     if (record->event.pressed) {
 332:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 333:quantum/quantum.c ****       if(shifted) {
 334:quantum/quantum.c ****         rgblight_step();
 335:quantum/quantum.c ****       }
 336:quantum/quantum.c ****       else {
 337:quantum/quantum.c ****         rgblight_step_reverse();
 338:quantum/quantum.c ****       }
 339:quantum/quantum.c ****     }
 340:quantum/quantum.c ****     return false;
 341:quantum/quantum.c ****   case RGB_HUI:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 343:quantum/quantum.c ****       rgblight_increase_hue();
 344:quantum/quantum.c ****     }
 345:quantum/quantum.c ****     return false;
 346:quantum/quantum.c ****   case RGB_HUD:
 347:quantum/quantum.c ****     if (record->event.pressed) {
 348:quantum/quantum.c ****       rgblight_decrease_hue();
 349:quantum/quantum.c ****     }
 350:quantum/quantum.c ****     return false;
 351:quantum/quantum.c ****   case RGB_SAI:
 352:quantum/quantum.c ****     if (record->event.pressed) {
 353:quantum/quantum.c ****       rgblight_increase_sat();
 354:quantum/quantum.c ****     }
 355:quantum/quantum.c ****     return false;
 356:quantum/quantum.c ****   case RGB_SAD:
 357:quantum/quantum.c ****     if (record->event.pressed) {
 358:quantum/quantum.c ****       rgblight_decrease_sat();
 359:quantum/quantum.c ****     }
 360:quantum/quantum.c ****     return false;
 361:quantum/quantum.c ****   case RGB_VAI:
 362:quantum/quantum.c ****     if (record->event.pressed) {
 363:quantum/quantum.c ****       rgblight_increase_val();
 364:quantum/quantum.c ****     }
 365:quantum/quantum.c ****     return false;
 366:quantum/quantum.c ****   case RGB_VAD:
 367:quantum/quantum.c ****     if (record->event.pressed) {
 368:quantum/quantum.c ****       rgblight_decrease_val();
 369:quantum/quantum.c ****     }
 370:quantum/quantum.c ****     return false;
 371:quantum/quantum.c ****   case RGB_SPI:
 372:quantum/quantum.c ****     if (record->event.pressed) {
 373:quantum/quantum.c ****       rgblight_increase_speed();
 374:quantum/quantum.c ****     }
 375:quantum/quantum.c ****     return false;
 376:quantum/quantum.c ****   case RGB_SPD:
 377:quantum/quantum.c ****     if (record->event.pressed) {
 378:quantum/quantum.c ****       rgblight_decrease_speed();
 379:quantum/quantum.c ****     }
 380:quantum/quantum.c ****     return false;
 381:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 382:quantum/quantum.c ****     if (record->event.pressed) {
 383:quantum/quantum.c ****       rgblight_mode(1);
 384:quantum/quantum.c ****     }
 385:quantum/quantum.c ****     return false;
 386:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 387:quantum/quantum.c ****     if (record->event.pressed) {
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 389:quantum/quantum.c ****         rgblight_step();
 390:quantum/quantum.c ****       } else {
 391:quantum/quantum.c ****         rgblight_mode(2);
 392:quantum/quantum.c ****       }
 393:quantum/quantum.c ****     }
 394:quantum/quantum.c ****     return false;
 395:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 396:quantum/quantum.c ****     if (record->event.pressed) {
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 398:quantum/quantum.c ****         rgblight_step();
 399:quantum/quantum.c ****       } else {
 400:quantum/quantum.c ****         rgblight_mode(6);
 401:quantum/quantum.c ****       }
 402:quantum/quantum.c ****     }
 403:quantum/quantum.c ****     return false;
 404:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 405:quantum/quantum.c ****     if (record->event.pressed) {
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 407:quantum/quantum.c ****         rgblight_step();
 408:quantum/quantum.c ****       } else {
 409:quantum/quantum.c ****         rgblight_mode(9);
 410:quantum/quantum.c ****       }
 411:quantum/quantum.c ****     }
 412:quantum/quantum.c ****     return false;
 413:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 414:quantum/quantum.c ****     if (record->event.pressed) {
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 416:quantum/quantum.c ****         rgblight_step();
 417:quantum/quantum.c ****       } else {
 418:quantum/quantum.c ****         rgblight_mode(15);
 419:quantum/quantum.c ****       }
 420:quantum/quantum.c ****     }
 421:quantum/quantum.c ****     return false;
 422:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 423:quantum/quantum.c ****     if (record->event.pressed) {
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 425:quantum/quantum.c ****         rgblight_step();
 426:quantum/quantum.c ****       } else {
 427:quantum/quantum.c ****         rgblight_mode(21);
 428:quantum/quantum.c ****       }
 429:quantum/quantum.c ****     }
 430:quantum/quantum.c ****     return false;
 431:quantum/quantum.c ****   case RGB_MODE_XMAS:
 432:quantum/quantum.c ****     if (record->event.pressed) {
 433:quantum/quantum.c ****       rgblight_mode(24);
 434:quantum/quantum.c ****     }
 435:quantum/quantum.c ****     return false;
 436:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 437:quantum/quantum.c ****     if (record->event.pressed) {
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 439:quantum/quantum.c ****         rgblight_step();
 440:quantum/quantum.c ****       } else {
 441:quantum/quantum.c ****         rgblight_mode(25);
 442:quantum/quantum.c ****       }
 443:quantum/quantum.c ****     }
 444:quantum/quantum.c ****     return false;
 445:quantum/quantum.c ****   #endif
 446:quantum/quantum.c ****     #ifdef PROTOCOL_LUFA
 447:quantum/quantum.c ****     case OUT_AUTO:
 448:quantum/quantum.c ****       if (record->event.pressed) {
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 450:quantum/quantum.c ****       }
 451:quantum/quantum.c ****       return false;
 452:quantum/quantum.c ****     case OUT_USB:
 453:quantum/quantum.c ****       if (record->event.pressed) {
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 455:quantum/quantum.c ****       }
 456:quantum/quantum.c ****       return false;
 457:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 458:quantum/quantum.c ****     case OUT_BT:
 459:quantum/quantum.c ****       if (record->event.pressed) {
 460:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 461:quantum/quantum.c ****       }
 462:quantum/quantum.c ****       return false;
 463:quantum/quantum.c ****     #endif
 464:quantum/quantum.c ****     #endif
 465:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 466:quantum/quantum.c ****       if (record->event.pressed) {
 467:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 468:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 469:quantum/quantum.c ****             eeconfig_init();
 470:quantum/quantum.c ****         }
 471:quantum/quantum.c ****         /* keymap config */
 472:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 473:quantum/quantum.c ****         switch (keycode)
 474:quantum/quantum.c ****         {
 475:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 476:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 477:quantum/quantum.c ****             break;
 478:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 479:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 480:quantum/quantum.c ****             break;
 481:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 482:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 483:quantum/quantum.c ****             break;
 484:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 485:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 486:quantum/quantum.c ****             break;
 487:quantum/quantum.c ****           case MAGIC_NO_GUI:
 488:quantum/quantum.c ****             keymap_config.no_gui = true;
 489:quantum/quantum.c ****             break;
 490:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 491:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 492:quantum/quantum.c ****             break;
 493:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 494:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 495:quantum/quantum.c ****             break;
 496:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 497:quantum/quantum.c ****             keymap_config.nkro = true;
 498:quantum/quantum.c ****             break;
 499:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 500:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 501:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 502:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 503:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 504:quantum/quantum.c ****             #endif
 505:quantum/quantum.c ****             break;
 506:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 507:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 508:quantum/quantum.c ****             break;
 509:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 510:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 511:quantum/quantum.c ****             break;
 512:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 513:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 514:quantum/quantum.c ****             break;
 515:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 516:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 517:quantum/quantum.c ****             break;
 518:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 519:quantum/quantum.c ****             keymap_config.no_gui = false;
 520:quantum/quantum.c ****             break;
 521:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 522:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 523:quantum/quantum.c ****             break;
 524:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 525:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 526:quantum/quantum.c ****             break;
 527:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 528:quantum/quantum.c ****             keymap_config.nkro = false;
 529:quantum/quantum.c ****             break;
 530:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 531:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 532:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 533:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 534:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 535:quantum/quantum.c ****             #endif
 536:quantum/quantum.c ****             break;
 537:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 538:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 539:quantum/quantum.c ****             break;
 540:quantum/quantum.c ****           default:
 541:quantum/quantum.c ****             break;
 542:quantum/quantum.c ****         }
 543:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 544:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 545:quantum/quantum.c **** 
 546:quantum/quantum.c ****         return false;
 547:quantum/quantum.c ****       }
 548:quantum/quantum.c ****       break;
 549:quantum/quantum.c ****     case KC_LSPO: {
 550:quantum/quantum.c ****       if (record->event.pressed) {
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 554:quantum/quantum.c ****       }
 555:quantum/quantum.c ****       else {
 556:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 557:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 558:quantum/quantum.c ****             shift_interrupted[0] = true;
 559:quantum/quantum.c ****             shift_interrupted[1] = true;
 560:quantum/quantum.c ****           }
 561:quantum/quantum.c ****         #endif
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 565:quantum/quantum.c ****         }
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 567:quantum/quantum.c ****       }
 568:quantum/quantum.c ****       return false;
 569:quantum/quantum.c ****     }
 570:quantum/quantum.c **** 
 571:quantum/quantum.c ****     case KC_RSPC: {
 572:quantum/quantum.c ****       if (record->event.pressed) {
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 576:quantum/quantum.c ****       }
 577:quantum/quantum.c ****       else {
 578:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 579:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 580:quantum/quantum.c ****             shift_interrupted[0] = true;
 581:quantum/quantum.c ****             shift_interrupted[1] = true;
 582:quantum/quantum.c ****           }
 583:quantum/quantum.c ****         #endif
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 587:quantum/quantum.c ****         }
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 589:quantum/quantum.c ****       }
 590:quantum/quantum.c ****       return false;
 591:quantum/quantum.c ****     }
 592:quantum/quantum.c **** 
 593:quantum/quantum.c ****     case KC_SFTENT: {
 594:quantum/quantum.c ****       if (record->event.pressed) {
 595:quantum/quantum.c ****         shift_interrupted[1] = false;
 596:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 597:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 598:quantum/quantum.c ****       }
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 603:quantum/quantum.c ****       }
 604:quantum/quantum.c ****       else {
 605:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 606:quantum/quantum.c ****       }
 607:quantum/quantum.c ****       return false;
 608:quantum/quantum.c ****     }
 609:quantum/quantum.c **** 
 610:quantum/quantum.c ****     case GRAVE_ESC: {
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 703               		.loc 1 611 0
 704 0056 0E94 0000 		call get_mods
 705               	.LVL57:
 706 005a 382F      		mov r19,r24
 707               	.LVL58:
 612:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 613:quantum/quantum.c **** 
 614:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 615:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 616:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 617:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 618:quantum/quantum.c ****         shifted = 0;
 619:quantum/quantum.c ****       }
 620:quantum/quantum.c **** #endif
 621:quantum/quantum.c **** 
 622:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 623:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 624:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 625:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 626:quantum/quantum.c ****         shifted = 0;
 627:quantum/quantum.c ****       }
 628:quantum/quantum.c **** #endif
 629:quantum/quantum.c **** 
 630:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 631:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 632:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 633:quantum/quantum.c ****         shifted = 0;
 634:quantum/quantum.c ****       }
 635:quantum/quantum.c **** #endif
 636:quantum/quantum.c **** 
 637:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 638:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 639:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 640:quantum/quantum.c ****         shifted = 0;
 641:quantum/quantum.c ****       }
 642:quantum/quantum.c **** #endif
 643:quantum/quantum.c **** 
 644:quantum/quantum.c ****       if (record->event.pressed) {
 708               		.loc 1 644 0
 709 005c F801      		movw r30,r16
 710 005e 2281      		ldd r18,Z+2
 711 0060 8091 0000 		lds r24,keyboard_report
 712 0064 9091 0000 		lds r25,keyboard_report+1
 713 0068 2223      		tst r18
 714 006a 01F0      		breq .L94
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 715               		.loc 1 611 0
 716 006c 3A7A      		andi r19,lo8(-86)
 717               	.LVL59:
 645:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 718               		.loc 1 645 0
 719 006e 21E0      		ldi r18,lo8(1)
 720 0070 01F4      		brne .L95
 721 0072 20E0      		ldi r18,0
 722               	.L95:
 723 0074 2093 0000 		sts grave_esc_was_shifted,r18
 646:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 724               		.loc 1 646 0
 725 0078 2223      		tst r18
 726 007a 01F0      		breq .L102
 727 007c 65E3      		ldi r22,lo8(53)
 728 007e 00C0      		rjmp .L96
 729               	.L102:
 730 0080 69E2      		ldi r22,lo8(41)
 731               	.L96:
 732               	.LVL60:
 733               	.LBB30:
 734               	.LBB31:
 735               		.file 4 "./tmk_core/common/action_util.h"
   1:./tmk_core/common/action_util.h **** /*
   2:./tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action_util.h **** 
   4:./tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action_util.h **** (at your option) any later version.
   8:./tmk_core/common/action_util.h **** 
   9:./tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:./tmk_core/common/action_util.h **** 
  14:./tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action_util.h **** */
  17:./tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:./tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:./tmk_core/common/action_util.h **** 
  20:./tmk_core/common/action_util.h **** #include <stdint.h>
  21:./tmk_core/common/action_util.h **** #include "report.h"
  22:./tmk_core/common/action_util.h **** 
  23:./tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:./tmk_core/common/action_util.h **** extern "C" {
  25:./tmk_core/common/action_util.h **** #endif
  26:./tmk_core/common/action_util.h **** 
  27:./tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:./tmk_core/common/action_util.h **** 
  29:./tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:./tmk_core/common/action_util.h **** 
  31:./tmk_core/common/action_util.h **** /* key */
  32:./tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 736               		.loc 4 33 0 discriminator 1
 737 0082 0E94 0000 		call add_key_to_report
 738               	.LVL61:
 739 0086 00C0      		rjmp .L97
 740               	.LVL62:
 741               	.L94:
 742               	.LBE31:
 743               	.LBE30:
 647:quantum/quantum.c ****       }
 648:quantum/quantum.c ****       else {
 649:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 744               		.loc 1 649 0
 745 0088 2091 0000 		lds r18,grave_esc_was_shifted
 746 008c 2223      		tst r18
 747 008e 01F0      		breq .L103
 748 0090 65E3      		ldi r22,lo8(53)
 749 0092 00C0      		rjmp .L98
 750               	.L103:
 751 0094 69E2      		ldi r22,lo8(41)
 752               	.L98:
 753               	.LVL63:
 754               	.LBB32:
 755               	.LBB33:
  34:./tmk_core/common/action_util.h **** }
  35:./tmk_core/common/action_util.h **** 
  36:./tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:./tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 756               		.loc 4 37 0 discriminator 3
 757 0096 0E94 0000 		call del_key_from_report
 758               	.LVL64:
 759               	.L97:
 760               	.LBE33:
 761               	.LBE32:
 650:quantum/quantum.c ****       }
 651:quantum/quantum.c **** 
 652:quantum/quantum.c ****       send_keyboard_report();
 762               		.loc 1 652 0
 763 009a 0E94 0000 		call send_keyboard_report
 764               	.LVL65:
 653:quantum/quantum.c ****       return false;
 765               		.loc 1 653 0
 766 009e 00C0      		rjmp .L111
 767               	.L132:
 768               	.LBE29:
 284:quantum/quantum.c ****   switch(keycode) {
 769               		.loc 1 284 0
 770 00a0 C631      		cpi r28,22
 771 00a2 8CE5      		ldi r24,92
 772 00a4 D807      		cpc r29,r24
 773 00a6 00F0      		brlo .+2
 774 00a8 00C0      		rjmp .L100
 775 00aa C130      		cpi r28,1
 776 00ac ECE5      		ldi r30,92
 777 00ae DE07      		cpc r29,r30
 778 00b0 01F4      		brne .L133
 291:quantum/quantum.c ****       if (record->event.pressed) {
 779               		.loc 1 291 0
 780 00b2 F801      		movw r30,r16
 781 00b4 8281      		ldd r24,Z+2
 782 00b6 8823      		tst r24
 783 00b8 01F4      		brne .+2
 784 00ba 00C0      		rjmp .L111
 292:quantum/quantum.c ****           debug_enable = true;
 785               		.loc 1 292 0
 786 00bc 8091 0000 		lds r24,debug_config
 787 00c0 8160      		ori r24,lo8(1<<0)
 788 00c2 8093 0000 		sts debug_config,r24
 789 00c6 00C0      		rjmp .L111
 790               	.L133:
 284:quantum/quantum.c ****   switch(keycode) {
 791               		.loc 1 284 0
 792 00c8 C230      		cpi r28,2
 793 00ca FCE5      		ldi r31,92
 794 00cc DF07      		cpc r29,r31
 795 00ce 00F4      		brsh .+2
 796 00d0 00C0      		rjmp .L134
 466:quantum/quantum.c ****       if (record->event.pressed) {
 797               		.loc 1 466 0
 798 00d2 F801      		movw r30,r16
 799 00d4 8281      		ldd r24,Z+2
 800 00d6 8823      		tst r24
 801 00d8 01F4      		brne .+2
 802 00da 00C0      		rjmp .L58
 468:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 803               		.loc 1 468 0
 804 00dc 0E94 0000 		call eeconfig_is_enabled
 805               	.LVL66:
 806 00e0 8111      		cpse r24,__zero_reg__
 807 00e2 00C0      		rjmp .L59
 469:quantum/quantum.c ****             eeconfig_init();
 808               		.loc 1 469 0
 809 00e4 0E94 0000 		call eeconfig_init
 810               	.LVL67:
 811               	.L59:
 472:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 812               		.loc 1 472 0
 813 00e8 0E94 0000 		call eeconfig_read_keymap
 814               	.LVL68:
 815 00ec 90E0      		ldi r25,0
 816 00ee 9093 0000 		sts keymap_config+1,r25
 817 00f2 8093 0000 		sts keymap_config,r24
 473:quantum/quantum.c ****         switch (keycode)
 818               		.loc 1 473 0
 819 00f6 FE01      		movw r30,r28
 820 00f8 E350      		subi r30,3
 821 00fa FC45      		sbci r31,92
 822 00fc E231      		cpi r30,18
 823 00fe F105      		cpc r31,__zero_reg__
 824 0100 00F4      		brsh .L60
 825 0102 E050      		subi r30,lo8(-(gs(.L62)))
 826 0104 F040      		sbci r31,hi8(-(gs(.L62)))
 827 0106 0C94 0000 		jmp __tablejump2__
 828               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 829               		.p2align	1
 830               	.L62:
 831 0000 0000      		.word gs(.L61)
 832 0002 0000      		.word gs(.L63)
 833 0004 0000      		.word gs(.L64)
 834 0006 0000      		.word gs(.L65)
 835 0008 0000      		.word gs(.L66)
 836 000a 0000      		.word gs(.L67)
 837 000c 0000      		.word gs(.L68)
 838 000e 0000      		.word gs(.L69)
 839 0010 0000      		.word gs(.L70)
 840 0012 0000      		.word gs(.L71)
 841 0014 0000      		.word gs(.L72)
 842 0016 0000      		.word gs(.L73)
 843 0018 0000      		.word gs(.L74)
 844 001a 0000      		.word gs(.L75)
 845 001c 0000      		.word gs(.L76)
 846 001e 0000      		.word gs(.L77)
 847 0020 0000      		.word gs(.L78)
 848 0022 0000      		.word gs(.L79)
 849               		.section	.text.process_record_quantum
 850               	.L60:
 476:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 851               		.loc 1 476 0
 852 010a 8091 0000 		lds r24,keymap_config
 853 010e 8160      		ori r24,lo8(1<<0)
 854 0110 00C0      		rjmp .L126
 855               	.L61:
 479:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 856               		.loc 1 479 0
 857 0112 8091 0000 		lds r24,keymap_config
 858 0116 8260      		ori r24,lo8(1<<1)
 859               	.L126:
 860 0118 8093 0000 		sts keymap_config,r24
 480:quantum/quantum.c ****             break;
 861               		.loc 1 480 0
 862 011c 00C0      		rjmp .L80
 863               	.L63:
 482:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 864               		.loc 1 482 0
 865 011e 8091 0000 		lds r24,keymap_config
 866 0122 8460      		ori r24,lo8(1<<2)
 867 0124 00C0      		rjmp .L126
 868               	.L64:
 485:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 869               		.loc 1 485 0
 870 0126 8091 0000 		lds r24,keymap_config
 871 012a 00C0      		rjmp .L131
 872               	.L65:
 488:quantum/quantum.c ****             keymap_config.no_gui = true;
 873               		.loc 1 488 0
 874 012c 8091 0000 		lds r24,keymap_config
 875 0130 8061      		ori r24,lo8(1<<4)
 876 0132 00C0      		rjmp .L126
 877               	.L66:
 491:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 878               		.loc 1 491 0
 879 0134 8091 0000 		lds r24,keymap_config
 880 0138 8062      		ori r24,lo8(1<<5)
 881 013a 00C0      		rjmp .L126
 882               	.L67:
 494:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 883               		.loc 1 494 0
 884 013c 8091 0000 		lds r24,keymap_config
 885 0140 8064      		ori r24,lo8(1<<6)
 886 0142 00C0      		rjmp .L126
 887               	.L68:
 497:quantum/quantum.c ****             keymap_config.nkro = true;
 888               		.loc 1 497 0
 889 0144 8091 0000 		lds r24,keymap_config
 890 0148 8068      		ori r24,lo8(1<<7)
 891 014a 00C0      		rjmp .L126
 892               	.L69:
 500:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 893               		.loc 1 500 0
 894 014c 8091 0000 		lds r24,keymap_config
 501:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 895               		.loc 1 501 0
 896 0150 8460      		ori r24,lo8(4)
 897               	.L131:
 898 0152 8860      		ori r24,lo8(1<<3)
 899 0154 00C0      		rjmp .L126
 900               	.L70:
 507:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 901               		.loc 1 507 0
 902 0156 8091 0000 		lds r24,keymap_config
 903 015a 8E7F      		andi r24,lo8(~(1<<0))
 904 015c 00C0      		rjmp .L126
 905               	.L71:
 510:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 906               		.loc 1 510 0
 907 015e 8091 0000 		lds r24,keymap_config
 908 0162 8D7F      		andi r24,lo8(~(1<<1))
 909 0164 00C0      		rjmp .L126
 910               	.L72:
 513:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 911               		.loc 1 513 0
 912 0166 8091 0000 		lds r24,keymap_config
 913 016a 8B7F      		andi r24,lo8(~(1<<2))
 914 016c 00C0      		rjmp .L126
 915               	.L73:
 516:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 916               		.loc 1 516 0
 917 016e 8091 0000 		lds r24,keymap_config
 918 0172 00C0      		rjmp .L130
 919               	.L74:
 519:quantum/quantum.c ****             keymap_config.no_gui = false;
 920               		.loc 1 519 0
 921 0174 8091 0000 		lds r24,keymap_config
 922 0178 8F7E      		andi r24,lo8(~(1<<4))
 923 017a 00C0      		rjmp .L126
 924               	.L75:
 522:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 925               		.loc 1 522 0
 926 017c 8091 0000 		lds r24,keymap_config
 927 0180 8F7D      		andi r24,lo8(~(1<<5))
 928 0182 00C0      		rjmp .L126
 929               	.L76:
 525:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 930               		.loc 1 525 0
 931 0184 8091 0000 		lds r24,keymap_config
 932 0188 8F7B      		andi r24,lo8(~(1<<6))
 933 018a 00C0      		rjmp .L126
 934               	.L77:
 528:quantum/quantum.c ****             keymap_config.nkro = false;
 935               		.loc 1 528 0
 936 018c 8091 0000 		lds r24,keymap_config
 937 0190 8F77      		andi r24,lo8(~(1<<7))
 938 0192 00C0      		rjmp .L126
 939               	.L78:
 531:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 940               		.loc 1 531 0
 941 0194 8091 0000 		lds r24,keymap_config
 532:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 942               		.loc 1 532 0
 943 0198 8B7F      		andi r24,lo8(-5)
 944               	.L130:
 945 019a 877F      		andi r24,lo8(~(1<<3))
 946 019c 00C0      		rjmp .L126
 947               	.L79:
 538:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 948               		.loc 1 538 0
 949 019e 9091 0000 		lds r25,keymap_config
 950 01a2 97FB      		bst r25,7
 951 01a4 8827      		clr r24
 952 01a6 80F9      		bld r24,0
 953 01a8 21E0      		ldi r18,lo8(1)
 954 01aa 8227      		eor r24,r18
 955 01ac 80FB      		bst r24,0
 956 01ae 97F9      		bld r25,7
 957 01b0 9093 0000 		sts keymap_config,r25
 958               	.L80:
 543:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 959               		.loc 1 543 0
 960 01b4 8091 0000 		lds r24,keymap_config
 961 01b8 0E94 0000 		call eeconfig_update_keymap
 962               	.LVL69:
 544:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 963               		.loc 1 544 0
 964 01bc 0E94 0000 		call clear_keyboard
 965               	.LVL70:
 546:quantum/quantum.c ****         return false;
 966               		.loc 1 546 0
 967 01c0 00C0      		rjmp .L111
 968               	.L134:
 284:quantum/quantum.c ****   switch(keycode) {
 969               		.loc 1 284 0
 970 01c2 C115      		cp r28,__zero_reg__
 971 01c4 DC45      		sbci r29,92
 972 01c6 01F0      		breq .L52
 973               	.L99:
 654:quantum/quantum.c ****     }
 655:quantum/quantum.c **** 
 656:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 657:quantum/quantum.c ****     case BL_BRTG: {
 658:quantum/quantum.c ****       if (record->event.pressed)
 659:quantum/quantum.c ****         breathing_toggle();
 660:quantum/quantum.c ****       return false;
 661:quantum/quantum.c ****     }
 662:quantum/quantum.c **** #endif
 663:quantum/quantum.c **** 
 664:quantum/quantum.c ****     default: {
 665:quantum/quantum.c ****       shift_interrupted[0] = true;
 974               		.loc 1 665 0
 975 01c8 81E0      		ldi r24,lo8(1)
 976 01ca 8093 0000 		sts shift_interrupted,r24
 666:quantum/quantum.c ****       shift_interrupted[1] = true;
 977               		.loc 1 666 0
 978 01ce 8093 0000 		sts shift_interrupted+1,r24
 979               	.L58:
 667:quantum/quantum.c ****       break;
 668:quantum/quantum.c ****     }
 669:quantum/quantum.c ****   }
 670:quantum/quantum.c **** 
 671:quantum/quantum.c ****   return process_action_kb(record);
 980               		.loc 1 671 0
 981 01d2 C801      		movw r24,r16
 982               	/* epilogue start */
 672:quantum/quantum.c **** }
 983               		.loc 1 672 0
 984 01d4 DF91      		pop r29
 985 01d6 CF91      		pop r28
 986               	.LVL71:
 987 01d8 1F91      		pop r17
 988 01da 0F91      		pop r16
 989               	.LVL72:
 671:quantum/quantum.c ****   return process_action_kb(record);
 990               		.loc 1 671 0
 991 01dc 0C94 0000 		jmp process_action_kb
 992               	.LVL73:
 993               	.L52:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 994               		.loc 1 286 0
 995 01e0 F801      		movw r30,r16
 996 01e2 8281      		ldd r24,Z+2
 997 01e4 8823      		tst r24
 998 01e6 01F4      		brne .+2
 999 01e8 00C0      		rjmp .L111
 287:quantum/quantum.c ****         reset_keyboard();
 1000               		.loc 1 287 0
 1001 01ea 0E94 0000 		call reset_keyboard
 1002               	.LVL74:
 1003 01ee 00C0      		rjmp .L111
 1004               	.L100:
 284:quantum/quantum.c ****   switch(keycode) {
 1005               		.loc 1 284 0
 1006 01f0 C53D      		cpi r28,-43
 1007 01f2 ECE5      		ldi r30,92
 1008 01f4 DE07      		cpc r29,r30
 1009 01f6 01F4      		brne .L135
 594:quantum/quantum.c ****       if (record->event.pressed) {
 1010               		.loc 1 594 0
 1011 01f8 F801      		movw r30,r16
 1012 01fa 8281      		ldd r24,Z+2
 1013 01fc 8823      		tst r24
 1014 01fe 01F0      		breq .L136
 1015               	.L92:
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 1016               		.loc 1 573 0
 1017 0200 1092 0000 		sts shift_interrupted+1,__zero_reg__
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 1018               		.loc 1 574 0
 1019 0204 0E94 0000 		call timer_read
 1020               	.LVL75:
 1021 0208 9093 0000 		sts scs_timer+2+1,r25
 1022 020c 8093 0000 		sts scs_timer+2,r24
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 1023               		.loc 1 575 0
 1024 0210 80E2      		ldi r24,lo8(32)
 1025               	.L128:
 1026 0212 0E94 0000 		call register_mods
 1027               	.LVL76:
 1028 0216 00C0      		rjmp .L111
 1029               	.L136:
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1030               		.loc 1 599 0
 1031 0218 8091 0000 		lds r24,shift_interrupted+1
 1032 021c 8823      		tst r24
 1033 021e 01F0      		breq .L137
 1034               	.L89:
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1035               		.loc 1 588 0
 1036 0220 80E2      		ldi r24,lo8(32)
 1037               	.L129:
 1038 0222 0E94 0000 		call unregister_mods
 1039               	.LVL77:
 1040 0226 00C0      		rjmp .L111
 1041               	.L137:
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1042               		.loc 1 599 0 discriminator 1
 1043 0228 8091 0000 		lds r24,scs_timer+2
 1044 022c 9091 0000 		lds r25,scs_timer+2+1
 1045 0230 0E94 0000 		call timer_elapsed
 1046               	.LVL78:
 1047 0234 8639      		cpi r24,-106
 1048 0236 9105      		cpc r25,__zero_reg__
 1049 0238 00F4      		brsh .L89
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1050               		.loc 1 600 0
 1051 023a 80E2      		ldi r24,lo8(32)
 1052 023c 0E94 0000 		call unregister_mods
 1053               	.LVL79:
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 1054               		.loc 1 601 0
 1055 0240 88E2      		ldi r24,lo8(40)
 1056 0242 0E94 0000 		call register_code
 1057               	.LVL80:
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 1058               		.loc 1 602 0
 1059 0246 88E2      		ldi r24,lo8(40)
 1060 0248 0E94 0000 		call unregister_code
 1061               	.LVL81:
 1062 024c 00C0      		rjmp .L111
 1063               	.L135:
 284:quantum/quantum.c ****   switch(keycode) {
 1064               		.loc 1 284 0
 1065 024e C63D      		cpi r28,-42
 1066 0250 FCE5      		ldi r31,92
 1067 0252 DF07      		cpc r29,r31
 1068 0254 00F0      		brlo .+2
 1069 0256 00C0      		rjmp .L101
 1070 0258 C33D      		cpi r28,-45
 1071 025a 8CE5      		ldi r24,92
 1072 025c D807      		cpc r29,r24
 1073 025e 01F4      		brne .L138
 550:quantum/quantum.c ****       if (record->event.pressed) {
 1074               		.loc 1 550 0
 1075 0260 F801      		movw r30,r16
 1076 0262 8281      		ldd r24,Z+2
 1077 0264 8823      		tst r24
 1078 0266 01F0      		breq .L82
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 1079               		.loc 1 551 0
 1080 0268 1092 0000 		sts shift_interrupted,__zero_reg__
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 1081               		.loc 1 552 0
 1082 026c 0E94 0000 		call timer_read
 1083               	.LVL82:
 1084 0270 9093 0000 		sts scs_timer+1,r25
 1085 0274 8093 0000 		sts scs_timer,r24
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 1086               		.loc 1 553 0
 1087 0278 82E0      		ldi r24,lo8(2)
 1088 027a 00C0      		rjmp .L128
 1089               	.L82:
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 1090               		.loc 1 562 0
 1091 027c 8091 0000 		lds r24,shift_interrupted
 1092 0280 8111      		cpse r24,__zero_reg__
 1093 0282 00C0      		rjmp .L84
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 1094               		.loc 1 562 0 is_stmt 0 discriminator 1
 1095 0284 8091 0000 		lds r24,scs_timer
 1096 0288 9091 0000 		lds r25,scs_timer+1
 1097 028c 0E94 0000 		call timer_elapsed
 1098               	.LVL83:
 1099 0290 8639      		cpi r24,-106
 1100 0292 9105      		cpc r25,__zero_reg__
 1101 0294 00F4      		brsh .L84
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 1102               		.loc 1 563 0 is_stmt 1
 1103 0296 86E2      		ldi r24,lo8(38)
 1104 0298 0E94 0000 		call register_code
 1105               	.LVL84:
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 1106               		.loc 1 564 0
 1107 029c 86E2      		ldi r24,lo8(38)
 1108 029e 0E94 0000 		call unregister_code
 1109               	.LVL85:
 1110               	.L84:
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 1111               		.loc 1 566 0
 1112 02a2 82E0      		ldi r24,lo8(2)
 1113 02a4 00C0      		rjmp .L129
 1114               	.L138:
 284:quantum/quantum.c ****   switch(keycode) {
 1115               		.loc 1 284 0
 1116 02a6 C43D      		cpi r28,-44
 1117 02a8 DC45      		sbci r29,92
 1118 02aa 01F0      		breq .+2
 1119 02ac 00C0      		rjmp .L99
 572:quantum/quantum.c ****       if (record->event.pressed) {
 1120               		.loc 1 572 0
 1121 02ae F801      		movw r30,r16
 1122 02b0 8281      		ldd r24,Z+2
 1123 02b2 8111      		cpse r24,__zero_reg__
 1124 02b4 00C0      		rjmp .L92
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1125               		.loc 1 584 0
 1126 02b6 8091 0000 		lds r24,shift_interrupted+1
 1127 02ba 8111      		cpse r24,__zero_reg__
 1128 02bc 00C0      		rjmp .L89
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1129               		.loc 1 584 0 is_stmt 0 discriminator 1
 1130 02be 8091 0000 		lds r24,scs_timer+2
 1131 02c2 9091 0000 		lds r25,scs_timer+2+1
 1132 02c6 0E94 0000 		call timer_elapsed
 1133               	.LVL86:
 1134 02ca 8639      		cpi r24,-106
 1135 02cc 9105      		cpc r25,__zero_reg__
 1136 02ce 00F0      		brlo .+2
 1137 02d0 00C0      		rjmp .L89
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 1138               		.loc 1 585 0 is_stmt 1
 1139 02d2 87E2      		ldi r24,lo8(39)
 1140 02d4 0E94 0000 		call register_code
 1141               	.LVL87:
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 1142               		.loc 1 586 0
 1143 02d8 87E2      		ldi r24,lo8(39)
 1144 02da 0E94 0000 		call unregister_code
 1145               	.LVL88:
 1146 02de 00C0      		rjmp .L89
 1147               	.L101:
 284:quantum/quantum.c ****   switch(keycode) {
 1148               		.loc 1 284 0
 1149 02e0 C83D      		cpi r28,-40
 1150 02e2 FCE5      		ldi r31,92
 1151 02e4 DF07      		cpc r29,r31
 1152 02e6 01F4      		brne .L139
 448:quantum/quantum.c ****       if (record->event.pressed) {
 1153               		.loc 1 448 0
 1154 02e8 F801      		movw r30,r16
 1155 02ea 8281      		ldd r24,Z+2
 1156 02ec 8823      		tst r24
 1157 02ee 01F0      		breq .L111
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 1158               		.loc 1 449 0
 1159 02f0 80E0      		ldi r24,0
 1160 02f2 00C0      		rjmp .L127
 1161               	.L139:
 284:quantum/quantum.c ****   switch(keycode) {
 1162               		.loc 1 284 0
 1163 02f4 C93D      		cpi r28,-39
 1164 02f6 DC45      		sbci r29,92
 1165 02f8 01F0      		breq .+2
 1166 02fa 00C0      		rjmp .L99
 453:quantum/quantum.c ****       if (record->event.pressed) {
 1167               		.loc 1 453 0
 1168 02fc F801      		movw r30,r16
 1169 02fe 8281      		ldd r24,Z+2
 1170 0300 8823      		tst r24
 1171 0302 01F0      		breq .L111
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 1172               		.loc 1 454 0
 1173 0304 82E0      		ldi r24,lo8(2)
 1174               	.L127:
 1175 0306 0E94 0000 		call set_output
 1176               	.LVL89:
 1177               	.L111:
 1178               		.loc 1 672 0
 1179 030a 80E0      		ldi r24,0
 1180               	/* epilogue start */
 1181 030c DF91      		pop r29
 1182 030e CF91      		pop r28
 1183               	.LVL90:
 1184 0310 1F91      		pop r17
 1185 0312 0F91      		pop r16
 1186               	.LVL91:
 1187 0314 0895      		ret
 1188               		.cfi_endproc
 1189               	.LFE35:
 1191               		.section	.text.send_char,"ax",@progbits
 1192               	.global	send_char
 1194               	send_char:
 1195               	.LFB40:
 673:quantum/quantum.c **** 
 674:quantum/quantum.c **** __attribute__ ((weak))
 675:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 676:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 677:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 678:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 679:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 680:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 681:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 682:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 683:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 684:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 685:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 686:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 687:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 688:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 689:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 690:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 691:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 692:quantum/quantum.c **** };
 693:quantum/quantum.c **** 
 694:quantum/quantum.c **** __attribute__ ((weak))
 695:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 696:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 697:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 698:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 699:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 700:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 701:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 702:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 703:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 704:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 705:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 706:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 707:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 708:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 709:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 710:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 711:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 712:quantum/quantum.c **** };
 713:quantum/quantum.c **** 
 714:quantum/quantum.c **** void send_string(const char *str) {
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 716:quantum/quantum.c **** }
 717:quantum/quantum.c **** 
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 720:quantum/quantum.c **** }
 721:quantum/quantum.c **** 
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 723:quantum/quantum.c ****     while (1) {
 724:quantum/quantum.c ****         char ascii_code = *str;
 725:quantum/quantum.c ****         if (!ascii_code) break;
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 727:quantum/quantum.c ****           // tap
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 729:quantum/quantum.c ****           register_code(keycode);
 730:quantum/quantum.c ****           unregister_code(keycode);
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 732:quantum/quantum.c ****           // down
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 734:quantum/quantum.c ****           register_code(keycode);
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 736:quantum/quantum.c ****           // up
 737:quantum/quantum.c ****           uint8_t keycode = *(++str);
 738:quantum/quantum.c ****           unregister_code(keycode);
 739:quantum/quantum.c ****         } else {
 740:quantum/quantum.c ****           send_char(ascii_code);
 741:quantum/quantum.c ****         }
 742:quantum/quantum.c ****         ++str;
 743:quantum/quantum.c ****         // interval
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 745:quantum/quantum.c ****     }
 746:quantum/quantum.c **** }
 747:quantum/quantum.c **** 
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 749:quantum/quantum.c ****     while (1) {
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 751:quantum/quantum.c ****         if (!ascii_code) break;
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 753:quantum/quantum.c ****           // tap
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 755:quantum/quantum.c ****           register_code(keycode);
 756:quantum/quantum.c ****           unregister_code(keycode);
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 758:quantum/quantum.c ****           // down
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 760:quantum/quantum.c ****           register_code(keycode);
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 762:quantum/quantum.c ****           // up
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 764:quantum/quantum.c ****           unregister_code(keycode);
 765:quantum/quantum.c ****         } else {
 766:quantum/quantum.c ****           send_char(ascii_code);
 767:quantum/quantum.c ****         }
 768:quantum/quantum.c ****         ++str;
 769:quantum/quantum.c ****         // interval
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 771:quantum/quantum.c ****     }
 772:quantum/quantum.c **** }
 773:quantum/quantum.c **** 
 774:quantum/quantum.c **** void send_char(char ascii_code) {
 1196               		.loc 1 774 0
 1197               		.cfi_startproc
 1198               	.LVL92:
 1199 0000 CF93      		push r28
 1200               	.LCFI12:
 1201               		.cfi_def_cfa_offset 3
 1202               		.cfi_offset 28, -2
 1203               	/* prologue: function */
 1204               	/* frame size = 0 */
 1205               	/* stack size = 1 */
 1206               	.L__stack_usage = 1
 1207               	.LBB34:
 775:quantum/quantum.c ****   uint8_t keycode;
 776:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 1208               		.loc 1 776 0
 1209 0002 282F      		mov r18,r24
 1210 0004 30E0      		ldi r19,0
 1211               	.LVL93:
 1212 0006 F901      		movw r30,r18
 1213 0008 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 1214 000a F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 1215               	.LVL94:
 1216               	/* #APP */
 1217               	 ;  776 "quantum/quantum.c" 1
 1218 000c C491      		lpm r28, Z
 1219               		
 1220               	 ;  0 "" 2
 1221               	.LVL95:
 1222               	/* #NOAPP */
 1223               	.LBE34:
 1224               	.LBB35:
 777:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 1225               		.loc 1 777 0
 1226 000e F901      		movw r30,r18
 1227               	.LVL96:
 1228 0010 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 1229 0012 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 1230               	.LVL97:
 1231               	/* #APP */
 1232               	 ;  777 "quantum/quantum.c" 1
 1233 0014 2491      		lpm r18, Z
 1234               		
 1235               	 ;  0 "" 2
 1236               	.LVL98:
 1237               	/* #NOAPP */
 1238               	.LBE35:
 1239 0016 2223      		tst r18
 1240 0018 01F0      		breq .L141
 778:quantum/quantum.c ****       register_code(KC_LSFT);
 1241               		.loc 1 778 0
 1242 001a 81EE      		ldi r24,lo8(-31)
 1243               	.LVL99:
 1244 001c 0E94 0000 		call register_code
 1245               	.LVL100:
 779:quantum/quantum.c ****       register_code(keycode);
 1246               		.loc 1 779 0
 1247 0020 8C2F      		mov r24,r28
 1248 0022 0E94 0000 		call register_code
 1249               	.LVL101:
 780:quantum/quantum.c ****       unregister_code(keycode);
 1250               		.loc 1 780 0
 1251 0026 8C2F      		mov r24,r28
 1252 0028 0E94 0000 		call unregister_code
 1253               	.LVL102:
 781:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1254               		.loc 1 781 0
 1255 002c 81EE      		ldi r24,lo8(-31)
 1256 002e 00C0      		rjmp .L142
 1257               	.LVL103:
 1258               	.L141:
 782:quantum/quantum.c ****   } else {
 783:quantum/quantum.c ****       register_code(keycode);
 1259               		.loc 1 783 0
 1260 0030 8C2F      		mov r24,r28
 1261               	.LVL104:
 1262 0032 0E94 0000 		call register_code
 1263               	.LVL105:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1264               		.loc 1 784 0
 1265 0036 8C2F      		mov r24,r28
 1266               	.L142:
 1267               	/* epilogue start */
 785:quantum/quantum.c ****   }
 786:quantum/quantum.c **** }
 1268               		.loc 1 786 0
 1269 0038 CF91      		pop r28
 1270               	.LVL106:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1271               		.loc 1 784 0
 1272 003a 0C94 0000 		jmp unregister_code
 1273               	.LVL107:
 1274               		.cfi_endproc
 1275               	.LFE40:
 1277               		.section	.text.send_string_with_delay,"ax",@progbits
 1278               	.global	send_string_with_delay
 1280               	send_string_with_delay:
 1281               	.LFB38:
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 1282               		.loc 1 722 0
 1283               		.cfi_startproc
 1284               	.LVL108:
 1285 0000 FF92      		push r15
 1286               	.LCFI13:
 1287               		.cfi_def_cfa_offset 3
 1288               		.cfi_offset 15, -2
 1289 0002 0F93      		push r16
 1290               	.LCFI14:
 1291               		.cfi_def_cfa_offset 4
 1292               		.cfi_offset 16, -3
 1293 0004 1F93      		push r17
 1294               	.LCFI15:
 1295               		.cfi_def_cfa_offset 5
 1296               		.cfi_offset 17, -4
 1297 0006 CF93      		push r28
 1298               	.LCFI16:
 1299               		.cfi_def_cfa_offset 6
 1300               		.cfi_offset 28, -5
 1301 0008 DF93      		push r29
 1302               	.LCFI17:
 1303               		.cfi_def_cfa_offset 7
 1304               		.cfi_offset 29, -6
 1305               	/* prologue: function */
 1306               	/* frame size = 0 */
 1307               	/* stack size = 5 */
 1308               	.L__stack_usage = 5
 1309 000a EC01      		movw r28,r24
 1310 000c F62E      		mov r15,r22
 1311               	.LVL109:
 1312               	.L151:
 1313               	.LBB36:
 724:quantum/quantum.c ****         char ascii_code = *str;
 1314               		.loc 1 724 0
 1315 000e 8881      		ld r24,Y
 1316               	.LVL110:
 725:quantum/quantum.c ****         if (!ascii_code) break;
 1317               		.loc 1 725 0
 1318 0010 8823      		tst r24
 1319 0012 01F0      		breq .L143
 1320 0014 8E01      		movw r16,r28
 1321 0016 0F5F      		subi r16,-1
 1322 0018 1F4F      		sbci r17,-1
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 1323               		.loc 1 726 0
 1324 001a 8130      		cpi r24,lo8(1)
 1325 001c 01F4      		brne .L145
 1326               	.LVL111:
 1327               	.LBB37:
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 1328               		.loc 1 728 0
 1329 001e C981      		ldd r28,Y+1
 1330               	.LVL112:
 729:quantum/quantum.c ****           register_code(keycode);
 1331               		.loc 1 729 0
 1332 0020 8C2F      		mov r24,r28
 1333               	.LVL113:
 1334 0022 0E94 0000 		call register_code
 1335               	.LVL114:
 730:quantum/quantum.c ****           unregister_code(keycode);
 1336               		.loc 1 730 0
 1337 0026 8C2F      		mov r24,r28
 1338 0028 00C0      		rjmp .L153
 1339               	.LVL115:
 1340               	.L145:
 1341               	.LBE37:
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1342               		.loc 1 731 0
 1343 002a 8230      		cpi r24,lo8(2)
 1344 002c 01F4      		brne .L147
 1345               	.LVL116:
 1346               	.LBB38:
 734:quantum/quantum.c ****           register_code(keycode);
 1347               		.loc 1 734 0
 1348 002e 8981      		ldd r24,Y+1
 1349               	.LVL117:
 1350 0030 0E94 0000 		call register_code
 1351               	.LVL118:
 1352               	.L152:
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 1353               		.loc 1 733 0
 1354 0034 E801      		movw r28,r16
 1355               	.LBE38:
 1356 0036 00C0      		rjmp .L146
 1357               	.LVL119:
 1358               	.L147:
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1359               		.loc 1 735 0
 1360 0038 8330      		cpi r24,lo8(3)
 1361 003a 01F4      		brne .L148
 1362               	.LVL120:
 1363               	.LBB39:
 738:quantum/quantum.c ****           unregister_code(keycode);
 1364               		.loc 1 738 0
 1365 003c 8981      		ldd r24,Y+1
 1366               	.LVL121:
 1367               	.L153:
 1368 003e 0E94 0000 		call unregister_code
 1369               	.LVL122:
 1370 0042 00C0      		rjmp .L152
 1371               	.LVL123:
 1372               	.L148:
 1373               	.LBE39:
 740:quantum/quantum.c ****           send_char(ascii_code);
 1374               		.loc 1 740 0
 1375 0044 0E94 0000 		call send_char
 1376               	.LVL124:
 1377               	.L146:
 742:quantum/quantum.c ****         ++str;
 1378               		.loc 1 742 0
 1379 0048 2196      		adiw r28,1
 1380               	.LVL125:
 1381               	.LBB40:
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1382               		.loc 1 744 0
 1383 004a 8F2D      		mov r24,r15
 1384               	.LVL126:
 1385               	.L149:
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1386               		.loc 1 744 0 is_stmt 0 discriminator 1
 1387 004c 8823      		tst r24
 1388 004e 01F0      		breq .L151
 1389               	.LVL127:
 1390               	.LBB41:
 1391               	.LBB42:
 1392               		.loc 3 164 0 is_stmt 1
 1393 0050 EFE9      		ldi r30,lo8(3999)
 1394 0052 FFE0      		ldi r31,hi8(3999)
 1395 0054 3197      		1: sbiw r30,1
 1396 0056 01F4      		brne 1b
 1397 0058 00C0      		rjmp .
 1398 005a 0000      		nop
 1399 005c 8150      		subi r24,lo8(-(-1))
 1400               	.LVL128:
 1401 005e 00C0      		rjmp .L149
 1402               	.LVL129:
 1403               	.L143:
 1404               	/* epilogue start */
 1405               	.LBE42:
 1406               	.LBE41:
 1407               	.LBE40:
 1408               	.LBE36:
 746:quantum/quantum.c **** }
 1409               		.loc 1 746 0
 1410 0060 DF91      		pop r29
 1411 0062 CF91      		pop r28
 1412               	.LVL130:
 1413 0064 1F91      		pop r17
 1414 0066 0F91      		pop r16
 1415 0068 FF90      		pop r15
 1416               	.LVL131:
 1417 006a 0895      		ret
 1418               		.cfi_endproc
 1419               	.LFE38:
 1421               		.section	.text.send_string,"ax",@progbits
 1422               	.global	send_string
 1424               	send_string:
 1425               	.LFB36:
 714:quantum/quantum.c **** void send_string(const char *str) {
 1426               		.loc 1 714 0
 1427               		.cfi_startproc
 1428               	.LVL132:
 1429               	/* prologue: function */
 1430               	/* frame size = 0 */
 1431               	/* stack size = 0 */
 1432               	.L__stack_usage = 0
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 1433               		.loc 1 715 0
 1434 0000 60E0      		ldi r22,0
 1435 0002 0C94 0000 		jmp send_string_with_delay
 1436               	.LVL133:
 1437               		.cfi_endproc
 1438               	.LFE36:
 1440               		.section	.text.send_string_with_delay_P,"ax",@progbits
 1441               	.global	send_string_with_delay_P
 1443               	send_string_with_delay_P:
 1444               	.LFB39:
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 1445               		.loc 1 748 0
 1446               		.cfi_startproc
 1447               	.LVL134:
 1448 0000 0F93      		push r16
 1449               	.LCFI18:
 1450               		.cfi_def_cfa_offset 3
 1451               		.cfi_offset 16, -2
 1452 0002 1F93      		push r17
 1453               	.LCFI19:
 1454               		.cfi_def_cfa_offset 4
 1455               		.cfi_offset 17, -3
 1456 0004 CF93      		push r28
 1457               	.LCFI20:
 1458               		.cfi_def_cfa_offset 5
 1459               		.cfi_offset 28, -4
 1460 0006 DF93      		push r29
 1461               	.LCFI21:
 1462               		.cfi_def_cfa_offset 6
 1463               		.cfi_offset 29, -5
 1464               	/* prologue: function */
 1465               	/* frame size = 0 */
 1466               	/* stack size = 4 */
 1467               	.L__stack_usage = 4
 1468 0008 EC01      		movw r28,r24
 1469 000a 062F      		mov r16,r22
 1470               	.LVL135:
 1471               	.L163:
 1472               	.LBB43:
 1473               	.LBB44:
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 1474               		.loc 1 750 0
 1475 000c FE01      		movw r30,r28
 1476               	/* #APP */
 1477               	 ;  750 "quantum/quantum.c" 1
 1478 000e 8491      		lpm r24, Z
 1479               		
 1480               	 ;  0 "" 2
 1481               	.LVL136:
 1482               	/* #NOAPP */
 1483               	.LBE44:
 751:quantum/quantum.c ****         if (!ascii_code) break;
 1484               		.loc 1 751 0
 1485 0010 8823      		tst r24
 1486 0012 01F0      		breq .L155
 1487 0014 9E01      		movw r18,r28
 1488 0016 2F5F      		subi r18,-1
 1489 0018 3F4F      		sbci r19,-1
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 1490               		.loc 1 752 0
 1491 001a 8130      		cpi r24,lo8(1)
 1492 001c 01F4      		brne .L157
 1493               	.LBB45:
 1494               	.LBB46:
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1495               		.loc 1 754 0
 1496 001e E901      		movw r28,r18
 1497               	.LVL137:
 1498 0020 F901      		movw r30,r18
 1499               	.LVL138:
 1500               	/* #APP */
 1501               	 ;  754 "quantum/quantum.c" 1
 1502 0022 1491      		lpm r17, Z
 1503               		
 1504               	 ;  0 "" 2
 1505               	.LVL139:
 1506               	/* #NOAPP */
 1507               	.LBE46:
 755:quantum/quantum.c ****           register_code(keycode);
 1508               		.loc 1 755 0
 1509 0024 812F      		mov r24,r17
 1510               	.LVL140:
 1511 0026 0E94 0000 		call register_code
 1512               	.LVL141:
 756:quantum/quantum.c ****           unregister_code(keycode);
 1513               		.loc 1 756 0
 1514 002a 812F      		mov r24,r17
 1515 002c 00C0      		rjmp .L164
 1516               	.LVL142:
 1517               	.L157:
 1518               	.LBE45:
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1519               		.loc 1 757 0
 1520 002e 8230      		cpi r24,lo8(2)
 1521 0030 01F4      		brne .L159
 1522               	.LBB47:
 1523               	.LBB48:
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1524               		.loc 1 759 0
 1525 0032 E901      		movw r28,r18
 1526               	.LVL143:
 1527 0034 F901      		movw r30,r18
 1528               	.LVL144:
 1529               	/* #APP */
 1530               	 ;  759 "quantum/quantum.c" 1
 1531 0036 8491      		lpm r24, Z
 1532               		
 1533               	 ;  0 "" 2
 1534               	.LVL145:
 1535               	/* #NOAPP */
 1536               	.LBE48:
 760:quantum/quantum.c ****           register_code(keycode);
 1537               		.loc 1 760 0
 1538 0038 0E94 0000 		call register_code
 1539               	.LVL146:
 1540               	.LBE47:
 1541 003c 00C0      		rjmp .L158
 1542               	.LVL147:
 1543               	.L159:
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1544               		.loc 1 761 0
 1545 003e 8330      		cpi r24,lo8(3)
 1546 0040 01F4      		brne .L160
 1547               	.LBB49:
 1548               	.LBB50:
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1549               		.loc 1 763 0
 1550 0042 E901      		movw r28,r18
 1551               	.LVL148:
 1552 0044 F901      		movw r30,r18
 1553               	.LVL149:
 1554               	/* #APP */
 1555               	 ;  763 "quantum/quantum.c" 1
 1556 0046 8491      		lpm r24, Z
 1557               		
 1558               	 ;  0 "" 2
 1559               	.LVL150:
 1560               	/* #NOAPP */
 1561               	.L164:
 1562               	.LBE50:
 764:quantum/quantum.c ****           unregister_code(keycode);
 1563               		.loc 1 764 0
 1564 0048 0E94 0000 		call unregister_code
 1565               	.LVL151:
 1566               	.LBE49:
 1567 004c 00C0      		rjmp .L158
 1568               	.LVL152:
 1569               	.L160:
 766:quantum/quantum.c ****           send_char(ascii_code);
 1570               		.loc 1 766 0
 1571 004e 0E94 0000 		call send_char
 1572               	.LVL153:
 1573               	.L158:
 768:quantum/quantum.c ****         ++str;
 1574               		.loc 1 768 0
 1575 0052 2196      		adiw r28,1
 1576               	.LVL154:
 1577               	.LBB51:
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1578               		.loc 1 770 0
 1579 0054 802F      		mov r24,r16
 1580               	.LVL155:
 1581               	.L161:
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1582               		.loc 1 770 0 is_stmt 0 discriminator 1
 1583 0056 8823      		tst r24
 1584 0058 01F0      		breq .L163
 1585               	.LVL156:
 1586               	.LBB52:
 1587               	.LBB53:
 1588               		.loc 3 164 0 is_stmt 1
 1589 005a EFE9      		ldi r30,lo8(3999)
 1590 005c FFE0      		ldi r31,hi8(3999)
 1591 005e 3197      		1: sbiw r30,1
 1592 0060 01F4      		brne 1b
 1593 0062 00C0      		rjmp .
 1594 0064 0000      		nop
 1595 0066 8150      		subi r24,lo8(-(-1))
 1596               	.LVL157:
 1597 0068 00C0      		rjmp .L161
 1598               	.LVL158:
 1599               	.L155:
 1600               	/* epilogue start */
 1601               	.LBE53:
 1602               	.LBE52:
 1603               	.LBE51:
 1604               	.LBE43:
 772:quantum/quantum.c **** }
 1605               		.loc 1 772 0
 1606 006a DF91      		pop r29
 1607 006c CF91      		pop r28
 1608               	.LVL159:
 1609 006e 1F91      		pop r17
 1610 0070 0F91      		pop r16
 1611               	.LVL160:
 1612 0072 0895      		ret
 1613               		.cfi_endproc
 1614               	.LFE39:
 1616               		.section	.text.send_string_P,"ax",@progbits
 1617               	.global	send_string_P
 1619               	send_string_P:
 1620               	.LFB37:
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 1621               		.loc 1 718 0
 1622               		.cfi_startproc
 1623               	.LVL161:
 1624               	/* prologue: function */
 1625               	/* frame size = 0 */
 1626               	/* stack size = 0 */
 1627               	.L__stack_usage = 0
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1628               		.loc 1 719 0
 1629 0000 60E0      		ldi r22,0
 1630 0002 0C94 0000 		jmp send_string_with_delay_P
 1631               	.LVL162:
 1632               		.cfi_endproc
 1633               	.LFE37:
 1635               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1636               	.global	set_single_persistent_default_layer
 1638               	set_single_persistent_default_layer:
 1639               	.LFB41:
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1640               		.loc 1 788 0
 1641               		.cfi_startproc
 1642               	.LVL163:
 1643 0000 CF93      		push r28
 1644               	.LCFI22:
 1645               		.cfi_def_cfa_offset 3
 1646               		.cfi_offset 28, -2
 1647 0002 DF93      		push r29
 1648               	.LCFI23:
 1649               		.cfi_def_cfa_offset 4
 1650               		.cfi_offset 29, -3
 1651               	/* prologue: function */
 1652               	/* frame size = 0 */
 1653               	/* stack size = 2 */
 1654               	.L__stack_usage = 2
 789:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 790:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 791:quantum/quantum.c ****   #endif
 792:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1655               		.loc 1 792 0
 1656 0004 C1E0      		ldi r28,lo8(1)
 1657 0006 D0E0      		ldi r29,0
 1658 0008 00C0      		rjmp 2f
 1659               		1:
 1660 000a CC0F      		lsl r28
 1661 000c DD1F      		rol r29
 1662               		2:
 1663 000e 8A95      		dec r24
 1664 0010 02F4      		brpl 1b
 1665 0012 8C2F      		mov r24,r28
 1666               	.LVL164:
 1667 0014 0E94 0000 		call eeconfig_update_default_layer
 1668               	.LVL165:
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1669               		.loc 1 793 0
 1670 0018 BE01      		movw r22,r28
 1671 001a 80E0      		ldi r24,0
 1672 001c 90E0      		ldi r25,0
 1673               	/* epilogue start */
 794:quantum/quantum.c **** }
 1674               		.loc 1 794 0
 1675 001e DF91      		pop r29
 1676 0020 CF91      		pop r28
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1677               		.loc 1 793 0
 1678 0022 0C94 0000 		jmp default_layer_set
 1679               	.LVL166:
 1680               		.cfi_endproc
 1681               	.LFE41:
 1683               		.section	.text.update_tri_layer_state,"ax",@progbits
 1684               	.global	update_tri_layer_state
 1686               	update_tri_layer_state:
 1687               	.LFB42:
 795:quantum/quantum.c **** 
 796:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1688               		.loc 1 796 0
 1689               		.cfi_startproc
 1690               	.LVL167:
 1691 0000 4F92      		push r4
 1692               	.LCFI24:
 1693               		.cfi_def_cfa_offset 3
 1694               		.cfi_offset 4, -2
 1695 0002 5F92      		push r5
 1696               	.LCFI25:
 1697               		.cfi_def_cfa_offset 4
 1698               		.cfi_offset 5, -3
 1699 0004 6F92      		push r6
 1700               	.LCFI26:
 1701               		.cfi_def_cfa_offset 5
 1702               		.cfi_offset 6, -4
 1703 0006 7F92      		push r7
 1704               	.LCFI27:
 1705               		.cfi_def_cfa_offset 6
 1706               		.cfi_offset 7, -5
 1707 0008 8F92      		push r8
 1708               	.LCFI28:
 1709               		.cfi_def_cfa_offset 7
 1710               		.cfi_offset 8, -6
 1711 000a 9F92      		push r9
 1712               	.LCFI29:
 1713               		.cfi_def_cfa_offset 8
 1714               		.cfi_offset 9, -7
 1715 000c AF92      		push r10
 1716               	.LCFI30:
 1717               		.cfi_def_cfa_offset 9
 1718               		.cfi_offset 10, -8
 1719 000e BF92      		push r11
 1720               	.LCFI31:
 1721               		.cfi_def_cfa_offset 10
 1722               		.cfi_offset 11, -9
 1723 0010 CF92      		push r12
 1724               	.LCFI32:
 1725               		.cfi_def_cfa_offset 11
 1726               		.cfi_offset 12, -10
 1727 0012 DF92      		push r13
 1728               	.LCFI33:
 1729               		.cfi_def_cfa_offset 12
 1730               		.cfi_offset 13, -11
 1731 0014 EF92      		push r14
 1732               	.LCFI34:
 1733               		.cfi_def_cfa_offset 13
 1734               		.cfi_offset 14, -12
 1735 0016 FF92      		push r15
 1736               	.LCFI35:
 1737               		.cfi_def_cfa_offset 14
 1738               		.cfi_offset 15, -13
 1739 0018 0F93      		push r16
 1740               	.LCFI36:
 1741               		.cfi_def_cfa_offset 15
 1742               		.cfi_offset 16, -14
 1743 001a 1F93      		push r17
 1744               	.LCFI37:
 1745               		.cfi_def_cfa_offset 16
 1746               		.cfi_offset 17, -15
 1747               	/* prologue: function */
 1748               	/* frame size = 0 */
 1749               	/* stack size = 14 */
 1750               	.L__stack_usage = 14
 1751 001c 2B01      		movw r4,r22
 1752 001e 3C01      		movw r6,r24
 797:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 1753               		.loc 1 797 0
 1754 0020 C12C      		mov r12,__zero_reg__
 1755 0022 D12C      		mov r13,__zero_reg__
 1756 0024 7601      		movw r14,r12
 1757 0026 C394      		inc r12
 1758 0028 D701      		movw r26,r14
 1759 002a C601      		movw r24,r12
 1760 002c 00C0      		rjmp 2f
 1761               		1:
 1762 002e 880F      		lsl r24
 1763 0030 991F      		rol r25
 1764 0032 AA1F      		rol r26
 1765 0034 BB1F      		rol r27
 1766               		2:
 1767 0036 4A95      		dec r20
 1768 0038 02F4      		brpl 1b
 1769 003a AC01      		movw r20,r24
 1770 003c BD01      		movw r22,r26
 1771               	.LVL168:
 1772 003e 4601      		movw r8,r12
 1773 0040 5701      		movw r10,r14
 1774 0042 00C0      		rjmp 2f
 1775               		1:
 1776 0044 880C      		lsl r8
 1777 0046 991C      		rol r9
 1778 0048 AA1C      		rol r10
 1779 004a BB1C      		rol r11
 1780               		2:
 1781 004c 2A95      		dec r18
 1782 004e 02F4      		brpl 1b
 1783 0050 4829      		or r20,r8
 1784 0052 5929      		or r21,r9
 1785 0054 6A29      		or r22,r10
 1786 0056 7B29      		or r23,r11
 1787               	.LVL169:
 798:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 1788               		.loc 1 798 0
 1789 0058 D701      		movw r26,r14
 1790 005a C601      		movw r24,r12
 1791 005c 00C0      		rjmp 2f
 1792               		1:
 1793 005e 880F      		lsl r24
 1794 0060 991F      		rol r25
 1795 0062 AA1F      		rol r26
 1796 0064 BB1F      		rol r27
 1797               		2:
 1798 0066 0A95      		dec r16
 1799 0068 02F4      		brpl 1b
 1800               	.LVL170:
 799:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1801               		.loc 1 799 0
 1802 006a 6A01      		movw r12,r20
 1803 006c 7B01      		movw r14,r22
 1804 006e C420      		and r12,r4
 1805 0070 D520      		and r13,r5
 1806 0072 E620      		and r14,r6
 1807 0074 F720      		and r15,r7
 1808 0076 C416      		cp r12,r20
 1809 0078 D506      		cpc r13,r21
 1810 007a E606      		cpc r14,r22
 1811 007c F706      		cpc r15,r23
 1812 007e 01F4      		brne .L168
 1813               		.loc 1 799 0 is_stmt 0 discriminator 1
 1814 0080 BC01      		movw r22,r24
 1815 0082 CD01      		movw r24,r26
 1816               	.LVL171:
 1817 0084 6429      		or r22,r4
 1818 0086 7529      		or r23,r5
 1819 0088 8629      		or r24,r6
 1820 008a 9729      		or r25,r7
 1821 008c 00C0      		rjmp .L169
 1822               	.L168:
 1823               		.loc 1 799 0 discriminator 2
 1824 008e BC01      		movw r22,r24
 1825 0090 CD01      		movw r24,r26
 1826 0092 6095      		com r22
 1827 0094 7095      		com r23
 1828 0096 8095      		com r24
 1829 0098 9095      		com r25
 1830 009a 6421      		and r22,r4
 1831 009c 7521      		and r23,r5
 1832 009e 8621      		and r24,r6
 1833 00a0 9721      		and r25,r7
 1834               	.L169:
 1835               	/* epilogue start */
 800:quantum/quantum.c **** }
 1836               		.loc 1 800 0 is_stmt 1 discriminator 3
 1837 00a2 1F91      		pop r17
 1838 00a4 0F91      		pop r16
 1839               	.LVL172:
 1840 00a6 FF90      		pop r15
 1841               	.LVL173:
 1842 00a8 EF90      		pop r14
 1843               	.LVL174:
 1844 00aa DF90      		pop r13
 1845               	.LVL175:
 1846 00ac CF90      		pop r12
 1847               	.LVL176:
 1848 00ae BF90      		pop r11
 1849               	.LVL177:
 1850 00b0 AF90      		pop r10
 1851               	.LVL178:
 1852 00b2 9F90      		pop r9
 1853               	.LVL179:
 1854 00b4 8F90      		pop r8
 1855               	.LVL180:
 1856 00b6 7F90      		pop r7
 1857               	.LVL181:
 1858 00b8 6F90      		pop r6
 1859               	.LVL182:
 1860 00ba 5F90      		pop r5
 1861               	.LVL183:
 1862 00bc 4F90      		pop r4
 1863               	.LVL184:
 1864 00be 0895      		ret
 1865               		.cfi_endproc
 1866               	.LFE42:
 1868               		.section	.text.update_tri_layer,"ax",@progbits
 1869               	.global	update_tri_layer
 1871               	update_tri_layer:
 1872               	.LFB43:
 801:quantum/quantum.c **** 
 802:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1873               		.loc 1 802 0
 1874               		.cfi_startproc
 1875               	.LVL185:
 1876 0000 0F93      		push r16
 1877               	.LCFI38:
 1878               		.cfi_def_cfa_offset 3
 1879               		.cfi_offset 16, -2
 1880               	/* prologue: function */
 1881               	/* frame size = 0 */
 1882               	/* stack size = 1 */
 1883               	.L__stack_usage = 1
 1884 0002 382F      		mov r19,r24
 1885 0004 262F      		mov r18,r22
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1886               		.loc 1 803 0
 1887 0006 6091 0000 		lds r22,layer_state
 1888 000a 7091 0000 		lds r23,layer_state+1
 1889 000e 8091 0000 		lds r24,layer_state+2
 1890 0012 9091 0000 		lds r25,layer_state+3
 1891               	.LVL186:
 1892 0016 042F      		mov r16,r20
 1893 0018 432F      		mov r20,r19
 1894               	.LVL187:
 1895 001a 0E94 0000 		call update_tri_layer_state
 1896               	.LVL188:
 1897               	/* epilogue start */
 804:quantum/quantum.c **** }
 1898               		.loc 1 804 0
 1899 001e 0F91      		pop r16
 1900               	.LVL189:
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1901               		.loc 1 803 0
 1902 0020 0C94 0000 		jmp layer_state_set
 1903               	.LVL190:
 1904               		.cfi_endproc
 1905               	.LFE43:
 1907               		.section	.text.tap_random_base64,"ax",@progbits
 1908               	.global	tap_random_base64
 1910               	tap_random_base64:
 1911               	.LFB44:
 805:quantum/quantum.c **** 
 806:quantum/quantum.c **** void tap_random_base64(void) {
 1912               		.loc 1 806 0
 1913               		.cfi_startproc
 1914 0000 CF93      		push r28
 1915               	.LCFI39:
 1916               		.cfi_def_cfa_offset 3
 1917               		.cfi_offset 28, -2
 1918               	/* prologue: function */
 1919               	/* frame size = 0 */
 1920               	/* stack size = 1 */
 1921               	.L__stack_usage = 1
 807:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 808:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1922               		.loc 1 808 0
 1923 0002 66B5      		in r22,0x26
 1924 0004 4091 8400 		lds r20,132
 1925 0008 5091 8500 		lds r21,132+1
 1926 000c 8091 9400 		lds r24,148
 1927 0010 9091 9500 		lds r25,148+1
 1928 0014 2091 BE00 		lds r18,190
 1929 0018 3091 BF00 		lds r19,190+1
 1930 001c C42F      		mov r28,r20
 1931 001e C80F      		add r28,r24
 1932 0020 C60F      		add r28,r22
 1933 0022 C20F      		add r28,r18
 1934 0024 CF73      		andi r28,lo8(63)
 1935               	.LVL191:
 809:quantum/quantum.c ****   #else
 810:quantum/quantum.c ****     uint8_t key = rand() % 64;
 811:quantum/quantum.c ****   #endif
 812:quantum/quantum.c ****   switch (key) {
 1936               		.loc 1 812 0
 1937 0026 CE33      		cpi r28,lo8(62)
 1938 0028 00F4      		brsh .L173
 1939 002a C533      		cpi r28,lo8(53)
 1940 002c 00F4      		brsh .L174
 1941 002e CA31      		cpi r28,lo8(26)
 1942 0030 00F0      		brlo .L172
 1943 0032 C433      		cpi r28,lo8(52)
 1944 0034 00F4      		brsh .L179
 813:quantum/quantum.c ****     case 0 ... 25:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 815:quantum/quantum.c ****       register_code(key + KC_A);
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 817:quantum/quantum.c ****       unregister_code(KC_LSFT);
 818:quantum/quantum.c ****       break;
 819:quantum/quantum.c ****     case 26 ... 51:
 820:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 1945               		.loc 1 820 0
 1946 0036 C651      		subi r28,lo8(-(-22))
 1947               	.LVL192:
 1948 0038 00C0      		rjmp .L182
 1949               	.LVL193:
 1950               	.L173:
 812:quantum/quantum.c ****   switch (key) {
 1951               		.loc 1 812 0
 1952 003a CE33      		cpi r28,lo8(62)
 1953 003c 01F0      		breq .L177
 1954 003e CF33      		cpi r28,lo8(63)
 1955 0040 01F0      		breq .L178
 1956               	.L172:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 1957               		.loc 1 814 0
 1958 0042 81EE      		ldi r24,lo8(-31)
 1959 0044 0E94 0000 		call register_code
 1960               	.LVL194:
 815:quantum/quantum.c ****       register_code(key + KC_A);
 1961               		.loc 1 815 0
 1962 0048 CC5F      		subi r28,lo8(-(4))
 1963               	.LVL195:
 1964 004a 8C2F      		mov r24,r28
 1965 004c 0E94 0000 		call register_code
 1966               	.LVL196:
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 1967               		.loc 1 816 0
 1968 0050 8C2F      		mov r24,r28
 1969 0052 00C0      		rjmp .L181
 1970               	.LVL197:
 1971               	.L179:
 821:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 822:quantum/quantum.c ****       break;
 823:quantum/quantum.c ****     case 52:
 824:quantum/quantum.c ****       register_code(KC_0);
 1972               		.loc 1 824 0
 1973 0054 87E2      		ldi r24,lo8(39)
 1974 0056 0E94 0000 		call register_code
 1975               	.LVL198:
 825:quantum/quantum.c ****       unregister_code(KC_0);
 1976               		.loc 1 825 0
 1977 005a 87E2      		ldi r24,lo8(39)
 1978 005c 00C0      		rjmp .L180
 1979               	.L174:
 826:quantum/quantum.c ****       break;
 827:quantum/quantum.c ****     case 53 ... 61:
 828:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 1980               		.loc 1 828 0
 1981 005e C751      		subi r28,lo8(-(-23))
 1982               	.LVL199:
 1983               	.L182:
 1984 0060 8C2F      		mov r24,r28
 1985               	.LVL200:
 1986 0062 0E94 0000 		call register_code
 1987               	.LVL201:
 829:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1988               		.loc 1 829 0
 1989 0066 8C2F      		mov r24,r28
 1990 0068 00C0      		rjmp .L180
 1991               	.LVL202:
 1992               	.L177:
 830:quantum/quantum.c ****       break;
 831:quantum/quantum.c ****     case 62:
 832:quantum/quantum.c ****       register_code(KC_LSFT);
 1993               		.loc 1 832 0
 1994 006a 81EE      		ldi r24,lo8(-31)
 1995 006c 0E94 0000 		call register_code
 1996               	.LVL203:
 833:quantum/quantum.c ****       register_code(KC_EQL);
 1997               		.loc 1 833 0
 1998 0070 8EE2      		ldi r24,lo8(46)
 1999 0072 0E94 0000 		call register_code
 2000               	.LVL204:
 834:quantum/quantum.c ****       unregister_code(KC_EQL);
 2001               		.loc 1 834 0
 2002 0076 8EE2      		ldi r24,lo8(46)
 2003               	.LVL205:
 2004               	.L181:
 2005 0078 0E94 0000 		call unregister_code
 2006               	.LVL206:
 835:quantum/quantum.c ****       unregister_code(KC_LSFT);
 2007               		.loc 1 835 0
 2008 007c 81EE      		ldi r24,lo8(-31)
 2009 007e 00C0      		rjmp .L180
 2010               	.LVL207:
 2011               	.L178:
 836:quantum/quantum.c ****       break;
 837:quantum/quantum.c ****     case 63:
 838:quantum/quantum.c ****       register_code(KC_SLSH);
 2012               		.loc 1 838 0
 2013 0080 88E3      		ldi r24,lo8(56)
 2014 0082 0E94 0000 		call register_code
 2015               	.LVL208:
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2016               		.loc 1 839 0
 2017 0086 88E3      		ldi r24,lo8(56)
 2018               	.LVL209:
 2019               	.L180:
 2020               	/* epilogue start */
 840:quantum/quantum.c ****       break;
 841:quantum/quantum.c ****   }
 842:quantum/quantum.c **** }
 2021               		.loc 1 842 0
 2022 0088 CF91      		pop r28
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2023               		.loc 1 839 0
 2024 008a 0C94 0000 		jmp unregister_code
 2025               	.LVL210:
 2026               		.cfi_endproc
 2027               	.LFE44:
 2029               		.section	.text.matrix_init_quantum,"ax",@progbits
 2030               	.global	matrix_init_quantum
 2032               	matrix_init_quantum:
 2033               	.LFB45:
 843:quantum/quantum.c **** 
 844:quantum/quantum.c **** void matrix_init_quantum() {
 2034               		.loc 1 844 0
 2035               		.cfi_startproc
 2036               	/* prologue: function */
 2037               	/* frame size = 0 */
 2038               	/* stack size = 0 */
 2039               	.L__stack_usage = 0
 845:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 846:quantum/quantum.c ****     backlight_init_ports();
 847:quantum/quantum.c ****   #endif
 848:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 849:quantum/quantum.c ****     audio_init();
 850:quantum/quantum.c ****   #endif
 851:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 852:quantum/quantum.c ****     rgb_matrix_init_drivers();
 853:quantum/quantum.c ****   #endif
 854:quantum/quantum.c ****   matrix_init_kb();
 2040               		.loc 1 854 0
 2041 0000 0C94 0000 		jmp matrix_init_kb
 2042               	.LVL211:
 2043               		.cfi_endproc
 2044               	.LFE45:
 2046               		.section	.text.matrix_scan_quantum,"ax",@progbits
 2047               	.global	matrix_scan_quantum
 2049               	matrix_scan_quantum:
 2050               	.LFB46:
 855:quantum/quantum.c **** }
 856:quantum/quantum.c **** 
 857:quantum/quantum.c **** uint8_t rgb_matrix_task_counter = 0;
 858:quantum/quantum.c **** 
 859:quantum/quantum.c **** #ifndef RGB_MATRIX_SKIP_FRAMES
 860:quantum/quantum.c ****   #define RGB_MATRIX_SKIP_FRAMES 1
 861:quantum/quantum.c **** #endif
 862:quantum/quantum.c **** 
 863:quantum/quantum.c **** void matrix_scan_quantum() {
 2051               		.loc 1 863 0
 2052               		.cfi_startproc
 2053               	/* prologue: function */
 2054               	/* frame size = 0 */
 2055               	/* stack size = 0 */
 2056               	.L__stack_usage = 0
 864:quantum/quantum.c ****   #if defined(AUDIO_ENABLE)
 865:quantum/quantum.c ****     matrix_scan_music();
 866:quantum/quantum.c ****   #endif
 867:quantum/quantum.c **** 
 868:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 869:quantum/quantum.c ****     matrix_scan_tap_dance();
 2057               		.loc 1 869 0
 2058 0000 0E94 0000 		call matrix_scan_tap_dance
 2059               	.LVL212:
 870:quantum/quantum.c ****   #endif
 871:quantum/quantum.c **** 
 872:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 873:quantum/quantum.c ****     matrix_scan_combo();
 874:quantum/quantum.c ****   #endif
 875:quantum/quantum.c **** 
 876:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 877:quantum/quantum.c ****     backlight_task();
 878:quantum/quantum.c ****   #endif
 879:quantum/quantum.c **** 
 880:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 881:quantum/quantum.c ****     rgb_matrix_task();
 882:quantum/quantum.c ****     if (rgb_matrix_task_counter == 0) {
 883:quantum/quantum.c ****       rgb_matrix_update_pwm_buffers();
 884:quantum/quantum.c ****     }
 885:quantum/quantum.c ****     rgb_matrix_task_counter = ((rgb_matrix_task_counter + 1) % (RGB_MATRIX_SKIP_FRAMES + 1));
 886:quantum/quantum.c ****   #endif
 887:quantum/quantum.c **** 
 888:quantum/quantum.c ****   matrix_scan_kb();
 2060               		.loc 1 888 0
 2061 0004 0C94 0000 		jmp matrix_scan_kb
 2062               	.LVL213:
 2063               		.cfi_endproc
 2064               	.LFE46:
 2066               		.section	.text.backlight_init_ports,"ax",@progbits
 2067               		.weak	backlight_init_ports
 2069               	backlight_init_ports:
 2070               	.LFB47:
 889:quantum/quantum.c **** }
 890:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 891:quantum/quantum.c **** 
 892:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 893:quantum/quantum.c **** 
 894:quantum/quantum.c **** // depending on the pin, we use a different output compare unit
 895:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 896:quantum/quantum.c **** #  define COM1x1 COM1C1
 897:quantum/quantum.c **** #  define OCR1x  OCR1C
 898:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 899:quantum/quantum.c **** #  define COM1x1 COM1B1
 900:quantum/quantum.c **** #  define OCR1x  OCR1B
 901:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 902:quantum/quantum.c **** #  define COM1x1 COM1A1
 903:quantum/quantum.c **** #  define OCR1x  OCR1A
 904:quantum/quantum.c **** #else
 905:quantum/quantum.c **** #  define NO_HARDWARE_PWM
 906:quantum/quantum.c **** #endif
 907:quantum/quantum.c **** 
 908:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
 909:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
 910:quantum/quantum.c **** #endif
 911:quantum/quantum.c **** 
 912:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM // pwm through software
 913:quantum/quantum.c **** 
 914:quantum/quantum.c **** __attribute__ ((weak))
 915:quantum/quantum.c **** void backlight_init_ports(void)
 916:quantum/quantum.c **** {
 917:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
 918:quantum/quantum.c ****   // DDRx |= n
 919:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 920:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
 921:quantum/quantum.c ****     // PORTx &= ~n
 922:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 923:quantum/quantum.c ****   #else
 924:quantum/quantum.c ****     // PORTx |= n
 925:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 926:quantum/quantum.c ****   #endif
 927:quantum/quantum.c **** }
 928:quantum/quantum.c **** 
 929:quantum/quantum.c **** __attribute__ ((weak))
 930:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 931:quantum/quantum.c **** 
 932:quantum/quantum.c **** uint8_t backlight_tick = 0;
 933:quantum/quantum.c **** 
 934:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 935:quantum/quantum.c **** void backlight_task(void) {
 936:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
 937:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 938:quantum/quantum.c ****       // PORTx &= ~n
 939:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 940:quantum/quantum.c ****     #else
 941:quantum/quantum.c ****       // PORTx |= n
 942:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 943:quantum/quantum.c ****     #endif
 944:quantum/quantum.c ****   } else {
 945:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 946:quantum/quantum.c ****       // PORTx |= n
 947:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 948:quantum/quantum.c ****     #else
 949:quantum/quantum.c ****       // PORTx &= ~n
 950:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 951:quantum/quantum.c ****     #endif
 952:quantum/quantum.c ****   }
 953:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
 954:quantum/quantum.c **** }
 955:quantum/quantum.c **** #endif
 956:quantum/quantum.c **** 
 957:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 958:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
 959:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
 960:quantum/quantum.c ****   #endif
 961:quantum/quantum.c **** #endif
 962:quantum/quantum.c **** 
 963:quantum/quantum.c **** #else // pwm through timer
 964:quantum/quantum.c **** 
 965:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
 966:quantum/quantum.c **** 
 967:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
 968:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
 969:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
 970:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 971:quantum/quantum.c ****   else {
 972:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
 973:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
 974:quantum/quantum.c ****     // and revert what we've done again after squaring.
 975:quantum/quantum.c ****     y = y * y * y >> 8;
 976:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 977:quantum/quantum.c ****       return 0xFFFFU;
 978:quantum/quantum.c ****     else
 979:quantum/quantum.c ****       return (uint16_t) y;
 980:quantum/quantum.c ****   }
 981:quantum/quantum.c **** }
 982:quantum/quantum.c **** 
 983:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
 984:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
 985:quantum/quantum.c ****   OCR1x = val;
 986:quantum/quantum.c **** }
 987:quantum/quantum.c **** 
 988:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 989:quantum/quantum.c **** __attribute__ ((weak))
 990:quantum/quantum.c **** void backlight_set(uint8_t level) {
 991:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
 992:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 993:quantum/quantum.c **** 
 994:quantum/quantum.c ****   if (level == 0) {
 995:quantum/quantum.c ****     // Turn off PWM control on backlight pin
 996:quantum/quantum.c ****     TCCR1A &= ~(_BV(COM1x1));
 997:quantum/quantum.c ****   } else {
 998:quantum/quantum.c ****     // Turn on PWM control of backlight pin
 999:quantum/quantum.c ****     TCCR1A |= _BV(COM1x1);
1000:quantum/quantum.c ****   }
1001:quantum/quantum.c ****   // Set the brightness
1002:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
1003:quantum/quantum.c **** }
1004:quantum/quantum.c **** 
1005:quantum/quantum.c **** void backlight_task(void) {}
1006:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1007:quantum/quantum.c **** 
1008:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1009:quantum/quantum.c **** 
1010:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1011:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1012:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1013:quantum/quantum.c **** #define BREATHING_STEPS 128
1014:quantum/quantum.c **** 
1015:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1016:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1017:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1018:quantum/quantum.c **** 
1019:quantum/quantum.c **** bool is_breathing(void) {
1020:quantum/quantum.c ****     return !!(TIMSK1 & _BV(TOIE1));
1021:quantum/quantum.c **** }
1022:quantum/quantum.c **** 
1023:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSK1 |= _BV(TOIE1);} while (0)
1024:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSK1 &= ~_BV(TOIE1);} while (0)
1025:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1026:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1027:quantum/quantum.c **** 
1028:quantum/quantum.c **** void breathing_enable(void)
1029:quantum/quantum.c **** {
1030:quantum/quantum.c ****   breathing_counter = 0;
1031:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1032:quantum/quantum.c ****   breathing_interrupt_enable();
1033:quantum/quantum.c **** }
1034:quantum/quantum.c **** 
1035:quantum/quantum.c **** void breathing_pulse(void)
1036:quantum/quantum.c **** {
1037:quantum/quantum.c ****     if (get_backlight_level() == 0)
1038:quantum/quantum.c ****       breathing_min();
1039:quantum/quantum.c ****     else
1040:quantum/quantum.c ****       breathing_max();
1041:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1042:quantum/quantum.c ****     breathing_interrupt_enable();
1043:quantum/quantum.c **** }
1044:quantum/quantum.c **** 
1045:quantum/quantum.c **** void breathing_disable(void)
1046:quantum/quantum.c **** {
1047:quantum/quantum.c ****     breathing_interrupt_disable();
1048:quantum/quantum.c ****     // Restore backlight level
1049:quantum/quantum.c ****     backlight_set(get_backlight_level());
1050:quantum/quantum.c **** }
1051:quantum/quantum.c **** 
1052:quantum/quantum.c **** void breathing_self_disable(void)
1053:quantum/quantum.c **** {
1054:quantum/quantum.c ****   if (get_backlight_level() == 0)
1055:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1056:quantum/quantum.c ****   else
1057:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1058:quantum/quantum.c **** }
1059:quantum/quantum.c **** 
1060:quantum/quantum.c **** void breathing_toggle(void) {
1061:quantum/quantum.c ****   if (is_breathing())
1062:quantum/quantum.c ****     breathing_disable();
1063:quantum/quantum.c ****   else
1064:quantum/quantum.c ****     breathing_enable();
1065:quantum/quantum.c **** }
1066:quantum/quantum.c **** 
1067:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1068:quantum/quantum.c **** {
1069:quantum/quantum.c ****   if (!value)
1070:quantum/quantum.c ****     value = 1;
1071:quantum/quantum.c ****   breathing_period = value;
1072:quantum/quantum.c **** }
1073:quantum/quantum.c **** 
1074:quantum/quantum.c **** void breathing_period_default(void) {
1075:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1076:quantum/quantum.c **** }
1077:quantum/quantum.c **** 
1078:quantum/quantum.c **** void breathing_period_inc(void)
1079:quantum/quantum.c **** {
1080:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1081:quantum/quantum.c **** }
1082:quantum/quantum.c **** 
1083:quantum/quantum.c **** void breathing_period_dec(void)
1084:quantum/quantum.c **** {
1085:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1086:quantum/quantum.c **** }
1087:quantum/quantum.c **** 
1088:quantum/quantum.c **** /* To generate breathing curve in python:
1089:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1090:quantum/quantum.c ****  */
1091:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1092:quantum/quantum.c **** 
1093:quantum/quantum.c **** // Use this before the cie_lightness function.
1094:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1095:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1096:quantum/quantum.c **** }
1097:quantum/quantum.c **** 
1098:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1099:quantum/quantum.c ****  * about 244 times per second.
1100:quantum/quantum.c ****  */
1101:quantum/quantum.c **** ISR(TIMER1_OVF_vect)
1102:quantum/quantum.c **** {
1103:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1104:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1105:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1106:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1107:quantum/quantum.c **** 
1108:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1109:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1110:quantum/quantum.c ****   {
1111:quantum/quantum.c ****       breathing_interrupt_disable();
1112:quantum/quantum.c ****   }
1113:quantum/quantum.c **** 
1114:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1115:quantum/quantum.c **** }
1116:quantum/quantum.c **** 
1117:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1118:quantum/quantum.c **** 
1119:quantum/quantum.c **** __attribute__ ((weak))
1120:quantum/quantum.c **** void backlight_init_ports(void)
1121:quantum/quantum.c **** {
1122:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1123:quantum/quantum.c ****   // DDRx |= n
1124:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
1125:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1126:quantum/quantum.c ****     // PORTx &= ~n
1127:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1128:quantum/quantum.c ****   #else
1129:quantum/quantum.c ****     // PORTx |= n
1130:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1131:quantum/quantum.c ****   #endif
1132:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1133:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1134:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1135:quantum/quantum.c **** 
1136:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1137:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1138:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1139:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1140:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1141:quantum/quantum.c **** 
1142:quantum/quantum.c ****   /*
1143:quantum/quantum.c ****   14.8.3:
1144:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1145:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1146:quantum/quantum.c ****   */
1147:quantum/quantum.c **** 
1148:quantum/quantum.c ****   TCCR1A = _BV(COM1x1) | _BV(WGM11); // = 0b00001010;
1149:quantum/quantum.c ****   TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1150:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1151:quantum/quantum.c ****   ICR1 = TIMER_TOP;
1152:quantum/quantum.c **** 
1153:quantum/quantum.c ****   backlight_init();
1154:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1155:quantum/quantum.c ****     breathing_enable();
1156:quantum/quantum.c ****   #endif
1157:quantum/quantum.c **** }
1158:quantum/quantum.c **** 
1159:quantum/quantum.c **** #endif // NO_HARDWARE_PWM
1160:quantum/quantum.c **** 
1161:quantum/quantum.c **** #else // backlight
1162:quantum/quantum.c **** 
1163:quantum/quantum.c **** __attribute__ ((weak))
1164:quantum/quantum.c **** void backlight_init_ports(void) {}
 2071               		.loc 1 1164 0
 2072               		.cfi_startproc
 2073               	/* prologue: function */
 2074               	/* frame size = 0 */
 2075               	/* stack size = 0 */
 2076               	.L__stack_usage = 0
 2077 0000 0895      		ret
 2078               		.cfi_endproc
 2079               	.LFE47:
 2081               		.section	.text.backlight_set,"ax",@progbits
 2082               		.weak	backlight_set
 2084               	backlight_set:
 2085               	.LFB48:
1165:quantum/quantum.c **** 
1166:quantum/quantum.c **** __attribute__ ((weak))
1167:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 2086               		.loc 1 1167 0
 2087               		.cfi_startproc
 2088               	.LVL214:
 2089               	/* prologue: function */
 2090               	/* frame size = 0 */
 2091               	/* stack size = 0 */
 2092               	.L__stack_usage = 0
 2093 0000 0895      		ret
 2094               		.cfi_endproc
 2095               	.LFE48:
 2097               		.section	.text.send_nibble,"ax",@progbits
 2098               	.global	send_nibble
 2100               	send_nibble:
 2101               	.LFB52:
1168:quantum/quantum.c **** 
1169:quantum/quantum.c **** #endif // backlight
1170:quantum/quantum.c **** 
1171:quantum/quantum.c **** 
1172:quantum/quantum.c **** // Functions for spitting out values
1173:quantum/quantum.c **** //
1174:quantum/quantum.c **** 
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1176:quantum/quantum.c ****     uint16_t word = (number >> 16);
1177:quantum/quantum.c ****     send_word(word);
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1179:quantum/quantum.c **** }
1180:quantum/quantum.c **** 
1181:quantum/quantum.c **** void send_word(uint16_t number) {
1182:quantum/quantum.c ****     uint8_t byte = number >> 8;
1183:quantum/quantum.c ****     send_byte(byte);
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
1185:quantum/quantum.c **** }
1186:quantum/quantum.c **** 
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
1188:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1189:quantum/quantum.c ****     send_nibble(nibble);
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
1191:quantum/quantum.c **** }
1192:quantum/quantum.c **** 
1193:quantum/quantum.c **** void send_nibble(uint8_t number) {
 2102               		.loc 1 1193 0
 2103               		.cfi_startproc
 2104               	.LVL215:
 2105               		.loc 1 1193 0
 2106 0000 CF93      		push r28
 2107               	.LCFI40:
 2108               		.cfi_def_cfa_offset 3
 2109               		.cfi_offset 28, -2
 2110               	/* prologue: function */
 2111               	/* frame size = 0 */
 2112               	/* stack size = 1 */
 2113               	.L__stack_usage = 1
1194:quantum/quantum.c ****     switch (number) {
 2114               		.loc 1 1194 0
 2115 0002 8A30      		cpi r24,lo8(10)
 2116 0004 00F4      		brsh .L189
 2117 0006 8130      		cpi r24,lo8(1)
 2118 0008 00F4      		brsh .L197
1195:quantum/quantum.c ****         case 0:
1196:quantum/quantum.c ****             register_code(KC_0);
 2119               		.loc 1 1196 0
 2120 000a 87E2      		ldi r24,lo8(39)
 2121               	.LVL216:
 2122 000c 0E94 0000 		call register_code
 2123               	.LVL217:
1197:quantum/quantum.c ****             unregister_code(KC_0);
 2124               		.loc 1 1197 0
 2125 0010 87E2      		ldi r24,lo8(39)
 2126 0012 00C0      		rjmp .L195
 2127               	.LVL218:
 2128               	.L189:
1194:quantum/quantum.c ****     switch (number) {
 2129               		.loc 1 1194 0
 2130 0014 8031      		cpi r24,lo8(16)
 2131 0016 00F4      		brsh .L198
1198:quantum/quantum.c ****             break;
1199:quantum/quantum.c ****         case 1 ... 9:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1201:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1202:quantum/quantum.c ****             break;
1203:quantum/quantum.c ****         case 0xA ... 0xF:
1204:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 2132               		.loc 1 1204 0
 2133 0018 CAEF      		ldi r28,lo8(-6)
 2134 001a 00C0      		rjmp .L196
 2135               	.L197:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
 2136               		.loc 1 1200 0
 2137 001c CDE1      		ldi r28,lo8(29)
 2138               	.L196:
 2139               		.loc 1 1204 0
 2140 001e C80F      		add r28,r24
 2141 0020 8C2F      		mov r24,r28
 2142               	.LVL219:
 2143 0022 0E94 0000 		call register_code
 2144               	.LVL220:
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2145               		.loc 1 1205 0
 2146 0026 8C2F      		mov r24,r28
 2147               	.L195:
 2148               	/* epilogue start */
1206:quantum/quantum.c ****             break;
1207:quantum/quantum.c ****     }
1208:quantum/quantum.c **** }
 2149               		.loc 1 1208 0
 2150 0028 CF91      		pop r28
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2151               		.loc 1 1205 0
 2152 002a 0C94 0000 		jmp unregister_code
 2153               	.LVL221:
 2154               	.L198:
 2155               	/* epilogue start */
 2156               		.loc 1 1208 0
 2157 002e CF91      		pop r28
 2158 0030 0895      		ret
 2159               		.cfi_endproc
 2160               	.LFE52:
 2162               		.section	.text.send_byte,"ax",@progbits
 2163               	.global	send_byte
 2165               	send_byte:
 2166               	.LFB51:
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
 2167               		.loc 1 1187 0
 2168               		.cfi_startproc
 2169               	.LVL222:
 2170 0000 CF93      		push r28
 2171               	.LCFI41:
 2172               		.cfi_def_cfa_offset 3
 2173               		.cfi_offset 28, -2
 2174               	/* prologue: function */
 2175               	/* frame size = 0 */
 2176               	/* stack size = 1 */
 2177               	.L__stack_usage = 1
 2178 0002 C82F      		mov r28,r24
 2179               	.LVL223:
1189:quantum/quantum.c ****     send_nibble(nibble);
 2180               		.loc 1 1189 0
 2181 0004 8295      		swap r24
 2182               	.LVL224:
 2183 0006 8F70      		andi r24,lo8(15)
 2184 0008 0E94 0000 		call send_nibble
 2185               	.LVL225:
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
 2186               		.loc 1 1190 0
 2187 000c 8C2F      		mov r24,r28
 2188 000e 8F70      		andi r24,lo8(15)
 2189               	/* epilogue start */
1191:quantum/quantum.c **** }
 2190               		.loc 1 1191 0
 2191 0010 CF91      		pop r28
 2192               	.LVL226:
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
 2193               		.loc 1 1190 0
 2194 0012 0C94 0000 		jmp send_nibble
 2195               	.LVL227:
 2196               		.cfi_endproc
 2197               	.LFE51:
 2199               		.section	.text.send_word,"ax",@progbits
 2200               	.global	send_word
 2202               	send_word:
 2203               	.LFB50:
1181:quantum/quantum.c **** void send_word(uint16_t number) {
 2204               		.loc 1 1181 0
 2205               		.cfi_startproc
 2206               	.LVL228:
 2207 0000 CF93      		push r28
 2208               	.LCFI42:
 2209               		.cfi_def_cfa_offset 3
 2210               		.cfi_offset 28, -2
 2211               	/* prologue: function */
 2212               	/* frame size = 0 */
 2213               	/* stack size = 1 */
 2214               	.L__stack_usage = 1
 2215 0002 C82F      		mov r28,r24
 2216               	.LVL229:
1183:quantum/quantum.c ****     send_byte(byte);
 2217               		.loc 1 1183 0
 2218 0004 892F      		mov r24,r25
 2219               	.LVL230:
 2220 0006 0E94 0000 		call send_byte
 2221               	.LVL231:
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
 2222               		.loc 1 1184 0
 2223 000a 8C2F      		mov r24,r28
 2224               	/* epilogue start */
1185:quantum/quantum.c **** }
 2225               		.loc 1 1185 0
 2226 000c CF91      		pop r28
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
 2227               		.loc 1 1184 0
 2228 000e 0C94 0000 		jmp send_byte
 2229               	.LVL232:
 2230               		.cfi_endproc
 2231               	.LFE50:
 2233               		.section	.text.send_dword,"ax",@progbits
 2234               	.global	send_dword
 2236               	send_dword:
 2237               	.LFB49:
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
 2238               		.loc 1 1175 0
 2239               		.cfi_startproc
 2240               	.LVL233:
 2241 0000 CF92      		push r12
 2242               	.LCFI43:
 2243               		.cfi_def_cfa_offset 3
 2244               		.cfi_offset 12, -2
 2245 0002 DF92      		push r13
 2246               	.LCFI44:
 2247               		.cfi_def_cfa_offset 4
 2248               		.cfi_offset 13, -3
 2249 0004 EF92      		push r14
 2250               	.LCFI45:
 2251               		.cfi_def_cfa_offset 5
 2252               		.cfi_offset 14, -4
 2253 0006 FF92      		push r15
 2254               	.LCFI46:
 2255               		.cfi_def_cfa_offset 6
 2256               		.cfi_offset 15, -5
 2257               	/* prologue: function */
 2258               	/* frame size = 0 */
 2259               	/* stack size = 4 */
 2260               	.L__stack_usage = 4
 2261 0008 6B01      		movw r12,r22
 2262 000a 7C01      		movw r14,r24
 2263               	.LVL234:
1177:quantum/quantum.c ****     send_word(word);
 2264               		.loc 1 1177 0
 2265 000c C701      		movw r24,r14
 2266 000e 0E94 0000 		call send_word
 2267               	.LVL235:
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2268               		.loc 1 1178 0
 2269 0012 C601      		movw r24,r12
 2270               	/* epilogue start */
1179:quantum/quantum.c **** }
 2271               		.loc 1 1179 0
 2272 0014 FF90      		pop r15
 2273 0016 EF90      		pop r14
 2274 0018 DF90      		pop r13
 2275 001a CF90      		pop r12
 2276               	.LVL236:
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2277               		.loc 1 1178 0
 2278 001c 0C94 0000 		jmp send_word
 2279               	.LVL237:
 2280               		.cfi_endproc
 2281               	.LFE49:
 2283               		.section	.text.hex_to_keycode,"ax",@progbits
 2284               		.weak	hex_to_keycode
 2286               	hex_to_keycode:
 2287               	.LFB53:
1209:quantum/quantum.c **** 
1210:quantum/quantum.c **** 
1211:quantum/quantum.c **** __attribute__((weak))
1212:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1213:quantum/quantum.c **** {
 2288               		.loc 1 1213 0
 2289               		.cfi_startproc
 2290               	.LVL238:
 2291               	/* prologue: function */
 2292               	/* frame size = 0 */
 2293               	/* stack size = 0 */
 2294               	.L__stack_usage = 0
1214:quantum/quantum.c ****   hex = hex & 0xF;
 2295               		.loc 1 1214 0
 2296 0000 282F      		mov r18,r24
 2297 0002 2F70      		andi r18,lo8(15)
 2298               	.LVL239:
1215:quantum/quantum.c ****   if (hex == 0x0) {
 2299               		.loc 1 1215 0
 2300 0004 01F0      		breq .L205
 2301 0006 822F      		mov r24,r18
 2302 0008 90E0      		ldi r25,0
1216:quantum/quantum.c ****     return KC_0;
1217:quantum/quantum.c ****   } else if (hex < 0xA) {
 2303               		.loc 1 1217 0
 2304 000a 2A30      		cpi r18,lo8(10)
 2305 000c 00F4      		brsh .L204
1218:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 2306               		.loc 1 1218 0
 2307 000e 4D96      		adiw r24,29
 2308 0010 0895      		ret
 2309               	.L204:
1219:quantum/quantum.c ****   } else {
1220:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 2310               		.loc 1 1220 0
 2311 0012 0697      		sbiw r24,6
 2312 0014 0895      		ret
 2313               	.L205:
1216:quantum/quantum.c ****     return KC_0;
 2314               		.loc 1 1216 0
 2315 0016 87E2      		ldi r24,lo8(39)
 2316 0018 90E0      		ldi r25,0
1221:quantum/quantum.c ****   }
1222:quantum/quantum.c **** }
 2317               		.loc 1 1222 0
 2318 001a 0895      		ret
 2319               		.cfi_endproc
 2320               	.LFE53:
 2322               		.section	.text.api_send_unicode,"ax",@progbits
 2323               	.global	api_send_unicode
 2325               	api_send_unicode:
 2326               	.LFB54:
1223:quantum/quantum.c **** 
1224:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 2327               		.loc 1 1224 0
 2328               		.cfi_startproc
 2329               	.LVL240:
 2330               	/* prologue: function */
 2331               	/* frame size = 0 */
 2332               	/* stack size = 0 */
 2333               	.L__stack_usage = 0
 2334 0000 0895      		ret
 2335               		.cfi_endproc
 2336               	.LFE54:
 2338               		.section	.text.led_set_user,"ax",@progbits
 2339               		.weak	led_set_user
 2341               	led_set_user:
 2342               	.LFB55:
1225:quantum/quantum.c **** #ifdef API_ENABLE
1226:quantum/quantum.c ****     uint8_t chunk[4];
1227:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1228:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1229:quantum/quantum.c **** #endif
1230:quantum/quantum.c **** }
1231:quantum/quantum.c **** 
1232:quantum/quantum.c **** __attribute__ ((weak))
1233:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 2343               		.loc 1 1233 0
 2344               		.cfi_startproc
 2345               	.LVL241:
 2346               	/* prologue: function */
 2347               	/* frame size = 0 */
 2348               	/* stack size = 0 */
 2349               	.L__stack_usage = 0
 2350 0000 0895      		ret
 2351               		.cfi_endproc
 2352               	.LFE55:
 2354               		.section	.text.led_set_kb,"ax",@progbits
 2355               		.weak	led_set_kb
 2357               	led_set_kb:
 2358               	.LFB56:
1234:quantum/quantum.c **** 
1235:quantum/quantum.c **** }
1236:quantum/quantum.c **** 
1237:quantum/quantum.c **** __attribute__ ((weak))
1238:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 2359               		.loc 1 1238 0
 2360               		.cfi_startproc
 2361               	.LVL242:
 2362               	/* prologue: function */
 2363               	/* frame size = 0 */
 2364               	/* stack size = 0 */
 2365               	.L__stack_usage = 0
1239:quantum/quantum.c ****     led_set_user(usb_led);
 2366               		.loc 1 1239 0
 2367 0000 0C94 0000 		jmp led_set_user
 2368               	.LVL243:
 2369               		.cfi_endproc
 2370               	.LFE56:
 2372               		.section	.text.led_init_ports,"ax",@progbits
 2373               		.weak	led_init_ports
 2375               	led_init_ports:
 2376               	.LFB57:
1240:quantum/quantum.c **** }
1241:quantum/quantum.c **** 
1242:quantum/quantum.c **** __attribute__ ((weak))
1243:quantum/quantum.c **** void led_init_ports(void)
1244:quantum/quantum.c **** {
 2377               		.loc 1 1244 0
 2378               		.cfi_startproc
 2379               	/* prologue: function */
 2380               	/* frame size = 0 */
 2381               	/* stack size = 0 */
 2382               	.L__stack_usage = 0
 2383 0000 0895      		ret
 2384               		.cfi_endproc
 2385               	.LFE57:
 2387               		.section	.text.led_set,"ax",@progbits
 2388               		.weak	led_set
 2390               	led_set:
 2391               	.LFB58:
1245:quantum/quantum.c **** 
1246:quantum/quantum.c **** }
1247:quantum/quantum.c **** 
1248:quantum/quantum.c **** __attribute__ ((weak))
1249:quantum/quantum.c **** void led_set(uint8_t usb_led)
1250:quantum/quantum.c **** {
 2392               		.loc 1 1250 0
 2393               		.cfi_startproc
 2394               	.LVL244:
 2395               	/* prologue: function */
 2396               	/* frame size = 0 */
 2397               	/* stack size = 0 */
 2398               	.L__stack_usage = 0
1251:quantum/quantum.c **** 
1252:quantum/quantum.c ****   // Example LED Code
1253:quantum/quantum.c ****   //
1254:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1255:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1256:quantum/quantum.c ****     // {
1257:quantum/quantum.c ****     //     // Output high.
1258:quantum/quantum.c ****     //     DDRE |= (1<<6);
1259:quantum/quantum.c ****     //     PORTE |= (1<<6);
1260:quantum/quantum.c ****     // }
1261:quantum/quantum.c ****     // else
1262:quantum/quantum.c ****     // {
1263:quantum/quantum.c ****     //     // Output low.
1264:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1265:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1266:quantum/quantum.c ****     // }
1267:quantum/quantum.c **** 
1268:quantum/quantum.c ****   led_set_kb(usb_led);
 2399               		.loc 1 1268 0
 2400 0000 0C94 0000 		jmp led_set_kb
 2401               	.LVL245:
 2402               		.cfi_endproc
 2403               	.LFE58:
 2405               		.section	.text.startup_user,"ax",@progbits
 2406               		.weak	startup_user
 2408               	startup_user:
 2409               	.LFB59:
1269:quantum/quantum.c **** }
1270:quantum/quantum.c **** 
1271:quantum/quantum.c **** 
1272:quantum/quantum.c **** //------------------------------------------------------------------------------
1273:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1274:quantum/quantum.c **** // different events such as startup and bootloader jump
1275:quantum/quantum.c **** 
1276:quantum/quantum.c **** __attribute__ ((weak))
1277:quantum/quantum.c **** void startup_user() {}
 2410               		.loc 1 1277 0
 2411               		.cfi_startproc
 2412               	/* prologue: function */
 2413               	/* frame size = 0 */
 2414               	/* stack size = 0 */
 2415               	.L__stack_usage = 0
 2416 0000 0895      		ret
 2417               		.cfi_endproc
 2418               	.LFE59:
 2420               		.section	.text.shutdown_user,"ax",@progbits
 2421               		.weak	shutdown_user
 2423               	shutdown_user:
 2424               	.LFB60:
1278:quantum/quantum.c **** 
1279:quantum/quantum.c **** __attribute__ ((weak))
1280:quantum/quantum.c **** void shutdown_user() {}
 2425               		.loc 1 1280 0
 2426               		.cfi_startproc
 2427               	/* prologue: function */
 2428               	/* frame size = 0 */
 2429               	/* stack size = 0 */
 2430               	.L__stack_usage = 0
 2431 0000 0895      		ret
 2432               		.cfi_endproc
 2433               	.LFE60:
 2435               	.global	rgb_matrix_task_counter
 2436               		.section	.bss.rgb_matrix_task_counter,"aw",@nobits
 2439               	rgb_matrix_task_counter:
 2440 0000 00        		.zero	1
 2441               		.weak	ascii_to_keycode_lut
 2442               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2445               	ascii_to_keycode_lut:
 2446 0000 00        		.byte	0
 2447 0001 00        		.byte	0
 2448 0002 00        		.byte	0
 2449 0003 00        		.byte	0
 2450 0004 00        		.byte	0
 2451 0005 00        		.byte	0
 2452 0006 00        		.byte	0
 2453 0007 00        		.byte	0
 2454 0008 2A        		.byte	42
 2455 0009 2B        		.byte	43
 2456 000a 28        		.byte	40
 2457 000b 00        		.byte	0
 2458 000c 00        		.byte	0
 2459 000d 00        		.byte	0
 2460 000e 00        		.byte	0
 2461 000f 00        		.byte	0
 2462 0010 00        		.byte	0
 2463 0011 00        		.byte	0
 2464 0012 00        		.byte	0
 2465 0013 00        		.byte	0
 2466 0014 00        		.byte	0
 2467 0015 00        		.byte	0
 2468 0016 00        		.byte	0
 2469 0017 00        		.byte	0
 2470 0018 00        		.byte	0
 2471 0019 00        		.byte	0
 2472 001a 00        		.byte	0
 2473 001b 29        		.byte	41
 2474 001c 00        		.byte	0
 2475 001d 00        		.byte	0
 2476 001e 00        		.byte	0
 2477 001f 00        		.byte	0
 2478 0020 2C        		.byte	44
 2479 0021 1E        		.byte	30
 2480 0022 34        		.byte	52
 2481 0023 20        		.byte	32
 2482 0024 21        		.byte	33
 2483 0025 22        		.byte	34
 2484 0026 24        		.byte	36
 2485 0027 34        		.byte	52
 2486 0028 26        		.byte	38
 2487 0029 27        		.byte	39
 2488 002a 25        		.byte	37
 2489 002b 2E        		.byte	46
 2490 002c 36        		.byte	54
 2491 002d 2D        		.byte	45
 2492 002e 37        		.byte	55
 2493 002f 38        		.byte	56
 2494 0030 27        		.byte	39
 2495 0031 1E        		.byte	30
 2496 0032 1F        		.byte	31
 2497 0033 20        		.byte	32
 2498 0034 21        		.byte	33
 2499 0035 22        		.byte	34
 2500 0036 23        		.byte	35
 2501 0037 24        		.byte	36
 2502 0038 25        		.byte	37
 2503 0039 26        		.byte	38
 2504 003a 33        		.byte	51
 2505 003b 33        		.byte	51
 2506 003c 36        		.byte	54
 2507 003d 2E        		.byte	46
 2508 003e 37        		.byte	55
 2509 003f 38        		.byte	56
 2510 0040 1F        		.byte	31
 2511 0041 04        		.byte	4
 2512 0042 05        		.byte	5
 2513 0043 06        		.byte	6
 2514 0044 07        		.byte	7
 2515 0045 08        		.byte	8
 2516 0046 09        		.byte	9
 2517 0047 0A        		.byte	10
 2518 0048 0B        		.byte	11
 2519 0049 0C        		.byte	12
 2520 004a 0D        		.byte	13
 2521 004b 0E        		.byte	14
 2522 004c 0F        		.byte	15
 2523 004d 10        		.byte	16
 2524 004e 11        		.byte	17
 2525 004f 12        		.byte	18
 2526 0050 13        		.byte	19
 2527 0051 14        		.byte	20
 2528 0052 15        		.byte	21
 2529 0053 16        		.byte	22
 2530 0054 17        		.byte	23
 2531 0055 18        		.byte	24
 2532 0056 19        		.byte	25
 2533 0057 1A        		.byte	26
 2534 0058 1B        		.byte	27
 2535 0059 1C        		.byte	28
 2536 005a 1D        		.byte	29
 2537 005b 2F        		.byte	47
 2538 005c 31        		.byte	49
 2539 005d 30        		.byte	48
 2540 005e 23        		.byte	35
 2541 005f 2D        		.byte	45
 2542 0060 35        		.byte	53
 2543 0061 04        		.byte	4
 2544 0062 05        		.byte	5
 2545 0063 06        		.byte	6
 2546 0064 07        		.byte	7
 2547 0065 08        		.byte	8
 2548 0066 09        		.byte	9
 2549 0067 0A        		.byte	10
 2550 0068 0B        		.byte	11
 2551 0069 0C        		.byte	12
 2552 006a 0D        		.byte	13
 2553 006b 0E        		.byte	14
 2554 006c 0F        		.byte	15
 2555 006d 10        		.byte	16
 2556 006e 11        		.byte	17
 2557 006f 12        		.byte	18
 2558 0070 13        		.byte	19
 2559 0071 14        		.byte	20
 2560 0072 15        		.byte	21
 2561 0073 16        		.byte	22
 2562 0074 17        		.byte	23
 2563 0075 18        		.byte	24
 2564 0076 19        		.byte	25
 2565 0077 1A        		.byte	26
 2566 0078 1B        		.byte	27
 2567 0079 1C        		.byte	28
 2568 007a 1D        		.byte	29
 2569 007b 2F        		.byte	47
 2570 007c 31        		.byte	49
 2571 007d 30        		.byte	48
 2572 007e 35        		.byte	53
 2573 007f 4C        		.byte	76
 2574               		.weak	ascii_to_shift_lut
 2575               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2578               	ascii_to_shift_lut:
 2579 0000 00        		.byte	0
 2580 0001 00        		.byte	0
 2581 0002 00        		.byte	0
 2582 0003 00        		.byte	0
 2583 0004 00        		.byte	0
 2584 0005 00        		.byte	0
 2585 0006 00        		.byte	0
 2586 0007 00        		.byte	0
 2587 0008 00        		.byte	0
 2588 0009 00        		.byte	0
 2589 000a 00        		.byte	0
 2590 000b 00        		.byte	0
 2591 000c 00        		.byte	0
 2592 000d 00        		.byte	0
 2593 000e 00        		.byte	0
 2594 000f 00        		.byte	0
 2595 0010 00        		.byte	0
 2596 0011 00        		.byte	0
 2597 0012 00        		.byte	0
 2598 0013 00        		.byte	0
 2599 0014 00        		.byte	0
 2600 0015 00        		.byte	0
 2601 0016 00        		.byte	0
 2602 0017 00        		.byte	0
 2603 0018 00        		.byte	0
 2604 0019 00        		.byte	0
 2605 001a 00        		.byte	0
 2606 001b 00        		.byte	0
 2607 001c 00        		.byte	0
 2608 001d 00        		.byte	0
 2609 001e 00        		.byte	0
 2610 001f 00        		.byte	0
 2611 0020 00        		.byte	0
 2612 0021 01        		.byte	1
 2613 0022 01        		.byte	1
 2614 0023 01        		.byte	1
 2615 0024 01        		.byte	1
 2616 0025 01        		.byte	1
 2617 0026 01        		.byte	1
 2618 0027 00        		.byte	0
 2619 0028 01        		.byte	1
 2620 0029 01        		.byte	1
 2621 002a 01        		.byte	1
 2622 002b 01        		.byte	1
 2623 002c 00        		.byte	0
 2624 002d 00        		.byte	0
 2625 002e 00        		.byte	0
 2626 002f 00        		.byte	0
 2627 0030 00        		.byte	0
 2628 0031 00        		.byte	0
 2629 0032 00        		.byte	0
 2630 0033 00        		.byte	0
 2631 0034 00        		.byte	0
 2632 0035 00        		.byte	0
 2633 0036 00        		.byte	0
 2634 0037 00        		.byte	0
 2635 0038 00        		.byte	0
 2636 0039 00        		.byte	0
 2637 003a 01        		.byte	1
 2638 003b 00        		.byte	0
 2639 003c 01        		.byte	1
 2640 003d 00        		.byte	0
 2641 003e 01        		.byte	1
 2642 003f 01        		.byte	1
 2643 0040 01        		.byte	1
 2644 0041 01        		.byte	1
 2645 0042 01        		.byte	1
 2646 0043 01        		.byte	1
 2647 0044 01        		.byte	1
 2648 0045 01        		.byte	1
 2649 0046 01        		.byte	1
 2650 0047 01        		.byte	1
 2651 0048 01        		.byte	1
 2652 0049 01        		.byte	1
 2653 004a 01        		.byte	1
 2654 004b 01        		.byte	1
 2655 004c 01        		.byte	1
 2656 004d 01        		.byte	1
 2657 004e 01        		.byte	1
 2658 004f 01        		.byte	1
 2659 0050 01        		.byte	1
 2660 0051 01        		.byte	1
 2661 0052 01        		.byte	1
 2662 0053 01        		.byte	1
 2663 0054 01        		.byte	1
 2664 0055 01        		.byte	1
 2665 0056 01        		.byte	1
 2666 0057 01        		.byte	1
 2667 0058 01        		.byte	1
 2668 0059 01        		.byte	1
 2669 005a 01        		.byte	1
 2670 005b 00        		.byte	0
 2671 005c 00        		.byte	0
 2672 005d 00        		.byte	0
 2673 005e 01        		.byte	1
 2674 005f 01        		.byte	1
 2675 0060 00        		.byte	0
 2676 0061 00        		.byte	0
 2677 0062 00        		.byte	0
 2678 0063 00        		.byte	0
 2679 0064 00        		.byte	0
 2680 0065 00        		.byte	0
 2681 0066 00        		.byte	0
 2682 0067 00        		.byte	0
 2683 0068 00        		.byte	0
 2684 0069 00        		.byte	0
 2685 006a 00        		.byte	0
 2686 006b 00        		.byte	0
 2687 006c 00        		.byte	0
 2688 006d 00        		.byte	0
 2689 006e 00        		.byte	0
 2690 006f 00        		.byte	0
 2691 0070 00        		.byte	0
 2692 0071 00        		.byte	0
 2693 0072 00        		.byte	0
 2694 0073 00        		.byte	0
 2695 0074 00        		.byte	0
 2696 0075 00        		.byte	0
 2697 0076 00        		.byte	0
 2698 0077 00        		.byte	0
 2699 0078 00        		.byte	0
 2700 0079 00        		.byte	0
 2701 007a 00        		.byte	0
 2702 007b 01        		.byte	1
 2703 007c 01        		.byte	1
 2704 007d 01        		.byte	1
 2705 007e 01        		.byte	1
 2706 007f 00        		.byte	0
 2707               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2710               	grave_esc_was_shifted:
 2711 0000 00        		.zero	1
 2712               		.section	.bss.scs_timer,"aw",@nobits
 2715               	scs_timer:
 2716 0000 0000 0000 		.zero	4
 2717               		.section	.bss.shift_interrupted,"aw",@nobits
 2720               	shift_interrupted:
 2721 0000 0000      		.zero	2
 2722               		.text
 2723               	.Letext0:
 2724               		.file 5 "/usr/lib/avr/include/stdint.h"
 2725               		.file 6 "./tmk_core/common/keyboard.h"
 2726               		.file 7 "./tmk_core/common/action.h"
 2727               		.file 8 "./tmk_core/common/report.h"
 2728               		.file 9 "./tmk_core/common/debug.h"
 2729               		.file 10 "quantum/keycode_config.h"
 2730               		.file 11 "./tmk_core/common/keycode.h"
 2731               		.file 12 "quantum/quantum_keycodes.h"
 2732               		.file 13 "./tmk_core/protocol/lufa/outputselect.h"
 2733               		.file 14 "quantum/quantum.h"
 2734               		.file 15 "./tmk_core/common/bootloader.h"
 2735               		.file 16 "./tmk_core/common/action_layer.h"
 2736               		.file 17 "quantum/keymap.h"
 2737               		.file 18 "./quantum/process_keycode/process_tap_dance.h"
 2738               		.file 19 "./quantum/process_keycode/process_leader.h"
 2739               		.file 20 "./tmk_core/common/eeconfig.h"
 2740               		.file 21 "./tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/ccArKwmV.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccArKwmV.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccArKwmV.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccArKwmV.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccArKwmV.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccArKwmV.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/ccArKwmV.s:130    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
     /tmp/ccArKwmV.s:160    .text.qk_register_mods:0000000000000000 qk_register_mods
     /tmp/ccArKwmV.s:190    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
     /tmp/ccArKwmV.s:220    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
     /tmp/ccArKwmV.s:251    .text.rgblight_toggle:0000000000000000 rgblight_toggle
     /tmp/ccArKwmV.s:267    .text.rgblight_step:0000000000000000 rgblight_step
     /tmp/ccArKwmV.s:282    .text.rgblight_step_reverse:0000000000000000 rgblight_step_reverse
     /tmp/ccArKwmV.s:297    .text.rgblight_increase_hue:0000000000000000 rgblight_increase_hue
     /tmp/ccArKwmV.s:312    .text.rgblight_decrease_hue:0000000000000000 rgblight_decrease_hue
     /tmp/ccArKwmV.s:327    .text.rgblight_increase_sat:0000000000000000 rgblight_increase_sat
     /tmp/ccArKwmV.s:342    .text.rgblight_decrease_sat:0000000000000000 rgblight_decrease_sat
     /tmp/ccArKwmV.s:357    .text.rgblight_increase_val:0000000000000000 rgblight_increase_val
     /tmp/ccArKwmV.s:372    .text.rgblight_decrease_val:0000000000000000 rgblight_decrease_val
     /tmp/ccArKwmV.s:387    .text.rgblight_increase_speed:0000000000000000 rgblight_increase_speed
     /tmp/ccArKwmV.s:402    .text.rgblight_decrease_speed:0000000000000000 rgblight_decrease_speed
     /tmp/ccArKwmV.s:417    .text.register_code16:0000000000000000 register_code16
     /tmp/ccArKwmV.s:474    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/ccArKwmV.s:529    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/ccArKwmV.s:548    .text.process_record_user:0000000000000000 process_record_user
     /tmp/ccArKwmV.s:567    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/ccArKwmV.s:585    .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/ccArKwmV.s:625    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccArKwmV.s:2710   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted
     /tmp/ccArKwmV.s:2720   .bss.shift_interrupted:0000000000000000 shift_interrupted
     /tmp/ccArKwmV.s:2715   .bss.scs_timer:0000000000000000 scs_timer
     /tmp/ccArKwmV.s:1194   .text.send_char:0000000000000000 send_char
     /tmp/ccArKwmV.s:2445   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
     /tmp/ccArKwmV.s:2578   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
     /tmp/ccArKwmV.s:1280   .text.send_string_with_delay:0000000000000000 send_string_with_delay
     /tmp/ccArKwmV.s:1424   .text.send_string:0000000000000000 send_string
     /tmp/ccArKwmV.s:1443   .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
     /tmp/ccArKwmV.s:1619   .text.send_string_P:0000000000000000 send_string_P
     /tmp/ccArKwmV.s:1638   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/ccArKwmV.s:1686   .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
     /tmp/ccArKwmV.s:1871   .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/ccArKwmV.s:1910   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/ccArKwmV.s:2032   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccArKwmV.s:2049   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccArKwmV.s:2069   .text.backlight_init_ports:0000000000000000 backlight_init_ports
     /tmp/ccArKwmV.s:2084   .text.backlight_set:0000000000000000 backlight_set
     /tmp/ccArKwmV.s:2100   .text.send_nibble:0000000000000000 send_nibble
     /tmp/ccArKwmV.s:2165   .text.send_byte:0000000000000000 send_byte
     /tmp/ccArKwmV.s:2202   .text.send_word:0000000000000000 send_word
     /tmp/ccArKwmV.s:2236   .text.send_dword:0000000000000000 send_dword
     /tmp/ccArKwmV.s:2286   .text.hex_to_keycode:0000000000000000 hex_to_keycode
     /tmp/ccArKwmV.s:2325   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/ccArKwmV.s:2341   .text.led_set_user:0000000000000000 led_set_user
     /tmp/ccArKwmV.s:2357   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/ccArKwmV.s:2375   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/ccArKwmV.s:2390   .text.led_set:0000000000000000 led_set
     /tmp/ccArKwmV.s:2408   .text.startup_user:0000000000000000 startup_user
     /tmp/ccArKwmV.s:2423   .text.shutdown_user:0000000000000000 shutdown_user
     /tmp/ccArKwmV.s:2439   .bss.rgb_matrix_task_counter:0000000000000000 rgb_matrix_task_counter

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
clear_keyboard
bootloader_jump
layer_switch_get_layer
keymap_key_to_keycode
preprocess_tap_dance
process_tap_dance
process_leader
get_mods
keyboard_report
add_key_to_report
del_key_from_report
debug_config
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
timer_read
register_mods
unregister_mods
timer_elapsed
set_output
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_init_kb
matrix_scan_tap_dance
matrix_scan_kb
__do_clear_bss
