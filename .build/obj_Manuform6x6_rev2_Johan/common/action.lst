   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "./tmk_core/common/action.c"
   1:./tmk_core/common/action.c **** /*
   2:./tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action.c **** 
   4:./tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action.c **** (at your option) any later version.
   8:./tmk_core/common/action.c **** 
   9:./tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action.c **** GNU General Public License for more details.
  13:./tmk_core/common/action.c **** 
  14:./tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action.c **** */
  17:./tmk_core/common/action.c **** #include "host.h"
  18:./tmk_core/common/action.c **** #include "keycode.h"
  19:./tmk_core/common/action.c **** #include "keyboard.h"
  20:./tmk_core/common/action.c **** #include "mousekey.h"
  21:./tmk_core/common/action.c **** #include "command.h"
  22:./tmk_core/common/action.c **** #include "led.h"
  23:./tmk_core/common/action.c **** #include "backlight.h"
  24:./tmk_core/common/action.c **** #include "action_layer.h"
  25:./tmk_core/common/action.c **** #include "action_tapping.h"
  26:./tmk_core/common/action.c **** #include "action_macro.h"
  27:./tmk_core/common/action.c **** #include "action_util.h"
  28:./tmk_core/common/action.c **** #include "action.h"
  29:./tmk_core/common/action.c **** #include "wait.h"
  30:./tmk_core/common/action.c **** 
  31:./tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:./tmk_core/common/action.c **** #include "debug.h"
  33:./tmk_core/common/action.c **** #else
  34:./tmk_core/common/action.c **** #include "nodebug.h"
  35:./tmk_core/common/action.c **** #endif
  36:./tmk_core/common/action.c **** 
  37:./tmk_core/common/action.c **** int tp_buttons;
  38:./tmk_core/common/action.c **** 
  39:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:./tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:./tmk_core/common/action.c **** #endif
  42:./tmk_core/common/action.c **** 
  43:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:./tmk_core/common/action.c **** #include <fauxclicky.h>
  45:./tmk_core/common/action.c **** #endif
  46:./tmk_core/common/action.c **** 
  47:./tmk_core/common/action.c **** /** \brief Called to execute an action.
  48:./tmk_core/common/action.c ****  *
  49:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
  50:./tmk_core/common/action.c ****  */
  51:./tmk_core/common/action.c **** void action_exec(keyevent_t event)
  52:./tmk_core/common/action.c **** {
  16               		.loc 1 52 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  53:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  54:./tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  55:./tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  56:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  57:./tmk_core/common/action.c ****         retro_tapping_counter++;
  58:./tmk_core/common/action.c **** #endif
  59:./tmk_core/common/action.c ****     }
  60:./tmk_core/common/action.c **** 
  61:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  62:./tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  63:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  64:./tmk_core/common/action.c ****     }
  65:./tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  66:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  67:./tmk_core/common/action.c ****     }
  68:./tmk_core/common/action.c ****     fauxclicky_check();
  69:./tmk_core/common/action.c **** #endif
  70:./tmk_core/common/action.c **** 
  71:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  72:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  73:./tmk_core/common/action.c ****         process_hand_swap(&event);
  74:./tmk_core/common/action.c ****     }
  75:./tmk_core/common/action.c **** #endif
  76:./tmk_core/common/action.c **** 
  77:./tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  48               		.loc 1 77 0
  49 001e DE01      		movw r26,r28
  50 0020 1196      		adiw r26,1
  51 0022 86E0      		ldi r24,lo8(6)
  52 0024 FD01      		movw r30,r26
  53               		0:
  54 0026 1192      		st Z+,__zero_reg__
  55 0028 8A95      		dec r24
  56 002a 01F4      		brne 0b
  57 002c 85E0      		ldi r24,lo8(5)
  58 002e FE01      		movw r30,r28
  59 0030 3796      		adiw r30,7
  60               		0:
  61 0032 0190      		ld r0,Z+
  62 0034 0D92      		st X+,r0
  63 0036 8A95      		dec r24
  64 0038 01F4      		brne 0b
  78:./tmk_core/common/action.c **** 
  79:./tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  80:./tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  81:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  82:./tmk_core/common/action.c ****     }
  83:./tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  84:./tmk_core/common/action.c ****         clear_oneshot_mods();
  85:./tmk_core/common/action.c ****     }
  86:./tmk_core/common/action.c **** #endif
  87:./tmk_core/common/action.c **** 
  88:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  89:./tmk_core/common/action.c ****     action_tapping_process(record);
  65               		.loc 1 89 0
  66 003a 4981      		ldd r20,Y+1
  67               	.LVL1:
  68 003c 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70 003e 6B81      		ldd r22,Y+3
  71 0040 7C81      		ldd r23,Y+4
  72 0042 8D81      		ldd r24,Y+5
  73 0044 9E81      		ldd r25,Y+6
  74 0046 0E94 0000 		call action_tapping_process
  75               	.LVL3:
  76               	/* epilogue start */
  90:./tmk_core/common/action.c **** #else
  91:./tmk_core/common/action.c ****     process_record(&record);
  92:./tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  93:./tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
  94:./tmk_core/common/action.c ****     }
  95:./tmk_core/common/action.c **** #endif
  96:./tmk_core/common/action.c **** }
  77               		.loc 1 96 0
  78 004a 2B96      		adiw r28,11
  79 004c 0FB6      		in __tmp_reg__,__SREG__
  80 004e F894      		cli
  81 0050 DEBF      		out __SP_H__,r29
  82 0052 0FBE      		out __SREG__,__tmp_reg__
  83 0054 CDBF      		out __SP_L__,r28
  84 0056 DF91      		pop r29
  85 0058 CF91      		pop r28
  86 005a 0895      		ret
  87               		.cfi_endproc
  88               	.LFE13:
  90               		.section	.text.process_record_quantum,"ax",@progbits
  91               		.weak	process_record_quantum
  93               	process_record_quantum:
  94               	.LFB15:
  97:./tmk_core/common/action.c **** 
  98:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  99:./tmk_core/common/action.c **** bool swap_hands = false;
 100:./tmk_core/common/action.c **** bool swap_held = false;
 101:./tmk_core/common/action.c **** 
 102:./tmk_core/common/action.c **** /** \brief Process Hand Swap
 103:./tmk_core/common/action.c ****  *
 104:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 105:./tmk_core/common/action.c ****  */
 106:./tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 107:./tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 108:./tmk_core/common/action.c **** 
 109:./tmk_core/common/action.c ****     keypos_t pos = event->key;
 110:./tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1<<pos.col;
 111:./tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
 112:./tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 113:./tmk_core/common/action.c **** 
 114:./tmk_core/common/action.c ****     if (do_swap) {
 115:./tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 116:./tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 117:./tmk_core/common/action.c ****     } else {
 118:./tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 119:./tmk_core/common/action.c ****     }
 120:./tmk_core/common/action.c **** }
 121:./tmk_core/common/action.c **** #endif
 122:./tmk_core/common/action.c **** 
 123:./tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 124:./tmk_core/common/action.c **** bool disable_action_cache = false;
 125:./tmk_core/common/action.c **** 
 126:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 127:./tmk_core/common/action.c **** {
 128:./tmk_core/common/action.c ****     disable_action_cache = true;
 129:./tmk_core/common/action.c ****     process_record(record);
 130:./tmk_core/common/action.c ****     disable_action_cache = false;
 131:./tmk_core/common/action.c **** }
 132:./tmk_core/common/action.c **** #else
 133:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 134:./tmk_core/common/action.c **** {
 135:./tmk_core/common/action.c ****     process_record(record);
 136:./tmk_core/common/action.c **** }
 137:./tmk_core/common/action.c **** #endif
 138:./tmk_core/common/action.c **** 
 139:./tmk_core/common/action.c **** __attribute__ ((weak))
 140:./tmk_core/common/action.c **** bool process_record_quantum(keyrecord_t *record) {
  95               		.loc 1 140 0
  96               		.cfi_startproc
  97               	.LVL4:
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 0 */
 101               	.L__stack_usage = 0
 141:./tmk_core/common/action.c ****     return true;
 142:./tmk_core/common/action.c **** }
 102               		.loc 1 142 0
 103 0000 81E0      		ldi r24,lo8(1)
 104               	.LVL5:
 105 0002 0895      		ret
 106               		.cfi_endproc
 107               	.LFE15:
 109               		.section	.text.process_record_tap_hint,"ax",@progbits
 110               	.global	process_record_tap_hint
 112               	process_record_tap_hint:
 113               	.LFB16:
 143:./tmk_core/common/action.c **** 
 144:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 145:./tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 146:./tmk_core/common/action.c ****  *
 147:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 148:./tmk_core/common/action.c ****  */
 149:./tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record)
 150:./tmk_core/common/action.c **** {
 114               		.loc 1 150 0
 115               		.cfi_startproc
 116               	.LVL6:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 151:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 121               		.loc 1 151 0
 122 0000 FC01      		movw r30,r24
 123 0002 8081      		ld r24,Z
 124 0004 9181      		ldd r25,Z+1
 125               	.LVL7:
 126 0006 0E94 0000 		call layer_switch_get_action
 127               	.LVL8:
 128 000a 0895      		ret
 129               		.cfi_endproc
 130               	.LFE16:
 132               		.section	.text.register_code,"ax",@progbits
 133               	.global	register_code
 135               	register_code:
 136               	.LFB19:
 152:./tmk_core/common/action.c **** 
 153:./tmk_core/common/action.c ****     switch (action.kind.id) {
 154:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 155:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 156:./tmk_core/common/action.c ****             switch (action.swap.code) {
 157:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 158:./tmk_core/common/action.c ****                 default:
 159:./tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 160:./tmk_core/common/action.c ****                     swap_held = true;
 161:./tmk_core/common/action.c ****             }
 162:./tmk_core/common/action.c ****             break;
 163:./tmk_core/common/action.c **** #endif
 164:./tmk_core/common/action.c ****     }
 165:./tmk_core/common/action.c **** }
 166:./tmk_core/common/action.c **** #endif
 167:./tmk_core/common/action.c **** 
 168:./tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 169:./tmk_core/common/action.c ****  *
 170:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 171:./tmk_core/common/action.c ****  */
 172:./tmk_core/common/action.c **** void process_record(keyrecord_t *record)
 173:./tmk_core/common/action.c **** {
 174:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 175:./tmk_core/common/action.c **** 
 176:./tmk_core/common/action.c ****     if(!process_record_quantum(record))
 177:./tmk_core/common/action.c ****         return;
 178:./tmk_core/common/action.c **** 
 179:./tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 180:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 181:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 182:./tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 183:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 184:./tmk_core/common/action.c **** #endif
 185:./tmk_core/common/action.c ****     dprintln();
 186:./tmk_core/common/action.c **** 
 187:./tmk_core/common/action.c ****     process_action(record, action);
 188:./tmk_core/common/action.c **** }
 189:./tmk_core/common/action.c **** 
 190:./tmk_core/common/action.c **** /** \brief Take an action and processes it.
 191:./tmk_core/common/action.c ****  *
 192:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 193:./tmk_core/common/action.c ****  */
 194:./tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action)
 195:./tmk_core/common/action.c **** {
 196:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 197:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 198:./tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 199:./tmk_core/common/action.c **** #endif
 200:./tmk_core/common/action.c **** 
 201:./tmk_core/common/action.c ****     if (event.pressed) {
 202:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 203:./tmk_core/common/action.c ****         clear_weak_mods();
 204:./tmk_core/common/action.c ****     }
 205:./tmk_core/common/action.c **** 
 206:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 207:./tmk_core/common/action.c ****     bool do_release_oneshot = false;
 208:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 209:./tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 210:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 211:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 212:./tmk_core/common/action.c ****     }
 213:./tmk_core/common/action.c **** #endif
 214:./tmk_core/common/action.c **** 
 215:./tmk_core/common/action.c ****     switch (action.kind.id) {
 216:./tmk_core/common/action.c ****         /* Key and Mods */
 217:./tmk_core/common/action.c ****         case ACT_LMODS:
 218:./tmk_core/common/action.c ****         case ACT_RMODS:
 219:./tmk_core/common/action.c ****             {
 220:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 221:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 222:./tmk_core/common/action.c ****                 if (event.pressed) {
 223:./tmk_core/common/action.c ****                     if (mods) {
 224:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 225:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 226:./tmk_core/common/action.c ****                             // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSF
 227:./tmk_core/common/action.c ****                             // Same applies for some keys like KC_MEH which are declared as MEH(KC_
 228:./tmk_core/common/action.c ****                             add_mods(mods);
 229:./tmk_core/common/action.c ****                         } else {
 230:./tmk_core/common/action.c ****                             add_weak_mods(mods);
 231:./tmk_core/common/action.c ****                         }
 232:./tmk_core/common/action.c ****                         send_keyboard_report();
 233:./tmk_core/common/action.c ****                     }
 234:./tmk_core/common/action.c ****                     register_code(action.key.code);
 235:./tmk_core/common/action.c ****                 } else {
 236:./tmk_core/common/action.c ****                     unregister_code(action.key.code);
 237:./tmk_core/common/action.c ****                     if (mods) {
 238:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 239:./tmk_core/common/action.c ****                             del_mods(mods);
 240:./tmk_core/common/action.c ****                         } else {
 241:./tmk_core/common/action.c ****                             del_weak_mods(mods);
 242:./tmk_core/common/action.c ****                         }
 243:./tmk_core/common/action.c ****                         send_keyboard_report();
 244:./tmk_core/common/action.c ****                     }
 245:./tmk_core/common/action.c ****                 }
 246:./tmk_core/common/action.c ****             }
 247:./tmk_core/common/action.c ****             break;
 248:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 249:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 250:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 251:./tmk_core/common/action.c ****             {
 252:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 253:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 254:./tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 255:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 256:./tmk_core/common/action.c ****                     case MODS_ONESHOT:
 257:./tmk_core/common/action.c ****                         // Oneshot modifier
 258:./tmk_core/common/action.c ****                         if (event.pressed) {
 259:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 260:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 261:./tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 262:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 263:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 264:./tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 265:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 266:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 267:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Toggling oneshot");
 268:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 269:./tmk_core/common/action.c ****                                 set_oneshot_locked_mods(mods);
 270:./tmk_core/common/action.c ****                                 register_mods(mods);
 271:./tmk_core/common/action.c ****                     #endif
 272:./tmk_core/common/action.c ****                             } else {
 273:./tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 274:./tmk_core/common/action.c ****                             }
 275:./tmk_core/common/action.c ****                         } else {
 276:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 277:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 278:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 279:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 280:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 281:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 282:./tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 283:./tmk_core/common/action.c ****                                     clear_oneshot_locked_mods();
 284:./tmk_core/common/action.c ****                                     clear_oneshot_mods();
 285:./tmk_core/common/action.c ****                                     unregister_mods(mods);
 286:./tmk_core/common/action.c ****                                 }
 287:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 288:./tmk_core/common/action.c ****                                 // Toggle Oneshot Layer
 289:./tmk_core/common/action.c ****                     #endif
 290:./tmk_core/common/action.c ****                             } else {
 291:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 292:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 293:./tmk_core/common/action.c ****                             }
 294:./tmk_core/common/action.c ****                         }
 295:./tmk_core/common/action.c ****                         break;
 296:./tmk_core/common/action.c ****     #endif
 297:./tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 298:./tmk_core/common/action.c ****                         if (event.pressed) {
 299:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 300:./tmk_core/common/action.c ****                                 register_mods(mods);
 301:./tmk_core/common/action.c ****                             }
 302:./tmk_core/common/action.c ****                         } else {
 303:./tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 304:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 305:./tmk_core/common/action.c ****                             }
 306:./tmk_core/common/action.c ****                         }
 307:./tmk_core/common/action.c ****                         break;
 308:./tmk_core/common/action.c ****                     default:
 309:./tmk_core/common/action.c ****                         if (event.pressed) {
 310:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 311:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 312:./tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 313:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 314:./tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 315:./tmk_core/common/action.c ****                                     record->tap.count = 0;
 316:./tmk_core/common/action.c ****                                     register_mods(mods);
 317:./tmk_core/common/action.c ****                                 } else
 318:./tmk_core/common/action.c **** #endif
 319:./tmk_core/common/action.c ****                                 {
 320:./tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 321:./tmk_core/common/action.c ****                                     register_code(action.key.code);
 322:./tmk_core/common/action.c ****                                 }
 323:./tmk_core/common/action.c ****                             } else {
 324:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 325:./tmk_core/common/action.c ****                                 register_mods(mods);
 326:./tmk_core/common/action.c ****                             }
 327:./tmk_core/common/action.c ****                         } else {
 328:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 329:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 330:./tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 331:./tmk_core/common/action.c ****                             } else {
 332:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 333:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 334:./tmk_core/common/action.c ****                             }
 335:./tmk_core/common/action.c ****                         }
 336:./tmk_core/common/action.c ****                         break;
 337:./tmk_core/common/action.c ****                 }
 338:./tmk_core/common/action.c ****             }
 339:./tmk_core/common/action.c ****             break;
 340:./tmk_core/common/action.c **** #endif
 341:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 342:./tmk_core/common/action.c ****         /* other HID usage */
 343:./tmk_core/common/action.c ****         case ACT_USAGE:
 344:./tmk_core/common/action.c ****             switch (action.usage.page) {
 345:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 346:./tmk_core/common/action.c ****                     if (event.pressed) {
 347:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 348:./tmk_core/common/action.c ****                     } else {
 349:./tmk_core/common/action.c ****                         host_system_send(0);
 350:./tmk_core/common/action.c ****                     }
 351:./tmk_core/common/action.c ****                     break;
 352:./tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 353:./tmk_core/common/action.c ****                     if (event.pressed) {
 354:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 355:./tmk_core/common/action.c ****                     } else {
 356:./tmk_core/common/action.c ****                         host_consumer_send(0);
 357:./tmk_core/common/action.c ****                     }
 358:./tmk_core/common/action.c ****                     break;
 359:./tmk_core/common/action.c ****             }
 360:./tmk_core/common/action.c ****             break;
 361:./tmk_core/common/action.c **** #endif
 362:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 363:./tmk_core/common/action.c ****         /* Mouse key */
 364:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 365:./tmk_core/common/action.c ****             if (event.pressed) {
 366:./tmk_core/common/action.c ****                 switch (action.key.code) {
 367:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 368:./tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 369:./tmk_core/common/action.c ****                         break;
 370:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 371:./tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 372:./tmk_core/common/action.c ****                         break;
 373:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 374:./tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 375:./tmk_core/common/action.c ****                         break;
 376:./tmk_core/common/action.c ****                     default:
 377:./tmk_core/common/action.c ****                         break;
 378:./tmk_core/common/action.c ****                 }
 379:./tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 380:./tmk_core/common/action.c ****                 mousekey_send();
 381:./tmk_core/common/action.c ****             } else {
 382:./tmk_core/common/action.c ****                 switch (action.key.code) {
 383:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 384:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 385:./tmk_core/common/action.c ****                         break;
 386:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 387:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 388:./tmk_core/common/action.c ****                         break;
 389:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 390:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 391:./tmk_core/common/action.c ****                         break;
 392:./tmk_core/common/action.c ****                     default:
 393:./tmk_core/common/action.c ****                         break;
 394:./tmk_core/common/action.c ****                 }
 395:./tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 396:./tmk_core/common/action.c ****                 mousekey_send();
 397:./tmk_core/common/action.c ****             }
 398:./tmk_core/common/action.c ****             break;
 399:./tmk_core/common/action.c **** #endif
 400:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 401:./tmk_core/common/action.c ****         case ACT_LAYER:
 402:./tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 403:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 404:./tmk_core/common/action.c ****                 if (!event.pressed) {
 405:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 406:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 407:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 408:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 409:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 410:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 411:./tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 412:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 413:./tmk_core/common/action.c ****                     }
 414:./tmk_core/common/action.c ****                 }
 415:./tmk_core/common/action.c ****             } else {
 416:./tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 417:./tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 418:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 419:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 420:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 421:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 422:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 423:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 424:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 425:./tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 426:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 427:./tmk_core/common/action.c ****                     }
 428:./tmk_core/common/action.c ****                 }
 429:./tmk_core/common/action.c ****             }
 430:./tmk_core/common/action.c ****             break;
 431:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 432:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 433:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 434:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 435:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 436:./tmk_core/common/action.c ****                     /* layer On/Off with modifiers(left only) */
 437:./tmk_core/common/action.c ****                     if (event.pressed) {
 438:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 439:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 440:./tmk_core/common/action.c ****                     } else {
 441:./tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 442:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 443:./tmk_core/common/action.c ****                     }
 444:./tmk_core/common/action.c ****                     break;
 445:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 446:./tmk_core/common/action.c ****                     /* tap toggle */
 447:./tmk_core/common/action.c ****                     if (event.pressed) {
 448:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 449:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 450:./tmk_core/common/action.c ****                         }
 451:./tmk_core/common/action.c ****                     } else {
 452:./tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 453:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 454:./tmk_core/common/action.c ****                         }
 455:./tmk_core/common/action.c ****                     }
 456:./tmk_core/common/action.c ****                     break;
 457:./tmk_core/common/action.c ****                 case OP_ON_OFF:
 458:./tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 459:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 460:./tmk_core/common/action.c ****                     break;
 461:./tmk_core/common/action.c ****                 case OP_OFF_ON:
 462:./tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 463:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 464:./tmk_core/common/action.c ****                     break;
 465:./tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 466:./tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 467:./tmk_core/common/action.c ****                                     layer_clear();
 468:./tmk_core/common/action.c ****                     break;
 469:./tmk_core/common/action.c ****             #ifndef NO_ACTION_ONESHOT
 470:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 471:./tmk_core/common/action.c ****                     // Oneshot modifier
 472:./tmk_core/common/action.c ****                 #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 473:./tmk_core/common/action.c ****                     do_release_oneshot = false;
 474:./tmk_core/common/action.c ****                     if (event.pressed) {
 475:./tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 476:./tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 477:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 478:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 479:./tmk_core/common/action.c ****                             break;
 480:./tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 481:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 482:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 483:./tmk_core/common/action.c ****                         }
 484:./tmk_core/common/action.c ****                     } else {
 485:./tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 486:./tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 487:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 488:./tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 489:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 490:./tmk_core/common/action.c ****                         } else {
 491:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 492:./tmk_core/common/action.c ****                         }
 493:./tmk_core/common/action.c ****                     }
 494:./tmk_core/common/action.c ****                 #else
 495:./tmk_core/common/action.c ****                     if (event.pressed) {
 496:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 497:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 498:./tmk_core/common/action.c ****                     } else {
 499:./tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 500:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 501:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 502:./tmk_core/common/action.c ****                         }
 503:./tmk_core/common/action.c ****                     }
 504:./tmk_core/common/action.c ****                 #endif
 505:./tmk_core/common/action.c ****                     break;
 506:./tmk_core/common/action.c ****             #endif
 507:./tmk_core/common/action.c ****                 default:
 508:./tmk_core/common/action.c ****                     /* tap key */
 509:./tmk_core/common/action.c ****                     if (event.pressed) {
 510:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 511:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 512:./tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 513:./tmk_core/common/action.c ****                         } else {
 514:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 515:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 516:./tmk_core/common/action.c ****                         }
 517:./tmk_core/common/action.c ****                     } else {
 518:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 519:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 520:./tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 521:./tmk_core/common/action.c ****                                 wait_ms(80);
 522:./tmk_core/common/action.c ****                             }
 523:./tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 524:./tmk_core/common/action.c ****                         } else {
 525:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 526:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 527:./tmk_core/common/action.c ****                         }
 528:./tmk_core/common/action.c ****                     }
 529:./tmk_core/common/action.c ****                     break;
 530:./tmk_core/common/action.c ****             }
 531:./tmk_core/common/action.c ****             break;
 532:./tmk_core/common/action.c ****     #endif
 533:./tmk_core/common/action.c **** #endif
 534:./tmk_core/common/action.c ****         /* Extentions */
 535:./tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 536:./tmk_core/common/action.c ****         case ACT_MACRO:
 537:./tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 538:./tmk_core/common/action.c ****             break;
 539:./tmk_core/common/action.c **** #endif
 540:./tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
 541:./tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 542:./tmk_core/common/action.c ****             if (!event.pressed) {
 543:./tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 544:./tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 545:./tmk_core/common/action.c ****                         backlight_increase();
 546:./tmk_core/common/action.c ****                         break;
 547:./tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 548:./tmk_core/common/action.c ****                         backlight_decrease();
 549:./tmk_core/common/action.c ****                         break;
 550:./tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 551:./tmk_core/common/action.c ****                         backlight_toggle();
 552:./tmk_core/common/action.c ****                         break;
 553:./tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 554:./tmk_core/common/action.c ****                         backlight_step();
 555:./tmk_core/common/action.c ****                         break;
 556:./tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 557:./tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 558:./tmk_core/common/action.c ****                         break;
 559:./tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 560:./tmk_core/common/action.c ****                         backlight_level(0);
 561:./tmk_core/common/action.c ****                         break;
 562:./tmk_core/common/action.c ****                 }
 563:./tmk_core/common/action.c ****             }
 564:./tmk_core/common/action.c ****             break;
 565:./tmk_core/common/action.c **** #endif
 566:./tmk_core/common/action.c ****         case ACT_COMMAND:
 567:./tmk_core/common/action.c ****             break;
 568:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 569:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 570:./tmk_core/common/action.c ****             switch (action.swap.code) {
 571:./tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 572:./tmk_core/common/action.c ****                     if (event.pressed) {
 573:./tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 574:./tmk_core/common/action.c ****                     }
 575:./tmk_core/common/action.c ****                     break;
 576:./tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 577:./tmk_core/common/action.c ****                     swap_hands = event.pressed;
 578:./tmk_core/common/action.c ****                     break;
 579:./tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 580:./tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 581:./tmk_core/common/action.c ****                     break;
 582:./tmk_core/common/action.c ****                 case OP_SH_ON:
 583:./tmk_core/common/action.c ****                     if (!event.pressed) {
 584:./tmk_core/common/action.c ****                         swap_hands = true;
 585:./tmk_core/common/action.c ****                     }
 586:./tmk_core/common/action.c ****                     break;
 587:./tmk_core/common/action.c ****                 case OP_SH_OFF:
 588:./tmk_core/common/action.c ****                     if (!event.pressed) {
 589:./tmk_core/common/action.c ****                         swap_hands = false;
 590:./tmk_core/common/action.c ****                     }
 591:./tmk_core/common/action.c ****                     break;
 592:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 593:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 594:./tmk_core/common/action.c ****                     /* tap toggle */
 595:./tmk_core/common/action.c **** 
 596:./tmk_core/common/action.c ****                     if (event.pressed) {
 597:./tmk_core/common/action.c ****                         if (swap_held) {
 598:./tmk_core/common/action.c ****                             swap_held = false;
 599:./tmk_core/common/action.c ****                         } else {
 600:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 601:./tmk_core/common/action.c ****                         }
 602:./tmk_core/common/action.c ****                     } else {
 603:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 604:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 605:./tmk_core/common/action.c ****                         }
 606:./tmk_core/common/action.c ****                     }
 607:./tmk_core/common/action.c ****                     break;
 608:./tmk_core/common/action.c ****                 default:
 609:./tmk_core/common/action.c ****                     /* tap key */
 610:./tmk_core/common/action.c ****                     if (tap_count > 0) {
 611:./tmk_core/common/action.c ****                         if (swap_held) {
 612:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 613:./tmk_core/common/action.c ****                             swap_held = false;
 614:./tmk_core/common/action.c ****                         }
 615:./tmk_core/common/action.c ****                         if (event.pressed) {
 616:./tmk_core/common/action.c ****                             register_code(action.swap.code);
 617:./tmk_core/common/action.c ****                         } else {
 618:./tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 619:./tmk_core/common/action.c ****                             *record = (keyrecord_t){}; // hack: reset tap mode
 620:./tmk_core/common/action.c ****                         }
 621:./tmk_core/common/action.c ****                     } else {
 622:./tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 623:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 624:./tmk_core/common/action.c ****                             swap_held = false;
 625:./tmk_core/common/action.c ****                         }
 626:./tmk_core/common/action.c ****                     }
 627:./tmk_core/common/action.c ****     #endif
 628:./tmk_core/common/action.c ****             }
 629:./tmk_core/common/action.c **** #endif
 630:./tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 631:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 632:./tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 633:./tmk_core/common/action.c ****             break;
 634:./tmk_core/common/action.c **** #endif
 635:./tmk_core/common/action.c ****         default:
 636:./tmk_core/common/action.c ****             break;
 637:./tmk_core/common/action.c ****     }
 638:./tmk_core/common/action.c **** 
 639:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 640:./tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 641:./tmk_core/common/action.c ****     switch (action.kind.id) {
 642:./tmk_core/common/action.c ****         case ACT_LAYER:
 643:./tmk_core/common/action.c ****         #ifndef NO_ACTION_TAPPING
 644:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 645:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 646:./tmk_core/common/action.c ****         #endif
 647:./tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 648:./tmk_core/common/action.c ****             break;
 649:./tmk_core/common/action.c ****         default:
 650:./tmk_core/common/action.c ****             break;
 651:./tmk_core/common/action.c ****     }
 652:./tmk_core/common/action.c **** #endif
 653:./tmk_core/common/action.c **** 
 654:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 655:./tmk_core/common/action.c ****   #ifdef RETRO_TAPPING
 656:./tmk_core/common/action.c ****   if (!is_tap_key(record->event.key)) {
 657:./tmk_core/common/action.c ****     retro_tapping_counter = 0;
 658:./tmk_core/common/action.c ****   } else {
 659:./tmk_core/common/action.c ****     if (event.pressed) {
 660:./tmk_core/common/action.c ****         if (tap_count > 0) {
 661:./tmk_core/common/action.c ****           retro_tapping_counter = 0;
 662:./tmk_core/common/action.c ****         } else {
 663:./tmk_core/common/action.c **** 
 664:./tmk_core/common/action.c ****         }
 665:./tmk_core/common/action.c ****     } else {
 666:./tmk_core/common/action.c ****       if (tap_count > 0) {
 667:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 668:./tmk_core/common/action.c ****       } else {
 669:./tmk_core/common/action.c ****         if (retro_tapping_counter == 2) {
 670:./tmk_core/common/action.c ****           register_code(action.layer_tap.code);
 671:./tmk_core/common/action.c ****           unregister_code(action.layer_tap.code);
 672:./tmk_core/common/action.c ****         }
 673:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 674:./tmk_core/common/action.c ****       }
 675:./tmk_core/common/action.c ****     }
 676:./tmk_core/common/action.c ****   }
 677:./tmk_core/common/action.c ****   #endif
 678:./tmk_core/common/action.c **** #endif
 679:./tmk_core/common/action.c **** 
 680:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 681:./tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 682:./tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 683:./tmk_core/common/action.c ****      */
 684:./tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 685:./tmk_core/common/action.c ****         record->event.pressed = false;
 686:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 687:./tmk_core/common/action.c ****         process_record(record);
 688:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 689:./tmk_core/common/action.c ****     }
 690:./tmk_core/common/action.c **** #endif
 691:./tmk_core/common/action.c **** }
 692:./tmk_core/common/action.c **** 
 693:./tmk_core/common/action.c **** 
 694:./tmk_core/common/action.c **** 
 695:./tmk_core/common/action.c **** 
 696:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 697:./tmk_core/common/action.c ****  *
 698:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 699:./tmk_core/common/action.c ****  */
 700:./tmk_core/common/action.c **** void register_code(uint8_t code)
 701:./tmk_core/common/action.c **** {
 137               		.loc 1 701 0
 138               		.cfi_startproc
 139               	.LVL9:
 140 0000 CF93      		push r28
 141               	.LCFI4:
 142               		.cfi_def_cfa_offset 3
 143               		.cfi_offset 28, -2
 144 0002 DF93      		push r29
 145               	.LCFI5:
 146               		.cfi_def_cfa_offset 4
 147               		.cfi_offset 29, -3
 148 0004 1F92      		push __zero_reg__
 149               	.LCFI6:
 150               		.cfi_def_cfa_offset 5
 151 0006 CDB7      		in r28,__SP_L__
 152 0008 DEB7      		in r29,__SP_H__
 153               	.LCFI7:
 154               		.cfi_def_cfa_register 28
 155               	/* prologue: function */
 156               	/* frame size = 1 */
 157               	/* stack size = 3 */
 158               	.L__stack_usage = 3
 159 000a 682F      		mov r22,r24
 702:./tmk_core/common/action.c ****     if (code == KC_NO) {
 160               		.loc 1 702 0
 161 000c 8823      		tst r24
 162 000e 01F4      		brne .+2
 163 0010 00C0      		rjmp .L4
 703:./tmk_core/common/action.c ****         return;
 704:./tmk_core/common/action.c ****     }
 705:./tmk_core/common/action.c **** 
 706:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 707:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 164               		.loc 1 707 0
 165 0012 8238      		cpi r24,lo8(-126)
 166 0014 01F4      		brne .L7
 708:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 709:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 710:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 167               		.loc 1 710 0
 168 0016 0E94 0000 		call host_keyboard_leds
 169               	.LVL10:
 170 001a 81FD      		sbrc r24,1
 171 001c 00C0      		rjmp .L4
 172               	.LVL11:
 173               	.LBB44:
 174               	.LBB45:
 175               		.file 2 "./tmk_core/common/action_util.h"
   1:./tmk_core/common/action_util.h **** /*
   2:./tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action_util.h **** 
   4:./tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action_util.h **** (at your option) any later version.
   8:./tmk_core/common/action_util.h **** 
   9:./tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:./tmk_core/common/action_util.h **** 
  14:./tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action_util.h **** */
  17:./tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:./tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:./tmk_core/common/action_util.h **** 
  20:./tmk_core/common/action_util.h **** #include <stdint.h>
  21:./tmk_core/common/action_util.h **** #include "report.h"
  22:./tmk_core/common/action_util.h **** 
  23:./tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:./tmk_core/common/action_util.h **** extern "C" {
  25:./tmk_core/common/action_util.h **** #endif
  26:./tmk_core/common/action_util.h **** 
  27:./tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:./tmk_core/common/action_util.h **** 
  29:./tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:./tmk_core/common/action_util.h **** 
  31:./tmk_core/common/action_util.h **** /* key */
  32:./tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 176               		.loc 2 33 0
 177 001e 69E3      		ldi r22,lo8(57)
 178 0020 8091 0000 		lds r24,keyboard_report
 179 0024 9091 0000 		lds r25,keyboard_report+1
 180 0028 0E94 0000 		call add_key_to_report
 181               	.LVL12:
 182               	.LBE45:
 183               	.LBE44:
 711:./tmk_core/common/action.c **** #endif
 712:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 713:./tmk_core/common/action.c ****         send_keyboard_report();
 184               		.loc 1 713 0
 185 002c 0E94 0000 		call send_keyboard_report
 186               	.LVL13:
 187               	.LBB46:
 188               	.LBB47:
 189               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 190               		.loc 3 164 0
 191 0030 2FEF      		ldi r18,lo8(319999)
 192 0032 81EE      		ldi r24,hi8(319999)
 193 0034 94E0      		ldi r25,hlo8(319999)
 194 0036 2150      		1: subi r18,1
 195 0038 8040      		sbci r24,0
 196 003a 9040      		sbci r25,0
 197 003c 01F4      		brne 1b
 198 003e 00C0      		rjmp .
 199 0040 0000      		nop
 200               	.LVL14:
 201               	.LBE47:
 202               	.LBE46:
 203               	.LBB48:
 204               	.LBB49:
  34:./tmk_core/common/action_util.h **** }
  35:./tmk_core/common/action_util.h **** 
  36:./tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:./tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 205               		.loc 2 37 0
 206 0042 69E3      		ldi r22,lo8(57)
 207 0044 00C0      		rjmp .L39
 208               	.LVL15:
 209               	.L7:
 210               	.LBE49:
 211               	.LBE48:
 714:./tmk_core/common/action.c ****         wait_ms(100);
 715:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 716:./tmk_core/common/action.c ****         send_keyboard_report();
 717:./tmk_core/common/action.c ****     }
 718:./tmk_core/common/action.c **** 
 719:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 212               		.loc 1 719 0
 213 0046 8338      		cpi r24,lo8(-125)
 214 0048 01F4      		brne .L9
 720:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 721:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 215               		.loc 1 721 0
 216 004a 0E94 0000 		call host_keyboard_leds
 217               	.LVL16:
 218 004e 80FD      		sbrc r24,0
 219 0050 00C0      		rjmp .L4
 220               	.LVL17:
 221               	.LBB50:
 222               	.LBB51:
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 223               		.loc 2 33 0
 224 0052 63E5      		ldi r22,lo8(83)
 225 0054 8091 0000 		lds r24,keyboard_report
 226 0058 9091 0000 		lds r25,keyboard_report+1
 227 005c 0E94 0000 		call add_key_to_report
 228               	.LVL18:
 229               	.LBE51:
 230               	.LBE50:
 722:./tmk_core/common/action.c **** #endif
 723:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 724:./tmk_core/common/action.c ****         send_keyboard_report();
 231               		.loc 1 724 0
 232 0060 0E94 0000 		call send_keyboard_report
 233               	.LVL19:
 234               	.LBB52:
 235               	.LBB53:
 236               		.loc 3 164 0
 237 0064 EFEF      		ldi r30,lo8(319999)
 238 0066 F1EE      		ldi r31,hi8(319999)
 239 0068 24E0      		ldi r18,hlo8(319999)
 240 006a E150      		1: subi r30,1
 241 006c F040      		sbci r31,0
 242 006e 2040      		sbci r18,0
 243 0070 01F4      		brne 1b
 244 0072 00C0      		rjmp .
 245 0074 0000      		nop
 246               	.LVL20:
 247               	.LBE53:
 248               	.LBE52:
 249               	.LBB54:
 250               	.LBB55:
 251               		.loc 2 37 0
 252 0076 63E5      		ldi r22,lo8(83)
 253               	.LVL21:
 254               	.L39:
 255 0078 8091 0000 		lds r24,keyboard_report
 256 007c 9091 0000 		lds r25,keyboard_report+1
 257 0080 0E94 0000 		call del_key_from_report
 258               	.LVL22:
 259               	.L40:
 260               	/* epilogue start */
 261               	.LBE55:
 262               	.LBE54:
 725:./tmk_core/common/action.c ****         wait_ms(100);
 726:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 727:./tmk_core/common/action.c ****         send_keyboard_report();
 728:./tmk_core/common/action.c ****     }
 729:./tmk_core/common/action.c **** 
 730:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 731:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 732:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 733:./tmk_core/common/action.c **** #endif
 734:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 735:./tmk_core/common/action.c ****         send_keyboard_report();
 736:./tmk_core/common/action.c ****         wait_ms(100);
 737:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 738:./tmk_core/common/action.c ****         send_keyboard_report();
 739:./tmk_core/common/action.c ****     }
 740:./tmk_core/common/action.c **** #endif
 741:./tmk_core/common/action.c **** 
 742:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 743:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 744:./tmk_core/common/action.c ****         if (command_proc(code)) return;
 745:./tmk_core/common/action.c **** 
 746:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 747:./tmk_core/common/action.c **** /* TODO: remove
 748:./tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 749:./tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 750:./tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 751:./tmk_core/common/action.c **** 
 752:./tmk_core/common/action.c ****             add_key(code);
 753:./tmk_core/common/action.c ****             send_keyboard_report();
 754:./tmk_core/common/action.c **** 
 755:./tmk_core/common/action.c ****             set_mods(tmp_mods);
 756:./tmk_core/common/action.c ****             send_keyboard_report();
 757:./tmk_core/common/action.c ****             oneshot_cancel();
 758:./tmk_core/common/action.c ****         } else
 759:./tmk_core/common/action.c **** */
 760:./tmk_core/common/action.c **** #endif
 761:./tmk_core/common/action.c ****         {
 762:./tmk_core/common/action.c ****             add_key(code);
 763:./tmk_core/common/action.c ****             send_keyboard_report();
 764:./tmk_core/common/action.c ****         }
 765:./tmk_core/common/action.c ****     }
 766:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 767:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 768:./tmk_core/common/action.c ****         send_keyboard_report();
 769:./tmk_core/common/action.c ****     }
 770:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 771:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 772:./tmk_core/common/action.c ****     }
 773:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 775:./tmk_core/common/action.c ****     }
 776:./tmk_core/common/action.c **** }
 263               		.loc 1 776 0
 264 0084 0F90      		pop __tmp_reg__
 265 0086 DF91      		pop r29
 266 0088 CF91      		pop r28
 727:./tmk_core/common/action.c ****         send_keyboard_report();
 267               		.loc 1 727 0
 268 008a 0C94 0000 		jmp send_keyboard_report
 269               	.LVL23:
 270               	.L9:
 730:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 271               		.loc 1 730 0
 272 008e 8438      		cpi r24,lo8(-124)
 273 0090 01F4      		brne .L10
 732:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 274               		.loc 1 732 0
 275 0092 0E94 0000 		call host_keyboard_leds
 276               	.LVL24:
 277 0096 82FD      		sbrc r24,2
 278 0098 00C0      		rjmp .L4
 279               	.LVL25:
 280               	.LBB56:
 281               	.LBB57:
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 282               		.loc 2 33 0
 283 009a 67E4      		ldi r22,lo8(71)
 284 009c 8091 0000 		lds r24,keyboard_report
 285 00a0 9091 0000 		lds r25,keyboard_report+1
 286 00a4 0E94 0000 		call add_key_to_report
 287               	.LVL26:
 288               	.LBE57:
 289               	.LBE56:
 735:./tmk_core/common/action.c ****         send_keyboard_report();
 290               		.loc 1 735 0
 291 00a8 0E94 0000 		call send_keyboard_report
 292               	.LVL27:
 293               	.LBB58:
 294               	.LBB59:
 295               		.loc 3 164 0
 296 00ac 8FEF      		ldi r24,lo8(319999)
 297 00ae 91EE      		ldi r25,hi8(319999)
 298 00b0 E4E0      		ldi r30,hlo8(319999)
 299 00b2 8150      		1: subi r24,1
 300 00b4 9040      		sbci r25,0
 301 00b6 E040      		sbci r30,0
 302 00b8 01F4      		brne 1b
 303 00ba 00C0      		rjmp .
 304 00bc 0000      		nop
 305               	.LVL28:
 306               	.LBE59:
 307               	.LBE58:
 308               	.LBB60:
 309               	.LBB61:
 310               		.loc 2 37 0
 311 00be 67E4      		ldi r22,lo8(71)
 312 00c0 00C0      		rjmp .L39
 313               	.LVL29:
 314               	.L10:
 315               	.LBE61:
 316               	.LBE60:
 742:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 317               		.loc 1 742 0
 318 00c2 8CEF      		ldi r24,lo8(-4)
 319 00c4 860F      		add r24,r22
 320 00c6 813A      		cpi r24,lo8(-95)
 321 00c8 00F4      		brsh .L11
 744:./tmk_core/common/action.c ****         if (command_proc(code)) return;
 322               		.loc 1 744 0
 323 00ca 862F      		mov r24,r22
 324 00cc 6983      		std Y+1,r22
 325 00ce 0E94 0000 		call command_proc
 326               	.LVL30:
 327 00d2 6981      		ldd r22,Y+1
 328 00d4 8111      		cpse r24,__zero_reg__
 329 00d6 00C0      		rjmp .L4
 330               	.LVL31:
 331               	.LBB62:
 332               	.LBB63:
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 333               		.loc 2 33 0
 334 00d8 8091 0000 		lds r24,keyboard_report
 335 00dc 9091 0000 		lds r25,keyboard_report+1
 336 00e0 0E94 0000 		call add_key_to_report
 337               	.LVL32:
 338 00e4 00C0      		rjmp .L40
 339               	.LVL33:
 340               	.L11:
 341               	.LBE63:
 342               	.LBE62:
 766:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 343               		.loc 1 766 0
 344 00e6 80E2      		ldi r24,lo8(32)
 345 00e8 860F      		add r24,r22
 346 00ea 8830      		cpi r24,lo8(8)
 347 00ec 00F4      		brsh .L12
 767:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 348               		.loc 1 767 0
 349 00ee 6770      		andi r22,lo8(7)
 350               	.LVL34:
 351 00f0 81E0      		ldi r24,lo8(1)
 352 00f2 00C0      		rjmp 2f
 353               		1:
 354 00f4 880F      		lsl r24
 355               		2:
 356 00f6 6A95      		dec r22
 357 00f8 02F4      		brpl 1b
 358 00fa 0E94 0000 		call add_mods
 359               	.LVL35:
 360 00fe 00C0      		rjmp .L40
 361               	.LVL36:
 362               	.L12:
 770:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 363               		.loc 1 770 0
 364 0100 8BE5      		ldi r24,lo8(91)
 365 0102 860F      		add r24,r22
 366 0104 8330      		cpi r24,lo8(3)
 367 0106 00F4      		brsh .L13
 771:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 368               		.loc 1 771 0
 369 0108 653A      		cpi r22,lo8(-91)
 370 010a 01F0      		breq .L16
 771:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 371               		.loc 1 771 0 is_stmt 0 discriminator 1
 372 010c 663A      		cpi r22,lo8(-90)
 373 010e 01F4      		brne .L17
 771:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 374               		.loc 1 771 0
 375 0110 82E8      		ldi r24,lo8(-126)
 376 0112 90E0      		ldi r25,0
 377 0114 00C0      		rjmp .L14
 378               	.L16:
 379 0116 81E8      		ldi r24,lo8(-127)
 380 0118 90E0      		ldi r25,0
 381 011a 00C0      		rjmp .L14
 382               	.L17:
 383 011c 83E8      		ldi r24,lo8(-125)
 384 011e 90E0      		ldi r25,0
 385               	.L14:
 386               	/* epilogue start */
 387               		.loc 1 776 0 is_stmt 1 discriminator 4
 388 0120 0F90      		pop __tmp_reg__
 389 0122 DF91      		pop r29
 390 0124 CF91      		pop r28
 771:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 391               		.loc 1 771 0 discriminator 4
 392 0126 0C94 0000 		jmp host_system_send
 393               	.LVL37:
 394               	.L13:
 773:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 395               		.loc 1 773 0
 396 012a 88E5      		ldi r24,lo8(88)
 397 012c 860F      		add r24,r22
 398 012e 8531      		cpi r24,lo8(21)
 399 0130 00F0      		brlo .+2
 400 0132 00C0      		rjmp .L4
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 401               		.loc 1 774 0
 402 0134 683A      		cpi r22,lo8(-88)
 403 0136 01F0      		breq .L18
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 404               		.loc 1 774 0 is_stmt 0 discriminator 1
 405 0138 693A      		cpi r22,lo8(-87)
 406 013a 01F0      		breq .L19
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 407               		.loc 1 774 0 discriminator 3
 408 013c 6A3A      		cpi r22,lo8(-86)
 409 013e 01F0      		breq .L20
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 410               		.loc 1 774 0 discriminator 5
 411 0140 6B3A      		cpi r22,lo8(-85)
 412 0142 01F0      		breq .L21
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 413               		.loc 1 774 0 discriminator 7
 414 0144 6C3A      		cpi r22,lo8(-84)
 415 0146 01F0      		breq .L22
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 416               		.loc 1 774 0 discriminator 9
 417 0148 6B3B      		cpi r22,lo8(-69)
 418 014a 01F0      		breq .L23
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 419               		.loc 1 774 0 discriminator 11
 420 014c 6C3B      		cpi r22,lo8(-68)
 421 014e 01F0      		breq .L24
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 422               		.loc 1 774 0 discriminator 13
 423 0150 6D3A      		cpi r22,lo8(-83)
 424 0152 01F0      		breq .L25
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 425               		.loc 1 774 0 discriminator 15
 426 0154 603B      		cpi r22,lo8(-80)
 427 0156 01F0      		breq .L26
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 428               		.loc 1 774 0 discriminator 17
 429 0158 6E3A      		cpi r22,lo8(-82)
 430 015a 01F0      		breq .L27
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 431               		.loc 1 774 0 discriminator 19
 432 015c 6F3A      		cpi r22,lo8(-81)
 433 015e 01F0      		breq .L28
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 434               		.loc 1 774 0 discriminator 21
 435 0160 613B      		cpi r22,lo8(-79)
 436 0162 01F0      		breq .L29
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 437               		.loc 1 774 0 discriminator 23
 438 0164 623B      		cpi r22,lo8(-78)
 439 0166 01F0      		breq .L30
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 440               		.loc 1 774 0 discriminator 25
 441 0168 633B      		cpi r22,lo8(-77)
 442 016a 01F0      		breq .L31
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 443               		.loc 1 774 0 discriminator 27
 444 016c 643B      		cpi r22,lo8(-76)
 445 016e 01F0      		breq .L32
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 446               		.loc 1 774 0 discriminator 29
 447 0170 653B      		cpi r22,lo8(-75)
 448 0172 01F0      		breq .L33
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 449               		.loc 1 774 0 discriminator 31
 450 0174 663B      		cpi r22,lo8(-74)
 451 0176 01F0      		breq .L34
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 452               		.loc 1 774 0 discriminator 33
 453 0178 673B      		cpi r22,lo8(-73)
 454 017a 01F0      		breq .L35
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 455               		.loc 1 774 0 discriminator 35
 456 017c 683B      		cpi r22,lo8(-72)
 457 017e 01F0      		breq .L36
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 458               		.loc 1 774 0 discriminator 37
 459 0180 693B      		cpi r22,lo8(-71)
 460 0182 01F0      		breq .L37
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 461               		.loc 1 774 0 discriminator 39
 462 0184 6A3B      		cpi r22,lo8(-70)
 463 0186 01F0      		breq .+2
 464 0188 00C0      		rjmp .L38
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 465               		.loc 1 774 0
 466 018a 8AE2      		ldi r24,lo8(42)
 467 018c 92E0      		ldi r25,lo8(2)
 468 018e 00C0      		rjmp .L15
 469               	.L18:
 470 0190 82EE      		ldi r24,lo8(-30)
 471 0192 90E0      		ldi r25,0
 472 0194 00C0      		rjmp .L15
 473               	.L19:
 474 0196 89EE      		ldi r24,lo8(-23)
 475 0198 90E0      		ldi r25,0
 476 019a 00C0      		rjmp .L15
 477               	.L20:
 478 019c 8AEE      		ldi r24,lo8(-22)
 479 019e 90E0      		ldi r25,0
 480 01a0 00C0      		rjmp .L15
 481               	.L21:
 482 01a2 85EB      		ldi r24,lo8(-75)
 483 01a4 90E0      		ldi r25,0
 484 01a6 00C0      		rjmp .L15
 485               	.L22:
 486 01a8 86EB      		ldi r24,lo8(-74)
 487 01aa 90E0      		ldi r25,0
 488 01ac 00C0      		rjmp .L15
 489               	.L23:
 490 01ae 83EB      		ldi r24,lo8(-77)
 491 01b0 90E0      		ldi r25,0
 492 01b2 00C0      		rjmp .L15
 493               	.L24:
 494 01b4 84EB      		ldi r24,lo8(-76)
 495 01b6 90E0      		ldi r25,0
 496 01b8 00C0      		rjmp .L15
 497               	.L25:
 498 01ba 87EB      		ldi r24,lo8(-73)
 499 01bc 90E0      		ldi r25,0
 500 01be 00C0      		rjmp .L15
 501               	.L26:
 502 01c0 8CEC      		ldi r24,lo8(-52)
 503 01c2 90E0      		ldi r25,0
 504 01c4 00C0      		rjmp .L15
 505               	.L27:
 506 01c6 8DEC      		ldi r24,lo8(-51)
 507 01c8 90E0      		ldi r25,0
 508 01ca 00C0      		rjmp .L15
 509               	.L28:
 510 01cc 83E8      		ldi r24,lo8(-125)
 511 01ce 91E0      		ldi r25,lo8(1)
 512 01d0 00C0      		rjmp .L15
 513               	.L29:
 514 01d2 8AE8      		ldi r24,lo8(-118)
 515 01d4 91E0      		ldi r25,lo8(1)
 516 01d6 00C0      		rjmp .L15
 517               	.L30:
 518 01d8 82E9      		ldi r24,lo8(-110)
 519 01da 91E0      		ldi r25,lo8(1)
 520 01dc 00C0      		rjmp .L15
 521               	.L31:
 522 01de 84E9      		ldi r24,lo8(-108)
 523 01e0 91E0      		ldi r25,lo8(1)
 524 01e2 00C0      		rjmp .L15
 525               	.L32:
 526 01e4 81E2      		ldi r24,lo8(33)
 527 01e6 92E0      		ldi r25,lo8(2)
 528 01e8 00C0      		rjmp .L15
 529               	.L33:
 530 01ea 83E2      		ldi r24,lo8(35)
 531 01ec 92E0      		ldi r25,lo8(2)
 532 01ee 00C0      		rjmp .L15
 533               	.L34:
 534 01f0 84E2      		ldi r24,lo8(36)
 535 01f2 92E0      		ldi r25,lo8(2)
 536 01f4 00C0      		rjmp .L15
 537               	.L35:
 538 01f6 85E2      		ldi r24,lo8(37)
 539 01f8 92E0      		ldi r25,lo8(2)
 540 01fa 00C0      		rjmp .L15
 541               	.L36:
 542 01fc 86E2      		ldi r24,lo8(38)
 543 01fe 92E0      		ldi r25,lo8(2)
 544 0200 00C0      		rjmp .L15
 545               	.L37:
 546 0202 87E2      		ldi r24,lo8(39)
 547 0204 92E0      		ldi r25,lo8(2)
 548 0206 00C0      		rjmp .L15
 549               	.L38:
 550 0208 80E0      		ldi r24,0
 551 020a 90E0      		ldi r25,0
 552               	.L15:
 553               	/* epilogue start */
 554               		.loc 1 776 0 is_stmt 1 discriminator 43
 555 020c 0F90      		pop __tmp_reg__
 556 020e DF91      		pop r29
 557 0210 CF91      		pop r28
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 558               		.loc 1 774 0 discriminator 43
 559 0212 0C94 0000 		jmp host_consumer_send
 560               	.LVL38:
 561               	.L4:
 562               	/* epilogue start */
 563               		.loc 1 776 0
 564 0216 0F90      		pop __tmp_reg__
 565 0218 DF91      		pop r29
 566 021a CF91      		pop r28
 567 021c 0895      		ret
 568               		.cfi_endproc
 569               	.LFE19:
 571               		.section	.text.unregister_code,"ax",@progbits
 572               	.global	unregister_code
 574               	unregister_code:
 575               	.LFB20:
 777:./tmk_core/common/action.c **** 
 778:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 779:./tmk_core/common/action.c ****  *
 780:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 781:./tmk_core/common/action.c ****  */
 782:./tmk_core/common/action.c **** void unregister_code(uint8_t code)
 783:./tmk_core/common/action.c **** {
 576               		.loc 1 783 0
 577               		.cfi_startproc
 578               	.LVL39:
 579               	/* prologue: function */
 580               	/* frame size = 0 */
 581               	/* stack size = 0 */
 582               	.L__stack_usage = 0
 784:./tmk_core/common/action.c ****     if (code == KC_NO) {
 583               		.loc 1 784 0
 584 0000 8823      		tst r24
 585 0002 01F4      		brne .+2
 586 0004 00C0      		rjmp .L42
 785:./tmk_core/common/action.c ****         return;
 786:./tmk_core/common/action.c ****     }
 787:./tmk_core/common/action.c **** 
 788:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 789:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 587               		.loc 1 789 0
 588 0006 8238      		cpi r24,lo8(-126)
 589 0008 01F4      		brne .L45
 790:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 791:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 792:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 590               		.loc 1 792 0
 591 000a 0E94 0000 		call host_keyboard_leds
 592               	.LVL40:
 593 000e 81FF      		sbrs r24,1
 594 0010 00C0      		rjmp .L42
 595               	.LVL41:
 596               	.LBB64:
 597               	.LBB65:
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 598               		.loc 2 33 0
 599 0012 69E3      		ldi r22,lo8(57)
 600 0014 8091 0000 		lds r24,keyboard_report
 601 0018 9091 0000 		lds r25,keyboard_report+1
 602 001c 0E94 0000 		call add_key_to_report
 603               	.LVL42:
 604               	.LBE65:
 605               	.LBE64:
 793:./tmk_core/common/action.c **** #endif
 794:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 795:./tmk_core/common/action.c ****         send_keyboard_report();
 606               		.loc 1 795 0
 607 0020 0E94 0000 		call send_keyboard_report
 608               	.LVL43:
 609               	.LBB66:
 610               	.LBB67:
 611               		.loc 2 37 0
 612 0024 69E3      		ldi r22,lo8(57)
 613 0026 00C0      		rjmp .L61
 614               	.LVL44:
 615               	.L45:
 616               	.LBE67:
 617               	.LBE66:
 796:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 797:./tmk_core/common/action.c ****         send_keyboard_report();
 798:./tmk_core/common/action.c ****     }
 799:./tmk_core/common/action.c **** 
 800:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 618               		.loc 1 800 0
 619 0028 8338      		cpi r24,lo8(-125)
 620 002a 01F4      		brne .L47
 801:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 802:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 621               		.loc 1 802 0
 622 002c 0E94 0000 		call host_keyboard_leds
 623               	.LVL45:
 624 0030 80FF      		sbrs r24,0
 625 0032 00C0      		rjmp .L42
 626               	.LVL46:
 627               	.LBB68:
 628               	.LBB69:
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 629               		.loc 2 33 0
 630 0034 63E5      		ldi r22,lo8(83)
 631 0036 8091 0000 		lds r24,keyboard_report
 632 003a 9091 0000 		lds r25,keyboard_report+1
 633 003e 0E94 0000 		call add_key_to_report
 634               	.LVL47:
 635               	.LBE69:
 636               	.LBE68:
 803:./tmk_core/common/action.c **** #endif
 804:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 805:./tmk_core/common/action.c ****         send_keyboard_report();
 637               		.loc 1 805 0
 638 0042 0E94 0000 		call send_keyboard_report
 639               	.LVL48:
 640               	.LBB70:
 641               	.LBB71:
 642               		.loc 2 37 0
 643 0046 63E5      		ldi r22,lo8(83)
 644               	.LVL49:
 645               	.L61:
 646 0048 8091 0000 		lds r24,keyboard_report
 647 004c 9091 0000 		lds r25,keyboard_report+1
 648 0050 0E94 0000 		call del_key_from_report
 649               	.LVL50:
 650               	.L62:
 651               	.LBE71:
 652               	.LBE70:
 806:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 807:./tmk_core/common/action.c ****         send_keyboard_report();
 653               		.loc 1 807 0
 654 0054 0C94 0000 		jmp send_keyboard_report
 655               	.LVL51:
 656               	.L47:
 808:./tmk_core/common/action.c ****     }
 809:./tmk_core/common/action.c **** 
 810:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 657               		.loc 1 810 0
 658 0058 8438      		cpi r24,lo8(-124)
 659 005a 01F4      		brne .L48
 811:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 812:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 660               		.loc 1 812 0
 661 005c 0E94 0000 		call host_keyboard_leds
 662               	.LVL52:
 663 0060 82FF      		sbrs r24,2
 664 0062 00C0      		rjmp .L42
 665               	.LVL53:
 666               	.LBB72:
 667               	.LBB73:
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 668               		.loc 2 33 0
 669 0064 67E4      		ldi r22,lo8(71)
 670 0066 8091 0000 		lds r24,keyboard_report
 671 006a 9091 0000 		lds r25,keyboard_report+1
 672 006e 0E94 0000 		call add_key_to_report
 673               	.LVL54:
 674               	.LBE73:
 675               	.LBE72:
 813:./tmk_core/common/action.c **** #endif
 814:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 815:./tmk_core/common/action.c ****         send_keyboard_report();
 676               		.loc 1 815 0
 677 0072 0E94 0000 		call send_keyboard_report
 678               	.LVL55:
 679               	.LBB74:
 680               	.LBB75:
 681               		.loc 2 37 0
 682 0076 67E4      		ldi r22,lo8(71)
 683 0078 00C0      		rjmp .L61
 684               	.LVL56:
 685               	.L48:
 686               	.LBE75:
 687               	.LBE74:
 816:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 817:./tmk_core/common/action.c ****         send_keyboard_report();
 818:./tmk_core/common/action.c ****     }
 819:./tmk_core/common/action.c **** #endif
 820:./tmk_core/common/action.c **** 
 821:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 688               		.loc 1 821 0
 689 007a 9CEF      		ldi r25,lo8(-4)
 690 007c 980F      		add r25,r24
 691 007e 913A      		cpi r25,lo8(-95)
 692 0080 00F4      		brsh .L49
 693               	.LVL57:
 694               	.LBB76:
 695               	.LBB77:
 696               		.loc 2 37 0
 697 0082 682F      		mov r22,r24
 698 0084 00C0      		rjmp .L61
 699               	.LVL58:
 700               	.L49:
 701               	.LBE77:
 702               	.LBE76:
 822:./tmk_core/common/action.c ****         del_key(code);
 823:./tmk_core/common/action.c ****         send_keyboard_report();
 824:./tmk_core/common/action.c ****     }
 825:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 703               		.loc 1 825 0
 704 0086 90E2      		ldi r25,lo8(32)
 705 0088 980F      		add r25,r24
 706 008a 9830      		cpi r25,lo8(8)
 707 008c 00F4      		brsh .L50
 826:./tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 708               		.loc 1 826 0
 709 008e 8770      		andi r24,lo8(7)
 710               	.LVL59:
 711 0090 91E0      		ldi r25,lo8(1)
 712 0092 00C0      		rjmp 2f
 713               		1:
 714 0094 990F      		lsl r25
 715               		2:
 716 0096 8A95      		dec r24
 717 0098 02F4      		brpl 1b
 718 009a 892F      		mov r24,r25
 719 009c 0E94 0000 		call del_mods
 720               	.LVL60:
 721 00a0 00C0      		rjmp .L62
 722               	.LVL61:
 723               	.L50:
 827:./tmk_core/common/action.c ****         send_keyboard_report();
 828:./tmk_core/common/action.c ****     }
 829:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 724               		.loc 1 829 0
 725 00a2 9BE5      		ldi r25,lo8(91)
 726 00a4 980F      		add r25,r24
 727 00a6 9330      		cpi r25,lo8(3)
 728 00a8 00F4      		brsh .L51
 830:./tmk_core/common/action.c ****         host_system_send(0);
 729               		.loc 1 830 0
 730 00aa 80E0      		ldi r24,0
 731 00ac 90E0      		ldi r25,0
 732               	.LVL62:
 733 00ae 0C94 0000 		jmp host_system_send
 734               	.LVL63:
 735               	.L51:
 831:./tmk_core/common/action.c ****     }
 832:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 736               		.loc 1 832 0
 737 00b2 885A      		subi r24,lo8(-(88))
 738               	.LVL64:
 739 00b4 8531      		cpi r24,lo8(21)
 740 00b6 00F4      		brsh .L42
 833:./tmk_core/common/action.c ****         host_consumer_send(0);
 741               		.loc 1 833 0
 742 00b8 80E0      		ldi r24,0
 743 00ba 90E0      		ldi r25,0
 744               	.LVL65:
 745 00bc 0C94 0000 		jmp host_consumer_send
 746               	.LVL66:
 747               	.L42:
 748 00c0 0895      		ret
 749               		.cfi_endproc
 750               	.LFE20:
 752               		.section	.text.register_mods,"ax",@progbits
 753               	.global	register_mods
 755               	register_mods:
 756               	.LFB21:
 834:./tmk_core/common/action.c ****     }
 835:./tmk_core/common/action.c **** }
 836:./tmk_core/common/action.c **** 
 837:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 838:./tmk_core/common/action.c ****  *
 839:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 840:./tmk_core/common/action.c ****  */
 841:./tmk_core/common/action.c **** void register_mods(uint8_t mods)
 842:./tmk_core/common/action.c **** {
 757               		.loc 1 842 0
 758               		.cfi_startproc
 759               	.LVL67:
 760               	/* prologue: function */
 761               	/* frame size = 0 */
 762               	/* stack size = 0 */
 763               	.L__stack_usage = 0
 843:./tmk_core/common/action.c ****     if (mods) {
 764               		.loc 1 843 0
 765 0000 8823      		tst r24
 766 0002 01F0      		breq .L63
 844:./tmk_core/common/action.c ****         add_mods(mods);
 767               		.loc 1 844 0
 768 0004 0E94 0000 		call add_mods
 769               	.LVL68:
 845:./tmk_core/common/action.c ****         send_keyboard_report();
 770               		.loc 1 845 0
 771 0008 0C94 0000 		jmp send_keyboard_report
 772               	.LVL69:
 773               	.L63:
 774 000c 0895      		ret
 775               		.cfi_endproc
 776               	.LFE21:
 778               		.section	.text.unregister_mods,"ax",@progbits
 779               	.global	unregister_mods
 781               	unregister_mods:
 782               	.LFB22:
 846:./tmk_core/common/action.c ****     }
 847:./tmk_core/common/action.c **** }
 848:./tmk_core/common/action.c **** 
 849:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 850:./tmk_core/common/action.c ****  *
 851:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 852:./tmk_core/common/action.c ****  */
 853:./tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 854:./tmk_core/common/action.c **** {
 783               		.loc 1 854 0
 784               		.cfi_startproc
 785               	.LVL70:
 786               	/* prologue: function */
 787               	/* frame size = 0 */
 788               	/* stack size = 0 */
 789               	.L__stack_usage = 0
 855:./tmk_core/common/action.c ****     if (mods) {
 790               		.loc 1 855 0
 791 0000 8823      		tst r24
 792 0002 01F0      		breq .L65
 856:./tmk_core/common/action.c ****         del_mods(mods);
 793               		.loc 1 856 0
 794 0004 0E94 0000 		call del_mods
 795               	.LVL71:
 857:./tmk_core/common/action.c ****         send_keyboard_report();
 796               		.loc 1 857 0
 797 0008 0C94 0000 		jmp send_keyboard_report
 798               	.LVL72:
 799               	.L65:
 800 000c 0895      		ret
 801               		.cfi_endproc
 802               	.LFE22:
 804               		.section	.text.process_action,"ax",@progbits
 805               	.global	process_action
 807               	process_action:
 808               	.LFB18:
 195:./tmk_core/common/action.c **** {
 809               		.loc 1 195 0
 810               		.cfi_startproc
 811               	.LVL73:
 812 0000 8F92      		push r8
 813               	.LCFI8:
 814               		.cfi_def_cfa_offset 3
 815               		.cfi_offset 8, -2
 816 0002 9F92      		push r9
 817               	.LCFI9:
 818               		.cfi_def_cfa_offset 4
 819               		.cfi_offset 9, -3
 820 0004 BF92      		push r11
 821               	.LCFI10:
 822               		.cfi_def_cfa_offset 5
 823               		.cfi_offset 11, -4
 824 0006 CF92      		push r12
 825               	.LCFI11:
 826               		.cfi_def_cfa_offset 6
 827               		.cfi_offset 12, -5
 828 0008 DF92      		push r13
 829               	.LCFI12:
 830               		.cfi_def_cfa_offset 7
 831               		.cfi_offset 13, -6
 832 000a EF92      		push r14
 833               	.LCFI13:
 834               		.cfi_def_cfa_offset 8
 835               		.cfi_offset 14, -7
 836 000c FF92      		push r15
 837               	.LCFI14:
 838               		.cfi_def_cfa_offset 9
 839               		.cfi_offset 15, -8
 840 000e 0F93      		push r16
 841               	.LCFI15:
 842               		.cfi_def_cfa_offset 10
 843               		.cfi_offset 16, -9
 844 0010 1F93      		push r17
 845               	.LCFI16:
 846               		.cfi_def_cfa_offset 11
 847               		.cfi_offset 17, -10
 848 0012 CF93      		push r28
 849               	.LCFI17:
 850               		.cfi_def_cfa_offset 12
 851               		.cfi_offset 28, -11
 852 0014 DF93      		push r29
 853               	.LCFI18:
 854               		.cfi_def_cfa_offset 13
 855               		.cfi_offset 29, -12
 856 0016 00D0      		rcall .
 857               	.LCFI19:
 858               		.cfi_def_cfa_offset 15
 859 0018 CDB7      		in r28,__SP_L__
 860 001a DEB7      		in r29,__SP_H__
 861               	.LCFI20:
 862               		.cfi_def_cfa_register 28
 863               	/* prologue: function */
 864               	/* frame size = 2 */
 865               	/* stack size = 13 */
 866               	.L__stack_usage = 13
 867 001c 4C01      		movw r8,r24
 868 001e 472F      		mov r20,r23
 869               	.LVL74:
 198:./tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 870               		.loc 1 198 0
 871 0020 FC01      		movw r30,r24
 872 0022 C580      		ldd r12,Z+5
 873 0024 C294      		swap r12
 874 0026 9FE0      		ldi r25,lo8(15)
 875 0028 C922      		and r12,r25
 876               	.LVL75:
 201:./tmk_core/common/action.c ****     if (event.pressed) {
 877               		.loc 1 201 0
 878 002a D280      		ldd r13,Z+2
 879 002c DD20      		tst r13
 880 002e 01F0      		breq .L68
 203:./tmk_core/common/action.c ****         clear_weak_mods();
 881               		.loc 1 203 0
 882 0030 7983      		std Y+1,r23
 883               	.LVL76:
 884 0032 6A83      		std Y+2,r22
 885 0034 0E94 0000 		call clear_weak_mods
 886               	.LVL77:
 887 0038 6A81      		ldd r22,Y+2
 888 003a 4981      		ldd r20,Y+1
 889               	.LVL78:
 890               	.L68:
 209:./tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 891               		.loc 1 209 0
 892 003c 4983      		std Y+1,r20
 893 003e 6A83      		std Y+2,r22
 894 0040 0E94 0000 		call is_oneshot_layer_active
 895               	.LVL79:
 896 0044 4981      		ldd r20,Y+1
 897 0046 6A81      		ldd r22,Y+2
 898 0048 8823      		tst r24
 899 004a 01F0      		breq .L158
 209:./tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 900               		.loc 1 209 0 is_stmt 0 discriminator 1
 901 004c DD20      		tst r13
 902 004e 01F0      		breq .L158
 903 0050 80E2      		ldi r24,lo8(32)
 904 0052 860F      		add r24,r22
 905 0054 8830      		cpi r24,lo8(8)
 906 0056 00F0      		brlo .L158
 210:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 907               		.loc 1 210 0 is_stmt 1
 908 0058 82E0      		ldi r24,lo8(2)
 909 005a 0E94 0000 		call clear_oneshot_layer_state
 910               	.LVL80:
 211:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 911               		.loc 1 211 0
 912 005e 0E94 0000 		call is_oneshot_layer_active
 913               	.LVL81:
 914 0062 BB24      		clr r11
 915 0064 B394      		inc r11
 916 0066 B826      		eor r11,r24
 917               	.LVL82:
 918 0068 4981      		ldd r20,Y+1
 919 006a 6A81      		ldd r22,Y+2
 920 006c 00C0      		rjmp .L69
 921               	.LVL83:
 922               	.L158:
 207:./tmk_core/common/action.c ****     bool do_release_oneshot = false;
 923               		.loc 1 207 0
 924 006e B12C      		mov r11,__zero_reg__
 925               	.LVL84:
 926               	.L69:
 215:./tmk_core/common/action.c ****     switch (action.kind.id) {
 927               		.loc 1 215 0
 928 0070 E42E      		mov r14,r20
 929 0072 E294      		swap r14
 930 0074 8FE0      		ldi r24,lo8(15)
 931 0076 E822      		and r14,r24
 932 0078 F12C      		mov r15,__zero_reg__
 933 007a F701      		movw r30,r14
 934 007c E050      		subi r30,lo8(-(gs(.L72)))
 935 007e F040      		sbci r31,hi8(-(gs(.L72)))
 936 0080 0C94 0000 		jmp __tablejump2__
 937               		.section	.progmem.gcc_sw_table.process_action,"a",@progbits
 938               		.p2align	1
 939               	.L72:
 940 0000 0000      		.word gs(.L71)
 941 0002 0000      		.word gs(.L71)
 942 0004 0000      		.word gs(.L73)
 943 0006 0000      		.word gs(.L73)
 944 0008 0000      		.word gs(.L74)
 945 000a 0000      		.word gs(.L75)
 946 000c 0000      		.word gs(.L70)
 947 000e 0000      		.word gs(.L70)
 948 0010 0000      		.word gs(.L76)
 949 0012 0000      		.word gs(.L70)
 950 0014 0000      		.word gs(.L77)
 951 0016 0000      		.word gs(.L77)
 952 0018 0000      		.word gs(.L78)
 953 001a 0000      		.word gs(.L70)
 954 001c 0000      		.word gs(.L70)
 955 001e 0000      		.word gs(.L79)
 956               		.section	.text.process_action
 957               	.L71:
 958               	.LBB78:
 220:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 959               		.loc 1 220 0
 960 0084 842F      		mov r24,r20
 961 0086 807F      		andi r24,lo8(-16)
 962 0088 142F      		mov r17,r20
 963 008a 1F70      		andi r17,lo8(15)
 964 008c 8823      		tst r24
 965 008e 01F0      		breq .L81
 220:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 966               		.loc 1 220 0 is_stmt 0 discriminator 2
 967 0090 1295      		swap r17
 968 0092 107F      		andi r17,lo8(-16)
 969               	.L81:
 970               	.LVL85:
 222:./tmk_core/common/action.c ****                 if (event.pressed) {
 971               		.loc 1 222 0 is_stmt 1 discriminator 3
 972 0094 DD20      		tst r13
 973 0096 01F0      		breq .L82
 223:./tmk_core/common/action.c ****                     if (mods) {
 974               		.loc 1 223 0
 975 0098 1123      		tst r17
 976 009a 01F4      		brne .+2
 977 009c 00C0      		rjmp .L189
 224:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 978               		.loc 1 224 0
 979 009e 80E2      		ldi r24,lo8(32)
 980 00a0 860F      		add r24,r22
 981 00a2 8830      		cpi r24,lo8(8)
 982 00a4 00F0      		brlo .L84
 224:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 983               		.loc 1 224 0 is_stmt 0 discriminator 1
 984 00a6 6111      		cpse r22,__zero_reg__
 985 00a8 00C0      		rjmp .L85
 986               	.L84:
 228:./tmk_core/common/action.c ****                             add_mods(mods);
 987               		.loc 1 228 0 is_stmt 1
 988 00aa 812F      		mov r24,r17
 989 00ac 6A83      		std Y+2,r22
 990 00ae 0E94 0000 		call add_mods
 991               	.LVL86:
 992 00b2 00C0      		rjmp .L186
 993               	.LVL87:
 994               	.L85:
 230:./tmk_core/common/action.c ****                             add_weak_mods(mods);
 995               		.loc 1 230 0
 996 00b4 812F      		mov r24,r17
 997 00b6 6A83      		std Y+2,r22
 998 00b8 0E94 0000 		call add_weak_mods
 999               	.LVL88:
 1000               	.L186:
 1001 00bc 6A81      		ldd r22,Y+2
 232:./tmk_core/common/action.c ****                         send_keyboard_report();
 1002               		.loc 1 232 0
 1003 00be 6A83      		std Y+2,r22
 1004 00c0 0E94 0000 		call send_keyboard_report
 1005               	.LVL89:
 1006 00c4 6A81      		ldd r22,Y+2
 1007 00c6 00C0      		rjmp .L189
 1008               	.LVL90:
 1009               	.L82:
 236:./tmk_core/common/action.c ****                     unregister_code(action.key.code);
 1010               		.loc 1 236 0
 1011 00c8 862F      		mov r24,r22
 1012 00ca 6A83      		std Y+2,r22
 1013               	.LVL91:
 1014 00cc 0E94 0000 		call unregister_code
 1015               	.LVL92:
 237:./tmk_core/common/action.c ****                     if (mods) {
 1016               		.loc 1 237 0
 1017 00d0 6A81      		ldd r22,Y+2
 1018 00d2 1123      		tst r17
 1019 00d4 01F4      		brne .+2
 1020 00d6 00C0      		rjmp .L70
 238:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1021               		.loc 1 238 0
 1022 00d8 80E2      		ldi r24,lo8(32)
 1023 00da 860F      		add r24,r22
 1024 00dc 8830      		cpi r24,lo8(8)
 1025 00de 00F0      		brlo .L88
 238:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1026               		.loc 1 238 0 is_stmt 0 discriminator 1
 1027 00e0 6111      		cpse r22,__zero_reg__
 1028 00e2 00C0      		rjmp .L89
 1029               	.L88:
 239:./tmk_core/common/action.c ****                             del_mods(mods);
 1030               		.loc 1 239 0 is_stmt 1
 1031 00e4 812F      		mov r24,r17
 1032 00e6 0E94 0000 		call del_mods
 1033               	.LVL93:
 1034 00ea 00C0      		rjmp .L90
 1035               	.L89:
 241:./tmk_core/common/action.c ****                             del_weak_mods(mods);
 1036               		.loc 1 241 0
 1037 00ec 812F      		mov r24,r17
 1038 00ee 0E94 0000 		call del_weak_mods
 1039               	.LVL94:
 1040               	.L90:
 243:./tmk_core/common/action.c ****                         send_keyboard_report();
 1041               		.loc 1 243 0
 1042 00f2 0E94 0000 		call send_keyboard_report
 1043               	.LVL95:
 1044 00f6 00C0      		rjmp .L70
 1045               	.LVL96:
 1046               	.L73:
 1047               	.LBE78:
 1048               	.LBB79:
 252:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 1049               		.loc 1 252 0
 1050 00f8 842F      		mov r24,r20
 1051 00fa 807F      		andi r24,lo8(-16)
 1052 00fc 142F      		mov r17,r20
 1053 00fe 1F70      		andi r17,lo8(15)
 1054 0100 8032      		cpi r24,lo8(32)
 1055 0102 01F0      		breq .L92
 252:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 1056               		.loc 1 252 0 is_stmt 0 discriminator 2
 1057 0104 1295      		swap r17
 1058 0106 107F      		andi r17,lo8(-16)
 1059               	.L92:
 1060               	.LVL97:
 254:./tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 1061               		.loc 1 254 0 is_stmt 1 discriminator 3
 1062 0108 6623      		tst r22
 1063 010a 01F0      		breq .L94
 1064 010c 6130      		cpi r22,lo8(1)
 1065 010e 01F0      		breq .L95
 1066 0110 00C0      		rjmp .L199
 1067               	.L94:
 258:./tmk_core/common/action.c ****                         if (event.pressed) {
 1068               		.loc 1 258 0
 1069 0112 DD20      		tst r13
 1070 0114 01F0      		breq .L96
 259:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 1071               		.loc 1 259 0
 1072 0116 CC20      		tst r12
 1073 0118 01F0      		breq .L98
 262:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 1074               		.loc 1 262 0
 1075 011a F1E0      		ldi r31,lo8(1)
 1076 011c CF12      		cpse r12,r31
 1077 011e 00C0      		rjmp .L98
 264:./tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 1078               		.loc 1 264 0
 1079 0120 0E94 0000 		call get_oneshot_mods
 1080               	.LVL98:
 1081 0124 812B      		or r24,r17
 1082 0126 0E94 0000 		call set_oneshot_mods
 1083               	.LVL99:
 1084 012a 00C0      		rjmp .L70
 1085               	.LVL100:
 1086               	.L98:
 273:./tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 1087               		.loc 1 273 0
 1088 012c 0E94 0000 		call get_oneshot_mods
 1089               	.LVL101:
 1090 0130 812B      		or r24,r17
 1091 0132 00C0      		rjmp .L190
 1092               	.LVL102:
 1093               	.L96:
 276:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 1094               		.loc 1 276 0
 1095 0134 CC20      		tst r12
 1096 0136 01F0      		breq .L198
 279:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 1097               		.loc 1 279 0
 1098 0138 21E0      		ldi r18,lo8(1)
 1099 013a C216      		cp r12,r18
 1100 013c 01F4      		brne .+2
 1101 013e 00C0      		rjmp .L70
 1102               	.L198:
 291:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1103               		.loc 1 291 0
 1104 0140 0E94 0000 		call clear_oneshot_mods
 1105               	.LVL103:
 1106 0144 00C0      		rjmp .L192
 1107               	.LVL104:
 1108               	.L95:
 298:./tmk_core/common/action.c ****                         if (event.pressed) {
 1109               		.loc 1 298 0
 1110 0146 DD20      		tst r13
 1111 0148 01F0      		breq .L101
 299:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1112               		.loc 1 299 0
 1113 014a 85E0      		ldi r24,lo8(5)
 1114 014c 8C15      		cp r24,r12
 1115 014e 00F4      		brsh .+2
 1116 0150 00C0      		rjmp .L70
 1117 0152 00C0      		rjmp .L191
 1118               	.L101:
 303:./tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 1119               		.loc 1 303 0
 1120 0154 94E0      		ldi r25,lo8(4)
 1121 0156 9C15      		cp r25,r12
 1122 0158 00F4      		brsh .+2
 1123 015a 00C0      		rjmp .L70
 1124 015c 00C0      		rjmp .L192
 1125               	.L199:
 309:./tmk_core/common/action.c ****                         if (event.pressed) {
 1126               		.loc 1 309 0
 1127 015e DD20      		tst r13
 1128 0160 01F0      		breq .L102
 310:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 1129               		.loc 1 310 0
 1130 0162 CC20      		tst r12
 1131 0164 01F4      		brne .+2
 1132 0166 00C0      		rjmp .L191
 312:./tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 1133               		.loc 1 312 0
 1134 0168 F401      		movw r30,r8
 1135 016a 8581      		ldd r24,Z+5
 1136 016c 80FF      		sbrs r24,0
 1137 016e 00C0      		rjmp .L189
 315:./tmk_core/common/action.c ****                                     record->tap.count = 0;
 1138               		.loc 1 315 0
 1139 0170 8F70      		andi r24,lo8(15)
 1140 0172 8583      		std Z+5,r24
 1141 0174 00C0      		rjmp .L191
 1142               	.L102:
 328:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 1143               		.loc 1 328 0
 1144 0176 CC20      		tst r12
 1145 0178 01F4      		brne .+2
 1146 017a 00C0      		rjmp .L192
 1147 017c 00C0      		rjmp .L150
 1148               	.LVL105:
 1149               	.L74:
 1150               	.LBE79:
 344:./tmk_core/common/action.c ****             switch (action.usage.page) {
 1151               		.loc 1 344 0
 1152 017e 242F      		mov r18,r20
 1153 0180 2695      		lsr r18
 1154 0182 2695      		lsr r18
 1155 0184 2370      		andi r18,lo8(3)
 1156 0186 30E0      		ldi r19,0
 1157 0188 2115      		cp r18,__zero_reg__
 1158 018a 3105      		cpc r19,__zero_reg__
 1159 018c 01F0      		breq .L106
 1160 018e 2130      		cpi r18,1
 1161 0190 3105      		cpc r19,__zero_reg__
 1162 0192 01F0      		breq .L107
 1163 0194 00C0      		rjmp .L70
 1164               	.L106:
 346:./tmk_core/common/action.c ****                     if (event.pressed) {
 1165               		.loc 1 346 0
 1166 0196 DD20      		tst r13
 1167 0198 01F0      		breq .L108
 347:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1168               		.loc 1 347 0
 1169 019a 862F      		mov r24,r22
 1170 019c 942F      		mov r25,r20
 1171 019e 9370      		andi r25,lo8(3)
 1172 01a0 00C0      		rjmp .L195
 1173               	.L108:
 349:./tmk_core/common/action.c ****                         host_system_send(0);
 1174               		.loc 1 349 0
 1175 01a2 80E0      		ldi r24,0
 1176 01a4 90E0      		ldi r25,0
 1177               	.L195:
 1178 01a6 0E94 0000 		call host_system_send
 1179               	.LVL106:
 1180 01aa 00C0      		rjmp .L151
 1181               	.LVL107:
 1182               	.L107:
 353:./tmk_core/common/action.c ****                     if (event.pressed) {
 1183               		.loc 1 353 0
 1184 01ac DD20      		tst r13
 1185 01ae 01F0      		breq .L110
 354:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1186               		.loc 1 354 0
 1187 01b0 862F      		mov r24,r22
 1188 01b2 942F      		mov r25,r20
 1189 01b4 9370      		andi r25,lo8(3)
 1190 01b6 00C0      		rjmp .L196
 1191               	.L110:
 356:./tmk_core/common/action.c ****                         host_consumer_send(0);
 1192               		.loc 1 356 0
 1193 01b8 80E0      		ldi r24,0
 1194 01ba 90E0      		ldi r25,0
 1195               	.L196:
 1196 01bc 0E94 0000 		call host_consumer_send
 1197               	.LVL108:
 1198 01c0 00C0      		rjmp .L151
 1199               	.LVL109:
 1200               	.L75:
 365:./tmk_core/common/action.c ****             if (event.pressed) {
 1201               		.loc 1 365 0
 1202 01c2 DD20      		tst r13
 1203 01c4 01F0      		breq .L111
 366:./tmk_core/common/action.c ****                 switch (action.key.code) {
 1204               		.loc 1 366 0
 1205 01c6 653F      		cpi r22,lo8(-11)
 1206 01c8 01F0      		breq .L113
 1207 01ca 663F      		cpi r22,lo8(-10)
 1208 01cc 01F0      		breq .L114
 1209 01ce 643F      		cpi r22,lo8(-12)
 1210 01d0 01F4      		brne .L112
 368:./tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 1211               		.loc 1 368 0
 1212 01d2 8091 0000 		lds r24,tp_buttons
 1213 01d6 9091 0000 		lds r25,tp_buttons+1
 1214 01da 8160      		ori r24,1
 1215 01dc 00C0      		rjmp .L187
 1216               	.L113:
 371:./tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 1217               		.loc 1 371 0
 1218 01de 8091 0000 		lds r24,tp_buttons
 1219 01e2 9091 0000 		lds r25,tp_buttons+1
 1220 01e6 8260      		ori r24,2
 1221 01e8 00C0      		rjmp .L187
 1222               	.L114:
 374:./tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 1223               		.loc 1 374 0
 1224 01ea 8091 0000 		lds r24,tp_buttons
 1225 01ee 9091 0000 		lds r25,tp_buttons+1
 1226 01f2 8460      		ori r24,4
 1227               	.L187:
 1228 01f4 9093 0000 		sts tp_buttons+1,r25
 1229 01f8 8093 0000 		sts tp_buttons,r24
 1230               	.L112:
 379:./tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1231               		.loc 1 379 0
 1232 01fc 862F      		mov r24,r22
 1233 01fe 0E94 0000 		call mousekey_on
 1234               	.LVL110:
 1235 0202 00C0      		rjmp .L197
 1236               	.LVL111:
 1237               	.L111:
 382:./tmk_core/common/action.c ****                 switch (action.key.code) {
 1238               		.loc 1 382 0
 1239 0204 653F      		cpi r22,lo8(-11)
 1240 0206 01F0      		breq .L117
 1241 0208 663F      		cpi r22,lo8(-10)
 1242 020a 01F0      		breq .L118
 1243 020c 643F      		cpi r22,lo8(-12)
 1244 020e 01F4      		brne .L116
 384:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 1245               		.loc 1 384 0
 1246 0210 8091 0000 		lds r24,tp_buttons
 1247 0214 9091 0000 		lds r25,tp_buttons+1
 1248 0218 8E7F      		andi r24,254
 1249 021a 00C0      		rjmp .L188
 1250               	.L117:
 387:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 1251               		.loc 1 387 0
 1252 021c 8091 0000 		lds r24,tp_buttons
 1253 0220 9091 0000 		lds r25,tp_buttons+1
 1254 0224 8D7F      		andi r24,253
 1255               	.L188:
 1256 0226 9093 0000 		sts tp_buttons+1,r25
 1257 022a 8093 0000 		sts tp_buttons,r24
 388:./tmk_core/common/action.c ****                         break;
 1258               		.loc 1 388 0
 1259 022e 00C0      		rjmp .L116
 1260               	.L118:
 390:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 1261               		.loc 1 390 0
 1262 0230 2091 0000 		lds r18,tp_buttons
 1263 0234 3091 0000 		lds r19,tp_buttons+1
 1264 0238 2B7F      		andi r18,251
 1265 023a 3093 0000 		sts tp_buttons+1,r19
 1266 023e 2093 0000 		sts tp_buttons,r18
 1267               	.L116:
 395:./tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 1268               		.loc 1 395 0
 1269 0242 862F      		mov r24,r22
 1270 0244 0E94 0000 		call mousekey_off
 1271               	.LVL112:
 1272               	.L197:
 396:./tmk_core/common/action.c ****                 mousekey_send();
 1273               		.loc 1 396 0
 1274 0248 0E94 0000 		call mousekey_send
 1275               	.LVL113:
 1276 024c 00C0      		rjmp .L151
 1277               	.LVL114:
 1278               	.L76:
 402:./tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 1279               		.loc 1 402 0
 1280 024e 842F      		mov r24,r20
 1281 0250 8370      		andi r24,lo8(3)
 1282 0252 01F0      		breq .+2
 1283 0254 00C0      		rjmp .L120
 404:./tmk_core/common/action.c ****                 if (!event.pressed) {
 1284               		.loc 1 404 0
 1285 0256 D110      		cpse r13,__zero_reg__
 1286 0258 00C0      		rjmp .L152
 1287               	.LVL115:
 1288               	.LBB80:
 405:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1289               		.loc 1 405 0
 1290 025a 262F      		mov r18,r22
 1291 025c 2295      		swap r18
 1292 025e 2695      		lsr r18
 1293 0260 2770      		andi r18,lo8(7)
 1294 0262 220F      		lsl r18
 1295 0264 220F      		lsl r18
 406:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1296               		.loc 1 406 0
 1297 0266 862F      		mov r24,r22
 1298 0268 8F70      		andi r24,lo8(15)
 1299 026a C82E      		mov r12,r24
 1300               	.LVL116:
 1301 026c D12C      		mov r13,__zero_reg__
 1302               	.LVL117:
 1303 026e E12C      		mov r14,__zero_reg__
 1304 0270 F12C      		mov r15,__zero_reg__
 1305 0272 022E      		mov r0,r18
 1306 0274 00C0      		rjmp 2f
 1307               		1:
 1308 0276 CC0C      		lsl r12
 1309 0278 DD1C      		rol r13
 1310 027a EE1C      		rol r14
 1311 027c FF1C      		rol r15
 1312               		2:
 1313 027e 0A94      		dec r0
 1314 0280 02F4      		brpl 1b
 1315               	.LVL118:
 407:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1316               		.loc 1 407 0
 1317 0282 64FF      		sbrs r22,4
 1318 0284 00C0      		rjmp .L159
 407:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1319               		.loc 1 407 0 is_stmt 0 discriminator 1
 1320 0286 6FE0      		ldi r22,lo8(15)
 1321 0288 70E0      		ldi r23,0
 1322 028a 80E0      		ldi r24,0
 1323 028c 90E0      		ldi r25,0
 1324               	.LVL119:
 1325 028e 00C0      		rjmp 2f
 1326               		1:
 1327 0290 660F      		lsl r22
 1328 0292 771F      		rol r23
 1329 0294 881F      		rol r24
 1330 0296 991F      		rol r25
 1331               		2:
 1332 0298 2A95      		dec r18
 1333 029a 02F4      		brpl 1b
 1334 029c 6095      		com r22
 1335 029e 7095      		com r23
 1336 02a0 8095      		com r24
 1337 02a2 9095      		com r25
 1338 02a4 00C0      		rjmp .L122
 1339               	.LVL120:
 1340               	.L159:
 407:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1341               		.loc 1 407 0
 1342 02a6 60E0      		ldi r22,0
 1343 02a8 70E0      		ldi r23,0
 1344 02aa CB01      		movw r24,r22
 1345               	.LVL121:
 1346               	.L122:
 408:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1347               		.loc 1 408 0 is_stmt 1 discriminator 3
 1348 02ac 242F      		mov r18,r20
 1349 02ae 2695      		lsr r18
 1350 02b0 2695      		lsr r18
 1351 02b2 2370      		andi r18,lo8(3)
 1352 02b4 30E0      		ldi r19,0
 1353 02b6 2230      		cpi r18,2
 1354 02b8 3105      		cpc r19,__zero_reg__
 1355 02ba 01F0      		breq .L124
 1356 02bc 2330      		cpi r18,3
 1357 02be 3105      		cpc r19,__zero_reg__
 1358 02c0 01F0      		breq .L125
 1359 02c2 6C29      		or r22,r12
 1360 02c4 7D29      		or r23,r13
 1361 02c6 8E29      		or r24,r14
 1362 02c8 9F29      		or r25,r15
 1363               	.LVL122:
 1364 02ca 2130      		cpi r18,1
 1365 02cc 3105      		cpc r19,__zero_reg__
 1366 02ce 01F0      		breq .L194
 409:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1367               		.loc 1 409 0 discriminator 3
 1368 02d0 0E94 0000 		call default_layer_and
 1369               	.LVL123:
 1370 02d4 00C0      		rjmp .L152
 1371               	.LVL124:
 1372               	.L124:
 411:./tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 1373               		.loc 1 411 0
 1374 02d6 6C29      		or r22,r12
 1375 02d8 7D29      		or r23,r13
 1376 02da 8E29      		or r24,r14
 1377 02dc 9F29      		or r25,r15
 1378               	.LVL125:
 1379 02de 0E94 0000 		call default_layer_xor
 1380               	.LVL126:
 1381 02e2 00C0      		rjmp .L152
 1382               	.LVL127:
 1383               	.L125:
 412:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1384               		.loc 1 412 0
 1385 02e4 0E94 0000 		call default_layer_and
 1386               	.LVL128:
 1387 02e8 C701      		movw r24,r14
 1388 02ea B601      		movw r22,r12
 1389               	.L194:
 1390 02ec 0E94 0000 		call default_layer_or
 1391               	.LVL129:
 1392 02f0 00C0      		rjmp .L152
 1393               	.LVL130:
 1394               	.L120:
 1395               	.LBE80:
 417:./tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 1396               		.loc 1 417 0
 1397 02f2 DD20      		tst r13
 1398 02f4 01F0      		breq .L127
 417:./tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 1399               		.loc 1 417 0 is_stmt 0 discriminator 1
 1400 02f6 842F      		mov r24,r20
 1401 02f8 8170      		andi r24,lo8(1)
 1402 02fa 00C0      		rjmp .L128
 1403               	.L127:
 417:./tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 1404               		.loc 1 417 0 discriminator 2
 1405 02fc 8695      		lsr r24
 1406               	.L128:
 417:./tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 1407               		.loc 1 417 0 discriminator 3
 1408 02fe 8823      		tst r24
 1409 0300 01F4      		brne .+2
 1410 0302 00C0      		rjmp .L152
 1411               	.LVL131:
 1412               	.LBB81:
 419:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1413               		.loc 1 419 0 is_stmt 1
 1414 0304 262F      		mov r18,r22
 1415 0306 2295      		swap r18
 1416 0308 2695      		lsr r18
 1417 030a 2770      		andi r18,lo8(7)
 1418 030c 220F      		lsl r18
 1419 030e 220F      		lsl r18
 420:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1420               		.loc 1 420 0
 1421 0310 862F      		mov r24,r22
 1422 0312 8F70      		andi r24,lo8(15)
 1423 0314 C82E      		mov r12,r24
 1424               	.LVL132:
 1425 0316 D12C      		mov r13,__zero_reg__
 1426               	.LVL133:
 1427 0318 E12C      		mov r14,__zero_reg__
 1428 031a F12C      		mov r15,__zero_reg__
 1429 031c 022E      		mov r0,r18
 1430 031e 00C0      		rjmp 2f
 1431               		1:
 1432 0320 CC0C      		lsl r12
 1433 0322 DD1C      		rol r13
 1434 0324 EE1C      		rol r14
 1435 0326 FF1C      		rol r15
 1436               		2:
 1437 0328 0A94      		dec r0
 1438 032a 02F4      		brpl 1b
 1439               	.LVL134:
 421:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1440               		.loc 1 421 0
 1441 032c 64FF      		sbrs r22,4
 1442 032e 00C0      		rjmp .L160
 421:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1443               		.loc 1 421 0 is_stmt 0 discriminator 1
 1444 0330 6FE0      		ldi r22,lo8(15)
 1445 0332 70E0      		ldi r23,0
 1446 0334 80E0      		ldi r24,0
 1447 0336 90E0      		ldi r25,0
 1448               	.LVL135:
 1449 0338 00C0      		rjmp 2f
 1450               		1:
 1451 033a 660F      		lsl r22
 1452 033c 771F      		rol r23
 1453 033e 881F      		rol r24
 1454 0340 991F      		rol r25
 1455               		2:
 1456 0342 2A95      		dec r18
 1457 0344 02F4      		brpl 1b
 1458 0346 6095      		com r22
 1459 0348 7095      		com r23
 1460 034a 8095      		com r24
 1461 034c 9095      		com r25
 1462 034e 00C0      		rjmp .L129
 1463               	.LVL136:
 1464               	.L160:
 421:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1465               		.loc 1 421 0
 1466 0350 60E0      		ldi r22,0
 1467 0352 70E0      		ldi r23,0
 1468 0354 CB01      		movw r24,r22
 1469               	.LVL137:
 1470               	.L129:
 422:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1471               		.loc 1 422 0 is_stmt 1 discriminator 3
 1472 0356 242F      		mov r18,r20
 1473 0358 2695      		lsr r18
 1474 035a 2695      		lsr r18
 1475 035c 2370      		andi r18,lo8(3)
 1476 035e 30E0      		ldi r19,0
 1477 0360 2230      		cpi r18,2
 1478 0362 3105      		cpc r19,__zero_reg__
 1479 0364 01F0      		breq .L131
 1480 0366 2330      		cpi r18,3
 1481 0368 3105      		cpc r19,__zero_reg__
 1482 036a 01F0      		breq .L132
 1483 036c 6C29      		or r22,r12
 1484 036e 7D29      		or r23,r13
 1485 0370 8E29      		or r24,r14
 1486 0372 9F29      		or r25,r15
 1487               	.LVL138:
 1488 0374 2130      		cpi r18,1
 1489 0376 3105      		cpc r19,__zero_reg__
 1490 0378 01F0      		breq .L193
 423:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1491               		.loc 1 423 0 discriminator 3
 1492 037a 0E94 0000 		call layer_and
 1493               	.LVL139:
 1494 037e 00C0      		rjmp .L152
 1495               	.LVL140:
 1496               	.L131:
 425:./tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 1497               		.loc 1 425 0
 1498 0380 6C29      		or r22,r12
 1499 0382 7D29      		or r23,r13
 1500 0384 8E29      		or r24,r14
 1501 0386 9F29      		or r25,r15
 1502               	.LVL141:
 1503 0388 0E94 0000 		call layer_xor
 1504               	.LVL142:
 1505 038c 00C0      		rjmp .L152
 1506               	.LVL143:
 1507               	.L132:
 426:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1508               		.loc 1 426 0
 1509 038e 0E94 0000 		call layer_and
 1510               	.LVL144:
 1511 0392 C701      		movw r24,r14
 1512 0394 B601      		movw r22,r12
 1513               	.L193:
 1514 0396 0E94 0000 		call layer_or
 1515               	.LVL145:
 1516 039a 00C0      		rjmp .L152
 1517               	.LVL146:
 1518               	.L77:
 1519               	.LBE81:
 434:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1520               		.loc 1 434 0
 1521 039c 062F      		mov r16,r22
 1522 039e 10E0      		ldi r17,0
 1523 03a0 F801      		movw r30,r16
 1524 03a2 E05E      		subi r30,-32
 1525 03a4 F109      		sbc r31,__zero_reg__
 1526 03a6 E531      		cpi r30,21
 1527 03a8 F105      		cpc r31,__zero_reg__
 1528 03aa 00F0      		brlo .+2
 1529 03ac 00C0      		rjmp .L134
 1530 03ae E050      		subi r30,lo8(-(gs(.L136)))
 1531 03b0 F040      		sbci r31,hi8(-(gs(.L136)))
 1532 03b2 0C94 0000 		jmp __tablejump2__
 1533               		.section	.progmem.gcc_sw_table.process_action
 1534               		.p2align	1
 1535               	.L136:
 1536 0020 0000      		.word gs(.L135)
 1537 0022 0000      		.word gs(.L135)
 1538 0024 0000      		.word gs(.L135)
 1539 0026 0000      		.word gs(.L135)
 1540 0028 0000      		.word gs(.L135)
 1541 002a 0000      		.word gs(.L135)
 1542 002c 0000      		.word gs(.L135)
 1543 002e 0000      		.word gs(.L135)
 1544 0030 0000      		.word gs(.L135)
 1545 0032 0000      		.word gs(.L135)
 1546 0034 0000      		.word gs(.L135)
 1547 0036 0000      		.word gs(.L135)
 1548 0038 0000      		.word gs(.L135)
 1549 003a 0000      		.word gs(.L135)
 1550 003c 0000      		.word gs(.L135)
 1551 003e 0000      		.word gs(.L135)
 1552 0040 0000      		.word gs(.L137)
 1553 0042 0000      		.word gs(.L138)
 1554 0044 0000      		.word gs(.L139)
 1555 0046 0000      		.word gs(.L140)
 1556 0048 0000      		.word gs(.L141)
 1557               		.section	.text.process_action
 1558               	.L135:
 1559 03b6 162F      		mov r17,r22
 1560 03b8 1F70      		andi r17,lo8(15)
 1561 03ba 842F      		mov r24,r20
 1562 03bc 8F71      		andi r24,lo8(31)
 437:./tmk_core/common/action.c ****                     if (event.pressed) {
 1563               		.loc 1 437 0
 1564 03be DD20      		tst r13
 1565 03c0 01F0      		breq .L142
 438:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1566               		.loc 1 438 0
 1567 03c2 0E94 0000 		call layer_on
 1568               	.LVL147:
 1569               	.L191:
 439:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 1570               		.loc 1 439 0
 1571 03c6 812F      		mov r24,r17
 1572               	.L190:
 1573 03c8 0E94 0000 		call register_mods
 1574               	.LVL148:
 1575 03cc 00C0      		rjmp .L70
 1576               	.LVL149:
 1577               	.L142:
 441:./tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 1578               		.loc 1 441 0
 1579 03ce 0E94 0000 		call layer_off
 1580               	.LVL150:
 1581               	.L192:
 442:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 1582               		.loc 1 442 0
 1583 03d2 812F      		mov r24,r17
 1584 03d4 0E94 0000 		call unregister_mods
 1585               	.LVL151:
 1586 03d8 00C0      		rjmp .L70
 1587               	.LVL152:
 1588               	.L137:
 447:./tmk_core/common/action.c ****                     if (event.pressed) {
 1589               		.loc 1 447 0
 1590 03da DD20      		tst r13
 1591 03dc 01F0      		breq .L143
 448:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1592               		.loc 1 448 0
 1593 03de F4E0      		ldi r31,lo8(4)
 1594 03e0 FC15      		cp r31,r12
 1595 03e2 00F4      		brsh .+2
 1596 03e4 00C0      		rjmp .L70
 1597               	.L144:
 449:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1598               		.loc 1 449 0
 1599 03e6 842F      		mov r24,r20
 1600 03e8 8F71      		andi r24,lo8(31)
 1601 03ea 0E94 0000 		call layer_invert
 1602               	.LVL153:
 1603 03ee 00C0      		rjmp .L70
 1604               	.LVL154:
 1605               	.L143:
 452:./tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1606               		.loc 1 452 0
 1607 03f0 25E0      		ldi r18,lo8(5)
 1608 03f2 2C15      		cp r18,r12
 1609 03f4 00F4      		brsh .+2
 1610 03f6 00C0      		rjmp .L70
 1611 03f8 00C0      		rjmp .L144
 1612               	.L138:
 458:./tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 1613               		.loc 1 458 0
 1614 03fa DD20      		tst r13
 1615 03fc 01F0      		breq .L145
 1616               	.L146:
 458:./tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 1617               		.loc 1 458 0 is_stmt 0 discriminator 1
 1618 03fe 842F      		mov r24,r20
 1619 0400 8F71      		andi r24,lo8(31)
 1620 0402 0E94 0000 		call layer_on
 1621               	.LVL155:
 1622 0406 00C0      		rjmp .L70
 1623               	.LVL156:
 1624               	.L139:
 462:./tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 1625               		.loc 1 462 0 is_stmt 1
 1626 0408 DD20      		tst r13
 1627 040a 01F0      		breq .L146
 1628               	.L145:
 459:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1629               		.loc 1 459 0
 1630 040c 842F      		mov r24,r20
 1631 040e 8F71      		andi r24,lo8(31)
 1632 0410 0E94 0000 		call layer_off
 1633               	.LVL157:
 1634 0414 00C0      		rjmp .L70
 1635               	.LVL158:
 1636               	.L140:
 466:./tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 1637               		.loc 1 466 0
 1638 0416 DD20      		tst r13
 1639 0418 01F0      		breq .L147
 466:./tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 1640               		.loc 1 466 0 is_stmt 0 discriminator 1
 1641 041a 842F      		mov r24,r20
 1642 041c 8F71      		andi r24,lo8(31)
 1643 041e 0E94 0000 		call layer_move
 1644               	.LVL159:
 1645 0422 00C0      		rjmp .L70
 1646               	.LVL160:
 1647               	.L147:
 467:./tmk_core/common/action.c ****                                     layer_clear();
 1648               		.loc 1 467 0 is_stmt 1
 1649 0424 0E94 0000 		call layer_clear
 1650               	.LVL161:
 1651 0428 00C0      		rjmp .L70
 1652               	.LVL162:
 1653               	.L141:
 495:./tmk_core/common/action.c ****                     if (event.pressed) {
 1654               		.loc 1 495 0
 1655 042a DD20      		tst r13
 1656 042c 01F0      		breq .L148
 496:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1657               		.loc 1 496 0
 1658 042e 142F      		mov r17,r20
 1659 0430 1F71      		andi r17,lo8(31)
 1660 0432 812F      		mov r24,r17
 1661 0434 0E94 0000 		call layer_on
 1662               	.LVL163:
 497:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1663               		.loc 1 497 0
 1664 0438 63E0      		ldi r22,lo8(3)
 1665 043a 812F      		mov r24,r17
 1666 043c 0E94 0000 		call set_oneshot_layer
 1667               	.LVL164:
 1668 0440 00C0      		rjmp .L70
 1669               	.LVL165:
 1670               	.L148:
 499:./tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 1671               		.loc 1 499 0
 1672 0442 81E0      		ldi r24,lo8(1)
 1673 0444 0E94 0000 		call clear_oneshot_layer_state
 1674               	.LVL166:
 500:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 1675               		.loc 1 500 0
 1676 0448 81E0      		ldi r24,lo8(1)
 1677 044a 8C15      		cp r24,r12
 1678 044c 00F4      		brsh .L70
 501:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1679               		.loc 1 501 0
 1680 044e 82E0      		ldi r24,lo8(2)
 1681 0450 0E94 0000 		call clear_oneshot_layer_state
 1682               	.LVL167:
 1683 0454 00C0      		rjmp .L70
 1684               	.LVL168:
 1685               	.L134:
 509:./tmk_core/common/action.c ****                     if (event.pressed) {
 1686               		.loc 1 509 0
 1687 0456 DD20      		tst r13
 1688 0458 01F0      		breq .L149
 510:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 1689               		.loc 1 510 0
 1690 045a CC20      		tst r12
 1691 045c 01F0      		breq .L146
 1692               	.L189:
 512:./tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 1693               		.loc 1 512 0
 1694 045e 862F      		mov r24,r22
 1695 0460 0E94 0000 		call register_code
 1696               	.LVL169:
 1697 0464 00C0      		rjmp .L70
 1698               	.LVL170:
 1699               	.L149:
 518:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 1700               		.loc 1 518 0
 1701 0466 CC20      		tst r12
 1702 0468 01F0      		breq .L145
 520:./tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1703               		.loc 1 520 0
 1704 046a 6933      		cpi r22,lo8(57)
 1705 046c 01F4      		brne .L150
 1706               	.LVL171:
 1707               	.LBB82:
 1708               	.LBB83:
 1709               		.loc 3 164 0
 1710 046e 9FEF      		ldi r25,lo8(255999)
 1711 0470 E7EE      		ldi r30,hi8(255999)
 1712 0472 F3E0      		ldi r31,hlo8(255999)
 1713 0474 9150      		1: subi r25,1
 1714 0476 E040      		sbci r30,0
 1715 0478 F040      		sbci r31,0
 1716 047a 01F4      		brne 1b
 1717 047c 00C0      		rjmp .
 1718 047e 0000      		nop
 1719               	.LVL172:
 1720               	.L150:
 1721               	.LBE83:
 1722               	.LBE82:
 523:./tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 1723               		.loc 1 523 0
 1724 0480 862F      		mov r24,r22
 1725 0482 0E94 0000 		call unregister_code
 1726               	.LVL173:
 1727 0486 00C0      		rjmp .L70
 1728               	.LVL174:
 1729               	.L78:
 537:./tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 1730               		.loc 1 537 0
 1731 0488 4F70      		andi r20,lo8(15)
 1732               	.LVL175:
 1733 048a C401      		movw r24,r8
 1734 048c 0E94 0000 		call action_get_macro
 1735               	.LVL176:
 1736 0490 0E94 0000 		call action_macro_play
 1737               	.LVL177:
 538:./tmk_core/common/action.c ****             break;
 1738               		.loc 1 538 0
 1739 0494 00C0      		rjmp .L151
 1740               	.LVL178:
 1741               	.L79:
 632:./tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 1742               		.loc 1 632 0
 1743 0496 4F70      		andi r20,lo8(15)
 1744               	.LVL179:
 1745 0498 C401      		movw r24,r8
 1746 049a 0E94 0000 		call action_function
 1747               	.LVL180:
 633:./tmk_core/common/action.c ****             break;
 1748               		.loc 1 633 0
 1749 049e 00C0      		rjmp .L151
 1750               	.LVL181:
 1751               	.L70:
 641:./tmk_core/common/action.c ****     switch (action.kind.id) {
 1752               		.loc 1 641 0
 1753 04a0 28E0      		ldi r18,8
 1754 04a2 E216      		cp r14,r18
 1755 04a4 F104      		cpc r15,__zero_reg__
 1756 04a6 01F0      		breq .L152
 1757 04a8 04F0      		brlt .L151
 1758 04aa 9AE0      		ldi r25,10
 1759 04ac E91A      		sub r14,r25
 1760 04ae F108      		sbc r15,__zero_reg__
 1761 04b0 E2E0      		ldi r30,2
 1762 04b2 EE16      		cp r14,r30
 1763 04b4 F104      		cpc r15,__zero_reg__
 1764 04b6 00F4      		brsh .L151
 1765               	.LVL182:
 1766               	.L152:
 647:./tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 1767               		.loc 1 647 0
 1768 04b8 0E94 0000 		call host_keyboard_leds
 1769               	.LVL183:
 1770 04bc 0E94 0000 		call led_set
 1771               	.LVL184:
 1772               	.L151:
 684:./tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 1773               		.loc 1 684 0
 1774 04c0 BB20      		tst r11
 1775 04c2 01F0      		breq .L67
 684:./tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 1776               		.loc 1 684 0 is_stmt 0 discriminator 1
 1777 04c4 0E94 0000 		call get_oneshot_layer_state
 1778               	.LVL185:
 1779 04c8 80FD      		sbrc r24,0
 1780 04ca 00C0      		rjmp .L67
 685:./tmk_core/common/action.c ****         record->event.pressed = false;
 1781               		.loc 1 685 0 is_stmt 1
 1782 04cc F401      		movw r30,r8
 1783 04ce 1282      		std Z+2,__zero_reg__
 686:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1784               		.loc 1 686 0
 1785 04d0 0E94 0000 		call get_oneshot_layer
 1786               	.LVL186:
 1787 04d4 0E94 0000 		call layer_on
 1788               	.LVL187:
 687:./tmk_core/common/action.c ****         process_record(record);
 1789               		.loc 1 687 0
 1790 04d8 C401      		movw r24,r8
 1791 04da 0E94 0000 		call process_record
 1792               	.LVL188:
 688:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1793               		.loc 1 688 0
 1794 04de 0E94 0000 		call get_oneshot_layer
 1795               	.LVL189:
 1796               	/* epilogue start */
 691:./tmk_core/common/action.c **** }
 1797               		.loc 1 691 0
 1798 04e2 0F90      		pop __tmp_reg__
 1799 04e4 0F90      		pop __tmp_reg__
 1800 04e6 DF91      		pop r29
 1801 04e8 CF91      		pop r28
 1802 04ea 1F91      		pop r17
 1803 04ec 0F91      		pop r16
 1804 04ee FF90      		pop r15
 1805 04f0 EF90      		pop r14
 1806 04f2 DF90      		pop r13
 1807 04f4 CF90      		pop r12
 1808 04f6 BF90      		pop r11
 1809               	.LVL190:
 1810 04f8 9F90      		pop r9
 1811 04fa 8F90      		pop r8
 1812               	.LVL191:
 688:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1813               		.loc 1 688 0
 1814 04fc 0C94 0000 		jmp layer_off
 1815               	.LVL192:
 1816               	.L67:
 1817               	/* epilogue start */
 691:./tmk_core/common/action.c **** }
 1818               		.loc 1 691 0
 1819 0500 0F90      		pop __tmp_reg__
 1820 0502 0F90      		pop __tmp_reg__
 1821 0504 DF91      		pop r29
 1822 0506 CF91      		pop r28
 1823 0508 1F91      		pop r17
 1824 050a 0F91      		pop r16
 1825 050c FF90      		pop r15
 1826 050e EF90      		pop r14
 1827 0510 DF90      		pop r13
 1828 0512 CF90      		pop r12
 1829 0514 BF90      		pop r11
 1830               	.LVL193:
 1831 0516 9F90      		pop r9
 1832 0518 8F90      		pop r8
 1833               	.LVL194:
 1834 051a 0895      		ret
 1835               		.cfi_endproc
 1836               	.LFE18:
 1838               		.section	.text.process_record,"ax",@progbits
 1839               	.global	process_record
 1841               	process_record:
 1842               	.LFB17:
 173:./tmk_core/common/action.c **** {
 1843               		.loc 1 173 0
 1844               		.cfi_startproc
 1845               	.LVL195:
 1846 0000 0F93      		push r16
 1847               	.LCFI21:
 1848               		.cfi_def_cfa_offset 3
 1849               		.cfi_offset 16, -2
 1850 0002 1F93      		push r17
 1851               	.LCFI22:
 1852               		.cfi_def_cfa_offset 4
 1853               		.cfi_offset 17, -3
 1854 0004 CF93      		push r28
 1855               	.LCFI23:
 1856               		.cfi_def_cfa_offset 5
 1857               		.cfi_offset 28, -4
 1858 0006 DF93      		push r29
 1859               	.LCFI24:
 1860               		.cfi_def_cfa_offset 6
 1861               		.cfi_offset 29, -5
 1862               	/* prologue: function */
 1863               	/* frame size = 0 */
 1864               	/* stack size = 4 */
 1865               	.L__stack_usage = 4
 1866 0008 EC01      		movw r28,r24
 174:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1867               		.loc 1 174 0
 1868 000a 2881      		ld r18,Y
 1869 000c 3981      		ldd r19,Y+1
 1870               	.LBB86:
 1871               	.LBB87:
 1872               		.file 4 "./tmk_core/common/keyboard.h"
   1:./tmk_core/common/keyboard.h **** /*
   2:./tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/keyboard.h **** 
   4:./tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/keyboard.h **** (at your option) any later version.
   8:./tmk_core/common/keyboard.h **** 
   9:./tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:./tmk_core/common/keyboard.h **** 
  14:./tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/keyboard.h **** */
  17:./tmk_core/common/keyboard.h **** 
  18:./tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:./tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:./tmk_core/common/keyboard.h **** 
  21:./tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:./tmk_core/common/keyboard.h **** #include <stdint.h>
  23:./tmk_core/common/keyboard.h **** 
  24:./tmk_core/common/keyboard.h **** 
  25:./tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:./tmk_core/common/keyboard.h **** extern "C" {
  27:./tmk_core/common/keyboard.h **** #endif
  28:./tmk_core/common/keyboard.h **** 
  29:./tmk_core/common/keyboard.h **** /* key matrix position */
  30:./tmk_core/common/keyboard.h **** typedef struct {
  31:./tmk_core/common/keyboard.h ****     uint8_t col;
  32:./tmk_core/common/keyboard.h ****     uint8_t row;
  33:./tmk_core/common/keyboard.h **** } keypos_t;
  34:./tmk_core/common/keyboard.h **** 
  35:./tmk_core/common/keyboard.h **** /* key event */
  36:./tmk_core/common/keyboard.h **** typedef struct {
  37:./tmk_core/common/keyboard.h ****     keypos_t key;
  38:./tmk_core/common/keyboard.h ****     bool     pressed;
  39:./tmk_core/common/keyboard.h ****     uint16_t time;
  40:./tmk_core/common/keyboard.h **** } keyevent_t;
  41:./tmk_core/common/keyboard.h **** 
  42:./tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:./tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:./tmk_core/common/keyboard.h **** 
  45:./tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:./tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:./tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:./tmk_core/common/keyboard.h ****  */
  49:./tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1873               		.loc 4 49 0
 1874 000e 8B81      		ldd r24,Y+3
 1875 0010 9C81      		ldd r25,Y+4
 1876               	.LVL196:
 1877 0012 892B      		or r24,r25
 1878 0014 01F0      		breq .L206
 1879 0016 3F3F      		cpi r19,lo8(-1)
 1880 0018 01F0      		breq .L202
 1881               	.L203:
 1882 001a 80E0      		ldi r24,0
 1883 001c 00C0      		rjmp .L201
 1884               	.L202:
 1885 001e 2F3F      		cpi r18,lo8(-1)
 1886 0020 01F4      		brne .L203
 1887               	.L206:
 1888 0022 81E0      		ldi r24,lo8(1)
 1889               	.L201:
 1890               	.LBE87:
 1891               	.LBE86:
 174:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1892               		.loc 1 174 0
 1893 0024 8111      		cpse r24,__zero_reg__
 1894 0026 00C0      		rjmp .L200
 176:./tmk_core/common/action.c ****     if(!process_record_quantum(record))
 1895               		.loc 1 176 0
 1896 0028 CE01      		movw r24,r28
 1897 002a 0E94 0000 		call process_record_quantum
 1898               	.LVL197:
 1899 002e 8823      		tst r24
 1900 0030 01F0      		breq .L200
 179:./tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 1901               		.loc 1 179 0
 1902 0032 6881      		ld r22,Y
 1903 0034 7981      		ldd r23,Y+1
 1904 0036 8A81      		ldd r24,Y+2
 1905 0038 0E94 0000 		call store_or_get_action
 1906               	.LVL198:
 1907 003c 8C01      		movw r16,r24
 1908               	.LVL199:
 182:./tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 1909               		.loc 1 182 0
 1910 003e 0E94 0000 		call layer_debug
 1911               	.LVL200:
 183:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 1912               		.loc 1 183 0
 1913 0042 0E94 0000 		call default_layer_debug
 1914               	.LVL201:
 187:./tmk_core/common/action.c ****     process_action(record, action);
 1915               		.loc 1 187 0
 1916 0046 B801      		movw r22,r16
 1917               	.LVL202:
 1918 0048 CE01      		movw r24,r28
 1919 004a 0E94 0000 		call process_action
 1920               	.LVL203:
 1921               	.L200:
 1922               	/* epilogue start */
 188:./tmk_core/common/action.c **** }
 1923               		.loc 1 188 0
 1924 004e DF91      		pop r29
 1925 0050 CF91      		pop r28
 1926               	.LVL204:
 1927 0052 1F91      		pop r17
 1928 0054 0F91      		pop r16
 1929               	.LVL205:
 1930 0056 0895      		ret
 1931               		.cfi_endproc
 1932               	.LFE17:
 1934               		.section	.text.process_record_nocache,"ax",@progbits
 1935               	.global	process_record_nocache
 1937               	process_record_nocache:
 1938               	.LFB14:
 134:./tmk_core/common/action.c **** {
 1939               		.loc 1 134 0
 1940               		.cfi_startproc
 1941               	.LVL206:
 1942               	/* prologue: function */
 1943               	/* frame size = 0 */
 1944               	/* stack size = 0 */
 1945               	.L__stack_usage = 0
 135:./tmk_core/common/action.c ****     process_record(record);
 1946               		.loc 1 135 0
 1947 0000 0C94 0000 		jmp process_record
 1948               	.LVL207:
 1949               		.cfi_endproc
 1950               	.LFE14:
 1952               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1953               	.global	clear_keyboard_but_mods
 1955               	clear_keyboard_but_mods:
 1956               	.LFB24:
 858:./tmk_core/common/action.c ****     }
 859:./tmk_core/common/action.c **** }
 860:./tmk_core/common/action.c **** 
 861:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 862:./tmk_core/common/action.c ****  *
 863:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 864:./tmk_core/common/action.c ****  */
 865:./tmk_core/common/action.c **** void clear_keyboard(void)
 866:./tmk_core/common/action.c **** {
 867:./tmk_core/common/action.c ****     clear_mods();
 868:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 869:./tmk_core/common/action.c **** }
 870:./tmk_core/common/action.c **** 
 871:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 872:./tmk_core/common/action.c ****  *
 873:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 874:./tmk_core/common/action.c ****  */
 875:./tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 876:./tmk_core/common/action.c **** {
 1957               		.loc 1 876 0
 1958               		.cfi_startproc
 1959               	/* prologue: function */
 1960               	/* frame size = 0 */
 1961               	/* stack size = 0 */
 1962               	.L__stack_usage = 0
 877:./tmk_core/common/action.c ****     clear_weak_mods();
 1963               		.loc 1 877 0
 1964 0000 0E94 0000 		call clear_weak_mods
 1965               	.LVL208:
 878:./tmk_core/common/action.c ****     clear_macro_mods();
 1966               		.loc 1 878 0
 1967 0004 0E94 0000 		call clear_macro_mods
 1968               	.LVL209:
 1969               	.LBB88:
 1970               	.LBB89:
  38:./tmk_core/common/action_util.h **** }
  39:./tmk_core/common/action_util.h **** 
  40:./tmk_core/common/action_util.h **** inline void clear_keys(void) {
  41:./tmk_core/common/action_util.h ****   clear_keys_from_report(keyboard_report);
 1971               		.loc 2 41 0
 1972 0008 8091 0000 		lds r24,keyboard_report
 1973 000c 9091 0000 		lds r25,keyboard_report+1
 1974 0010 0E94 0000 		call clear_keys_from_report
 1975               	.LVL210:
 1976               	.LBE89:
 1977               	.LBE88:
 879:./tmk_core/common/action.c ****     clear_keys();
 880:./tmk_core/common/action.c ****     send_keyboard_report();
 1978               		.loc 1 880 0
 1979 0014 0E94 0000 		call send_keyboard_report
 1980               	.LVL211:
 881:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 882:./tmk_core/common/action.c ****     mousekey_clear();
 1981               		.loc 1 882 0
 1982 0018 0E94 0000 		call mousekey_clear
 1983               	.LVL212:
 883:./tmk_core/common/action.c ****     mousekey_send();
 1984               		.loc 1 883 0
 1985 001c 0E94 0000 		call mousekey_send
 1986               	.LVL213:
 884:./tmk_core/common/action.c **** #endif
 885:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 886:./tmk_core/common/action.c ****     host_system_send(0);
 1987               		.loc 1 886 0
 1988 0020 80E0      		ldi r24,0
 1989 0022 90E0      		ldi r25,0
 1990 0024 0E94 0000 		call host_system_send
 1991               	.LVL214:
 887:./tmk_core/common/action.c ****     host_consumer_send(0);
 1992               		.loc 1 887 0
 1993 0028 80E0      		ldi r24,0
 1994 002a 90E0      		ldi r25,0
 1995 002c 0C94 0000 		jmp host_consumer_send
 1996               	.LVL215:
 1997               		.cfi_endproc
 1998               	.LFE24:
 2000               		.section	.text.clear_keyboard,"ax",@progbits
 2001               	.global	clear_keyboard
 2003               	clear_keyboard:
 2004               	.LFB23:
 866:./tmk_core/common/action.c **** {
 2005               		.loc 1 866 0
 2006               		.cfi_startproc
 2007               	/* prologue: function */
 2008               	/* frame size = 0 */
 2009               	/* stack size = 0 */
 2010               	.L__stack_usage = 0
 867:./tmk_core/common/action.c ****     clear_mods();
 2011               		.loc 1 867 0
 2012 0000 0E94 0000 		call clear_mods
 2013               	.LVL216:
 868:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2014               		.loc 1 868 0
 2015 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2016               	.LVL217:
 2017               		.cfi_endproc
 2018               	.LFE23:
 2020               		.section	.text.is_tap_key,"ax",@progbits
 2021               	.global	is_tap_key
 2023               	is_tap_key:
 2024               	.LFB25:
 888:./tmk_core/common/action.c **** #endif
 889:./tmk_core/common/action.c **** }
 890:./tmk_core/common/action.c **** 
 891:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 892:./tmk_core/common/action.c ****  *
 893:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 894:./tmk_core/common/action.c ****  */
 895:./tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 896:./tmk_core/common/action.c **** {
 2025               		.loc 1 896 0
 2026               		.cfi_startproc
 2027               	.LVL218:
 2028               	/* prologue: function */
 2029               	/* frame size = 0 */
 2030               	/* stack size = 0 */
 2031               	.L__stack_usage = 0
 897:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2032               		.loc 1 897 0
 2033 0000 0E94 0000 		call layer_switch_get_action
 2034               	.LVL219:
 898:./tmk_core/common/action.c **** 
 899:./tmk_core/common/action.c ****     switch (action.kind.id) {
 2035               		.loc 1 899 0
 2036 0004 E92F      		mov r30,r25
 2037 0006 E295      		swap r30
 2038 0008 EF70      		andi r30,lo8(15)
 2039 000a F0E0      		ldi r31,0
 2040 000c 3297      		sbiw r30,2
 2041 000e EE30      		cpi r30,14
 2042 0010 F105      		cpc r31,__zero_reg__
 2043 0012 00F4      		brsh .L234
 2044 0014 E050      		subi r30,lo8(-(gs(.L216)))
 2045 0016 F040      		sbci r31,hi8(-(gs(.L216)))
 2046 0018 0C94 0000 		jmp __tablejump2__
 2047               		.section	.progmem.gcc_sw_table.is_tap_key,"a",@progbits
 2048               		.p2align	1
 2049               	.L216:
 2050 0000 0000      		.word gs(.L215)
 2051 0002 0000      		.word gs(.L215)
 2052 0004 0000      		.word gs(.L234)
 2053 0006 0000      		.word gs(.L234)
 2054 0008 0000      		.word gs(.L217)
 2055 000a 0000      		.word gs(.L234)
 2056 000c 0000      		.word gs(.L234)
 2057 000e 0000      		.word gs(.L234)
 2058 0010 0000      		.word gs(.L215)
 2059 0012 0000      		.word gs(.L215)
 2060 0014 0000      		.word gs(.L218)
 2061 0016 0000      		.word gs(.L234)
 2062 0018 0000      		.word gs(.L234)
 2063 001a 0000      		.word gs(.L218)
 2064               		.section	.text.is_tap_key
 2065               	.L215:
 900:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 901:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 902:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 903:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 904:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2066               		.loc 1 904 0
 2067 001c 803F      		cpi r24,lo8(-16)
 2068 001e 01F0      		breq .L221
 2069 0020 00F4      		brsh .L220
 2070 0022 803E      		cpi r24,lo8(-32)
 2071 0024 00F4      		brsh .L234
 2072 0026 00C0      		rjmp .L221
 2073               	.L220:
 2074 0028 843F      		cpi r24,lo8(-12)
 2075 002a 01F4      		brne .L234
 2076 002c 00C0      		rjmp .L221
 2077               	.L217:
 905:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 906:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 907:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 908:./tmk_core/common/action.c ****                     return true;
 909:./tmk_core/common/action.c ****             }
 910:./tmk_core/common/action.c ****             return false;
 911:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 912:./tmk_core/common/action.c ****             switch (action.swap.code) {
 2078               		.loc 1 912 0
 2079 002e 803E      		cpi r24,lo8(-32)
 2080 0030 00F0      		brlo .L221
 2081 0032 813F      		cpi r24,lo8(-15)
 2082 0034 01F4      		brne .L234
 2083               	.L221:
 913:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 914:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 915:./tmk_core/common/action.c ****                     return true;
 2084               		.loc 1 915 0
 2085 0036 81E0      		ldi r24,lo8(1)
 2086               	.LVL220:
 2087 0038 0895      		ret
 2088               	.LVL221:
 2089               	.L218:
 916:./tmk_core/common/action.c ****             }
 917:./tmk_core/common/action.c ****             return false;
 918:./tmk_core/common/action.c ****         case ACT_MACRO:
 919:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 920:./tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 2090               		.loc 1 920 0
 2091 003a 93FB      		bst r25,3
 2092 003c 8827      		clr r24
 2093 003e 80F9      		bld r24,0
 2094               	.LVL222:
 2095 0040 0895      		ret
 2096               	.LVL223:
 2097               	.L234:
 917:./tmk_core/common/action.c ****             return false;
 2098               		.loc 1 917 0
 2099 0042 80E0      		ldi r24,0
 2100               	.LVL224:
 921:./tmk_core/common/action.c ****             return false;
 922:./tmk_core/common/action.c ****     }
 923:./tmk_core/common/action.c ****     return false;
 924:./tmk_core/common/action.c **** }
 2101               		.loc 1 924 0
 2102 0044 0895      		ret
 2103               		.cfi_endproc
 2104               	.LFE25:
 2106               		.section	.text.debug_event,"ax",@progbits
 2107               	.global	debug_event
 2109               	debug_event:
 2110               	.LFB26:
 925:./tmk_core/common/action.c **** 
 926:./tmk_core/common/action.c **** 
 927:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 928:./tmk_core/common/action.c ****  *
 929:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 930:./tmk_core/common/action.c ****  */
 931:./tmk_core/common/action.c **** void debug_event(keyevent_t event)
 932:./tmk_core/common/action.c **** {
 2111               		.loc 1 932 0
 2112               		.cfi_startproc
 2113 0000 CF93      		push r28
 2114               	.LCFI25:
 2115               		.cfi_def_cfa_offset 3
 2116               		.cfi_offset 28, -2
 2117 0002 DF93      		push r29
 2118               	.LCFI26:
 2119               		.cfi_def_cfa_offset 4
 2120               		.cfi_offset 29, -3
 2121 0004 00D0      		rcall .
 2122 0006 00D0      		rcall .
 2123 0008 1F92      		push __zero_reg__
 2124               	.LCFI27:
 2125               		.cfi_def_cfa_offset 9
 2126 000a CDB7      		in r28,__SP_L__
 2127 000c DEB7      		in r29,__SP_H__
 2128               	.LCFI28:
 2129               		.cfi_def_cfa_register 28
 2130               	/* prologue: function */
 2131               	/* frame size = 5 */
 2132               	/* stack size = 7 */
 2133               	.L__stack_usage = 7
 2134               	/* epilogue start */
 933:./tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 934:./tmk_core/common/action.c **** }
 2135               		.loc 1 934 0
 2136 000e 0F90      		pop __tmp_reg__
 2137 0010 0F90      		pop __tmp_reg__
 2138 0012 0F90      		pop __tmp_reg__
 2139 0014 0F90      		pop __tmp_reg__
 2140 0016 0F90      		pop __tmp_reg__
 2141 0018 DF91      		pop r29
 2142 001a CF91      		pop r28
 2143 001c 0895      		ret
 2144               		.cfi_endproc
 2145               	.LFE26:
 2147               		.section	.text.debug_record,"ax",@progbits
 2148               	.global	debug_record
 2150               	debug_record:
 2151               	.LFB27:
 935:./tmk_core/common/action.c **** 
 936:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 937:./tmk_core/common/action.c ****  *
 938:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 939:./tmk_core/common/action.c ****  */
 940:./tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 941:./tmk_core/common/action.c **** {
 2152               		.loc 1 941 0
 2153               		.cfi_startproc
 2154 0000 CF93      		push r28
 2155               	.LCFI29:
 2156               		.cfi_def_cfa_offset 3
 2157               		.cfi_offset 28, -2
 2158 0002 DF93      		push r29
 2159               	.LCFI30:
 2160               		.cfi_def_cfa_offset 4
 2161               		.cfi_offset 29, -3
 2162 0004 00D0      		rcall .
 2163 0006 00D0      		rcall .
 2164 0008 00D0      		rcall .
 2165               	.LCFI31:
 2166               		.cfi_def_cfa_offset 10
 2167 000a CDB7      		in r28,__SP_L__
 2168 000c DEB7      		in r29,__SP_H__
 2169               	.LCFI32:
 2170               		.cfi_def_cfa_register 28
 2171               	/* prologue: function */
 2172               	/* frame size = 6 */
 2173               	/* stack size = 8 */
 2174               	.L__stack_usage = 8
 2175               	/* epilogue start */
 942:./tmk_core/common/action.c ****     debug_event(record.event);
 943:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 944:./tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 945:./tmk_core/common/action.c **** #endif
 946:./tmk_core/common/action.c **** }
 2176               		.loc 1 946 0
 2177 000e 2696      		adiw r28,6
 2178 0010 0FB6      		in __tmp_reg__,__SREG__
 2179 0012 F894      		cli
 2180 0014 DEBF      		out __SP_H__,r29
 2181 0016 0FBE      		out __SREG__,__tmp_reg__
 2182 0018 CDBF      		out __SP_L__,r28
 2183 001a DF91      		pop r29
 2184 001c CF91      		pop r28
 2185 001e 0895      		ret
 2186               		.cfi_endproc
 2187               	.LFE27:
 2189               		.section	.text.debug_action,"ax",@progbits
 2190               	.global	debug_action
 2192               	debug_action:
 2193               	.LFB28:
 947:./tmk_core/common/action.c **** 
 948:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 949:./tmk_core/common/action.c ****  *
 950:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 951:./tmk_core/common/action.c ****  */
 952:./tmk_core/common/action.c **** void debug_action(action_t action)
 953:./tmk_core/common/action.c **** {
 2194               		.loc 1 953 0
 2195               		.cfi_startproc
 2196               	.LVL225:
 2197               	/* prologue: function */
 2198               	/* frame size = 0 */
 2199               	/* stack size = 0 */
 2200               	.L__stack_usage = 0
 2201 0000 0895      		ret
 2202               		.cfi_endproc
 2203               	.LFE28:
 2205               		.comm	tp_buttons,2,1
 2206               		.text
 2207               	.Letext0:
 2208               		.file 5 "/usr/lib/avr/include/stdint.h"
 2209               		.file 6 "./tmk_core/common/keycode.h"
 2210               		.file 7 "./tmk_core/common/report.h"
 2211               		.file 8 "./tmk_core/common/action_code.h"
 2212               		.file 9 "./tmk_core/common/action_macro.h"
 2213               		.file 10 "./tmk_core/common/action.h"
 2214               		.file 11 "./tmk_core/common/action_tapping.h"
 2215               		.file 12 "./tmk_core/common/action_layer.h"
 2216               		.file 13 "./tmk_core/common/command.h"
 2217               		.file 14 "./tmk_core/common/host.h"
 2218               		.file 15 "./tmk_core/common/mousekey.h"
 2219               		.file 16 "./tmk_core/common/led.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/ccJfBQmU.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccJfBQmU.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccJfBQmU.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccJfBQmU.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccJfBQmU.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccJfBQmU.s:13     .text.action_exec:0000000000000000 action_exec
     /tmp/ccJfBQmU.s:93     .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccJfBQmU.s:112    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/ccJfBQmU.s:135    .text.register_code:0000000000000000 register_code
     /tmp/ccJfBQmU.s:574    .text.unregister_code:0000000000000000 unregister_code
     /tmp/ccJfBQmU.s:755    .text.register_mods:0000000000000000 register_mods
     /tmp/ccJfBQmU.s:781    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/ccJfBQmU.s:807    .text.process_action:0000000000000000 process_action
                            *COM*:0000000000000002 tp_buttons
     /tmp/ccJfBQmU.s:1841   .text.process_record:0000000000000000 process_record
     /tmp/ccJfBQmU.s:1937   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/ccJfBQmU.s:1955   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/ccJfBQmU.s:2003   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/ccJfBQmU.s:2023   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/ccJfBQmU.s:2109   .text.debug_event:0000000000000000 debug_event
     /tmp/ccJfBQmU.s:2150   .text.debug_record:0000000000000000 debug_record
     /tmp/ccJfBQmU.s:2192   .text.debug_action:0000000000000000 debug_action

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
keyboard_report
add_key_to_report
send_keyboard_report
del_key_from_report
command_proc
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
mousekey_on
mousekey_off
mousekey_send
default_layer_and
default_layer_xor
default_layer_or
layer_and
layer_xor
layer_or
layer_on
layer_off
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
led_set
get_oneshot_layer_state
get_oneshot_layer
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys_from_report
mousekey_clear
clear_mods
__do_clear_bss
