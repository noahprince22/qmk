   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB28:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  19:quantum/quantum.c **** #include "outputselect.h"
  20:quantum/quantum.c **** #endif
  21:quantum/quantum.c **** 
  22:quantum/quantum.c **** #ifndef TAPPING_TERM
  23:quantum/quantum.c **** #define TAPPING_TERM 200
  24:quantum/quantum.c **** #endif
  25:quantum/quantum.c **** 
  26:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  27:quantum/quantum.c **** #define BREATHING_PERIOD 6
  28:quantum/quantum.c **** #endif
  29:quantum/quantum.c **** 
  30:quantum/quantum.c **** #include "backlight.h"
  31:quantum/quantum.c **** extern backlight_config_t backlight_config;
  32:quantum/quantum.c **** 
  33:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  34:quantum/quantum.c **** #include "fauxclicky.h"
  35:quantum/quantum.c **** #endif
  36:quantum/quantum.c **** 
  37:quantum/quantum.c **** #ifdef API_ENABLE
  38:quantum/quantum.c **** #include "api.h"
  39:quantum/quantum.c **** #endif
  40:quantum/quantum.c **** 
  41:quantum/quantum.c **** #ifdef MIDI_ENABLE
  42:quantum/quantum.c **** #include "process_midi.h"
  43:quantum/quantum.c **** #endif
  44:quantum/quantum.c **** 
  45:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  46:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  47:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  48:quantum/quantum.c ****   #endif
  49:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  50:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  51:quantum/quantum.c ****   #endif
  52:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  53:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  54:quantum/quantum.c ****   #endif
  55:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  56:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  57:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  58:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  59:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  60:quantum/quantum.c ****   #endif
  61:quantum/quantum.c **** #endif
  62:quantum/quantum.c **** 
  63:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 63 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  64:quantum/quantum.c ****   switch (code) {
  38               		.loc 1 64 0
  39 0008 9C01      		movw r18,r24
  40 000a 3A95      		dec r19
  41 000c 2115      		cp r18,__zero_reg__
  42 000e 3F41      		sbci r19,31
  43 0010 00F4      		brsh .L1
  44 0012 EB01      		movw r28,r22
  45 0014 8C01      		movw r16,r24
  65:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  66:quantum/quantum.c ****     break;
  67:quantum/quantum.c ****   default:
  68:quantum/quantum.c ****     return;
  69:quantum/quantum.c ****   }
  70:quantum/quantum.c **** 
  71:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 71 0
  47 0016 90FF      		sbrs r25,0
  48 0018 00C0      		rjmp .L4
  72:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 72 0
  50 001a 80EE      		ldi r24,lo8(-32)
  51               	.LVL1:
  52 001c FB01      		movw r30,r22
  53 001e 0995      		icall
  54               	.LVL2:
  55               	.L4:
  73:quantum/quantum.c ****   if (code & QK_LSFT)
  56               		.loc 1 73 0
  57 0020 11FF      		sbrs r17,1
  58 0022 00C0      		rjmp .L5
  74:quantum/quantum.c ****     f(KC_LSFT);
  59               		.loc 1 74 0
  60 0024 81EE      		ldi r24,lo8(-31)
  61 0026 FE01      		movw r30,r28
  62 0028 0995      		icall
  63               	.LVL3:
  64               	.L5:
  75:quantum/quantum.c ****   if (code & QK_LALT)
  65               		.loc 1 75 0
  66 002a 12FF      		sbrs r17,2
  67 002c 00C0      		rjmp .L6
  76:quantum/quantum.c ****     f(KC_LALT);
  68               		.loc 1 76 0
  69 002e 82EE      		ldi r24,lo8(-30)
  70 0030 FE01      		movw r30,r28
  71 0032 0995      		icall
  72               	.LVL4:
  73               	.L6:
  77:quantum/quantum.c ****   if (code & QK_LGUI)
  74               		.loc 1 77 0
  75 0034 13FF      		sbrs r17,3
  76 0036 00C0      		rjmp .L7
  78:quantum/quantum.c ****     f(KC_LGUI);
  77               		.loc 1 78 0
  78 0038 83EE      		ldi r24,lo8(-29)
  79 003a FE01      		movw r30,r28
  80 003c 0995      		icall
  81               	.LVL5:
  82               	.L7:
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  83               		.loc 1 80 0
  84 003e 0115      		cp r16,__zero_reg__
  85 0040 1041      		sbci r17,16
  86 0042 00F0      		brlo .L1
  81:quantum/quantum.c **** 
  82:quantum/quantum.c ****   if (code & QK_RCTL)
  83:quantum/quantum.c ****     f(KC_RCTL);
  87               		.loc 1 83 0
  88 0044 84EE      		ldi r24,lo8(-28)
  89 0046 FE01      		movw r30,r28
  90 0048 0995      		icall
  91               	.LVL6:
  84:quantum/quantum.c ****   if (code & QK_RSFT)
  85:quantum/quantum.c ****     f(KC_RSFT);
  92               		.loc 1 85 0
  93 004a 85EE      		ldi r24,lo8(-27)
  94 004c FE01      		movw r30,r28
  95 004e 0995      		icall
  96               	.LVL7:
  86:quantum/quantum.c ****   if (code & QK_RALT)
  87:quantum/quantum.c ****     f(KC_RALT);
  97               		.loc 1 87 0
  98 0050 86EE      		ldi r24,lo8(-26)
  99 0052 FE01      		movw r30,r28
 100 0054 0995      		icall
 101               	.LVL8:
  88:quantum/quantum.c ****   if (code & QK_RGUI)
  89:quantum/quantum.c ****     f(KC_RGUI);
 102               		.loc 1 89 0
 103 0056 87EE      		ldi r24,lo8(-25)
 104 0058 FE01      		movw r30,r28
 105               	/* epilogue start */
  90:quantum/quantum.c **** }
 106               		.loc 1 90 0
 107 005a DF91      		pop r29
 108 005c CF91      		pop r28
 109               	.LVL9:
 110 005e 1F91      		pop r17
 111 0060 0F91      		pop r16
 112               	.LVL10:
  89:quantum/quantum.c **** }
 113               		.loc 1 89 0
 114 0062 0994      		ijmp
 115               	.LVL11:
 116               	.L1:
 117               	/* epilogue start */
 118               		.loc 1 90 0
 119 0064 DF91      		pop r29
 120 0066 CF91      		pop r28
 121 0068 1F91      		pop r17
 122 006a 0F91      		pop r16
 123 006c 0895      		ret
 124               		.cfi_endproc
 125               	.LFE28:
 127               		.section	.text.qk_register_mods,"ax",@progbits
 129               	qk_register_mods:
 130               	.LFB31:
  91:quantum/quantum.c **** 
  92:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
  93:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
  94:quantum/quantum.c ****     send_keyboard_report();
  95:quantum/quantum.c **** }
  96:quantum/quantum.c **** 
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
  99:quantum/quantum.c ****     send_keyboard_report();
 100:quantum/quantum.c **** }
 101:quantum/quantum.c **** 
 102:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 131               		.loc 1 102 0
 132               		.cfi_startproc
 133               	.LVL12:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 103:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 138               		.loc 1 103 0
 139 0000 8770      		andi r24,lo8(7)
 140               	.LVL13:
 141 0002 91E0      		ldi r25,lo8(1)
 142 0004 00C0      		rjmp 2f
 143               		1:
 144 0006 990F      		lsl r25
 145               		2:
 146 0008 8A95      		dec r24
 147 000a 02F4      		brpl 1b
 148 000c 892F      		mov r24,r25
 149 000e 0E94 0000 		call add_weak_mods
 150               	.LVL14:
 104:quantum/quantum.c ****     send_keyboard_report();
 151               		.loc 1 104 0
 152 0012 0C94 0000 		jmp send_keyboard_report
 153               	.LVL15:
 154               		.cfi_endproc
 155               	.LFE31:
 157               		.section	.text.qk_register_weak_mods,"ax",@progbits
 159               	qk_register_weak_mods:
 160               	.LFB98:
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 166 0000 0C94 0000 		jmp qk_register_mods
 167               		.cfi_endproc
 168               	.LFE98:
 170               		.section	.text.qk_unregister_mods,"ax",@progbits
 172               	qk_unregister_mods:
 173               	.LFB32:
 105:quantum/quantum.c **** }
 106:quantum/quantum.c **** 
 107:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 174               		.loc 1 107 0
 175               		.cfi_startproc
 176               	.LVL16:
 177               	/* prologue: function */
 178               	/* frame size = 0 */
 179               	/* stack size = 0 */
 180               	.L__stack_usage = 0
 108:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 181               		.loc 1 108 0
 182 0000 8770      		andi r24,lo8(7)
 183               	.LVL17:
 184 0002 91E0      		ldi r25,lo8(1)
 185 0004 00C0      		rjmp 2f
 186               		1:
 187 0006 990F      		lsl r25
 188               		2:
 189 0008 8A95      		dec r24
 190 000a 02F4      		brpl 1b
 191 000c 892F      		mov r24,r25
 192 000e 0E94 0000 		call del_weak_mods
 193               	.LVL18:
 109:quantum/quantum.c ****     send_keyboard_report();
 194               		.loc 1 109 0
 195 0012 0C94 0000 		jmp send_keyboard_report
 196               	.LVL19:
 197               		.cfi_endproc
 198               	.LFE32:
 200               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 202               	qk_unregister_weak_mods:
 203               	.LFB96:
 204               		.cfi_startproc
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 0 */
 208               	.L__stack_usage = 0
 209 0000 0C94 0000 		jmp qk_unregister_mods
 210               		.cfi_endproc
 211               	.LFE96:
 213               		.section	.text.rgblight_toggle,"ax",@progbits
 214               		.weak	rgblight_toggle
 216               	rgblight_toggle:
 217               	.LFB92:
 218               		.cfi_startproc
 219               	/* prologue: function */
 220               	/* frame size = 0 */
 221               	/* stack size = 0 */
 222               	.L__stack_usage = 0
 223 0000 0895      		ret
 224               		.cfi_endproc
 225               	.LFE92:
 227               		.section	.text.rgblight_step,"ax",@progbits
 228               		.weak	rgblight_step
 230               	rgblight_step:
 231               	.LFB90:
 232               		.cfi_startproc
 233               	/* prologue: function */
 234               	/* frame size = 0 */
 235               	/* stack size = 0 */
 236               	.L__stack_usage = 0
 237 0000 0895      		ret
 238               		.cfi_endproc
 239               	.LFE90:
 241               		.section	.text.rgblight_step_reverse,"ax",@progbits
 242               		.weak	rgblight_step_reverse
 244               	rgblight_step_reverse:
 245               	.LFB88:
 246               		.cfi_startproc
 247               	/* prologue: function */
 248               	/* frame size = 0 */
 249               	/* stack size = 0 */
 250               	.L__stack_usage = 0
 251 0000 0895      		ret
 252               		.cfi_endproc
 253               	.LFE88:
 255               		.section	.text.rgblight_increase_hue,"ax",@progbits
 256               		.weak	rgblight_increase_hue
 258               	rgblight_increase_hue:
 259               	.LFB86:
 260               		.cfi_startproc
 261               	/* prologue: function */
 262               	/* frame size = 0 */
 263               	/* stack size = 0 */
 264               	.L__stack_usage = 0
 265 0000 0895      		ret
 266               		.cfi_endproc
 267               	.LFE86:
 269               		.section	.text.rgblight_decrease_hue,"ax",@progbits
 270               		.weak	rgblight_decrease_hue
 272               	rgblight_decrease_hue:
 273               	.LFB84:
 274               		.cfi_startproc
 275               	/* prologue: function */
 276               	/* frame size = 0 */
 277               	/* stack size = 0 */
 278               	.L__stack_usage = 0
 279 0000 0895      		ret
 280               		.cfi_endproc
 281               	.LFE84:
 283               		.section	.text.rgblight_increase_sat,"ax",@progbits
 284               		.weak	rgblight_increase_sat
 286               	rgblight_increase_sat:
 287               	.LFB82:
 288               		.cfi_startproc
 289               	/* prologue: function */
 290               	/* frame size = 0 */
 291               	/* stack size = 0 */
 292               	.L__stack_usage = 0
 293 0000 0895      		ret
 294               		.cfi_endproc
 295               	.LFE82:
 297               		.section	.text.rgblight_decrease_sat,"ax",@progbits
 298               		.weak	rgblight_decrease_sat
 300               	rgblight_decrease_sat:
 301               	.LFB80:
 302               		.cfi_startproc
 303               	/* prologue: function */
 304               	/* frame size = 0 */
 305               	/* stack size = 0 */
 306               	.L__stack_usage = 0
 307 0000 0895      		ret
 308               		.cfi_endproc
 309               	.LFE80:
 311               		.section	.text.rgblight_increase_val,"ax",@progbits
 312               		.weak	rgblight_increase_val
 314               	rgblight_increase_val:
 315               	.LFB78:
 316               		.cfi_startproc
 317               	/* prologue: function */
 318               	/* frame size = 0 */
 319               	/* stack size = 0 */
 320               	.L__stack_usage = 0
 321 0000 0895      		ret
 322               		.cfi_endproc
 323               	.LFE78:
 325               		.section	.text.rgblight_decrease_val,"ax",@progbits
 326               		.weak	rgblight_decrease_val
 328               	rgblight_decrease_val:
 329               	.LFB76:
 330               		.cfi_startproc
 331               	/* prologue: function */
 332               	/* frame size = 0 */
 333               	/* stack size = 0 */
 334               	.L__stack_usage = 0
 335 0000 0895      		ret
 336               		.cfi_endproc
 337               	.LFE76:
 339               		.section	.text.rgblight_increase_speed,"ax",@progbits
 340               		.weak	rgblight_increase_speed
 342               	rgblight_increase_speed:
 343               	.LFB74:
 344               		.cfi_startproc
 345               	/* prologue: function */
 346               	/* frame size = 0 */
 347               	/* stack size = 0 */
 348               	.L__stack_usage = 0
 349 0000 0895      		ret
 350               		.cfi_endproc
 351               	.LFE74:
 353               		.section	.text.rgblight_decrease_speed,"ax",@progbits
 354               		.weak	rgblight_decrease_speed
 356               	rgblight_decrease_speed:
 357               	.LFB72:
 358               		.cfi_startproc
 359               	/* prologue: function */
 360               	/* frame size = 0 */
 361               	/* stack size = 0 */
 362               	.L__stack_usage = 0
 363 0000 0895      		ret
 364               		.cfi_endproc
 365               	.LFE72:
 367               		.section	.text.register_code16,"ax",@progbits
 368               	.global	register_code16
 370               	register_code16:
 371               	.LFB33:
 110:quantum/quantum.c **** }
 111:quantum/quantum.c **** 
 112:quantum/quantum.c **** void register_code16 (uint16_t code) {
 372               		.loc 1 112 0
 373               		.cfi_startproc
 374               	.LVL20:
 375               		.loc 1 112 0
 376 0000 CF93      		push r28
 377               	.LCFI4:
 378               		.cfi_def_cfa_offset 3
 379               		.cfi_offset 28, -2
 380 0002 DF93      		push r29
 381               	.LCFI5:
 382               		.cfi_def_cfa_offset 4
 383               		.cfi_offset 29, -3
 384               	/* prologue: function */
 385               	/* frame size = 0 */
 386               	/* stack size = 2 */
 387               	.L__stack_usage = 2
 388 0004 EC01      		movw r28,r24
 113:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 389               		.loc 1 113 0
 390 0006 805E      		subi r24,-32
 391 0008 9109      		sbc r25,__zero_reg__
 392               	.LVL21:
 393 000a 0897      		sbiw r24,8
 394 000c 00F0      		brlo .L39
 395               		.loc 1 113 0 is_stmt 0 discriminator 1
 396 000e 2097      		sbiw r28,0
 397 0010 01F4      		brne .L40
 398               	.L39:
 114:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 399               		.loc 1 114 0 is_stmt 1
 400 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 401 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 402 0016 00C0      		rjmp .L42
 403               	.L40:
 115:quantum/quantum.c ****   } else {
 116:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 404               		.loc 1 116 0
 405 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 406 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 407               	.L42:
 408 001c CE01      		movw r24,r28
 409 001e 0E94 0000 		call do_code16
 410               	.LVL22:
 117:quantum/quantum.c ****   }
 118:quantum/quantum.c ****   register_code (code);
 411               		.loc 1 118 0
 412 0022 8C2F      		mov r24,r28
 413               	/* epilogue start */
 119:quantum/quantum.c **** }
 414               		.loc 1 119 0
 415 0024 DF91      		pop r29
 416 0026 CF91      		pop r28
 417               	.LVL23:
 118:quantum/quantum.c **** }
 418               		.loc 1 118 0
 419 0028 0C94 0000 		jmp register_code
 420               	.LVL24:
 421               		.cfi_endproc
 422               	.LFE33:
 424               		.section	.text.unregister_code16,"ax",@progbits
 425               	.global	unregister_code16
 427               	unregister_code16:
 428               	.LFB34:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 429               		.loc 1 121 0
 430               		.cfi_startproc
 431               	.LVL25:
 432 0000 CF93      		push r28
 433               	.LCFI6:
 434               		.cfi_def_cfa_offset 3
 435               		.cfi_offset 28, -2
 436 0002 DF93      		push r29
 437               	.LCFI7:
 438               		.cfi_def_cfa_offset 4
 439               		.cfi_offset 29, -3
 440               	/* prologue: function */
 441               	/* frame size = 0 */
 442               	/* stack size = 2 */
 443               	.L__stack_usage = 2
 444 0004 EC01      		movw r28,r24
 122:quantum/quantum.c ****   unregister_code (code);
 445               		.loc 1 122 0
 446 0006 0E94 0000 		call unregister_code
 447               	.LVL26:
 123:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 448               		.loc 1 123 0
 449 000a CE01      		movw r24,r28
 450 000c 805E      		subi r24,-32
 451 000e 9109      		sbc r25,__zero_reg__
 452 0010 0897      		sbiw r24,8
 453 0012 00F0      		brlo .L44
 454               		.loc 1 123 0 is_stmt 0 discriminator 1
 455 0014 2097      		sbiw r28,0
 456 0016 01F4      		brne .L45
 457               	.L44:
 124:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 458               		.loc 1 124 0 is_stmt 1
 459 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 460 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 461 001c 00C0      		rjmp .L46
 462               	.L45:
 125:quantum/quantum.c ****   } else {
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 463               		.loc 1 126 0
 464 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 465 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 466               	.L46:
 467 0022 CE01      		movw r24,r28
 468               	/* epilogue start */
 127:quantum/quantum.c ****   }
 128:quantum/quantum.c **** }
 469               		.loc 1 128 0
 470 0024 DF91      		pop r29
 471 0026 CF91      		pop r28
 472               	.LVL27:
 126:quantum/quantum.c ****   }
 473               		.loc 1 126 0
 474 0028 0C94 0000 		jmp do_code16
 475               	.LVL28:
 476               		.cfi_endproc
 477               	.LFE34:
 479               		.section	.text.process_action_kb,"ax",@progbits
 480               		.weak	process_action_kb
 482               	process_action_kb:
 483               	.LFB35:
 129:quantum/quantum.c **** 
 130:quantum/quantum.c **** __attribute__ ((weak))
 131:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 484               		.loc 1 131 0
 485               		.cfi_startproc
 486               	.LVL29:
 487               	/* prologue: function */
 488               	/* frame size = 0 */
 489               	/* stack size = 0 */
 490               	.L__stack_usage = 0
 132:quantum/quantum.c ****   return true;
 133:quantum/quantum.c **** }
 491               		.loc 1 133 0
 492 0000 81E0      		ldi r24,lo8(1)
 493               	.LVL30:
 494 0002 0895      		ret
 495               		.cfi_endproc
 496               	.LFE35:
 498               		.section	.text.process_record_user,"ax",@progbits
 499               		.weak	process_record_user
 501               	process_record_user:
 502               	.LFB37:
 134:quantum/quantum.c **** 
 135:quantum/quantum.c **** __attribute__ ((weak))
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 138:quantum/quantum.c **** }
 139:quantum/quantum.c **** 
 140:quantum/quantum.c **** __attribute__ ((weak))
 141:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 503               		.loc 1 141 0
 504               		.cfi_startproc
 505               	.LVL31:
 506               	/* prologue: function */
 507               	/* frame size = 0 */
 508               	/* stack size = 0 */
 509               	.L__stack_usage = 0
 142:quantum/quantum.c ****   return true;
 143:quantum/quantum.c **** }
 510               		.loc 1 143 0
 511 0000 81E0      		ldi r24,lo8(1)
 512               	.LVL32:
 513 0002 0895      		ret
 514               		.cfi_endproc
 515               	.LFE37:
 517               		.section	.text.process_record_kb,"ax",@progbits
 518               		.weak	process_record_kb
 520               	process_record_kb:
 521               	.LFB36:
 136:quantum/quantum.c ****   return process_record_user(keycode, record);
 522               		.loc 1 136 0
 523               		.cfi_startproc
 524               	.LVL33:
 525               	/* prologue: function */
 526               	/* frame size = 0 */
 527               	/* stack size = 0 */
 528               	.L__stack_usage = 0
 137:quantum/quantum.c **** }
 529               		.loc 1 137 0
 530 0000 0C94 0000 		jmp process_record_user
 531               	.LVL34:
 532               		.cfi_endproc
 533               	.LFE36:
 535               		.section	.text.reset_keyboard,"ax",@progbits
 536               	.global	reset_keyboard
 538               	reset_keyboard:
 539               	.LFB38:
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** void reset_keyboard(void) {
 540               		.loc 1 145 0
 541               		.cfi_startproc
 542               	/* prologue: function */
 543               	/* frame size = 0 */
 544               	/* stack size = 0 */
 545               	.L__stack_usage = 0
 146:quantum/quantum.c ****   clear_keyboard();
 546               		.loc 1 146 0
 547 0000 0E94 0000 		call clear_keyboard
 548               	.LVL35:
 549               	.LBB28:
 550               	.LBB29:
 551               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 552               		.loc 2 187 0
 553 0004 2FEF      		ldi r18,lo8(799999)
 554 0006 84E3      		ldi r24,hi8(799999)
 555 0008 9CE0      		ldi r25,hlo8(799999)
 556 000a 2150      	1:	subi r18,1
 557 000c 8040      		sbci r24,0
 558 000e 9040      		sbci r25,0
 559 0010 01F4      		brne 1b
 560 0012 00C0      		rjmp .
 561 0014 0000      		nop
 562               	.LVL36:
 563               	.LBE29:
 564               	.LBE28:
 147:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 148:quantum/quantum.c ****   process_midi_all_notes_off();
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 151:quantum/quantum.c ****   music_all_notes_off();
 152:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 153:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 154:quantum/quantum.c ****   shutdown_user();
 155:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 156:quantum/quantum.c ****     wait_ms(1);
 157:quantum/quantum.c ****   stop_all_notes();
 158:quantum/quantum.c **** #else
 159:quantum/quantum.c ****   wait_ms(250);
 160:quantum/quantum.c **** #endif
 161:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 162:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 163:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 565               		.loc 1 163 0
 566 0016 87E7      		ldi r24,lo8(119)
 567 0018 97E7      		ldi r25,lo8(119)
 568 001a 9093 0108 		sts 2048+1,r25
 569 001e 8093 0008 		sts 2048,r24
 164:quantum/quantum.c **** #endif
 165:quantum/quantum.c ****   bootloader_jump();
 570               		.loc 1 165 0
 571 0022 0C94 0000 		jmp bootloader_jump
 572               	.LVL37:
 573               		.cfi_endproc
 574               	.LFE38:
 576               		.section	.text.process_record_quantum,"ax",@progbits
 577               	.global	process_record_quantum
 579               	process_record_quantum:
 580               	.LFB39:
 166:quantum/quantum.c **** }
 167:quantum/quantum.c **** 
 168:quantum/quantum.c **** // Shift / paren setup
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** #ifndef LSPO_KEY
 171:quantum/quantum.c ****   #define LSPO_KEY KC_9
 172:quantum/quantum.c **** #endif
 173:quantum/quantum.c **** #ifndef RSPC_KEY
 174:quantum/quantum.c ****   #define RSPC_KEY KC_0
 175:quantum/quantum.c **** #endif
 176:quantum/quantum.c **** 
 177:quantum/quantum.c **** // Shift / Enter setup
 178:quantum/quantum.c **** #ifndef SFTENT_KEY
 179:quantum/quantum.c ****   #define SFTENT_KEY KC_ENT
 180:quantum/quantum.c **** #endif
 181:quantum/quantum.c **** 
 182:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 183:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 184:quantum/quantum.c **** 
 185:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 186:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 187:quantum/quantum.c ****  */
 188:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 581               		.loc 1 190 0
 582               		.cfi_startproc
 583               	.LVL38:
 584 0000 FF92      		push r15
 585               	.LCFI8:
 586               		.cfi_def_cfa_offset 3
 587               		.cfi_offset 15, -2
 588 0002 0F93      		push r16
 589               	.LCFI9:
 590               		.cfi_def_cfa_offset 4
 591               		.cfi_offset 16, -3
 592 0004 1F93      		push r17
 593               	.LCFI10:
 594               		.cfi_def_cfa_offset 5
 595               		.cfi_offset 17, -4
 596 0006 CF93      		push r28
 597               	.LCFI11:
 598               		.cfi_def_cfa_offset 6
 599               		.cfi_offset 28, -5
 600 0008 DF93      		push r29
 601               	.LCFI12:
 602               		.cfi_def_cfa_offset 7
 603               		.cfi_offset 29, -6
 604               	/* prologue: function */
 605               	/* frame size = 0 */
 606               	/* stack size = 5 */
 607               	.L__stack_usage = 5
 608 000a 8C01      		movw r16,r24
 191:quantum/quantum.c **** 
 192:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 193:quantum/quantum.c ****   keypos_t key = record->event.key;
 609               		.loc 1 193 0
 610 000c FC01      		movw r30,r24
 611 000e C081      		ld r28,Z
 612 0010 D181      		ldd r29,Z+1
 613               	.LVL39:
 194:quantum/quantum.c ****   uint16_t keycode;
 195:quantum/quantum.c **** 
 196:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 197:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 198:quantum/quantum.c ****     if (!disable_action_cache) {
 614               		.loc 1 198 0
 615 0012 8091 0000 		lds r24,disable_action_cache
 616               	.LVL40:
 617 0016 8111      		cpse r24,__zero_reg__
 618 0018 00C0      		rjmp .L52
 619               	.LBB30:
 199:quantum/quantum.c ****       uint8_t layer;
 200:quantum/quantum.c **** 
 201:quantum/quantum.c ****       if (record->event.pressed) {
 620               		.loc 1 201 0
 621 001a 8281      		ldd r24,Z+2
 622 001c 8823      		tst r24
 623 001e 01F0      		breq .L53
 624               	.LVL41:
 202:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 625               		.loc 1 202 0
 626 0020 CE01      		movw r24,r28
 627 0022 0E94 0000 		call layer_switch_get_layer
 628               	.LVL42:
 629 0026 F82E      		mov r15,r24
 630               	.LVL43:
 203:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 631               		.loc 1 203 0
 632 0028 682F      		mov r22,r24
 633 002a CE01      		movw r24,r28
 634 002c 0E94 0000 		call update_source_layers_cache
 635               	.LVL44:
 636 0030 00C0      		rjmp .L54
 637               	.LVL45:
 638               	.L53:
 204:quantum/quantum.c ****       } else {
 205:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 639               		.loc 1 205 0
 640 0032 CE01      		movw r24,r28
 641 0034 0E94 0000 		call read_source_layers_cache
 642               	.LVL46:
 643 0038 F82E      		mov r15,r24
 644               	.LVL47:
 645               	.L54:
 206:quantum/quantum.c ****       }
 207:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 646               		.loc 1 207 0
 647 003a BE01      		movw r22,r28
 648 003c 8F2D      		mov r24,r15
 649 003e 00C0      		rjmp .L133
 650               	.LVL48:
 651               	.L52:
 652               	.LBE30:
 208:quantum/quantum.c ****     } else
 209:quantum/quantum.c ****   #endif
 210:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 653               		.loc 1 210 0
 654 0040 CE01      		movw r24,r28
 655 0042 0E94 0000 		call layer_switch_get_layer
 656               	.LVL49:
 657 0046 BE01      		movw r22,r28
 658               	.L133:
 659 0048 0E94 0000 		call keymap_key_to_keycode
 660               	.LVL50:
 661 004c EC01      		movw r28,r24
 662               	.LVL51:
 211:quantum/quantum.c **** 
 212:quantum/quantum.c ****     // This is how you use actions here
 213:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 214:quantum/quantum.c ****     //   action_t action;
 215:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 216:quantum/quantum.c ****     //   process_action(record, action);
 217:quantum/quantum.c ****     //   return false;
 218:quantum/quantum.c ****     // }
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 221:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 663               		.loc 1 221 0
 664 004e B801      		movw r22,r16
 665 0050 0E94 0000 		call preprocess_tap_dance
 666               	.LVL52:
 222:quantum/quantum.c ****   #endif
 223:quantum/quantum.c **** 
 224:quantum/quantum.c ****   if (!(
 225:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 226:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 227:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 228:quantum/quantum.c ****   #endif
 229:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 230:quantum/quantum.c ****       process_clicky(keycode, record) &&
 231:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 667               		.loc 1 232 0
 668 0054 B801      		movw r22,r16
 669 0056 CE01      		movw r24,r28
 670 0058 0E94 0000 		call process_record_kb
 671               	.LVL53:
 233:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 234:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 235:quantum/quantum.c ****   #endif
 236:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 237:quantum/quantum.c ****     process_midi(keycode, record) &&
 238:quantum/quantum.c ****   #endif
 239:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 240:quantum/quantum.c ****     process_audio(keycode, record) &&
 241:quantum/quantum.c ****   #endif
 242:quantum/quantum.c ****   #ifdef STENO_ENABLE
 243:quantum/quantum.c ****     process_steno(keycode, record) &&
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c ****   #if ( defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSI
 246:quantum/quantum.c ****     process_music(keycode, record) &&
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 672               		.loc 1 249 0
 673 005c 8823      		tst r24
 674 005e 01F4      		brne .+2
 675 0060 00C0      		rjmp .L125
 676               		.loc 1 249 0 is_stmt 0 discriminator 2
 677 0062 B801      		movw r22,r16
 678 0064 CE01      		movw r24,r28
 679 0066 0E94 0000 		call process_tap_dance
 680               	.LVL54:
 232:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 681               		.loc 1 232 0 is_stmt 1 discriminator 2
 682 006a 8823      		tst r24
 683 006c 01F4      		brne .+2
 684 006e 00C0      		rjmp .L125
 250:quantum/quantum.c ****   #endif
 251:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 252:quantum/quantum.c ****     process_leader(keycode, record) &&
 685               		.loc 1 252 0 discriminator 3
 686 0070 B801      		movw r22,r16
 687 0072 CE01      		movw r24,r28
 688 0074 0E94 0000 		call process_leader
 689               	.LVL55:
 249:quantum/quantum.c ****   #endif
 690               		.loc 1 249 0 discriminator 3
 691 0078 8823      		tst r24
 692 007a 01F4      		brne .+2
 693 007c 00C0      		rjmp .L125
 253:quantum/quantum.c ****   #endif
 254:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 255:quantum/quantum.c ****     process_chording(keycode, record) &&
 256:quantum/quantum.c ****   #endif
 257:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 258:quantum/quantum.c ****     process_combo(keycode, record) &&
 259:quantum/quantum.c ****   #endif
 260:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 261:quantum/quantum.c ****     process_unicode(keycode, record) &&
 262:quantum/quantum.c ****   #endif
 263:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 264:quantum/quantum.c ****     process_ucis(keycode, record) &&
 265:quantum/quantum.c ****   #endif
 266:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 267:quantum/quantum.c ****     process_printer(keycode, record) &&
 268:quantum/quantum.c ****   #endif
 269:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 270:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 271:quantum/quantum.c ****   #endif
 272:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 273:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 274:quantum/quantum.c ****   #endif
 275:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 276:quantum/quantum.c ****     process_terminal(keycode, record) &&
 277:quantum/quantum.c ****   #endif
 278:quantum/quantum.c ****       true)) {
 279:quantum/quantum.c ****     return false;
 280:quantum/quantum.c ****   }
 281:quantum/quantum.c **** 
 282:quantum/quantum.c ****   // Shift / paren setup
 283:quantum/quantum.c **** 
 284:quantum/quantum.c ****   switch(keycode) {
 694               		.loc 1 284 0
 695 007e C531      		cpi r28,21
 696 0080 FCE5      		ldi r31,92
 697 0082 DF07      		cpc r29,r31
 698 0084 01F4      		brne .L140
 699               	.LBB31:
 285:quantum/quantum.c ****     case RESET:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 287:quantum/quantum.c ****         reset_keyboard();
 288:quantum/quantum.c ****       }
 289:quantum/quantum.c ****     return false;
 290:quantum/quantum.c ****     case DEBUG:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 292:quantum/quantum.c ****           debug_enable = true;
 293:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 294:quantum/quantum.c ****       }
 295:quantum/quantum.c ****     return false;
 296:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 297:quantum/quantum.c ****   case FC_TOG:
 298:quantum/quantum.c ****     if (record->event.pressed) {
 299:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 300:quantum/quantum.c ****     }
 301:quantum/quantum.c ****     return false;
 302:quantum/quantum.c ****   case FC_ON:
 303:quantum/quantum.c ****     if (record->event.pressed) {
 304:quantum/quantum.c ****       FAUXCLICKY_ON;
 305:quantum/quantum.c ****     }
 306:quantum/quantum.c ****     return false;
 307:quantum/quantum.c ****   case FC_OFF:
 308:quantum/quantum.c ****     if (record->event.pressed) {
 309:quantum/quantum.c ****       FAUXCLICKY_OFF;
 310:quantum/quantum.c ****     }
 311:quantum/quantum.c ****     return false;
 312:quantum/quantum.c ****   #endif
 313:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 314:quantum/quantum.c ****   case RGB_TOG:
 315:quantum/quantum.c ****     if (record->event.pressed) {
 316:quantum/quantum.c ****       rgblight_toggle();
 317:quantum/quantum.c ****     }
 318:quantum/quantum.c ****     return false;
 319:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 320:quantum/quantum.c ****     if (record->event.pressed) {
 321:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 322:quantum/quantum.c ****       if(shifted) {
 323:quantum/quantum.c ****         rgblight_step_reverse();
 324:quantum/quantum.c ****       }
 325:quantum/quantum.c ****       else {
 326:quantum/quantum.c ****         rgblight_step();
 327:quantum/quantum.c ****       }
 328:quantum/quantum.c ****     }
 329:quantum/quantum.c ****     return false;
 330:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 331:quantum/quantum.c ****     if (record->event.pressed) {
 332:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 333:quantum/quantum.c ****       if(shifted) {
 334:quantum/quantum.c ****         rgblight_step();
 335:quantum/quantum.c ****       }
 336:quantum/quantum.c ****       else {
 337:quantum/quantum.c ****         rgblight_step_reverse();
 338:quantum/quantum.c ****       }
 339:quantum/quantum.c ****     }
 340:quantum/quantum.c ****     return false;
 341:quantum/quantum.c ****   case RGB_HUI:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 343:quantum/quantum.c ****       rgblight_increase_hue();
 344:quantum/quantum.c ****     }
 345:quantum/quantum.c ****     return false;
 346:quantum/quantum.c ****   case RGB_HUD:
 347:quantum/quantum.c ****     if (record->event.pressed) {
 348:quantum/quantum.c ****       rgblight_decrease_hue();
 349:quantum/quantum.c ****     }
 350:quantum/quantum.c ****     return false;
 351:quantum/quantum.c ****   case RGB_SAI:
 352:quantum/quantum.c ****     if (record->event.pressed) {
 353:quantum/quantum.c ****       rgblight_increase_sat();
 354:quantum/quantum.c ****     }
 355:quantum/quantum.c ****     return false;
 356:quantum/quantum.c ****   case RGB_SAD:
 357:quantum/quantum.c ****     if (record->event.pressed) {
 358:quantum/quantum.c ****       rgblight_decrease_sat();
 359:quantum/quantum.c ****     }
 360:quantum/quantum.c ****     return false;
 361:quantum/quantum.c ****   case RGB_VAI:
 362:quantum/quantum.c ****     if (record->event.pressed) {
 363:quantum/quantum.c ****       rgblight_increase_val();
 364:quantum/quantum.c ****     }
 365:quantum/quantum.c ****     return false;
 366:quantum/quantum.c ****   case RGB_VAD:
 367:quantum/quantum.c ****     if (record->event.pressed) {
 368:quantum/quantum.c ****       rgblight_decrease_val();
 369:quantum/quantum.c ****     }
 370:quantum/quantum.c ****     return false;
 371:quantum/quantum.c ****   case RGB_SPI:
 372:quantum/quantum.c ****     if (record->event.pressed) {
 373:quantum/quantum.c ****       rgblight_increase_speed();
 374:quantum/quantum.c ****     }
 375:quantum/quantum.c ****     return false;
 376:quantum/quantum.c ****   case RGB_SPD:
 377:quantum/quantum.c ****     if (record->event.pressed) {
 378:quantum/quantum.c ****       rgblight_decrease_speed();
 379:quantum/quantum.c ****     }
 380:quantum/quantum.c ****     return false;
 381:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 382:quantum/quantum.c ****     if (record->event.pressed) {
 383:quantum/quantum.c ****       rgblight_mode(1);
 384:quantum/quantum.c ****     }
 385:quantum/quantum.c ****     return false;
 386:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 387:quantum/quantum.c ****     if (record->event.pressed) {
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 389:quantum/quantum.c ****         rgblight_step();
 390:quantum/quantum.c ****       } else {
 391:quantum/quantum.c ****         rgblight_mode(2);
 392:quantum/quantum.c ****       }
 393:quantum/quantum.c ****     }
 394:quantum/quantum.c ****     return false;
 395:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 396:quantum/quantum.c ****     if (record->event.pressed) {
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 398:quantum/quantum.c ****         rgblight_step();
 399:quantum/quantum.c ****       } else {
 400:quantum/quantum.c ****         rgblight_mode(6);
 401:quantum/quantum.c ****       }
 402:quantum/quantum.c ****     }
 403:quantum/quantum.c ****     return false;
 404:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 405:quantum/quantum.c ****     if (record->event.pressed) {
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 407:quantum/quantum.c ****         rgblight_step();
 408:quantum/quantum.c ****       } else {
 409:quantum/quantum.c ****         rgblight_mode(9);
 410:quantum/quantum.c ****       }
 411:quantum/quantum.c ****     }
 412:quantum/quantum.c ****     return false;
 413:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 414:quantum/quantum.c ****     if (record->event.pressed) {
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 416:quantum/quantum.c ****         rgblight_step();
 417:quantum/quantum.c ****       } else {
 418:quantum/quantum.c ****         rgblight_mode(15);
 419:quantum/quantum.c ****       }
 420:quantum/quantum.c ****     }
 421:quantum/quantum.c ****     return false;
 422:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 423:quantum/quantum.c ****     if (record->event.pressed) {
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 425:quantum/quantum.c ****         rgblight_step();
 426:quantum/quantum.c ****       } else {
 427:quantum/quantum.c ****         rgblight_mode(21);
 428:quantum/quantum.c ****       }
 429:quantum/quantum.c ****     }
 430:quantum/quantum.c ****     return false;
 431:quantum/quantum.c ****   case RGB_MODE_XMAS:
 432:quantum/quantum.c ****     if (record->event.pressed) {
 433:quantum/quantum.c ****       rgblight_mode(24);
 434:quantum/quantum.c ****     }
 435:quantum/quantum.c ****     return false;
 436:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 437:quantum/quantum.c ****     if (record->event.pressed) {
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 439:quantum/quantum.c ****         rgblight_step();
 440:quantum/quantum.c ****       } else {
 441:quantum/quantum.c ****         rgblight_mode(25);
 442:quantum/quantum.c ****       }
 443:quantum/quantum.c ****     }
 444:quantum/quantum.c ****     return false;
 445:quantum/quantum.c ****   #endif
 446:quantum/quantum.c ****     #ifdef PROTOCOL_LUFA
 447:quantum/quantum.c ****     case OUT_AUTO:
 448:quantum/quantum.c ****       if (record->event.pressed) {
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 450:quantum/quantum.c ****       }
 451:quantum/quantum.c ****       return false;
 452:quantum/quantum.c ****     case OUT_USB:
 453:quantum/quantum.c ****       if (record->event.pressed) {
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 455:quantum/quantum.c ****       }
 456:quantum/quantum.c ****       return false;
 457:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 458:quantum/quantum.c ****     case OUT_BT:
 459:quantum/quantum.c ****       if (record->event.pressed) {
 460:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 461:quantum/quantum.c ****       }
 462:quantum/quantum.c ****       return false;
 463:quantum/quantum.c ****     #endif
 464:quantum/quantum.c ****     #endif
 465:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 466:quantum/quantum.c ****       if (record->event.pressed) {
 467:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 468:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 469:quantum/quantum.c ****             eeconfig_init();
 470:quantum/quantum.c ****         }
 471:quantum/quantum.c ****         /* keymap config */
 472:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 473:quantum/quantum.c ****         switch (keycode)
 474:quantum/quantum.c ****         {
 475:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 476:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 477:quantum/quantum.c ****             break;
 478:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 479:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 480:quantum/quantum.c ****             break;
 481:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 482:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 483:quantum/quantum.c ****             break;
 484:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 485:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 486:quantum/quantum.c ****             break;
 487:quantum/quantum.c ****           case MAGIC_NO_GUI:
 488:quantum/quantum.c ****             keymap_config.no_gui = true;
 489:quantum/quantum.c ****             break;
 490:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 491:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 492:quantum/quantum.c ****             break;
 493:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 494:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 495:quantum/quantum.c ****             break;
 496:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 497:quantum/quantum.c ****             keymap_config.nkro = true;
 498:quantum/quantum.c ****             break;
 499:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 500:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 501:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 502:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 503:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 504:quantum/quantum.c ****             #endif
 505:quantum/quantum.c ****             break;
 506:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 507:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 508:quantum/quantum.c ****             break;
 509:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 510:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 511:quantum/quantum.c ****             break;
 512:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 513:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 514:quantum/quantum.c ****             break;
 515:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 516:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 517:quantum/quantum.c ****             break;
 518:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 519:quantum/quantum.c ****             keymap_config.no_gui = false;
 520:quantum/quantum.c ****             break;
 521:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 522:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 523:quantum/quantum.c ****             break;
 524:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 525:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 526:quantum/quantum.c ****             break;
 527:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 528:quantum/quantum.c ****             keymap_config.nkro = false;
 529:quantum/quantum.c ****             break;
 530:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 531:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 532:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 533:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 534:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 535:quantum/quantum.c ****             #endif
 536:quantum/quantum.c ****             break;
 537:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 538:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 539:quantum/quantum.c ****             break;
 540:quantum/quantum.c ****           default:
 541:quantum/quantum.c ****             break;
 542:quantum/quantum.c ****         }
 543:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 544:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 545:quantum/quantum.c **** 
 546:quantum/quantum.c ****         return false;
 547:quantum/quantum.c ****       }
 548:quantum/quantum.c ****       break;
 549:quantum/quantum.c ****     case KC_LSPO: {
 550:quantum/quantum.c ****       if (record->event.pressed) {
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 554:quantum/quantum.c ****       }
 555:quantum/quantum.c ****       else {
 556:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 557:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 558:quantum/quantum.c ****             shift_interrupted[0] = true;
 559:quantum/quantum.c ****             shift_interrupted[1] = true;
 560:quantum/quantum.c ****           }
 561:quantum/quantum.c ****         #endif
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 565:quantum/quantum.c ****         }
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 567:quantum/quantum.c ****       }
 568:quantum/quantum.c ****       return false;
 569:quantum/quantum.c ****     }
 570:quantum/quantum.c **** 
 571:quantum/quantum.c ****     case KC_RSPC: {
 572:quantum/quantum.c ****       if (record->event.pressed) {
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 576:quantum/quantum.c ****       }
 577:quantum/quantum.c ****       else {
 578:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 579:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 580:quantum/quantum.c ****             shift_interrupted[0] = true;
 581:quantum/quantum.c ****             shift_interrupted[1] = true;
 582:quantum/quantum.c ****           }
 583:quantum/quantum.c ****         #endif
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 587:quantum/quantum.c ****         }
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 589:quantum/quantum.c ****       }
 590:quantum/quantum.c ****       return false;
 591:quantum/quantum.c ****     }
 592:quantum/quantum.c **** 
 593:quantum/quantum.c ****     case KC_SFTENT: {
 594:quantum/quantum.c ****       if (record->event.pressed) {
 595:quantum/quantum.c ****         shift_interrupted[1] = false;
 596:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 597:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 598:quantum/quantum.c ****       }
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 603:quantum/quantum.c ****       }
 604:quantum/quantum.c ****       else {
 605:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 606:quantum/quantum.c ****       }
 607:quantum/quantum.c ****       return false;
 608:quantum/quantum.c ****     }
 609:quantum/quantum.c **** 
 610:quantum/quantum.c ****     case GRAVE_ESC: {
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 700               		.loc 1 611 0
 701 0086 0E94 0000 		call get_mods
 702               	.LVL56:
 703 008a 982F      		mov r25,r24
 704               	.LVL57:
 612:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 613:quantum/quantum.c **** 
 614:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 615:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 616:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 617:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 618:quantum/quantum.c ****         shifted = 0;
 619:quantum/quantum.c ****       }
 620:quantum/quantum.c **** #endif
 621:quantum/quantum.c **** 
 622:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 623:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 624:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 625:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 626:quantum/quantum.c ****         shifted = 0;
 627:quantum/quantum.c ****       }
 628:quantum/quantum.c **** #endif
 629:quantum/quantum.c **** 
 630:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 631:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 632:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 633:quantum/quantum.c ****         shifted = 0;
 634:quantum/quantum.c ****       }
 635:quantum/quantum.c **** #endif
 636:quantum/quantum.c **** 
 637:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 638:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 639:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 640:quantum/quantum.c ****         shifted = 0;
 641:quantum/quantum.c ****       }
 642:quantum/quantum.c **** #endif
 643:quantum/quantum.c **** 
 644:quantum/quantum.c ****       if (record->event.pressed) {
 705               		.loc 1 644 0
 706 008c F801      		movw r30,r16
 707 008e 8281      		ldd r24,Z+2
 708               	.LVL58:
 709 0090 2091 0000 		lds r18,keyboard_report
 710 0094 3091 0000 		lds r19,keyboard_report+1
 711 0098 8823      		tst r24
 712 009a 01F0      		breq .L101
 611:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 713               		.loc 1 611 0
 714 009c 9A7A      		andi r25,lo8(-86)
 715               	.LVL59:
 645:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 716               		.loc 1 645 0
 717 009e 81E0      		ldi r24,lo8(1)
 718 00a0 01F4      		brne .L102
 719 00a2 80E0      		ldi r24,0
 720               	.L102:
 721 00a4 8093 0000 		sts grave_esc_was_shifted,r24
 646:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 722               		.loc 1 646 0
 723 00a8 9111      		cpse r25,__zero_reg__
 724 00aa 00C0      		rjmp .L109
 725 00ac 69E2      		ldi r22,lo8(41)
 726 00ae 00C0      		rjmp .L103
 727               	.L109:
 728 00b0 65E3      		ldi r22,lo8(53)
 729               	.L103:
 730               	.LVL60:
 731               	.LBB32:
 732               	.LBB33:
 733               		.file 3 "./tmk_core/common/action_util.h"
   1:./tmk_core/common/action_util.h **** /*
   2:./tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action_util.h **** 
   4:./tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action_util.h **** (at your option) any later version.
   8:./tmk_core/common/action_util.h **** 
   9:./tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:./tmk_core/common/action_util.h **** 
  14:./tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action_util.h **** */
  17:./tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:./tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:./tmk_core/common/action_util.h **** 
  20:./tmk_core/common/action_util.h **** #include <stdint.h>
  21:./tmk_core/common/action_util.h **** #include "report.h"
  22:./tmk_core/common/action_util.h **** 
  23:./tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:./tmk_core/common/action_util.h **** extern "C" {
  25:./tmk_core/common/action_util.h **** #endif
  26:./tmk_core/common/action_util.h **** 
  27:./tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:./tmk_core/common/action_util.h **** 
  29:./tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:./tmk_core/common/action_util.h **** 
  31:./tmk_core/common/action_util.h **** /* key */
  32:./tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 734               		.loc 3 33 0 discriminator 4
 735 00b2 C901      		movw r24,r18
 736 00b4 0E94 0000 		call add_key_to_report
 737               	.LVL61:
 738 00b8 00C0      		rjmp .L104
 739               	.LVL62:
 740               	.L101:
 741               	.LBE33:
 742               	.LBE32:
 647:quantum/quantum.c ****       }
 648:quantum/quantum.c ****       else {
 649:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 743               		.loc 1 649 0
 744 00ba 8091 0000 		lds r24,grave_esc_was_shifted
 745 00be 8111      		cpse r24,__zero_reg__
 746 00c0 00C0      		rjmp .L110
 747 00c2 69E2      		ldi r22,lo8(41)
 748 00c4 00C0      		rjmp .L105
 749               	.L110:
 750 00c6 65E3      		ldi r22,lo8(53)
 751               	.L105:
 752               	.LVL63:
 753               	.LBB34:
 754               	.LBB35:
  34:./tmk_core/common/action_util.h **** }
  35:./tmk_core/common/action_util.h **** 
  36:./tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:./tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 755               		.loc 3 37 0 discriminator 4
 756 00c8 C901      		movw r24,r18
 757 00ca 0E94 0000 		call del_key_from_report
 758               	.LVL64:
 759               	.L104:
 760               	.LBE35:
 761               	.LBE34:
 650:quantum/quantum.c ****       }
 651:quantum/quantum.c **** 
 652:quantum/quantum.c ****       send_keyboard_report();
 762               		.loc 1 652 0
 763 00ce 0E94 0000 		call send_keyboard_report
 764               	.LVL65:
 653:quantum/quantum.c ****       return false;
 765               		.loc 1 653 0
 766 00d2 00C0      		rjmp .L125
 767               	.L140:
 768               	.LBE31:
 284:quantum/quantum.c ****     case RESET:
 769               		.loc 1 284 0
 770 00d4 C631      		cpi r28,22
 771 00d6 8CE5      		ldi r24,92
 772 00d8 D807      		cpc r29,r24
 773 00da 00F0      		brlo .+2
 774 00dc 00C0      		rjmp .L107
 775 00de C130      		cpi r28,1
 776 00e0 ECE5      		ldi r30,92
 777 00e2 DE07      		cpc r29,r30
 778 00e4 01F4      		brne .L141
 291:quantum/quantum.c ****           debug_enable = true;
 779               		.loc 1 291 0
 780 00e6 F801      		movw r30,r16
 781 00e8 8281      		ldd r24,Z+2
 782 00ea 8823      		tst r24
 783 00ec 01F4      		brne .+2
 784 00ee 00C0      		rjmp .L125
 292:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 785               		.loc 1 292 0
 786 00f0 8091 0000 		lds r24,debug_config
 787 00f4 8160      		ori r24,lo8(1<<0)
 788 00f6 8093 0000 		sts debug_config,r24
 789 00fa 00C0      		rjmp .L125
 790               	.L141:
 284:quantum/quantum.c ****     case RESET:
 791               		.loc 1 284 0
 792 00fc C230      		cpi r28,2
 793 00fe FCE5      		ldi r31,92
 794 0100 DF07      		cpc r29,r31
 795 0102 00F4      		brsh .+2
 796 0104 00C0      		rjmp .L142
 466:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 797               		.loc 1 466 0
 798 0106 F801      		movw r30,r16
 799 0108 8281      		ldd r24,Z+2
 800 010a 8823      		tst r24
 801 010c 01F4      		brne .+2
 802 010e 00C0      		rjmp .L65
 468:quantum/quantum.c ****             eeconfig_init();
 803               		.loc 1 468 0
 804 0110 0E94 0000 		call eeconfig_is_enabled
 805               	.LVL66:
 806 0114 8111      		cpse r24,__zero_reg__
 807 0116 00C0      		rjmp .L66
 469:quantum/quantum.c ****         }
 808               		.loc 1 469 0
 809 0118 0E94 0000 		call eeconfig_init
 810               	.LVL67:
 811               	.L66:
 472:quantum/quantum.c ****         switch (keycode)
 812               		.loc 1 472 0
 813 011c 0E94 0000 		call eeconfig_read_keymap
 814               	.LVL68:
 815 0120 90E0      		ldi r25,0
 816 0122 9093 0000 		sts keymap_config+1,r25
 817 0126 8093 0000 		sts keymap_config,r24
 473:quantum/quantum.c ****         {
 818               		.loc 1 473 0
 819 012a FE01      		movw r30,r28
 820 012c E350      		subi r30,3
 821 012e FC45      		sbci r31,92
 822 0130 E231      		cpi r30,18
 823 0132 F105      		cpc r31,__zero_reg__
 824 0134 00F4      		brsh .L67
 825 0136 E050      		subi r30,lo8(-(gs(.L69)))
 826 0138 F040      		sbci r31,hi8(-(gs(.L69)))
 538:quantum/quantum.c ****             break;
 827               		.loc 1 538 0
 828 013a 8091 0000 		lds r24,keymap_config
 473:quantum/quantum.c ****         {
 829               		.loc 1 473 0
 830 013e 0C94 0000 		jmp __tablejump2__
 831               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 832               		.p2align	1
 833               	.L69:
 834 0000 0000      		.word gs(.L68)
 835 0002 0000      		.word gs(.L70)
 836 0004 0000      		.word gs(.L139)
 837 0006 0000      		.word gs(.L72)
 838 0008 0000      		.word gs(.L73)
 839 000a 0000      		.word gs(.L74)
 840 000c 0000      		.word gs(.L75)
 841 000e 0000      		.word gs(.L76)
 842 0010 0000      		.word gs(.L77)
 843 0012 0000      		.word gs(.L78)
 844 0014 0000      		.word gs(.L79)
 845 0016 0000      		.word gs(.L138)
 846 0018 0000      		.word gs(.L81)
 847 001a 0000      		.word gs(.L82)
 848 001c 0000      		.word gs(.L83)
 849 001e 0000      		.word gs(.L84)
 850 0020 0000      		.word gs(.L85)
 851 0022 0000      		.word gs(.L86)
 852               		.section	.text.process_record_quantum
 853               	.L67:
 476:quantum/quantum.c ****             break;
 854               		.loc 1 476 0
 855 0142 8091 0000 		lds r24,keymap_config
 856 0146 8160      		ori r24,lo8(1<<0)
 857 0148 00C0      		rjmp .L134
 858               	.L68:
 479:quantum/quantum.c ****             break;
 859               		.loc 1 479 0
 860 014a 8260      		ori r24,lo8(1<<1)
 861 014c 00C0      		rjmp .L134
 862               	.L70:
 482:quantum/quantum.c ****             break;
 863               		.loc 1 482 0
 864 014e 8460      		ori r24,lo8(1<<2)
 865 0150 00C0      		rjmp .L134
 866               	.L72:
 488:quantum/quantum.c ****             break;
 867               		.loc 1 488 0
 868 0152 8061      		ori r24,lo8(1<<4)
 869 0154 00C0      		rjmp .L134
 870               	.L73:
 491:quantum/quantum.c ****             break;
 871               		.loc 1 491 0
 872 0156 8062      		ori r24,lo8(1<<5)
 873 0158 00C0      		rjmp .L134
 874               	.L74:
 494:quantum/quantum.c ****             break;
 875               		.loc 1 494 0
 876 015a 8064      		ori r24,lo8(1<<6)
 877 015c 00C0      		rjmp .L134
 878               	.L75:
 497:quantum/quantum.c ****             break;
 879               		.loc 1 497 0
 880 015e 8068      		ori r24,lo8(1<<7)
 881 0160 00C0      		rjmp .L134
 882               	.L76:
 501:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 883               		.loc 1 501 0
 884 0162 8460      		ori r24,lo8(4)
 885               	.L139:
 886 0164 8860      		ori r24,lo8(1<<3)
 887 0166 00C0      		rjmp .L134
 888               	.L77:
 507:quantum/quantum.c ****             break;
 889               		.loc 1 507 0
 890 0168 8E7F      		andi r24,lo8(~(1<<0))
 891 016a 00C0      		rjmp .L134
 892               	.L78:
 510:quantum/quantum.c ****             break;
 893               		.loc 1 510 0
 894 016c 8D7F      		andi r24,lo8(~(1<<1))
 895 016e 00C0      		rjmp .L134
 896               	.L79:
 513:quantum/quantum.c ****             break;
 897               		.loc 1 513 0
 898 0170 8B7F      		andi r24,lo8(~(1<<2))
 899 0172 00C0      		rjmp .L134
 900               	.L81:
 519:quantum/quantum.c ****             break;
 901               		.loc 1 519 0
 902 0174 8F7E      		andi r24,lo8(~(1<<4))
 903 0176 00C0      		rjmp .L134
 904               	.L82:
 522:quantum/quantum.c ****             break;
 905               		.loc 1 522 0
 906 0178 8F7D      		andi r24,lo8(~(1<<5))
 907 017a 00C0      		rjmp .L134
 908               	.L83:
 525:quantum/quantum.c ****             break;
 909               		.loc 1 525 0
 910 017c 8F7B      		andi r24,lo8(~(1<<6))
 911 017e 00C0      		rjmp .L134
 912               	.L84:
 528:quantum/quantum.c ****             break;
 913               		.loc 1 528 0
 914 0180 8F77      		andi r24,lo8(~(1<<7))
 915 0182 00C0      		rjmp .L134
 916               	.L85:
 532:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 917               		.loc 1 532 0
 918 0184 8B7F      		andi r24,lo8(-5)
 919               	.L138:
 920 0186 877F      		andi r24,lo8(~(1<<3))
 921 0188 00C0      		rjmp .L134
 922               	.L86:
 538:quantum/quantum.c ****             break;
 923               		.loc 1 538 0
 924 018a 87FB      		bst r24,7
 925 018c 2227      		clr r18
 926 018e 20F9      		bld r18,0
 927 0190 91E0      		ldi r25,lo8(1)
 928 0192 9227      		eor r25,r18
 929 0194 90FB      		bst r25,0
 930 0196 87F9      		bld r24,7
 931               	.L134:
 932 0198 8093 0000 		sts keymap_config,r24
 543:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 933               		.loc 1 543 0
 934 019c 8091 0000 		lds r24,keymap_config
 935 01a0 0E94 0000 		call eeconfig_update_keymap
 936               	.LVL69:
 544:quantum/quantum.c **** 
 937               		.loc 1 544 0
 938 01a4 0E94 0000 		call clear_keyboard
 939               	.LVL70:
 546:quantum/quantum.c ****       }
 940               		.loc 1 546 0
 941 01a8 00C0      		rjmp .L125
 942               	.L142:
 284:quantum/quantum.c ****     case RESET:
 943               		.loc 1 284 0
 944 01aa C115      		cp r28,__zero_reg__
 945 01ac DC45      		sbci r29,92
 946 01ae 01F0      		breq .L58
 947               	.L106:
 654:quantum/quantum.c ****     }
 655:quantum/quantum.c **** 
 656:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 657:quantum/quantum.c ****     case BL_BRTG: {
 658:quantum/quantum.c ****       if (record->event.pressed)
 659:quantum/quantum.c ****         breathing_toggle();
 660:quantum/quantum.c ****       return false;
 661:quantum/quantum.c ****     }
 662:quantum/quantum.c **** #endif
 663:quantum/quantum.c **** 
 664:quantum/quantum.c ****     default: {
 665:quantum/quantum.c ****       shift_interrupted[0] = true;
 948               		.loc 1 665 0
 949 01b0 81E0      		ldi r24,lo8(1)
 950 01b2 8093 0000 		sts shift_interrupted,r24
 666:quantum/quantum.c ****       shift_interrupted[1] = true;
 951               		.loc 1 666 0
 952 01b6 8093 0000 		sts shift_interrupted+1,r24
 953               	.L65:
 667:quantum/quantum.c ****       break;
 668:quantum/quantum.c ****     }
 669:quantum/quantum.c ****   }
 670:quantum/quantum.c **** 
 671:quantum/quantum.c ****   return process_action_kb(record);
 954               		.loc 1 671 0
 955 01ba C801      		movw r24,r16
 956               	/* epilogue start */
 672:quantum/quantum.c **** }
 957               		.loc 1 672 0
 958 01bc DF91      		pop r29
 959 01be CF91      		pop r28
 960               	.LVL71:
 961 01c0 1F91      		pop r17
 962 01c2 0F91      		pop r16
 963               	.LVL72:
 964 01c4 FF90      		pop r15
 671:quantum/quantum.c **** }
 965               		.loc 1 671 0
 966 01c6 0C94 0000 		jmp process_action_kb
 967               	.LVL73:
 968               	.L58:
 286:quantum/quantum.c ****         reset_keyboard();
 969               		.loc 1 286 0
 970 01ca F801      		movw r30,r16
 971 01cc 8281      		ldd r24,Z+2
 972 01ce 8823      		tst r24
 973 01d0 01F4      		brne .+2
 974 01d2 00C0      		rjmp .L125
 287:quantum/quantum.c ****       }
 975               		.loc 1 287 0
 976 01d4 0E94 0000 		call reset_keyboard
 977               	.LVL74:
 978 01d8 00C0      		rjmp .L125
 979               	.L107:
 284:quantum/quantum.c ****     case RESET:
 980               		.loc 1 284 0
 981 01da C53D      		cpi r28,-43
 982 01dc ECE5      		ldi r30,92
 983 01de DE07      		cpc r29,r30
 984 01e0 01F4      		brne .L143
 594:quantum/quantum.c ****         shift_interrupted[1] = false;
 985               		.loc 1 594 0
 986 01e2 F801      		movw r30,r16
 987 01e4 8281      		ldd r24,Z+2
 988 01e6 8823      		tst r24
 989 01e8 01F0      		breq .L144
 990               	.L99:
 573:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 991               		.loc 1 573 0
 992 01ea 1092 0000 		sts shift_interrupted+1,__zero_reg__
 574:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 993               		.loc 1 574 0
 994 01ee 0E94 0000 		call timer_read
 995               	.LVL75:
 996 01f2 9093 0000 		sts scs_timer+2+1,r25
 997 01f6 8093 0000 		sts scs_timer+2,r24
 575:quantum/quantum.c ****       }
 998               		.loc 1 575 0
 999 01fa 80E2      		ldi r24,lo8(32)
 1000               	.L136:
 1001 01fc 0E94 0000 		call register_mods
 1002               	.LVL76:
 1003 0200 00C0      		rjmp .L125
 1004               	.L144:
 599:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1005               		.loc 1 599 0
 1006 0202 8091 0000 		lds r24,shift_interrupted+1
 1007 0206 8823      		tst r24
 1008 0208 01F0      		breq .L145
 1009               	.L96:
 588:quantum/quantum.c ****       }
 1010               		.loc 1 588 0
 1011 020a 80E2      		ldi r24,lo8(32)
 1012               	.L137:
 1013 020c 0E94 0000 		call unregister_mods
 1014               	.LVL77:
 1015 0210 00C0      		rjmp .L125
 1016               	.L145:
 599:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1017               		.loc 1 599 0 discriminator 1
 1018 0212 8091 0000 		lds r24,scs_timer+2
 1019 0216 9091 0000 		lds r25,scs_timer+2+1
 1020 021a 0E94 0000 		call timer_elapsed
 1021               	.LVL78:
 1022 021e 883C      		cpi r24,-56
 1023 0220 9105      		cpc r25,__zero_reg__
 1024 0222 00F4      		brsh .L96
 600:quantum/quantum.c ****         register_code(SFTENT_KEY);
 1025               		.loc 1 600 0
 1026 0224 80E2      		ldi r24,lo8(32)
 1027 0226 0E94 0000 		call unregister_mods
 1028               	.LVL79:
 601:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 1029               		.loc 1 601 0
 1030 022a 88E2      		ldi r24,lo8(40)
 1031 022c 0E94 0000 		call register_code
 1032               	.LVL80:
 602:quantum/quantum.c ****       }
 1033               		.loc 1 602 0
 1034 0230 88E2      		ldi r24,lo8(40)
 1035 0232 0E94 0000 		call unregister_code
 1036               	.LVL81:
 1037 0236 00C0      		rjmp .L125
 1038               	.L143:
 284:quantum/quantum.c ****     case RESET:
 1039               		.loc 1 284 0
 1040 0238 C63D      		cpi r28,-42
 1041 023a FCE5      		ldi r31,92
 1042 023c DF07      		cpc r29,r31
 1043 023e 00F0      		brlo .+2
 1044 0240 00C0      		rjmp .L108
 1045 0242 C33D      		cpi r28,-45
 1046 0244 8CE5      		ldi r24,92
 1047 0246 D807      		cpc r29,r24
 1048 0248 01F4      		brne .L146
 550:quantum/quantum.c ****         shift_interrupted[0] = false;
 1049               		.loc 1 550 0
 1050 024a F801      		movw r30,r16
 1051 024c 8281      		ldd r24,Z+2
 1052 024e 8823      		tst r24
 1053 0250 01F0      		breq .L89
 551:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 1054               		.loc 1 551 0
 1055 0252 1092 0000 		sts shift_interrupted,__zero_reg__
 552:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 1056               		.loc 1 552 0
 1057 0256 0E94 0000 		call timer_read
 1058               	.LVL82:
 1059 025a 9093 0000 		sts scs_timer+1,r25
 1060 025e 8093 0000 		sts scs_timer,r24
 553:quantum/quantum.c ****       }
 1061               		.loc 1 553 0
 1062 0262 82E0      		ldi r24,lo8(2)
 1063 0264 00C0      		rjmp .L136
 1064               	.L89:
 562:quantum/quantum.c ****           register_code(LSPO_KEY);
 1065               		.loc 1 562 0
 1066 0266 8091 0000 		lds r24,shift_interrupted
 1067 026a 8111      		cpse r24,__zero_reg__
 1068 026c 00C0      		rjmp .L91
 562:quantum/quantum.c ****           register_code(LSPO_KEY);
 1069               		.loc 1 562 0 is_stmt 0 discriminator 1
 1070 026e 8091 0000 		lds r24,scs_timer
 1071 0272 9091 0000 		lds r25,scs_timer+1
 1072 0276 0E94 0000 		call timer_elapsed
 1073               	.LVL83:
 1074 027a 883C      		cpi r24,-56
 1075 027c 9105      		cpc r25,__zero_reg__
 1076 027e 00F4      		brsh .L91
 563:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 1077               		.loc 1 563 0 is_stmt 1
 1078 0280 86E2      		ldi r24,lo8(38)
 1079 0282 0E94 0000 		call register_code
 1080               	.LVL84:
 564:quantum/quantum.c ****         }
 1081               		.loc 1 564 0
 1082 0286 86E2      		ldi r24,lo8(38)
 1083 0288 0E94 0000 		call unregister_code
 1084               	.LVL85:
 1085               	.L91:
 566:quantum/quantum.c ****       }
 1086               		.loc 1 566 0
 1087 028c 82E0      		ldi r24,lo8(2)
 1088 028e 00C0      		rjmp .L137
 1089               	.L146:
 284:quantum/quantum.c ****     case RESET:
 1090               		.loc 1 284 0
 1091 0290 C43D      		cpi r28,-44
 1092 0292 DC45      		sbci r29,92
 1093 0294 01F0      		breq .+2
 1094 0296 00C0      		rjmp .L106
 572:quantum/quantum.c ****         shift_interrupted[1] = false;
 1095               		.loc 1 572 0
 1096 0298 F801      		movw r30,r16
 1097 029a 8281      		ldd r24,Z+2
 1098 029c 8111      		cpse r24,__zero_reg__
 1099 029e 00C0      		rjmp .L99
 584:quantum/quantum.c ****           register_code(RSPC_KEY);
 1100               		.loc 1 584 0
 1101 02a0 8091 0000 		lds r24,shift_interrupted+1
 1102 02a4 8111      		cpse r24,__zero_reg__
 1103 02a6 00C0      		rjmp .L96
 584:quantum/quantum.c ****           register_code(RSPC_KEY);
 1104               		.loc 1 584 0 is_stmt 0 discriminator 1
 1105 02a8 8091 0000 		lds r24,scs_timer+2
 1106 02ac 9091 0000 		lds r25,scs_timer+2+1
 1107 02b0 0E94 0000 		call timer_elapsed
 1108               	.LVL86:
 1109 02b4 883C      		cpi r24,-56
 1110 02b6 9105      		cpc r25,__zero_reg__
 1111 02b8 00F0      		brlo .+2
 1112 02ba 00C0      		rjmp .L96
 585:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 1113               		.loc 1 585 0 is_stmt 1
 1114 02bc 87E2      		ldi r24,lo8(39)
 1115 02be 0E94 0000 		call register_code
 1116               	.LVL87:
 586:quantum/quantum.c ****         }
 1117               		.loc 1 586 0
 1118 02c2 87E2      		ldi r24,lo8(39)
 1119 02c4 0E94 0000 		call unregister_code
 1120               	.LVL88:
 1121 02c8 00C0      		rjmp .L96
 1122               	.L108:
 284:quantum/quantum.c ****     case RESET:
 1123               		.loc 1 284 0
 1124 02ca C83D      		cpi r28,-40
 1125 02cc FCE5      		ldi r31,92
 1126 02ce DF07      		cpc r29,r31
 1127 02d0 01F4      		brne .L147
 448:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 1128               		.loc 1 448 0
 1129 02d2 F801      		movw r30,r16
 1130 02d4 8281      		ldd r24,Z+2
 1131 02d6 8823      		tst r24
 1132 02d8 01F0      		breq .L125
 449:quantum/quantum.c ****       }
 1133               		.loc 1 449 0
 1134 02da 80E0      		ldi r24,0
 1135 02dc 00C0      		rjmp .L135
 1136               	.L147:
 284:quantum/quantum.c ****     case RESET:
 1137               		.loc 1 284 0
 1138 02de C93D      		cpi r28,-39
 1139 02e0 DC45      		sbci r29,92
 1140 02e2 01F0      		breq .+2
 1141 02e4 00C0      		rjmp .L106
 453:quantum/quantum.c ****         set_output(OUTPUT_USB);
 1142               		.loc 1 453 0
 1143 02e6 F801      		movw r30,r16
 1144 02e8 8281      		ldd r24,Z+2
 1145 02ea 8823      		tst r24
 1146 02ec 01F0      		breq .L125
 454:quantum/quantum.c ****       }
 1147               		.loc 1 454 0
 1148 02ee 82E0      		ldi r24,lo8(2)
 1149               	.L135:
 1150 02f0 0E94 0000 		call set_output
 1151               	.LVL89:
 1152               	.L125:
 1153               		.loc 1 672 0
 1154 02f4 80E0      		ldi r24,0
 1155               	/* epilogue start */
 1156 02f6 DF91      		pop r29
 1157 02f8 CF91      		pop r28
 1158               	.LVL90:
 1159 02fa 1F91      		pop r17
 1160 02fc 0F91      		pop r16
 1161               	.LVL91:
 1162 02fe FF90      		pop r15
 1163 0300 0895      		ret
 1164               		.cfi_endproc
 1165               	.LFE39:
 1167               		.section	.text.send_char,"ax",@progbits
 1168               	.global	send_char
 1170               	send_char:
 1171               	.LFB44:
 673:quantum/quantum.c **** 
 674:quantum/quantum.c **** __attribute__ ((weak))
 675:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 676:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 677:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 678:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 679:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 680:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 681:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 682:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 683:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 684:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 685:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 686:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 687:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 688:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 689:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 690:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 691:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 692:quantum/quantum.c **** };
 693:quantum/quantum.c **** 
 694:quantum/quantum.c **** __attribute__ ((weak))
 695:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 696:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 697:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 698:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 699:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 700:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 701:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 702:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 703:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 704:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 705:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 706:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 707:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 708:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 709:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 710:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 711:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 712:quantum/quantum.c **** };
 713:quantum/quantum.c **** 
 714:quantum/quantum.c **** void send_string(const char *str) {
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 716:quantum/quantum.c **** }
 717:quantum/quantum.c **** 
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 720:quantum/quantum.c **** }
 721:quantum/quantum.c **** 
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 723:quantum/quantum.c ****     while (1) {
 724:quantum/quantum.c ****         char ascii_code = *str;
 725:quantum/quantum.c ****         if (!ascii_code) break;
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 727:quantum/quantum.c ****           // tap
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 729:quantum/quantum.c ****           register_code(keycode);
 730:quantum/quantum.c ****           unregister_code(keycode);
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 732:quantum/quantum.c ****           // down
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 734:quantum/quantum.c ****           register_code(keycode);
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 736:quantum/quantum.c ****           // up
 737:quantum/quantum.c ****           uint8_t keycode = *(++str);
 738:quantum/quantum.c ****           unregister_code(keycode);
 739:quantum/quantum.c ****         } else {
 740:quantum/quantum.c ****           send_char(ascii_code);
 741:quantum/quantum.c ****         }
 742:quantum/quantum.c ****         ++str;
 743:quantum/quantum.c ****         // interval
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 745:quantum/quantum.c ****     }
 746:quantum/quantum.c **** }
 747:quantum/quantum.c **** 
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 749:quantum/quantum.c ****     while (1) {
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 751:quantum/quantum.c ****         if (!ascii_code) break;
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 753:quantum/quantum.c ****           // tap
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 755:quantum/quantum.c ****           register_code(keycode);
 756:quantum/quantum.c ****           unregister_code(keycode);
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 758:quantum/quantum.c ****           // down
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 760:quantum/quantum.c ****           register_code(keycode);
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 762:quantum/quantum.c ****           // up
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 764:quantum/quantum.c ****           unregister_code(keycode);
 765:quantum/quantum.c ****         } else {
 766:quantum/quantum.c ****           send_char(ascii_code);
 767:quantum/quantum.c ****         }
 768:quantum/quantum.c ****         ++str;
 769:quantum/quantum.c ****         // interval
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 771:quantum/quantum.c ****     }
 772:quantum/quantum.c **** }
 773:quantum/quantum.c **** 
 774:quantum/quantum.c **** void send_char(char ascii_code) {
 1172               		.loc 1 774 0
 1173               		.cfi_startproc
 1174               	.LVL92:
 1175 0000 CF93      		push r28
 1176               	.LCFI13:
 1177               		.cfi_def_cfa_offset 3
 1178               		.cfi_offset 28, -2
 1179               	/* prologue: function */
 1180               	/* frame size = 0 */
 1181               	/* stack size = 1 */
 1182               	.L__stack_usage = 1
 1183               	.LBB36:
 775:quantum/quantum.c ****   uint8_t keycode;
 776:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 1184               		.loc 1 776 0
 1185 0002 90E0      		ldi r25,0
 1186               	.LVL93:
 1187 0004 FC01      		movw r30,r24
 1188 0006 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 1189 0008 F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 1190               	.LVL94:
 1191               	/* #APP */
 1192               	 ;  776 "quantum/quantum.c" 1
 1193 000a C491      		lpm r28, Z
 1194               		
 1195               	 ;  0 "" 2
 1196               	.LVL95:
 1197               	/* #NOAPP */
 1198               	.LBE36:
 1199               	.LBB37:
 777:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 1200               		.loc 1 777 0
 1201 000c FC01      		movw r30,r24
 1202               	.LVL96:
 1203 000e E050      		subi r30,lo8(-(ascii_to_shift_lut))
 1204 0010 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 1205               	.LVL97:
 1206               	/* #APP */
 1207               	 ;  777 "quantum/quantum.c" 1
 1208 0012 8491      		lpm r24, Z
 1209               		
 1210               	 ;  0 "" 2
 1211               	.LVL98:
 1212               	/* #NOAPP */
 1213               	.LBE37:
 1214 0014 8823      		tst r24
 1215 0016 01F0      		breq .L149
 778:quantum/quantum.c ****       register_code(KC_LSFT);
 1216               		.loc 1 778 0
 1217 0018 81EE      		ldi r24,lo8(-31)
 1218               	.LVL99:
 1219 001a 0E94 0000 		call register_code
 1220               	.LVL100:
 779:quantum/quantum.c ****       register_code(keycode);
 1221               		.loc 1 779 0
 1222 001e 8C2F      		mov r24,r28
 1223 0020 0E94 0000 		call register_code
 1224               	.LVL101:
 780:quantum/quantum.c ****       unregister_code(keycode);
 1225               		.loc 1 780 0
 1226 0024 8C2F      		mov r24,r28
 1227 0026 0E94 0000 		call unregister_code
 1228               	.LVL102:
 781:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1229               		.loc 1 781 0
 1230 002a 81EE      		ldi r24,lo8(-31)
 1231 002c 00C0      		rjmp .L150
 1232               	.LVL103:
 1233               	.L149:
 782:quantum/quantum.c ****   } else {
 783:quantum/quantum.c ****       register_code(keycode);
 1234               		.loc 1 783 0
 1235 002e 8C2F      		mov r24,r28
 1236               	.LVL104:
 1237 0030 0E94 0000 		call register_code
 1238               	.LVL105:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1239               		.loc 1 784 0
 1240 0034 8C2F      		mov r24,r28
 1241               	.L150:
 1242               	/* epilogue start */
 785:quantum/quantum.c ****   }
 786:quantum/quantum.c **** }
 1243               		.loc 1 786 0
 1244 0036 CF91      		pop r28
 1245               	.LVL106:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1246               		.loc 1 784 0
 1247 0038 0C94 0000 		jmp unregister_code
 1248               	.LVL107:
 1249               		.cfi_endproc
 1250               	.LFE44:
 1252               		.section	.text.send_string_with_delay,"ax",@progbits
 1253               	.global	send_string_with_delay
 1255               	send_string_with_delay:
 1256               	.LFB42:
 722:quantum/quantum.c ****     while (1) {
 1257               		.loc 1 722 0
 1258               		.cfi_startproc
 1259               	.LVL108:
 1260 0000 FF92      		push r15
 1261               	.LCFI14:
 1262               		.cfi_def_cfa_offset 3
 1263               		.cfi_offset 15, -2
 1264 0002 0F93      		push r16
 1265               	.LCFI15:
 1266               		.cfi_def_cfa_offset 4
 1267               		.cfi_offset 16, -3
 1268 0004 1F93      		push r17
 1269               	.LCFI16:
 1270               		.cfi_def_cfa_offset 5
 1271               		.cfi_offset 17, -4
 1272 0006 CF93      		push r28
 1273               	.LCFI17:
 1274               		.cfi_def_cfa_offset 6
 1275               		.cfi_offset 28, -5
 1276 0008 DF93      		push r29
 1277               	.LCFI18:
 1278               		.cfi_def_cfa_offset 7
 1279               		.cfi_offset 29, -6
 1280               	/* prologue: function */
 1281               	/* frame size = 0 */
 1282               	/* stack size = 5 */
 1283               	.L__stack_usage = 5
 1284 000a EC01      		movw r28,r24
 1285 000c F62E      		mov r15,r22
 1286               	.LVL109:
 1287               	.L159:
 1288               	.LBB38:
 724:quantum/quantum.c ****         if (!ascii_code) break;
 1289               		.loc 1 724 0
 1290 000e 8881      		ld r24,Y
 1291               	.LVL110:
 725:quantum/quantum.c ****         if (ascii_code == 1) {
 1292               		.loc 1 725 0
 1293 0010 8823      		tst r24
 1294 0012 01F0      		breq .L151
 1295 0014 8E01      		movw r16,r28
 1296 0016 0F5F      		subi r16,-1
 1297 0018 1F4F      		sbci r17,-1
 726:quantum/quantum.c ****           // tap
 1298               		.loc 1 726 0
 1299 001a 8130      		cpi r24,lo8(1)
 1300 001c 01F4      		brne .L153
 1301               	.LVL111:
 1302               	.LBB39:
 728:quantum/quantum.c ****           register_code(keycode);
 1303               		.loc 1 728 0
 1304 001e C981      		ldd r28,Y+1
 1305               	.LVL112:
 729:quantum/quantum.c ****           unregister_code(keycode);
 1306               		.loc 1 729 0
 1307 0020 8C2F      		mov r24,r28
 1308               	.LVL113:
 1309 0022 0E94 0000 		call register_code
 1310               	.LVL114:
 730:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1311               		.loc 1 730 0
 1312 0026 8C2F      		mov r24,r28
 1313 0028 00C0      		rjmp .L161
 1314               	.LVL115:
 1315               	.L153:
 1316               	.LBE39:
 731:quantum/quantum.c ****           // down
 1317               		.loc 1 731 0
 1318 002a 8230      		cpi r24,lo8(2)
 1319 002c 01F4      		brne .L155
 1320               	.LVL116:
 1321               	.LBB40:
 734:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1322               		.loc 1 734 0
 1323 002e 8981      		ldd r24,Y+1
 1324               	.LVL117:
 1325 0030 0E94 0000 		call register_code
 1326               	.LVL118:
 1327               	.L160:
 733:quantum/quantum.c ****           register_code(keycode);
 1328               		.loc 1 733 0
 1329 0034 E801      		movw r28,r16
 1330               	.LBE40:
 1331 0036 00C0      		rjmp .L154
 1332               	.LVL119:
 1333               	.L155:
 735:quantum/quantum.c ****           // up
 1334               		.loc 1 735 0
 1335 0038 8330      		cpi r24,lo8(3)
 1336 003a 01F4      		brne .L156
 1337               	.LVL120:
 1338               	.LBB41:
 738:quantum/quantum.c ****         } else {
 1339               		.loc 1 738 0
 1340 003c 8981      		ldd r24,Y+1
 1341               	.LVL121:
 1342               	.L161:
 1343 003e 0E94 0000 		call unregister_code
 1344               	.LVL122:
 1345 0042 00C0      		rjmp .L160
 1346               	.LVL123:
 1347               	.L156:
 1348               	.LBE41:
 740:quantum/quantum.c ****         }
 1349               		.loc 1 740 0
 1350 0044 0E94 0000 		call send_char
 1351               	.LVL124:
 1352               	.L154:
 742:quantum/quantum.c ****         // interval
 1353               		.loc 1 742 0
 1354 0048 2196      		adiw r28,1
 1355               	.LVL125:
 1356               	.LBB42:
 744:quantum/quantum.c ****     }
 1357               		.loc 1 744 0
 1358 004a 8F2D      		mov r24,r15
 1359               	.LVL126:
 1360               	.L157:
 744:quantum/quantum.c ****     }
 1361               		.loc 1 744 0 is_stmt 0 discriminator 1
 1362 004c 8823      		tst r24
 1363 004e 01F0      		breq .L159
 1364               	.LVL127:
 1365               	.LBB43:
 1366               	.LBB44:
 1367               		.loc 2 187 0 is_stmt 1
 1368 0050 EFE9      		ldi r30,lo8(3999)
 1369 0052 FFE0      		ldi r31,hi8(3999)
 1370 0054 3197      	1:	sbiw r30,1
 1371 0056 01F4      		brne 1b
 1372 0058 00C0      		rjmp .
 1373 005a 0000      		nop
 1374 005c 8150      		subi r24,lo8(-(-1))
 1375               	.LVL128:
 1376 005e 00C0      		rjmp .L157
 1377               	.LVL129:
 1378               	.L151:
 1379               	/* epilogue start */
 1380               	.LBE44:
 1381               	.LBE43:
 1382               	.LBE42:
 1383               	.LBE38:
 746:quantum/quantum.c **** 
 1384               		.loc 1 746 0
 1385 0060 DF91      		pop r29
 1386 0062 CF91      		pop r28
 1387               	.LVL130:
 1388 0064 1F91      		pop r17
 1389 0066 0F91      		pop r16
 1390 0068 FF90      		pop r15
 1391               	.LVL131:
 1392 006a 0895      		ret
 1393               		.cfi_endproc
 1394               	.LFE42:
 1396               		.section	.text.send_string,"ax",@progbits
 1397               	.global	send_string
 1399               	send_string:
 1400               	.LFB40:
 714:quantum/quantum.c ****   send_string_with_delay(str, 0);
 1401               		.loc 1 714 0
 1402               		.cfi_startproc
 1403               	.LVL132:
 1404               	/* prologue: function */
 1405               	/* frame size = 0 */
 1406               	/* stack size = 0 */
 1407               	.L__stack_usage = 0
 715:quantum/quantum.c **** }
 1408               		.loc 1 715 0
 1409 0000 60E0      		ldi r22,0
 1410 0002 0C94 0000 		jmp send_string_with_delay
 1411               	.LVL133:
 1412               		.cfi_endproc
 1413               	.LFE40:
 1415               		.section	.text.send_string_with_delay_P,"ax",@progbits
 1416               	.global	send_string_with_delay_P
 1418               	send_string_with_delay_P:
 1419               	.LFB43:
 748:quantum/quantum.c ****     while (1) {
 1420               		.loc 1 748 0
 1421               		.cfi_startproc
 1422               	.LVL134:
 1423 0000 0F93      		push r16
 1424               	.LCFI19:
 1425               		.cfi_def_cfa_offset 3
 1426               		.cfi_offset 16, -2
 1427 0002 1F93      		push r17
 1428               	.LCFI20:
 1429               		.cfi_def_cfa_offset 4
 1430               		.cfi_offset 17, -3
 1431 0004 CF93      		push r28
 1432               	.LCFI21:
 1433               		.cfi_def_cfa_offset 5
 1434               		.cfi_offset 28, -4
 1435 0006 DF93      		push r29
 1436               	.LCFI22:
 1437               		.cfi_def_cfa_offset 6
 1438               		.cfi_offset 29, -5
 1439               	/* prologue: function */
 1440               	/* frame size = 0 */
 1441               	/* stack size = 4 */
 1442               	.L__stack_usage = 4
 1443 0008 EC01      		movw r28,r24
 1444 000a 062F      		mov r16,r22
 1445               	.LVL135:
 1446               	.L171:
 1447               	.LBB45:
 1448               	.LBB46:
 750:quantum/quantum.c ****         if (!ascii_code) break;
 1449               		.loc 1 750 0
 1450 000c FE01      		movw r30,r28
 1451               	/* #APP */
 1452               	 ;  750 "quantum/quantum.c" 1
 1453 000e 8491      		lpm r24, Z
 1454               		
 1455               	 ;  0 "" 2
 1456               	.LVL136:
 1457               	/* #NOAPP */
 1458               	.LBE46:
 751:quantum/quantum.c ****         if (ascii_code == 1) {
 1459               		.loc 1 751 0
 1460 0010 8823      		tst r24
 1461 0012 01F0      		breq .L163
 1462 0014 9E01      		movw r18,r28
 1463 0016 2F5F      		subi r18,-1
 1464 0018 3F4F      		sbci r19,-1
 752:quantum/quantum.c ****           // tap
 1465               		.loc 1 752 0
 1466 001a 8130      		cpi r24,lo8(1)
 1467 001c 01F4      		brne .L165
 1468               	.LBB47:
 1469               	.LBB48:
 754:quantum/quantum.c ****           register_code(keycode);
 1470               		.loc 1 754 0
 1471 001e E901      		movw r28,r18
 1472               	.LVL137:
 1473 0020 F901      		movw r30,r18
 1474               	.LVL138:
 1475               	/* #APP */
 1476               	 ;  754 "quantum/quantum.c" 1
 1477 0022 1491      		lpm r17, Z
 1478               		
 1479               	 ;  0 "" 2
 1480               	.LVL139:
 1481               	/* #NOAPP */
 1482               	.LBE48:
 755:quantum/quantum.c ****           unregister_code(keycode);
 1483               		.loc 1 755 0
 1484 0024 812F      		mov r24,r17
 1485               	.LVL140:
 1486 0026 0E94 0000 		call register_code
 1487               	.LVL141:
 756:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1488               		.loc 1 756 0
 1489 002a 812F      		mov r24,r17
 1490 002c 00C0      		rjmp .L172
 1491               	.LVL142:
 1492               	.L165:
 1493               	.LBE47:
 757:quantum/quantum.c ****           // down
 1494               		.loc 1 757 0
 1495 002e 8230      		cpi r24,lo8(2)
 1496 0030 01F4      		brne .L167
 1497               	.LBB49:
 1498               	.LBB50:
 759:quantum/quantum.c ****           register_code(keycode);
 1499               		.loc 1 759 0
 1500 0032 E901      		movw r28,r18
 1501               	.LVL143:
 1502 0034 F901      		movw r30,r18
 1503               	.LVL144:
 1504               	/* #APP */
 1505               	 ;  759 "quantum/quantum.c" 1
 1506 0036 8491      		lpm r24, Z
 1507               		
 1508               	 ;  0 "" 2
 1509               	.LVL145:
 1510               	/* #NOAPP */
 1511               	.LBE50:
 760:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1512               		.loc 1 760 0
 1513 0038 0E94 0000 		call register_code
 1514               	.LVL146:
 1515               	.LBE49:
 1516 003c 00C0      		rjmp .L166
 1517               	.LVL147:
 1518               	.L167:
 761:quantum/quantum.c ****           // up
 1519               		.loc 1 761 0
 1520 003e 8330      		cpi r24,lo8(3)
 1521 0040 01F4      		brne .L168
 1522               	.LBB51:
 1523               	.LBB52:
 763:quantum/quantum.c ****           unregister_code(keycode);
 1524               		.loc 1 763 0
 1525 0042 E901      		movw r28,r18
 1526               	.LVL148:
 1527 0044 F901      		movw r30,r18
 1528               	.LVL149:
 1529               	/* #APP */
 1530               	 ;  763 "quantum/quantum.c" 1
 1531 0046 8491      		lpm r24, Z
 1532               		
 1533               	 ;  0 "" 2
 1534               	.LVL150:
 1535               	/* #NOAPP */
 1536               	.L172:
 1537               	.LBE52:
 764:quantum/quantum.c ****         } else {
 1538               		.loc 1 764 0
 1539 0048 0E94 0000 		call unregister_code
 1540               	.LVL151:
 1541               	.LBE51:
 1542 004c 00C0      		rjmp .L166
 1543               	.LVL152:
 1544               	.L168:
 766:quantum/quantum.c ****         }
 1545               		.loc 1 766 0
 1546 004e 0E94 0000 		call send_char
 1547               	.LVL153:
 1548               	.L166:
 768:quantum/quantum.c ****         // interval
 1549               		.loc 1 768 0
 1550 0052 2196      		adiw r28,1
 1551               	.LVL154:
 1552               	.LBB53:
 770:quantum/quantum.c ****     }
 1553               		.loc 1 770 0
 1554 0054 802F      		mov r24,r16
 1555               	.LVL155:
 1556               	.L169:
 770:quantum/quantum.c ****     }
 1557               		.loc 1 770 0 is_stmt 0 discriminator 1
 1558 0056 8823      		tst r24
 1559 0058 01F0      		breq .L171
 1560               	.LVL156:
 1561               	.LBB54:
 1562               	.LBB55:
 1563               		.loc 2 187 0 is_stmt 1
 1564 005a EFE9      		ldi r30,lo8(3999)
 1565 005c FFE0      		ldi r31,hi8(3999)
 1566 005e 3197      	1:	sbiw r30,1
 1567 0060 01F4      		brne 1b
 1568 0062 00C0      		rjmp .
 1569 0064 0000      		nop
 1570 0066 8150      		subi r24,lo8(-(-1))
 1571               	.LVL157:
 1572 0068 00C0      		rjmp .L169
 1573               	.LVL158:
 1574               	.L163:
 1575               	/* epilogue start */
 1576               	.LBE55:
 1577               	.LBE54:
 1578               	.LBE53:
 1579               	.LBE45:
 772:quantum/quantum.c **** 
 1580               		.loc 1 772 0
 1581 006a DF91      		pop r29
 1582 006c CF91      		pop r28
 1583               	.LVL159:
 1584 006e 1F91      		pop r17
 1585 0070 0F91      		pop r16
 1586               	.LVL160:
 1587 0072 0895      		ret
 1588               		.cfi_endproc
 1589               	.LFE43:
 1591               		.section	.text.send_string_P,"ax",@progbits
 1592               	.global	send_string_P
 1594               	send_string_P:
 1595               	.LFB41:
 718:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1596               		.loc 1 718 0
 1597               		.cfi_startproc
 1598               	.LVL161:
 1599               	/* prologue: function */
 1600               	/* frame size = 0 */
 1601               	/* stack size = 0 */
 1602               	.L__stack_usage = 0
 719:quantum/quantum.c **** }
 1603               		.loc 1 719 0
 1604 0000 60E0      		ldi r22,0
 1605 0002 0C94 0000 		jmp send_string_with_delay_P
 1606               	.LVL162:
 1607               		.cfi_endproc
 1608               	.LFE41:
 1610               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1611               	.global	set_single_persistent_default_layer
 1613               	set_single_persistent_default_layer:
 1614               	.LFB45:
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1615               		.loc 1 788 0
 1616               		.cfi_startproc
 1617               	.LVL163:
 1618 0000 CF93      		push r28
 1619               	.LCFI23:
 1620               		.cfi_def_cfa_offset 3
 1621               		.cfi_offset 28, -2
 1622 0002 DF93      		push r29
 1623               	.LCFI24:
 1624               		.cfi_def_cfa_offset 4
 1625               		.cfi_offset 29, -3
 1626               	/* prologue: function */
 1627               	/* frame size = 0 */
 1628               	/* stack size = 2 */
 1629               	.L__stack_usage = 2
 789:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 790:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 791:quantum/quantum.c ****   #endif
 792:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1630               		.loc 1 792 0
 1631 0004 61E0      		ldi r22,lo8(1)
 1632 0006 70E0      		ldi r23,0
 1633 0008 EB01      		movw r28,r22
 1634 000a 00C0      		rjmp 2f
 1635               		1:
 1636 000c CC0F      		lsl r28
 1637 000e DD1F      		rol r29
 1638               		2:
 1639 0010 8A95      		dec r24
 1640 0012 02F4      		brpl 1b
 1641 0014 8C2F      		mov r24,r28
 1642               	.LVL164:
 1643 0016 0E94 0000 		call eeconfig_update_default_layer
 1644               	.LVL165:
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1645               		.loc 1 793 0
 1646 001a BE01      		movw r22,r28
 1647 001c 80E0      		ldi r24,0
 1648 001e 90E0      		ldi r25,0
 1649               	/* epilogue start */
 794:quantum/quantum.c **** }
 1650               		.loc 1 794 0
 1651 0020 DF91      		pop r29
 1652 0022 CF91      		pop r28
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1653               		.loc 1 793 0
 1654 0024 0C94 0000 		jmp default_layer_set
 1655               	.LVL166:
 1656               		.cfi_endproc
 1657               	.LFE45:
 1659               		.section	.text.update_tri_layer_state,"ax",@progbits
 1660               	.global	update_tri_layer_state
 1662               	update_tri_layer_state:
 1663               	.LFB46:
 795:quantum/quantum.c **** 
 796:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1664               		.loc 1 796 0
 1665               		.cfi_startproc
 1666               	.LVL167:
 1667 0000 8F92      		push r8
 1668               	.LCFI25:
 1669               		.cfi_def_cfa_offset 3
 1670               		.cfi_offset 8, -2
 1671 0002 9F92      		push r9
 1672               	.LCFI26:
 1673               		.cfi_def_cfa_offset 4
 1674               		.cfi_offset 9, -3
 1675 0004 AF92      		push r10
 1676               	.LCFI27:
 1677               		.cfi_def_cfa_offset 5
 1678               		.cfi_offset 10, -4
 1679 0006 BF92      		push r11
 1680               	.LCFI28:
 1681               		.cfi_def_cfa_offset 6
 1682               		.cfi_offset 11, -5
 1683 0008 CF92      		push r12
 1684               	.LCFI29:
 1685               		.cfi_def_cfa_offset 7
 1686               		.cfi_offset 12, -6
 1687 000a DF92      		push r13
 1688               	.LCFI30:
 1689               		.cfi_def_cfa_offset 8
 1690               		.cfi_offset 13, -7
 1691 000c EF92      		push r14
 1692               	.LCFI31:
 1693               		.cfi_def_cfa_offset 9
 1694               		.cfi_offset 14, -8
 1695 000e FF92      		push r15
 1696               	.LCFI32:
 1697               		.cfi_def_cfa_offset 10
 1698               		.cfi_offset 15, -9
 1699 0010 0F93      		push r16
 1700               	.LCFI33:
 1701               		.cfi_def_cfa_offset 11
 1702               		.cfi_offset 16, -10
 1703 0012 1F93      		push r17
 1704               	.LCFI34:
 1705               		.cfi_def_cfa_offset 12
 1706               		.cfi_offset 17, -11
 1707               	/* prologue: function */
 1708               	/* frame size = 0 */
 1709               	/* stack size = 10 */
 1710               	.L__stack_usage = 10
 1711 0014 6B01      		movw r12,r22
 1712 0016 7C01      		movw r14,r24
 797:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 1713               		.loc 1 797 0
 1714 0018 81E0      		ldi r24,lo8(1)
 1715 001a 90E0      		ldi r25,0
 1716 001c A0E0      		ldi r26,0
 1717 001e B0E0      		ldi r27,0
 1718 0020 4C01      		movw r8,r24
 1719 0022 5D01      		movw r10,r26
 1720 0024 00C0      		rjmp 2f
 1721               		1:
 1722 0026 880C      		lsl r8
 1723 0028 991C      		rol r9
 1724 002a AA1C      		rol r10
 1725 002c BB1C      		rol r11
 1726               		2:
 1727 002e 4A95      		dec r20
 1728 0030 02F4      		brpl 1b
 1729 0032 AC01      		movw r20,r24
 1730 0034 BD01      		movw r22,r26
 1731               	.LVL168:
 1732 0036 00C0      		rjmp 2f
 1733               		1:
 1734 0038 440F      		lsl r20
 1735 003a 551F      		rol r21
 1736 003c 661F      		rol r22
 1737 003e 771F      		rol r23
 1738               		2:
 1739 0040 2A95      		dec r18
 1740 0042 02F4      		brpl 1b
 1741 0044 4829      		or r20,r8
 1742 0046 5929      		or r21,r9
 1743 0048 6A29      		or r22,r10
 1744 004a 7B29      		or r23,r11
 1745               	.LVL169:
 798:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 1746               		.loc 1 798 0
 1747 004c 00C0      		rjmp 2f
 1748               		1:
 1749 004e 880F      		lsl r24
 1750 0050 991F      		rol r25
 1751 0052 AA1F      		rol r26
 1752 0054 BB1F      		rol r27
 1753               		2:
 1754 0056 0A95      		dec r16
 1755 0058 02F4      		brpl 1b
 1756               	.LVL170:
 799:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1757               		.loc 1 799 0
 1758 005a 8A01      		movw r16,r20
 1759 005c 9B01      		movw r18,r22
 1760               	.LVL171:
 1761 005e 0C21      		and r16,r12
 1762 0060 1D21      		and r17,r13
 1763 0062 2E21      		and r18,r14
 1764 0064 3F21      		and r19,r15
 1765 0066 4017      		cp r20,r16
 1766 0068 5107      		cpc r21,r17
 1767 006a 6207      		cpc r22,r18
 1768 006c 7307      		cpc r23,r19
 1769 006e 01F4      		brne .L176
 1770               		.loc 1 799 0 is_stmt 0 discriminator 1
 1771 0070 BC01      		movw r22,r24
 1772 0072 CD01      		movw r24,r26
 1773               	.LVL172:
 1774 0074 6C29      		or r22,r12
 1775 0076 7D29      		or r23,r13
 1776 0078 8E29      		or r24,r14
 1777 007a 9F29      		or r25,r15
 1778 007c 00C0      		rjmp .L177
 1779               	.L176:
 1780               		.loc 1 799 0 discriminator 2
 1781 007e 8095      		com r24
 1782 0080 9095      		com r25
 1783 0082 A095      		com r26
 1784 0084 B095      		com r27
 1785               	.LVL173:
 1786 0086 BC01      		movw r22,r24
 1787 0088 CD01      		movw r24,r26
 1788 008a 6C21      		and r22,r12
 1789 008c 7D21      		and r23,r13
 1790 008e 8E21      		and r24,r14
 1791 0090 9F21      		and r25,r15
 1792               	.LVL174:
 1793               	.L177:
 1794               	/* epilogue start */
 800:quantum/quantum.c **** }
 1795               		.loc 1 800 0 is_stmt 1 discriminator 4
 1796 0092 1F91      		pop r17
 1797               	.LVL175:
 1798 0094 0F91      		pop r16
 1799               	.LVL176:
 1800 0096 FF90      		pop r15
 1801 0098 EF90      		pop r14
 1802 009a DF90      		pop r13
 1803 009c CF90      		pop r12
 1804               	.LVL177:
 1805 009e BF90      		pop r11
 1806 00a0 AF90      		pop r10
 1807 00a2 9F90      		pop r9
 1808 00a4 8F90      		pop r8
 1809               	.LVL178:
 1810 00a6 0895      		ret
 1811               		.cfi_endproc
 1812               	.LFE46:
 1814               		.section	.text.update_tri_layer,"ax",@progbits
 1815               	.global	update_tri_layer
 1817               	update_tri_layer:
 1818               	.LFB47:
 801:quantum/quantum.c **** 
 802:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1819               		.loc 1 802 0
 1820               		.cfi_startproc
 1821               	.LVL179:
 1822 0000 0F93      		push r16
 1823               	.LCFI35:
 1824               		.cfi_def_cfa_offset 3
 1825               		.cfi_offset 16, -2
 1826               	/* prologue: function */
 1827               	/* frame size = 0 */
 1828               	/* stack size = 1 */
 1829               	.L__stack_usage = 1
 1830 0002 382F      		mov r19,r24
 1831 0004 262F      		mov r18,r22
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1832               		.loc 1 803 0
 1833 0006 6091 0000 		lds r22,layer_state
 1834 000a 7091 0000 		lds r23,layer_state+1
 1835 000e 8091 0000 		lds r24,layer_state+2
 1836 0012 9091 0000 		lds r25,layer_state+3
 1837               	.LVL180:
 1838 0016 042F      		mov r16,r20
 1839 0018 432F      		mov r20,r19
 1840               	.LVL181:
 1841 001a 0E94 0000 		call update_tri_layer_state
 1842               	.LVL182:
 1843               	/* epilogue start */
 804:quantum/quantum.c **** }
 1844               		.loc 1 804 0
 1845 001e 0F91      		pop r16
 1846               	.LVL183:
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1847               		.loc 1 803 0
 1848 0020 0C94 0000 		jmp layer_state_set
 1849               	.LVL184:
 1850               		.cfi_endproc
 1851               	.LFE47:
 1853               		.section	.text.tap_random_base64,"ax",@progbits
 1854               	.global	tap_random_base64
 1856               	tap_random_base64:
 1857               	.LFB48:
 805:quantum/quantum.c **** 
 806:quantum/quantum.c **** void tap_random_base64(void) {
 1858               		.loc 1 806 0
 1859               		.cfi_startproc
 1860 0000 CF93      		push r28
 1861               	.LCFI36:
 1862               		.cfi_def_cfa_offset 3
 1863               		.cfi_offset 28, -2
 1864 0002 DF93      		push r29
 1865               	.LCFI37:
 1866               		.cfi_def_cfa_offset 4
 1867               		.cfi_offset 29, -3
 1868               	/* prologue: function */
 1869               	/* frame size = 0 */
 1870               	/* stack size = 2 */
 1871               	.L__stack_usage = 2
 807:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 808:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1872               		.loc 1 808 0
 1873 0004 26B5      		in r18,0x26
 1874 0006 C091 8400 		lds r28,132
 1875 000a D091 8500 		lds r29,132+1
 1876 000e 4091 9400 		lds r20,148
 1877 0012 5091 9500 		lds r21,148+1
 1878 0016 8091 BE00 		lds r24,190
 1879 001a 9091 BF00 		lds r25,190+1
 1880 001e C40F      		add r28,r20
 1881 0020 C20F      		add r28,r18
 1882 0022 8C0F      		add r24,r28
 1883 0024 C82F      		mov r28,r24
 1884 0026 CF73      		andi r28,lo8(63)
 1885               	.LVL185:
 809:quantum/quantum.c ****   #else
 810:quantum/quantum.c ****     uint8_t key = rand() % 64;
 811:quantum/quantum.c ****   #endif
 812:quantum/quantum.c ****   switch (key) {
 1886               		.loc 1 812 0
 1887 0028 CE33      		cpi r28,lo8(62)
 1888 002a 00F4      		brsh .L181
 1889 002c C533      		cpi r28,lo8(53)
 1890 002e 00F4      		brsh .L182
 1891 0030 CA31      		cpi r28,lo8(26)
 1892 0032 00F0      		brlo .L180
 1893 0034 C433      		cpi r28,lo8(52)
 1894 0036 00F4      		brsh .L187
 813:quantum/quantum.c ****     case 0 ... 25:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 815:quantum/quantum.c ****       register_code(key + KC_A);
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 817:quantum/quantum.c ****       unregister_code(KC_LSFT);
 818:quantum/quantum.c ****       break;
 819:quantum/quantum.c ****     case 26 ... 51:
 820:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 1895               		.loc 1 820 0
 1896 0038 C651      		subi r28,lo8(-(-22))
 1897               	.LVL186:
 1898 003a 00C0      		rjmp .L190
 1899               	.LVL187:
 1900               	.L181:
 812:quantum/quantum.c ****     case 0 ... 25:
 1901               		.loc 1 812 0
 1902 003c CE33      		cpi r28,lo8(62)
 1903 003e 01F0      		breq .L185
 1904 0040 CF33      		cpi r28,lo8(63)
 1905 0042 01F0      		breq .L186
 1906               	.L180:
 814:quantum/quantum.c ****       register_code(key + KC_A);
 1907               		.loc 1 814 0
 1908 0044 81EE      		ldi r24,lo8(-31)
 1909 0046 0E94 0000 		call register_code
 1910               	.LVL188:
 815:quantum/quantum.c ****       unregister_code(key + KC_A);
 1911               		.loc 1 815 0
 1912 004a CC5F      		subi r28,lo8(-(4))
 1913               	.LVL189:
 1914 004c 8C2F      		mov r24,r28
 1915 004e 0E94 0000 		call register_code
 1916               	.LVL190:
 816:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1917               		.loc 1 816 0
 1918 0052 8C2F      		mov r24,r28
 1919 0054 00C0      		rjmp .L189
 1920               	.LVL191:
 1921               	.L187:
 821:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 822:quantum/quantum.c ****       break;
 823:quantum/quantum.c ****     case 52:
 824:quantum/quantum.c ****       register_code(KC_0);
 1922               		.loc 1 824 0
 1923 0056 87E2      		ldi r24,lo8(39)
 1924 0058 0E94 0000 		call register_code
 1925               	.LVL192:
 825:quantum/quantum.c ****       unregister_code(KC_0);
 1926               		.loc 1 825 0
 1927 005c 87E2      		ldi r24,lo8(39)
 1928 005e 00C0      		rjmp .L188
 1929               	.L182:
 826:quantum/quantum.c ****       break;
 827:quantum/quantum.c ****     case 53 ... 61:
 828:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 1930               		.loc 1 828 0
 1931 0060 C751      		subi r28,lo8(-(-23))
 1932               	.LVL193:
 1933               	.L190:
 1934 0062 8C2F      		mov r24,r28
 1935               	.LVL194:
 1936 0064 0E94 0000 		call register_code
 1937               	.LVL195:
 829:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1938               		.loc 1 829 0
 1939 0068 8C2F      		mov r24,r28
 1940 006a 00C0      		rjmp .L188
 1941               	.LVL196:
 1942               	.L185:
 830:quantum/quantum.c ****       break;
 831:quantum/quantum.c ****     case 62:
 832:quantum/quantum.c ****       register_code(KC_LSFT);
 1943               		.loc 1 832 0
 1944 006c 81EE      		ldi r24,lo8(-31)
 1945 006e 0E94 0000 		call register_code
 1946               	.LVL197:
 833:quantum/quantum.c ****       register_code(KC_EQL);
 1947               		.loc 1 833 0
 1948 0072 8EE2      		ldi r24,lo8(46)
 1949 0074 0E94 0000 		call register_code
 1950               	.LVL198:
 834:quantum/quantum.c ****       unregister_code(KC_EQL);
 1951               		.loc 1 834 0
 1952 0078 8EE2      		ldi r24,lo8(46)
 1953               	.LVL199:
 1954               	.L189:
 1955 007a 0E94 0000 		call unregister_code
 1956               	.LVL200:
 835:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1957               		.loc 1 835 0
 1958 007e 81EE      		ldi r24,lo8(-31)
 1959 0080 00C0      		rjmp .L188
 1960               	.LVL201:
 1961               	.L186:
 836:quantum/quantum.c ****       break;
 837:quantum/quantum.c ****     case 63:
 838:quantum/quantum.c ****       register_code(KC_SLSH);
 1962               		.loc 1 838 0
 1963 0082 88E3      		ldi r24,lo8(56)
 1964 0084 0E94 0000 		call register_code
 1965               	.LVL202:
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1966               		.loc 1 839 0
 1967 0088 88E3      		ldi r24,lo8(56)
 1968               	.LVL203:
 1969               	.L188:
 1970               	/* epilogue start */
 840:quantum/quantum.c ****       break;
 841:quantum/quantum.c ****   }
 842:quantum/quantum.c **** }
 1971               		.loc 1 842 0
 1972 008a DF91      		pop r29
 1973 008c CF91      		pop r28
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1974               		.loc 1 839 0
 1975 008e 0C94 0000 		jmp unregister_code
 1976               	.LVL204:
 1977               		.cfi_endproc
 1978               	.LFE48:
 1980               		.section	.text.matrix_init_quantum,"ax",@progbits
 1981               	.global	matrix_init_quantum
 1983               	matrix_init_quantum:
 1984               	.LFB49:
 843:quantum/quantum.c **** 
 844:quantum/quantum.c **** void matrix_init_quantum() {
 1985               		.loc 1 844 0
 1986               		.cfi_startproc
 1987               	/* prologue: function */
 1988               	/* frame size = 0 */
 1989               	/* stack size = 0 */
 1990               	.L__stack_usage = 0
 845:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 846:quantum/quantum.c ****     backlight_init_ports();
 847:quantum/quantum.c ****   #endif
 848:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 849:quantum/quantum.c ****     audio_init();
 850:quantum/quantum.c ****   #endif
 851:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 852:quantum/quantum.c ****     rgb_matrix_init_drivers();
 853:quantum/quantum.c ****   #endif
 854:quantum/quantum.c ****   matrix_init_kb();
 1991               		.loc 1 854 0
 1992 0000 0C94 0000 		jmp matrix_init_kb
 1993               	.LVL205:
 1994               		.cfi_endproc
 1995               	.LFE49:
 1997               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1998               	.global	matrix_scan_quantum
 2000               	matrix_scan_quantum:
 2001               	.LFB50:
 855:quantum/quantum.c **** }
 856:quantum/quantum.c **** 
 857:quantum/quantum.c **** uint8_t rgb_matrix_task_counter = 0;
 858:quantum/quantum.c **** 
 859:quantum/quantum.c **** #ifndef RGB_MATRIX_SKIP_FRAMES
 860:quantum/quantum.c ****   #define RGB_MATRIX_SKIP_FRAMES 1
 861:quantum/quantum.c **** #endif
 862:quantum/quantum.c **** 
 863:quantum/quantum.c **** void matrix_scan_quantum() {
 2002               		.loc 1 863 0
 2003               		.cfi_startproc
 2004               	/* prologue: function */
 2005               	/* frame size = 0 */
 2006               	/* stack size = 0 */
 2007               	.L__stack_usage = 0
 864:quantum/quantum.c ****   #if defined(AUDIO_ENABLE)
 865:quantum/quantum.c ****     matrix_scan_music();
 866:quantum/quantum.c ****   #endif
 867:quantum/quantum.c **** 
 868:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 869:quantum/quantum.c ****     matrix_scan_tap_dance();
 2008               		.loc 1 869 0
 2009 0000 0E94 0000 		call matrix_scan_tap_dance
 2010               	.LVL206:
 870:quantum/quantum.c ****   #endif
 871:quantum/quantum.c **** 
 872:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 873:quantum/quantum.c ****     matrix_scan_combo();
 874:quantum/quantum.c ****   #endif
 875:quantum/quantum.c **** 
 876:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 877:quantum/quantum.c ****     backlight_task();
 878:quantum/quantum.c ****   #endif
 879:quantum/quantum.c **** 
 880:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 881:quantum/quantum.c ****     rgb_matrix_task();
 882:quantum/quantum.c ****     if (rgb_matrix_task_counter == 0) {
 883:quantum/quantum.c ****       rgb_matrix_update_pwm_buffers();
 884:quantum/quantum.c ****     }
 885:quantum/quantum.c ****     rgb_matrix_task_counter = ((rgb_matrix_task_counter + 1) % (RGB_MATRIX_SKIP_FRAMES + 1));
 886:quantum/quantum.c ****   #endif
 887:quantum/quantum.c **** 
 888:quantum/quantum.c ****   matrix_scan_kb();
 2011               		.loc 1 888 0
 2012 0004 0C94 0000 		jmp matrix_scan_kb
 2013               	.LVL207:
 2014               		.cfi_endproc
 2015               	.LFE50:
 2017               		.section	.text.backlight_init_ports,"ax",@progbits
 2018               		.weak	backlight_init_ports
 2020               	backlight_init_ports:
 2021               	.LFB70:
 2022               		.cfi_startproc
 2023               	/* prologue: function */
 2024               	/* frame size = 0 */
 2025               	/* stack size = 0 */
 2026               	.L__stack_usage = 0
 2027 0000 0895      		ret
 2028               		.cfi_endproc
 2029               	.LFE70:
 2031               		.section	.text.send_nibble,"ax",@progbits
 2032               	.global	send_nibble
 2034               	send_nibble:
 2035               	.LFB56:
 889:quantum/quantum.c **** }
 890:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 891:quantum/quantum.c **** 
 892:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 893:quantum/quantum.c **** 
 894:quantum/quantum.c **** // depending on the pin, we use a different output compare unit
 895:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 896:quantum/quantum.c **** #  define COM1x1 COM1C1
 897:quantum/quantum.c **** #  define OCR1x  OCR1C
 898:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 899:quantum/quantum.c **** #  define COM1x1 COM1B1
 900:quantum/quantum.c **** #  define OCR1x  OCR1B
 901:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 902:quantum/quantum.c **** #  define COM1x1 COM1A1
 903:quantum/quantum.c **** #  define OCR1x  OCR1A
 904:quantum/quantum.c **** #else
 905:quantum/quantum.c **** #  define NO_HARDWARE_PWM
 906:quantum/quantum.c **** #endif
 907:quantum/quantum.c **** 
 908:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
 909:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
 910:quantum/quantum.c **** #endif
 911:quantum/quantum.c **** 
 912:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM // pwm through software
 913:quantum/quantum.c **** 
 914:quantum/quantum.c **** __attribute__ ((weak))
 915:quantum/quantum.c **** void backlight_init_ports(void)
 916:quantum/quantum.c **** {
 917:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
 918:quantum/quantum.c ****   // DDRx |= n
 919:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 920:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
 921:quantum/quantum.c ****     // PORTx &= ~n
 922:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 923:quantum/quantum.c ****   #else
 924:quantum/quantum.c ****     // PORTx |= n
 925:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 926:quantum/quantum.c ****   #endif
 927:quantum/quantum.c **** }
 928:quantum/quantum.c **** 
 929:quantum/quantum.c **** __attribute__ ((weak))
 930:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 931:quantum/quantum.c **** 
 932:quantum/quantum.c **** uint8_t backlight_tick = 0;
 933:quantum/quantum.c **** 
 934:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 935:quantum/quantum.c **** void backlight_task(void) {
 936:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
 937:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 938:quantum/quantum.c ****       // PORTx &= ~n
 939:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 940:quantum/quantum.c ****     #else
 941:quantum/quantum.c ****       // PORTx |= n
 942:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 943:quantum/quantum.c ****     #endif
 944:quantum/quantum.c ****   } else {
 945:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 946:quantum/quantum.c ****       // PORTx |= n
 947:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 948:quantum/quantum.c ****     #else
 949:quantum/quantum.c ****       // PORTx &= ~n
 950:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 951:quantum/quantum.c ****     #endif
 952:quantum/quantum.c ****   }
 953:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
 954:quantum/quantum.c **** }
 955:quantum/quantum.c **** #endif
 956:quantum/quantum.c **** 
 957:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 958:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
 959:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
 960:quantum/quantum.c ****   #endif
 961:quantum/quantum.c **** #endif
 962:quantum/quantum.c **** 
 963:quantum/quantum.c **** #else // pwm through timer
 964:quantum/quantum.c **** 
 965:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
 966:quantum/quantum.c **** 
 967:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
 968:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
 969:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
 970:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 971:quantum/quantum.c ****   else {
 972:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
 973:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
 974:quantum/quantum.c ****     // and revert what we've done again after squaring.
 975:quantum/quantum.c ****     y = y * y * y >> 8;
 976:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 977:quantum/quantum.c ****       return 0xFFFFU;
 978:quantum/quantum.c ****     else
 979:quantum/quantum.c ****       return (uint16_t) y;
 980:quantum/quantum.c ****   }
 981:quantum/quantum.c **** }
 982:quantum/quantum.c **** 
 983:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
 984:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
 985:quantum/quantum.c ****   OCR1x = val;
 986:quantum/quantum.c **** }
 987:quantum/quantum.c **** 
 988:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 989:quantum/quantum.c **** __attribute__ ((weak))
 990:quantum/quantum.c **** void backlight_set(uint8_t level) {
 991:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
 992:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 993:quantum/quantum.c **** 
 994:quantum/quantum.c ****   if (level == 0) {
 995:quantum/quantum.c ****     // Turn off PWM control on backlight pin
 996:quantum/quantum.c ****     TCCR1A &= ~(_BV(COM1x1));
 997:quantum/quantum.c ****   } else {
 998:quantum/quantum.c ****     // Turn on PWM control of backlight pin
 999:quantum/quantum.c ****     TCCR1A |= _BV(COM1x1);
1000:quantum/quantum.c ****   }
1001:quantum/quantum.c ****   // Set the brightness
1002:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
1003:quantum/quantum.c **** }
1004:quantum/quantum.c **** 
1005:quantum/quantum.c **** void backlight_task(void) {}
1006:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1007:quantum/quantum.c **** 
1008:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1009:quantum/quantum.c **** 
1010:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1011:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1012:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1013:quantum/quantum.c **** #define BREATHING_STEPS 128
1014:quantum/quantum.c **** 
1015:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1016:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1017:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1018:quantum/quantum.c **** 
1019:quantum/quantum.c **** bool is_breathing(void) {
1020:quantum/quantum.c ****     return !!(TIMSK1 & _BV(TOIE1));
1021:quantum/quantum.c **** }
1022:quantum/quantum.c **** 
1023:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSK1 |= _BV(TOIE1);} while (0)
1024:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSK1 &= ~_BV(TOIE1);} while (0)
1025:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1026:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1027:quantum/quantum.c **** 
1028:quantum/quantum.c **** void breathing_enable(void)
1029:quantum/quantum.c **** {
1030:quantum/quantum.c ****   breathing_counter = 0;
1031:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1032:quantum/quantum.c ****   breathing_interrupt_enable();
1033:quantum/quantum.c **** }
1034:quantum/quantum.c **** 
1035:quantum/quantum.c **** void breathing_pulse(void)
1036:quantum/quantum.c **** {
1037:quantum/quantum.c ****     if (get_backlight_level() == 0)
1038:quantum/quantum.c ****       breathing_min();
1039:quantum/quantum.c ****     else
1040:quantum/quantum.c ****       breathing_max();
1041:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1042:quantum/quantum.c ****     breathing_interrupt_enable();
1043:quantum/quantum.c **** }
1044:quantum/quantum.c **** 
1045:quantum/quantum.c **** void breathing_disable(void)
1046:quantum/quantum.c **** {
1047:quantum/quantum.c ****     breathing_interrupt_disable();
1048:quantum/quantum.c ****     // Restore backlight level
1049:quantum/quantum.c ****     backlight_set(get_backlight_level());
1050:quantum/quantum.c **** }
1051:quantum/quantum.c **** 
1052:quantum/quantum.c **** void breathing_self_disable(void)
1053:quantum/quantum.c **** {
1054:quantum/quantum.c ****   if (get_backlight_level() == 0)
1055:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1056:quantum/quantum.c ****   else
1057:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1058:quantum/quantum.c **** }
1059:quantum/quantum.c **** 
1060:quantum/quantum.c **** void breathing_toggle(void) {
1061:quantum/quantum.c ****   if (is_breathing())
1062:quantum/quantum.c ****     breathing_disable();
1063:quantum/quantum.c ****   else
1064:quantum/quantum.c ****     breathing_enable();
1065:quantum/quantum.c **** }
1066:quantum/quantum.c **** 
1067:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1068:quantum/quantum.c **** {
1069:quantum/quantum.c ****   if (!value)
1070:quantum/quantum.c ****     value = 1;
1071:quantum/quantum.c ****   breathing_period = value;
1072:quantum/quantum.c **** }
1073:quantum/quantum.c **** 
1074:quantum/quantum.c **** void breathing_period_default(void) {
1075:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1076:quantum/quantum.c **** }
1077:quantum/quantum.c **** 
1078:quantum/quantum.c **** void breathing_period_inc(void)
1079:quantum/quantum.c **** {
1080:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1081:quantum/quantum.c **** }
1082:quantum/quantum.c **** 
1083:quantum/quantum.c **** void breathing_period_dec(void)
1084:quantum/quantum.c **** {
1085:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1086:quantum/quantum.c **** }
1087:quantum/quantum.c **** 
1088:quantum/quantum.c **** /* To generate breathing curve in python:
1089:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1090:quantum/quantum.c ****  */
1091:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1092:quantum/quantum.c **** 
1093:quantum/quantum.c **** // Use this before the cie_lightness function.
1094:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1095:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1096:quantum/quantum.c **** }
1097:quantum/quantum.c **** 
1098:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1099:quantum/quantum.c ****  * about 244 times per second.
1100:quantum/quantum.c ****  */
1101:quantum/quantum.c **** ISR(TIMER1_OVF_vect)
1102:quantum/quantum.c **** {
1103:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1104:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1105:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1106:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1107:quantum/quantum.c **** 
1108:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1109:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1110:quantum/quantum.c ****   {
1111:quantum/quantum.c ****       breathing_interrupt_disable();
1112:quantum/quantum.c ****   }
1113:quantum/quantum.c **** 
1114:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1115:quantum/quantum.c **** }
1116:quantum/quantum.c **** 
1117:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1118:quantum/quantum.c **** 
1119:quantum/quantum.c **** __attribute__ ((weak))
1120:quantum/quantum.c **** void backlight_init_ports(void)
1121:quantum/quantum.c **** {
1122:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1123:quantum/quantum.c ****   // DDRx |= n
1124:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
1125:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1126:quantum/quantum.c ****     // PORTx &= ~n
1127:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1128:quantum/quantum.c ****   #else
1129:quantum/quantum.c ****     // PORTx |= n
1130:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1131:quantum/quantum.c ****   #endif
1132:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1133:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1134:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1135:quantum/quantum.c **** 
1136:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1137:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1138:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1139:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1140:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1141:quantum/quantum.c **** 
1142:quantum/quantum.c ****   /*
1143:quantum/quantum.c ****   14.8.3:
1144:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1145:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1146:quantum/quantum.c ****   */
1147:quantum/quantum.c **** 
1148:quantum/quantum.c ****   TCCR1A = _BV(COM1x1) | _BV(WGM11); // = 0b00001010;
1149:quantum/quantum.c ****   TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1150:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1151:quantum/quantum.c ****   ICR1 = TIMER_TOP;
1152:quantum/quantum.c **** 
1153:quantum/quantum.c ****   backlight_init();
1154:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1155:quantum/quantum.c ****     breathing_enable();
1156:quantum/quantum.c ****   #endif
1157:quantum/quantum.c **** }
1158:quantum/quantum.c **** 
1159:quantum/quantum.c **** #endif // NO_HARDWARE_PWM
1160:quantum/quantum.c **** 
1161:quantum/quantum.c **** #else // backlight
1162:quantum/quantum.c **** 
1163:quantum/quantum.c **** __attribute__ ((weak))
1164:quantum/quantum.c **** void backlight_init_ports(void) {}
1165:quantum/quantum.c **** 
1166:quantum/quantum.c **** __attribute__ ((weak))
1167:quantum/quantum.c **** void backlight_set(uint8_t level) {}
1168:quantum/quantum.c **** 
1169:quantum/quantum.c **** #endif // backlight
1170:quantum/quantum.c **** 
1171:quantum/quantum.c **** 
1172:quantum/quantum.c **** // Functions for spitting out values
1173:quantum/quantum.c **** //
1174:quantum/quantum.c **** 
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1176:quantum/quantum.c ****     uint16_t word = (number >> 16);
1177:quantum/quantum.c ****     send_word(word);
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1179:quantum/quantum.c **** }
1180:quantum/quantum.c **** 
1181:quantum/quantum.c **** void send_word(uint16_t number) {
1182:quantum/quantum.c ****     uint8_t byte = number >> 8;
1183:quantum/quantum.c ****     send_byte(byte);
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
1185:quantum/quantum.c **** }
1186:quantum/quantum.c **** 
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
1188:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1189:quantum/quantum.c ****     send_nibble(nibble);
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
1191:quantum/quantum.c **** }
1192:quantum/quantum.c **** 
1193:quantum/quantum.c **** void send_nibble(uint8_t number) {
 2036               		.loc 1 1193 0
 2037               		.cfi_startproc
 2038               	.LVL208:
 2039               		.loc 1 1193 0
 2040 0000 CF93      		push r28
 2041               	.LCFI38:
 2042               		.cfi_def_cfa_offset 3
 2043               		.cfi_offset 28, -2
 2044               	/* prologue: function */
 2045               	/* frame size = 0 */
 2046               	/* stack size = 1 */
 2047               	.L__stack_usage = 1
1194:quantum/quantum.c ****     switch (number) {
 2048               		.loc 1 1194 0
 2049 0002 8A30      		cpi r24,lo8(10)
 2050 0004 00F4      		brsh .L196
 2051 0006 8130      		cpi r24,lo8(1)
 2052 0008 00F4      		brsh .L204
1195:quantum/quantum.c ****         case 0:
1196:quantum/quantum.c ****             register_code(KC_0);
 2053               		.loc 1 1196 0
 2054 000a 87E2      		ldi r24,lo8(39)
 2055               	.LVL209:
 2056 000c 0E94 0000 		call register_code
 2057               	.LVL210:
1197:quantum/quantum.c ****             unregister_code(KC_0);
 2058               		.loc 1 1197 0
 2059 0010 87E2      		ldi r24,lo8(39)
 2060 0012 00C0      		rjmp .L202
 2061               	.LVL211:
 2062               	.L196:
1194:quantum/quantum.c ****     switch (number) {
 2063               		.loc 1 1194 0
 2064 0014 8031      		cpi r24,lo8(16)
 2065 0016 00F4      		brsh .L205
1198:quantum/quantum.c ****             break;
1199:quantum/quantum.c ****         case 1 ... 9:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1201:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1202:quantum/quantum.c ****             break;
1203:quantum/quantum.c ****         case 0xA ... 0xF:
1204:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 2066               		.loc 1 1204 0
 2067 0018 CAEF      		ldi r28,lo8(-6)
 2068 001a 00C0      		rjmp .L203
 2069               	.L204:
1200:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
 2070               		.loc 1 1200 0
 2071 001c CDE1      		ldi r28,lo8(29)
 2072               	.L203:
 2073               		.loc 1 1204 0
 2074 001e C80F      		add r28,r24
 2075 0020 8C2F      		mov r24,r28
 2076               	.LVL212:
 2077 0022 0E94 0000 		call register_code
 2078               	.LVL213:
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2079               		.loc 1 1205 0
 2080 0026 8C2F      		mov r24,r28
 2081               	.L202:
 2082               	/* epilogue start */
1206:quantum/quantum.c ****             break;
1207:quantum/quantum.c ****     }
1208:quantum/quantum.c **** }
 2083               		.loc 1 1208 0
 2084 0028 CF91      		pop r28
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2085               		.loc 1 1205 0
 2086 002a 0C94 0000 		jmp unregister_code
 2087               	.LVL214:
 2088               	.L205:
 2089               	/* epilogue start */
 2090               		.loc 1 1208 0
 2091 002e CF91      		pop r28
 2092 0030 0895      		ret
 2093               		.cfi_endproc
 2094               	.LFE56:
 2096               		.section	.text.send_byte,"ax",@progbits
 2097               	.global	send_byte
 2099               	send_byte:
 2100               	.LFB55:
1187:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 2101               		.loc 1 1187 0
 2102               		.cfi_startproc
 2103               	.LVL215:
 2104 0000 CF93      		push r28
 2105               	.LCFI39:
 2106               		.cfi_def_cfa_offset 3
 2107               		.cfi_offset 28, -2
 2108               	/* prologue: function */
 2109               	/* frame size = 0 */
 2110               	/* stack size = 1 */
 2111               	.L__stack_usage = 1
 2112 0002 C82F      		mov r28,r24
 2113               	.LVL216:
1189:quantum/quantum.c ****     send_nibble(number & 0xF);
 2114               		.loc 1 1189 0
 2115 0004 8295      		swap r24
 2116               	.LVL217:
 2117 0006 8F70      		andi r24,lo8(15)
 2118 0008 0E94 0000 		call send_nibble
 2119               	.LVL218:
1190:quantum/quantum.c **** }
 2120               		.loc 1 1190 0
 2121 000c 8C2F      		mov r24,r28
 2122 000e 8F70      		andi r24,lo8(15)
 2123               	/* epilogue start */
1191:quantum/quantum.c **** 
 2124               		.loc 1 1191 0
 2125 0010 CF91      		pop r28
 2126               	.LVL219:
1190:quantum/quantum.c **** }
 2127               		.loc 1 1190 0
 2128 0012 0C94 0000 		jmp send_nibble
 2129               	.LVL220:
 2130               		.cfi_endproc
 2131               	.LFE55:
 2133               		.section	.text.send_word,"ax",@progbits
 2134               	.global	send_word
 2136               	send_word:
 2137               	.LFB54:
1181:quantum/quantum.c ****     uint8_t byte = number >> 8;
 2138               		.loc 1 1181 0
 2139               		.cfi_startproc
 2140               	.LVL221:
 2141 0000 CF93      		push r28
 2142               	.LCFI40:
 2143               		.cfi_def_cfa_offset 3
 2144               		.cfi_offset 28, -2
 2145               	/* prologue: function */
 2146               	/* frame size = 0 */
 2147               	/* stack size = 1 */
 2148               	.L__stack_usage = 1
 2149 0002 C82F      		mov r28,r24
 2150               	.LVL222:
1183:quantum/quantum.c ****     send_byte(number & 0xFF);
 2151               		.loc 1 1183 0
 2152 0004 892F      		mov r24,r25
 2153               	.LVL223:
 2154 0006 0E94 0000 		call send_byte
 2155               	.LVL224:
1184:quantum/quantum.c **** }
 2156               		.loc 1 1184 0
 2157 000a 8C2F      		mov r24,r28
 2158               	/* epilogue start */
1185:quantum/quantum.c **** 
 2159               		.loc 1 1185 0
 2160 000c CF91      		pop r28
1184:quantum/quantum.c **** }
 2161               		.loc 1 1184 0
 2162 000e 0C94 0000 		jmp send_byte
 2163               	.LVL225:
 2164               		.cfi_endproc
 2165               	.LFE54:
 2167               		.section	.text.send_dword,"ax",@progbits
 2168               	.global	send_dword
 2170               	send_dword:
 2171               	.LFB53:
1175:quantum/quantum.c ****     uint16_t word = (number >> 16);
 2172               		.loc 1 1175 0
 2173               		.cfi_startproc
 2174               	.LVL226:
 2175 0000 CF92      		push r12
 2176               	.LCFI41:
 2177               		.cfi_def_cfa_offset 3
 2178               		.cfi_offset 12, -2
 2179 0002 DF92      		push r13
 2180               	.LCFI42:
 2181               		.cfi_def_cfa_offset 4
 2182               		.cfi_offset 13, -3
 2183 0004 EF92      		push r14
 2184               	.LCFI43:
 2185               		.cfi_def_cfa_offset 5
 2186               		.cfi_offset 14, -4
 2187 0006 FF92      		push r15
 2188               	.LCFI44:
 2189               		.cfi_def_cfa_offset 6
 2190               		.cfi_offset 15, -5
 2191               	/* prologue: function */
 2192               	/* frame size = 0 */
 2193               	/* stack size = 4 */
 2194               	.L__stack_usage = 4
 2195 0008 6B01      		movw r12,r22
 2196 000a 7C01      		movw r14,r24
 2197               	.LVL227:
1177:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2198               		.loc 1 1177 0
 2199 000c C701      		movw r24,r14
 2200 000e 0E94 0000 		call send_word
 2201               	.LVL228:
1178:quantum/quantum.c **** }
 2202               		.loc 1 1178 0
 2203 0012 C601      		movw r24,r12
 2204               	/* epilogue start */
1179:quantum/quantum.c **** 
 2205               		.loc 1 1179 0
 2206 0014 FF90      		pop r15
 2207 0016 EF90      		pop r14
 2208 0018 DF90      		pop r13
 2209 001a CF90      		pop r12
 2210               	.LVL229:
1178:quantum/quantum.c **** }
 2211               		.loc 1 1178 0
 2212 001c 0C94 0000 		jmp send_word
 2213               	.LVL230:
 2214               		.cfi_endproc
 2215               	.LFE53:
 2217               		.section	.text.hex_to_keycode,"ax",@progbits
 2218               		.weak	hex_to_keycode
 2220               	hex_to_keycode:
 2221               	.LFB57:
1209:quantum/quantum.c **** 
1210:quantum/quantum.c **** 
1211:quantum/quantum.c **** __attribute__((weak))
1212:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1213:quantum/quantum.c **** {
 2222               		.loc 1 1213 0
 2223               		.cfi_startproc
 2224               	.LVL231:
 2225               	/* prologue: function */
 2226               	/* frame size = 0 */
 2227               	/* stack size = 0 */
 2228               	.L__stack_usage = 0
1214:quantum/quantum.c ****   hex = hex & 0xF;
 2229               		.loc 1 1214 0
 2230 0000 282F      		mov r18,r24
 2231 0002 2F70      		andi r18,lo8(15)
 2232               	.LVL232:
1215:quantum/quantum.c ****   if (hex == 0x0) {
 2233               		.loc 1 1215 0
 2234 0004 01F0      		breq .L212
 2235 0006 822F      		mov r24,r18
 2236 0008 90E0      		ldi r25,0
1216:quantum/quantum.c ****     return KC_0;
1217:quantum/quantum.c ****   } else if (hex < 0xA) {
 2237               		.loc 1 1217 0
 2238 000a 2A30      		cpi r18,lo8(10)
 2239 000c 00F4      		brsh .L211
1218:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 2240               		.loc 1 1218 0
 2241 000e 4D96      		adiw r24,29
 2242 0010 0895      		ret
 2243               	.L211:
1219:quantum/quantum.c ****   } else {
1220:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 2244               		.loc 1 1220 0
 2245 0012 0697      		sbiw r24,6
 2246 0014 0895      		ret
 2247               	.L212:
1216:quantum/quantum.c ****   } else if (hex < 0xA) {
 2248               		.loc 1 1216 0
 2249 0016 87E2      		ldi r24,lo8(39)
 2250 0018 90E0      		ldi r25,0
1221:quantum/quantum.c ****   }
1222:quantum/quantum.c **** }
 2251               		.loc 1 1222 0
 2252 001a 0895      		ret
 2253               		.cfi_endproc
 2254               	.LFE57:
 2256               		.section	.text.api_send_unicode,"ax",@progbits
 2257               	.global	api_send_unicode
 2259               	api_send_unicode:
 2260               	.LFB58:
1223:quantum/quantum.c **** 
1224:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 2261               		.loc 1 1224 0
 2262               		.cfi_startproc
 2263               	.LVL233:
 2264               	/* prologue: function */
 2265               	/* frame size = 0 */
 2266               	/* stack size = 0 */
 2267               	.L__stack_usage = 0
 2268 0000 0895      		ret
 2269               		.cfi_endproc
 2270               	.LFE58:
 2272               		.section	.text.led_set_user,"ax",@progbits
 2273               		.weak	led_set_user
 2275               	led_set_user:
 2276               	.LFB59:
1225:quantum/quantum.c **** #ifdef API_ENABLE
1226:quantum/quantum.c ****     uint8_t chunk[4];
1227:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1228:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1229:quantum/quantum.c **** #endif
1230:quantum/quantum.c **** }
1231:quantum/quantum.c **** 
1232:quantum/quantum.c **** __attribute__ ((weak))
1233:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 2277               		.loc 1 1233 0
 2278               		.cfi_startproc
 2279               	.LVL234:
 2280               	/* prologue: function */
 2281               	/* frame size = 0 */
 2282               	/* stack size = 0 */
 2283               	.L__stack_usage = 0
 2284 0000 0895      		ret
 2285               		.cfi_endproc
 2286               	.LFE59:
 2288               		.set	led_set_user.localalias.1,led_set_user
 2289               		.section	.text.backlight_set,"ax",@progbits
 2290               		.weak	backlight_set
 2292               	backlight_set:
 2293               	.LFB94:
 2294               		.cfi_startproc
 2295               	/* prologue: function */
 2296               	/* frame size = 0 */
 2297               	/* stack size = 0 */
 2298               	.L__stack_usage = 0
 2299 0000 0C94 0000 		jmp led_set_user.localalias.1
 2300               		.cfi_endproc
 2301               	.LFE94:
 2303               		.section	.text.led_set_kb,"ax",@progbits
 2304               		.weak	led_set_kb
 2306               	led_set_kb:
 2307               	.LFB60:
1234:quantum/quantum.c **** 
1235:quantum/quantum.c **** }
1236:quantum/quantum.c **** 
1237:quantum/quantum.c **** __attribute__ ((weak))
1238:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 2308               		.loc 1 1238 0
 2309               		.cfi_startproc
 2310               	.LVL235:
 2311               	/* prologue: function */
 2312               	/* frame size = 0 */
 2313               	/* stack size = 0 */
 2314               	.L__stack_usage = 0
1239:quantum/quantum.c ****     led_set_user(usb_led);
 2315               		.loc 1 1239 0
 2316 0000 0C94 0000 		jmp led_set_user
 2317               	.LVL236:
 2318               		.cfi_endproc
 2319               	.LFE60:
 2321               		.section	.text.led_init_ports,"ax",@progbits
 2322               		.weak	led_init_ports
 2324               	led_init_ports:
 2325               	.LFB68:
 2326               		.cfi_startproc
 2327               	/* prologue: function */
 2328               	/* frame size = 0 */
 2329               	/* stack size = 0 */
 2330               	.L__stack_usage = 0
 2331 0000 0895      		ret
 2332               		.cfi_endproc
 2333               	.LFE68:
 2335               		.section	.text.led_set,"ax",@progbits
 2336               		.weak	led_set
 2338               	led_set:
 2339               	.LFB62:
1240:quantum/quantum.c **** }
1241:quantum/quantum.c **** 
1242:quantum/quantum.c **** __attribute__ ((weak))
1243:quantum/quantum.c **** void led_init_ports(void)
1244:quantum/quantum.c **** {
1245:quantum/quantum.c **** 
1246:quantum/quantum.c **** }
1247:quantum/quantum.c **** 
1248:quantum/quantum.c **** __attribute__ ((weak))
1249:quantum/quantum.c **** void led_set(uint8_t usb_led)
1250:quantum/quantum.c **** {
 2340               		.loc 1 1250 0
 2341               		.cfi_startproc
 2342               	.LVL237:
 2343               	/* prologue: function */
 2344               	/* frame size = 0 */
 2345               	/* stack size = 0 */
 2346               	.L__stack_usage = 0
1251:quantum/quantum.c **** 
1252:quantum/quantum.c ****   // Example LED Code
1253:quantum/quantum.c ****   //
1254:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1255:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1256:quantum/quantum.c ****     // {
1257:quantum/quantum.c ****     //     // Output high.
1258:quantum/quantum.c ****     //     DDRE |= (1<<6);
1259:quantum/quantum.c ****     //     PORTE |= (1<<6);
1260:quantum/quantum.c ****     // }
1261:quantum/quantum.c ****     // else
1262:quantum/quantum.c ****     // {
1263:quantum/quantum.c ****     //     // Output low.
1264:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1265:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1266:quantum/quantum.c ****     // }
1267:quantum/quantum.c **** 
1268:quantum/quantum.c ****   led_set_kb(usb_led);
 2347               		.loc 1 1268 0
 2348 0000 0C94 0000 		jmp led_set_kb
 2349               	.LVL238:
 2350               		.cfi_endproc
 2351               	.LFE62:
 2353               		.section	.text.startup_user,"ax",@progbits
 2354               		.weak	startup_user
 2356               	startup_user:
 2357               	.LFB66:
 2358               		.cfi_startproc
 2359               	/* prologue: function */
 2360               	/* frame size = 0 */
 2361               	/* stack size = 0 */
 2362               	.L__stack_usage = 0
 2363 0000 0895      		ret
 2364               		.cfi_endproc
 2365               	.LFE66:
 2367               		.section	.text.shutdown_user,"ax",@progbits
 2368               		.weak	shutdown_user
 2370               	shutdown_user:
 2371               	.LFB64:
1269:quantum/quantum.c **** }
1270:quantum/quantum.c **** 
1271:quantum/quantum.c **** 
1272:quantum/quantum.c **** //------------------------------------------------------------------------------
1273:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1274:quantum/quantum.c **** // different events such as startup and bootloader jump
1275:quantum/quantum.c **** 
1276:quantum/quantum.c **** __attribute__ ((weak))
1277:quantum/quantum.c **** void startup_user() {}
1278:quantum/quantum.c **** 
1279:quantum/quantum.c **** __attribute__ ((weak))
1280:quantum/quantum.c **** void shutdown_user() {}
 2372               		.loc 1 1280 0
 2373               		.cfi_startproc
 2374               	/* prologue: function */
 2375               	/* frame size = 0 */
 2376               	/* stack size = 0 */
 2377               	.L__stack_usage = 0
 2378 0000 0895      		ret
 2379               		.cfi_endproc
 2380               	.LFE64:
 2382               	.global	rgb_matrix_task_counter
 2383               		.section	.bss.rgb_matrix_task_counter,"aw",@nobits
 2386               	rgb_matrix_task_counter:
 2387 0000 00        		.zero	1
 2388               		.weak	ascii_to_keycode_lut
 2389               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2392               	ascii_to_keycode_lut:
 2393 0000 00        		.byte	0
 2394 0001 00        		.byte	0
 2395 0002 00        		.byte	0
 2396 0003 00        		.byte	0
 2397 0004 00        		.byte	0
 2398 0005 00        		.byte	0
 2399 0006 00        		.byte	0
 2400 0007 00        		.byte	0
 2401 0008 2A        		.byte	42
 2402 0009 2B        		.byte	43
 2403 000a 28        		.byte	40
 2404 000b 00        		.byte	0
 2405 000c 00        		.byte	0
 2406 000d 00        		.byte	0
 2407 000e 00        		.byte	0
 2408 000f 00        		.byte	0
 2409 0010 00        		.byte	0
 2410 0011 00        		.byte	0
 2411 0012 00        		.byte	0
 2412 0013 00        		.byte	0
 2413 0014 00        		.byte	0
 2414 0015 00        		.byte	0
 2415 0016 00        		.byte	0
 2416 0017 00        		.byte	0
 2417 0018 00        		.byte	0
 2418 0019 00        		.byte	0
 2419 001a 00        		.byte	0
 2420 001b 29        		.byte	41
 2421 001c 00        		.byte	0
 2422 001d 00        		.byte	0
 2423 001e 00        		.byte	0
 2424 001f 00        		.byte	0
 2425 0020 2C        		.byte	44
 2426 0021 1E        		.byte	30
 2427 0022 34        		.byte	52
 2428 0023 20        		.byte	32
 2429 0024 21        		.byte	33
 2430 0025 22        		.byte	34
 2431 0026 24        		.byte	36
 2432 0027 34        		.byte	52
 2433 0028 26        		.byte	38
 2434 0029 27        		.byte	39
 2435 002a 25        		.byte	37
 2436 002b 2E        		.byte	46
 2437 002c 36        		.byte	54
 2438 002d 2D        		.byte	45
 2439 002e 37        		.byte	55
 2440 002f 38        		.byte	56
 2441 0030 27        		.byte	39
 2442 0031 1E        		.byte	30
 2443 0032 1F        		.byte	31
 2444 0033 20        		.byte	32
 2445 0034 21        		.byte	33
 2446 0035 22        		.byte	34
 2447 0036 23        		.byte	35
 2448 0037 24        		.byte	36
 2449 0038 25        		.byte	37
 2450 0039 26        		.byte	38
 2451 003a 33        		.byte	51
 2452 003b 33        		.byte	51
 2453 003c 36        		.byte	54
 2454 003d 2E        		.byte	46
 2455 003e 37        		.byte	55
 2456 003f 38        		.byte	56
 2457 0040 1F        		.byte	31
 2458 0041 04        		.byte	4
 2459 0042 05        		.byte	5
 2460 0043 06        		.byte	6
 2461 0044 07        		.byte	7
 2462 0045 08        		.byte	8
 2463 0046 09        		.byte	9
 2464 0047 0A        		.byte	10
 2465 0048 0B        		.byte	11
 2466 0049 0C        		.byte	12
 2467 004a 0D        		.byte	13
 2468 004b 0E        		.byte	14
 2469 004c 0F        		.byte	15
 2470 004d 10        		.byte	16
 2471 004e 11        		.byte	17
 2472 004f 12        		.byte	18
 2473 0050 13        		.byte	19
 2474 0051 14        		.byte	20
 2475 0052 15        		.byte	21
 2476 0053 16        		.byte	22
 2477 0054 17        		.byte	23
 2478 0055 18        		.byte	24
 2479 0056 19        		.byte	25
 2480 0057 1A        		.byte	26
 2481 0058 1B        		.byte	27
 2482 0059 1C        		.byte	28
 2483 005a 1D        		.byte	29
 2484 005b 2F        		.byte	47
 2485 005c 31        		.byte	49
 2486 005d 30        		.byte	48
 2487 005e 23        		.byte	35
 2488 005f 2D        		.byte	45
 2489 0060 35        		.byte	53
 2490 0061 04        		.byte	4
 2491 0062 05        		.byte	5
 2492 0063 06        		.byte	6
 2493 0064 07        		.byte	7
 2494 0065 08        		.byte	8
 2495 0066 09        		.byte	9
 2496 0067 0A        		.byte	10
 2497 0068 0B        		.byte	11
 2498 0069 0C        		.byte	12
 2499 006a 0D        		.byte	13
 2500 006b 0E        		.byte	14
 2501 006c 0F        		.byte	15
 2502 006d 10        		.byte	16
 2503 006e 11        		.byte	17
 2504 006f 12        		.byte	18
 2505 0070 13        		.byte	19
 2506 0071 14        		.byte	20
 2507 0072 15        		.byte	21
 2508 0073 16        		.byte	22
 2509 0074 17        		.byte	23
 2510 0075 18        		.byte	24
 2511 0076 19        		.byte	25
 2512 0077 1A        		.byte	26
 2513 0078 1B        		.byte	27
 2514 0079 1C        		.byte	28
 2515 007a 1D        		.byte	29
 2516 007b 2F        		.byte	47
 2517 007c 31        		.byte	49
 2518 007d 30        		.byte	48
 2519 007e 35        		.byte	53
 2520 007f 4C        		.byte	76
 2521               		.weak	ascii_to_shift_lut
 2522               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2525               	ascii_to_shift_lut:
 2526 0000 00        		.byte	0
 2527 0001 00        		.byte	0
 2528 0002 00        		.byte	0
 2529 0003 00        		.byte	0
 2530 0004 00        		.byte	0
 2531 0005 00        		.byte	0
 2532 0006 00        		.byte	0
 2533 0007 00        		.byte	0
 2534 0008 00        		.byte	0
 2535 0009 00        		.byte	0
 2536 000a 00        		.byte	0
 2537 000b 00        		.byte	0
 2538 000c 00        		.byte	0
 2539 000d 00        		.byte	0
 2540 000e 00        		.byte	0
 2541 000f 00        		.byte	0
 2542 0010 00        		.byte	0
 2543 0011 00        		.byte	0
 2544 0012 00        		.byte	0
 2545 0013 00        		.byte	0
 2546 0014 00        		.byte	0
 2547 0015 00        		.byte	0
 2548 0016 00        		.byte	0
 2549 0017 00        		.byte	0
 2550 0018 00        		.byte	0
 2551 0019 00        		.byte	0
 2552 001a 00        		.byte	0
 2553 001b 00        		.byte	0
 2554 001c 00        		.byte	0
 2555 001d 00        		.byte	0
 2556 001e 00        		.byte	0
 2557 001f 00        		.byte	0
 2558 0020 00        		.byte	0
 2559 0021 01        		.byte	1
 2560 0022 01        		.byte	1
 2561 0023 01        		.byte	1
 2562 0024 01        		.byte	1
 2563 0025 01        		.byte	1
 2564 0026 01        		.byte	1
 2565 0027 00        		.byte	0
 2566 0028 01        		.byte	1
 2567 0029 01        		.byte	1
 2568 002a 01        		.byte	1
 2569 002b 01        		.byte	1
 2570 002c 00        		.byte	0
 2571 002d 00        		.byte	0
 2572 002e 00        		.byte	0
 2573 002f 00        		.byte	0
 2574 0030 00        		.byte	0
 2575 0031 00        		.byte	0
 2576 0032 00        		.byte	0
 2577 0033 00        		.byte	0
 2578 0034 00        		.byte	0
 2579 0035 00        		.byte	0
 2580 0036 00        		.byte	0
 2581 0037 00        		.byte	0
 2582 0038 00        		.byte	0
 2583 0039 00        		.byte	0
 2584 003a 01        		.byte	1
 2585 003b 00        		.byte	0
 2586 003c 01        		.byte	1
 2587 003d 00        		.byte	0
 2588 003e 01        		.byte	1
 2589 003f 01        		.byte	1
 2590 0040 01        		.byte	1
 2591 0041 01        		.byte	1
 2592 0042 01        		.byte	1
 2593 0043 01        		.byte	1
 2594 0044 01        		.byte	1
 2595 0045 01        		.byte	1
 2596 0046 01        		.byte	1
 2597 0047 01        		.byte	1
 2598 0048 01        		.byte	1
 2599 0049 01        		.byte	1
 2600 004a 01        		.byte	1
 2601 004b 01        		.byte	1
 2602 004c 01        		.byte	1
 2603 004d 01        		.byte	1
 2604 004e 01        		.byte	1
 2605 004f 01        		.byte	1
 2606 0050 01        		.byte	1
 2607 0051 01        		.byte	1
 2608 0052 01        		.byte	1
 2609 0053 01        		.byte	1
 2610 0054 01        		.byte	1
 2611 0055 01        		.byte	1
 2612 0056 01        		.byte	1
 2613 0057 01        		.byte	1
 2614 0058 01        		.byte	1
 2615 0059 01        		.byte	1
 2616 005a 01        		.byte	1
 2617 005b 00        		.byte	0
 2618 005c 00        		.byte	0
 2619 005d 00        		.byte	0
 2620 005e 01        		.byte	1
 2621 005f 01        		.byte	1
 2622 0060 00        		.byte	0
 2623 0061 00        		.byte	0
 2624 0062 00        		.byte	0
 2625 0063 00        		.byte	0
 2626 0064 00        		.byte	0
 2627 0065 00        		.byte	0
 2628 0066 00        		.byte	0
 2629 0067 00        		.byte	0
 2630 0068 00        		.byte	0
 2631 0069 00        		.byte	0
 2632 006a 00        		.byte	0
 2633 006b 00        		.byte	0
 2634 006c 00        		.byte	0
 2635 006d 00        		.byte	0
 2636 006e 00        		.byte	0
 2637 006f 00        		.byte	0
 2638 0070 00        		.byte	0
 2639 0071 00        		.byte	0
 2640 0072 00        		.byte	0
 2641 0073 00        		.byte	0
 2642 0074 00        		.byte	0
 2643 0075 00        		.byte	0
 2644 0076 00        		.byte	0
 2645 0077 00        		.byte	0
 2646 0078 00        		.byte	0
 2647 0079 00        		.byte	0
 2648 007a 00        		.byte	0
 2649 007b 01        		.byte	1
 2650 007c 01        		.byte	1
 2651 007d 01        		.byte	1
 2652 007e 01        		.byte	1
 2653 007f 00        		.byte	0
 2654               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2657               	grave_esc_was_shifted:
 2658 0000 00        		.zero	1
 2659               		.section	.bss.scs_timer,"aw",@nobits
 2662               	scs_timer:
 2663 0000 0000 0000 		.zero	4
 2664               		.section	.bss.shift_interrupted,"aw",@nobits
 2667               	shift_interrupted:
 2668 0000 0000      		.zero	2
 2669               		.text
 2670               	.Letext0:
 2671               		.file 4 "/usr/lib/avr/include/stdint.h"
 2672               		.file 5 "./tmk_core/common/keyboard.h"
 2673               		.file 6 "./tmk_core/common/action.h"
 2674               		.file 7 "./tmk_core/common/report.h"
 2675               		.file 8 "./tmk_core/common/debug.h"
 2676               		.file 9 "quantum/keycode_config.h"
 2677               		.file 10 "./tmk_core/common/keycode.h"
 2678               		.file 11 "quantum/quantum_keycodes.h"
 2679               		.file 12 "./tmk_core/protocol/lufa/outputselect.h"
 2680               		.file 13 "quantum/quantum.h"
 2681               		.file 14 "./tmk_core/common/bootloader.h"
 2682               		.file 15 "./tmk_core/common/action_layer.h"
 2683               		.file 16 "quantum/keymap.h"
 2684               		.file 17 "./quantum/process_keycode/process_tap_dance.h"
 2685               		.file 18 "./quantum/process_keycode/process_leader.h"
 2686               		.file 19 "./tmk_core/common/eeconfig.h"
 2687               		.file 20 "./tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/cc7bgZxV.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc7bgZxV.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc7bgZxV.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc7bgZxV.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc7bgZxV.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc7bgZxV.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/cc7bgZxV.s:129    .text.qk_register_mods:0000000000000000 qk_register_mods
     /tmp/cc7bgZxV.s:159    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
     /tmp/cc7bgZxV.s:172    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
     /tmp/cc7bgZxV.s:202    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
     /tmp/cc7bgZxV.s:216    .text.rgblight_toggle:0000000000000000 rgblight_toggle
     /tmp/cc7bgZxV.s:230    .text.rgblight_step:0000000000000000 rgblight_step
     /tmp/cc7bgZxV.s:244    .text.rgblight_step_reverse:0000000000000000 rgblight_step_reverse
     /tmp/cc7bgZxV.s:258    .text.rgblight_increase_hue:0000000000000000 rgblight_increase_hue
     /tmp/cc7bgZxV.s:272    .text.rgblight_decrease_hue:0000000000000000 rgblight_decrease_hue
     /tmp/cc7bgZxV.s:286    .text.rgblight_increase_sat:0000000000000000 rgblight_increase_sat
     /tmp/cc7bgZxV.s:300    .text.rgblight_decrease_sat:0000000000000000 rgblight_decrease_sat
     /tmp/cc7bgZxV.s:314    .text.rgblight_increase_val:0000000000000000 rgblight_increase_val
     /tmp/cc7bgZxV.s:328    .text.rgblight_decrease_val:0000000000000000 rgblight_decrease_val
     /tmp/cc7bgZxV.s:342    .text.rgblight_increase_speed:0000000000000000 rgblight_increase_speed
     /tmp/cc7bgZxV.s:356    .text.rgblight_decrease_speed:0000000000000000 rgblight_decrease_speed
     /tmp/cc7bgZxV.s:370    .text.register_code16:0000000000000000 register_code16
     /tmp/cc7bgZxV.s:427    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/cc7bgZxV.s:482    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/cc7bgZxV.s:501    .text.process_record_user:0000000000000000 process_record_user
     /tmp/cc7bgZxV.s:520    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/cc7bgZxV.s:538    .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/cc7bgZxV.s:579    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/cc7bgZxV.s:2657   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted
     /tmp/cc7bgZxV.s:2667   .bss.shift_interrupted:0000000000000000 shift_interrupted
     /tmp/cc7bgZxV.s:2662   .bss.scs_timer:0000000000000000 scs_timer
     /tmp/cc7bgZxV.s:1170   .text.send_char:0000000000000000 send_char
     /tmp/cc7bgZxV.s:2392   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
     /tmp/cc7bgZxV.s:2525   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
     /tmp/cc7bgZxV.s:1255   .text.send_string_with_delay:0000000000000000 send_string_with_delay
     /tmp/cc7bgZxV.s:1399   .text.send_string:0000000000000000 send_string
     /tmp/cc7bgZxV.s:1418   .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
     /tmp/cc7bgZxV.s:1594   .text.send_string_P:0000000000000000 send_string_P
     /tmp/cc7bgZxV.s:1613   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/cc7bgZxV.s:1662   .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
     /tmp/cc7bgZxV.s:1817   .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/cc7bgZxV.s:1856   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/cc7bgZxV.s:1983   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/cc7bgZxV.s:2000   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/cc7bgZxV.s:2020   .text.backlight_init_ports:0000000000000000 backlight_init_ports
     /tmp/cc7bgZxV.s:2034   .text.send_nibble:0000000000000000 send_nibble
     /tmp/cc7bgZxV.s:2099   .text.send_byte:0000000000000000 send_byte
     /tmp/cc7bgZxV.s:2136   .text.send_word:0000000000000000 send_word
     /tmp/cc7bgZxV.s:2170   .text.send_dword:0000000000000000 send_dword
     /tmp/cc7bgZxV.s:2220   .text.hex_to_keycode:0000000000000000 hex_to_keycode
     /tmp/cc7bgZxV.s:2259   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/cc7bgZxV.s:2275   .text.led_set_user:0000000000000000 led_set_user
     /tmp/cc7bgZxV.s:2275   .text.led_set_user:0000000000000000 led_set_user.localalias.1
     /tmp/cc7bgZxV.s:2292   .text.backlight_set:0000000000000000 backlight_set
     /tmp/cc7bgZxV.s:2306   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/cc7bgZxV.s:2324   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/cc7bgZxV.s:2338   .text.led_set:0000000000000000 led_set
     /tmp/cc7bgZxV.s:2356   .text.startup_user:0000000000000000 startup_user
     /tmp/cc7bgZxV.s:2370   .text.shutdown_user:0000000000000000 shutdown_user
     /tmp/cc7bgZxV.s:2386   .bss.rgb_matrix_task_counter:0000000000000000 rgb_matrix_task_counter

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
clear_keyboard
bootloader_jump
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
read_source_layers_cache
keymap_key_to_keycode
preprocess_tap_dance
process_tap_dance
process_leader
get_mods
keyboard_report
add_key_to_report
del_key_from_report
debug_config
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
timer_read
register_mods
unregister_mods
timer_elapsed
set_output
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_init_kb
matrix_scan_tap_dance
matrix_scan_kb
__do_clear_bss
