   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB28:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  19:quantum/quantum.c **** #include "outputselect.h"
  20:quantum/quantum.c **** #endif
  21:quantum/quantum.c **** 
  22:quantum/quantum.c **** #ifndef TAPPING_TERM
  23:quantum/quantum.c **** #define TAPPING_TERM 200
  24:quantum/quantum.c **** #endif
  25:quantum/quantum.c **** 
  26:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  27:quantum/quantum.c **** #define BREATHING_PERIOD 6
  28:quantum/quantum.c **** #endif
  29:quantum/quantum.c **** 
  30:quantum/quantum.c **** #include "backlight.h"
  31:quantum/quantum.c **** extern backlight_config_t backlight_config;
  32:quantum/quantum.c **** 
  33:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  34:quantum/quantum.c **** #include "fauxclicky.h"
  35:quantum/quantum.c **** #endif
  36:quantum/quantum.c **** 
  37:quantum/quantum.c **** #ifdef API_ENABLE
  38:quantum/quantum.c **** #include "api.h"
  39:quantum/quantum.c **** #endif
  40:quantum/quantum.c **** 
  41:quantum/quantum.c **** #ifdef MIDI_ENABLE
  42:quantum/quantum.c **** #include "process_midi.h"
  43:quantum/quantum.c **** #endif
  44:quantum/quantum.c **** 
  45:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  46:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  47:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  48:quantum/quantum.c ****   #endif
  49:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  50:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  51:quantum/quantum.c ****   #endif
  52:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  53:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  54:quantum/quantum.c ****   #endif
  55:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  56:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  57:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  58:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  59:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  60:quantum/quantum.c ****   #endif
  61:quantum/quantum.c **** #endif
  62:quantum/quantum.c **** 
  63:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 63 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  64:quantum/quantum.c ****   switch (code) {
  38               		.loc 1 64 0
  39 0008 9C01      		movw r18,r24
  40 000a 3A95      		dec r19
  41 000c 2115      		cp r18,__zero_reg__
  42 000e 3F41      		sbci r19,31
  43 0010 00F4      		brsh .L1
  44 0012 EB01      		movw r28,r22
  45 0014 8C01      		movw r16,r24
  65:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  66:quantum/quantum.c ****     break;
  67:quantum/quantum.c ****   default:
  68:quantum/quantum.c ****     return;
  69:quantum/quantum.c ****   }
  70:quantum/quantum.c **** 
  71:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 71 0
  47 0016 90FF      		sbrs r25,0
  48 0018 00C0      		rjmp .L4
  72:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 72 0
  50 001a 80EE      		ldi r24,lo8(-32)
  51               	.LVL1:
  52 001c FB01      		movw r30,r22
  53 001e 0995      		icall
  54               	.LVL2:
  55               	.L4:
  73:quantum/quantum.c ****   if (code & QK_LSFT)
  56               		.loc 1 73 0
  57 0020 11FF      		sbrs r17,1
  58 0022 00C0      		rjmp .L5
  74:quantum/quantum.c ****     f(KC_LSFT);
  59               		.loc 1 74 0
  60 0024 81EE      		ldi r24,lo8(-31)
  61 0026 FE01      		movw r30,r28
  62 0028 0995      		icall
  63               	.LVL3:
  64               	.L5:
  75:quantum/quantum.c ****   if (code & QK_LALT)
  65               		.loc 1 75 0
  66 002a 12FF      		sbrs r17,2
  67 002c 00C0      		rjmp .L6
  76:quantum/quantum.c ****     f(KC_LALT);
  68               		.loc 1 76 0
  69 002e 82EE      		ldi r24,lo8(-30)
  70 0030 FE01      		movw r30,r28
  71 0032 0995      		icall
  72               	.LVL4:
  73               	.L6:
  77:quantum/quantum.c ****   if (code & QK_LGUI)
  74               		.loc 1 77 0
  75 0034 13FF      		sbrs r17,3
  76 0036 00C0      		rjmp .L7
  78:quantum/quantum.c ****     f(KC_LGUI);
  77               		.loc 1 78 0
  78 0038 83EE      		ldi r24,lo8(-29)
  79 003a FE01      		movw r30,r28
  80 003c 0995      		icall
  81               	.LVL5:
  82               	.L7:
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  83               		.loc 1 80 0
  84 003e 0115      		cp r16,__zero_reg__
  85 0040 1041      		sbci r17,16
  86 0042 00F0      		brlo .L1
  81:quantum/quantum.c **** 
  82:quantum/quantum.c ****   if (code & QK_RCTL)
  83:quantum/quantum.c ****     f(KC_RCTL);
  87               		.loc 1 83 0
  88 0044 84EE      		ldi r24,lo8(-28)
  89 0046 FE01      		movw r30,r28
  90 0048 0995      		icall
  91               	.LVL6:
  84:quantum/quantum.c ****   if (code & QK_RSFT)
  85:quantum/quantum.c ****     f(KC_RSFT);
  92               		.loc 1 85 0
  93 004a 85EE      		ldi r24,lo8(-27)
  94 004c FE01      		movw r30,r28
  95 004e 0995      		icall
  96               	.LVL7:
  86:quantum/quantum.c ****   if (code & QK_RALT)
  87:quantum/quantum.c ****     f(KC_RALT);
  97               		.loc 1 87 0
  98 0050 86EE      		ldi r24,lo8(-26)
  99 0052 FE01      		movw r30,r28
 100 0054 0995      		icall
 101               	.LVL8:
  88:quantum/quantum.c ****   if (code & QK_RGUI)
  89:quantum/quantum.c ****     f(KC_RGUI);
 102               		.loc 1 89 0
 103 0056 87EE      		ldi r24,lo8(-25)
 104 0058 FE01      		movw r30,r28
 105               	/* epilogue start */
  90:quantum/quantum.c **** }
 106               		.loc 1 90 0
 107 005a DF91      		pop r29
 108 005c CF91      		pop r28
 109               	.LVL9:
 110 005e 1F91      		pop r17
 111 0060 0F91      		pop r16
 112               	.LVL10:
  89:quantum/quantum.c **** }
 113               		.loc 1 89 0
 114 0062 0994      		ijmp
 115               	.LVL11:
 116               	.L1:
 117               	/* epilogue start */
 118               		.loc 1 90 0
 119 0064 DF91      		pop r29
 120 0066 CF91      		pop r28
 121 0068 1F91      		pop r17
 122 006a 0F91      		pop r16
 123 006c 0895      		ret
 124               		.cfi_endproc
 125               	.LFE28:
 127               		.section	.text.qk_register_mods,"ax",@progbits
 129               	qk_register_mods:
 130               	.LFB31:
  91:quantum/quantum.c **** 
  92:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
  93:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
  94:quantum/quantum.c ****     send_keyboard_report();
  95:quantum/quantum.c **** }
  96:quantum/quantum.c **** 
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
  99:quantum/quantum.c ****     send_keyboard_report();
 100:quantum/quantum.c **** }
 101:quantum/quantum.c **** 
 102:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 131               		.loc 1 102 0
 132               		.cfi_startproc
 133               	.LVL12:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 103:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 138               		.loc 1 103 0
 139 0000 8770      		andi r24,lo8(7)
 140               	.LVL13:
 141 0002 91E0      		ldi r25,lo8(1)
 142 0004 00C0      		rjmp 2f
 143               		1:
 144 0006 990F      		lsl r25
 145               		2:
 146 0008 8A95      		dec r24
 147 000a 02F4      		brpl 1b
 148 000c 892F      		mov r24,r25
 149 000e 0E94 0000 		call add_weak_mods
 150               	.LVL14:
 104:quantum/quantum.c ****     send_keyboard_report();
 151               		.loc 1 104 0
 152 0012 0C94 0000 		jmp send_keyboard_report
 153               	.LVL15:
 154               		.cfi_endproc
 155               	.LFE31:
 157               		.section	.text.qk_register_weak_mods,"ax",@progbits
 159               	qk_register_weak_mods:
 160               	.LFB98:
 161               		.cfi_startproc
 162               	/* prologue: function */
 163               	/* frame size = 0 */
 164               	/* stack size = 0 */
 165               	.L__stack_usage = 0
 166 0000 0C94 0000 		jmp qk_register_mods
 167               		.cfi_endproc
 168               	.LFE98:
 170               		.section	.text.qk_unregister_mods,"ax",@progbits
 172               	qk_unregister_mods:
 173               	.LFB32:
 105:quantum/quantum.c **** }
 106:quantum/quantum.c **** 
 107:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 174               		.loc 1 107 0
 175               		.cfi_startproc
 176               	.LVL16:
 177               	/* prologue: function */
 178               	/* frame size = 0 */
 179               	/* stack size = 0 */
 180               	.L__stack_usage = 0
 108:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 181               		.loc 1 108 0
 182 0000 8770      		andi r24,lo8(7)
 183               	.LVL17:
 184 0002 91E0      		ldi r25,lo8(1)
 185 0004 00C0      		rjmp 2f
 186               		1:
 187 0006 990F      		lsl r25
 188               		2:
 189 0008 8A95      		dec r24
 190 000a 02F4      		brpl 1b
 191 000c 892F      		mov r24,r25
 192 000e 0E94 0000 		call del_weak_mods
 193               	.LVL18:
 109:quantum/quantum.c ****     send_keyboard_report();
 194               		.loc 1 109 0
 195 0012 0C94 0000 		jmp send_keyboard_report
 196               	.LVL19:
 197               		.cfi_endproc
 198               	.LFE32:
 200               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 202               	qk_unregister_weak_mods:
 203               	.LFB96:
 204               		.cfi_startproc
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 0 */
 208               	.L__stack_usage = 0
 209 0000 0C94 0000 		jmp qk_unregister_mods
 210               		.cfi_endproc
 211               	.LFE96:
 213               		.section	.text.rgblight_toggle,"ax",@progbits
 214               		.weak	rgblight_toggle
 216               	rgblight_toggle:
 217               	.LFB92:
 218               		.cfi_startproc
 219               	/* prologue: function */
 220               	/* frame size = 0 */
 221               	/* stack size = 0 */
 222               	.L__stack_usage = 0
 223 0000 0895      		ret
 224               		.cfi_endproc
 225               	.LFE92:
 227               		.section	.text.rgblight_step,"ax",@progbits
 228               		.weak	rgblight_step
 230               	rgblight_step:
 231               	.LFB90:
 232               		.cfi_startproc
 233               	/* prologue: function */
 234               	/* frame size = 0 */
 235               	/* stack size = 0 */
 236               	.L__stack_usage = 0
 237 0000 0895      		ret
 238               		.cfi_endproc
 239               	.LFE90:
 241               		.section	.text.rgblight_step_reverse,"ax",@progbits
 242               		.weak	rgblight_step_reverse
 244               	rgblight_step_reverse:
 245               	.LFB88:
 246               		.cfi_startproc
 247               	/* prologue: function */
 248               	/* frame size = 0 */
 249               	/* stack size = 0 */
 250               	.L__stack_usage = 0
 251 0000 0895      		ret
 252               		.cfi_endproc
 253               	.LFE88:
 255               		.section	.text.rgblight_increase_hue,"ax",@progbits
 256               		.weak	rgblight_increase_hue
 258               	rgblight_increase_hue:
 259               	.LFB86:
 260               		.cfi_startproc
 261               	/* prologue: function */
 262               	/* frame size = 0 */
 263               	/* stack size = 0 */
 264               	.L__stack_usage = 0
 265 0000 0895      		ret
 266               		.cfi_endproc
 267               	.LFE86:
 269               		.section	.text.rgblight_decrease_hue,"ax",@progbits
 270               		.weak	rgblight_decrease_hue
 272               	rgblight_decrease_hue:
 273               	.LFB84:
 274               		.cfi_startproc
 275               	/* prologue: function */
 276               	/* frame size = 0 */
 277               	/* stack size = 0 */
 278               	.L__stack_usage = 0
 279 0000 0895      		ret
 280               		.cfi_endproc
 281               	.LFE84:
 283               		.section	.text.rgblight_increase_sat,"ax",@progbits
 284               		.weak	rgblight_increase_sat
 286               	rgblight_increase_sat:
 287               	.LFB82:
 288               		.cfi_startproc
 289               	/* prologue: function */
 290               	/* frame size = 0 */
 291               	/* stack size = 0 */
 292               	.L__stack_usage = 0
 293 0000 0895      		ret
 294               		.cfi_endproc
 295               	.LFE82:
 297               		.section	.text.rgblight_decrease_sat,"ax",@progbits
 298               		.weak	rgblight_decrease_sat
 300               	rgblight_decrease_sat:
 301               	.LFB80:
 302               		.cfi_startproc
 303               	/* prologue: function */
 304               	/* frame size = 0 */
 305               	/* stack size = 0 */
 306               	.L__stack_usage = 0
 307 0000 0895      		ret
 308               		.cfi_endproc
 309               	.LFE80:
 311               		.section	.text.rgblight_increase_val,"ax",@progbits
 312               		.weak	rgblight_increase_val
 314               	rgblight_increase_val:
 315               	.LFB78:
 316               		.cfi_startproc
 317               	/* prologue: function */
 318               	/* frame size = 0 */
 319               	/* stack size = 0 */
 320               	.L__stack_usage = 0
 321 0000 0895      		ret
 322               		.cfi_endproc
 323               	.LFE78:
 325               		.section	.text.rgblight_decrease_val,"ax",@progbits
 326               		.weak	rgblight_decrease_val
 328               	rgblight_decrease_val:
 329               	.LFB76:
 330               		.cfi_startproc
 331               	/* prologue: function */
 332               	/* frame size = 0 */
 333               	/* stack size = 0 */
 334               	.L__stack_usage = 0
 335 0000 0895      		ret
 336               		.cfi_endproc
 337               	.LFE76:
 339               		.section	.text.rgblight_increase_speed,"ax",@progbits
 340               		.weak	rgblight_increase_speed
 342               	rgblight_increase_speed:
 343               	.LFB74:
 344               		.cfi_startproc
 345               	/* prologue: function */
 346               	/* frame size = 0 */
 347               	/* stack size = 0 */
 348               	.L__stack_usage = 0
 349 0000 0895      		ret
 350               		.cfi_endproc
 351               	.LFE74:
 353               		.section	.text.rgblight_decrease_speed,"ax",@progbits
 354               		.weak	rgblight_decrease_speed
 356               	rgblight_decrease_speed:
 357               	.LFB72:
 358               		.cfi_startproc
 359               	/* prologue: function */
 360               	/* frame size = 0 */
 361               	/* stack size = 0 */
 362               	.L__stack_usage = 0
 363 0000 0895      		ret
 364               		.cfi_endproc
 365               	.LFE72:
 367               		.section	.text.register_code16,"ax",@progbits
 368               	.global	register_code16
 370               	register_code16:
 371               	.LFB33:
 110:quantum/quantum.c **** }
 111:quantum/quantum.c **** 
 112:quantum/quantum.c **** void register_code16 (uint16_t code) {
 372               		.loc 1 112 0
 373               		.cfi_startproc
 374               	.LVL20:
 375               		.loc 1 112 0
 376 0000 CF93      		push r28
 377               	.LCFI4:
 378               		.cfi_def_cfa_offset 3
 379               		.cfi_offset 28, -2
 380 0002 DF93      		push r29
 381               	.LCFI5:
 382               		.cfi_def_cfa_offset 4
 383               		.cfi_offset 29, -3
 384               	/* prologue: function */
 385               	/* frame size = 0 */
 386               	/* stack size = 2 */
 387               	.L__stack_usage = 2
 388 0004 EC01      		movw r28,r24
 113:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 389               		.loc 1 113 0
 390 0006 805E      		subi r24,-32
 391 0008 9109      		sbc r25,__zero_reg__
 392               	.LVL21:
 393 000a 0897      		sbiw r24,8
 394 000c 00F0      		brlo .L39
 395               		.loc 1 113 0 is_stmt 0 discriminator 1
 396 000e 2097      		sbiw r28,0
 397 0010 01F4      		brne .L40
 398               	.L39:
 114:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 399               		.loc 1 114 0 is_stmt 1
 400 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 401 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 402 0016 00C0      		rjmp .L42
 403               	.L40:
 115:quantum/quantum.c ****   } else {
 116:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 404               		.loc 1 116 0
 405 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 406 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 407               	.L42:
 408 001c CE01      		movw r24,r28
 409 001e 0E94 0000 		call do_code16
 410               	.LVL22:
 117:quantum/quantum.c ****   }
 118:quantum/quantum.c ****   register_code (code);
 411               		.loc 1 118 0
 412 0022 8C2F      		mov r24,r28
 413               	/* epilogue start */
 119:quantum/quantum.c **** }
 414               		.loc 1 119 0
 415 0024 DF91      		pop r29
 416 0026 CF91      		pop r28
 417               	.LVL23:
 118:quantum/quantum.c **** }
 418               		.loc 1 118 0
 419 0028 0C94 0000 		jmp register_code
 420               	.LVL24:
 421               		.cfi_endproc
 422               	.LFE33:
 424               		.section	.text.unregister_code16,"ax",@progbits
 425               	.global	unregister_code16
 427               	unregister_code16:
 428               	.LFB34:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 429               		.loc 1 121 0
 430               		.cfi_startproc
 431               	.LVL25:
 432 0000 CF93      		push r28
 433               	.LCFI6:
 434               		.cfi_def_cfa_offset 3
 435               		.cfi_offset 28, -2
 436 0002 DF93      		push r29
 437               	.LCFI7:
 438               		.cfi_def_cfa_offset 4
 439               		.cfi_offset 29, -3
 440               	/* prologue: function */
 441               	/* frame size = 0 */
 442               	/* stack size = 2 */
 443               	.L__stack_usage = 2
 444 0004 EC01      		movw r28,r24
 122:quantum/quantum.c ****   unregister_code (code);
 445               		.loc 1 122 0
 446 0006 0E94 0000 		call unregister_code
 447               	.LVL26:
 123:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 448               		.loc 1 123 0
 449 000a CE01      		movw r24,r28
 450 000c 805E      		subi r24,-32
 451 000e 9109      		sbc r25,__zero_reg__
 452 0010 0897      		sbiw r24,8
 453 0012 00F0      		brlo .L44
 454               		.loc 1 123 0 is_stmt 0 discriminator 1
 455 0014 2097      		sbiw r28,0
 456 0016 01F4      		brne .L45
 457               	.L44:
 124:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 458               		.loc 1 124 0 is_stmt 1
 459 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 460 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 461 001c 00C0      		rjmp .L46
 462               	.L45:
 125:quantum/quantum.c ****   } else {
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 463               		.loc 1 126 0
 464 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 465 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 466               	.L46:
 467 0022 CE01      		movw r24,r28
 468               	/* epilogue start */
 127:quantum/quantum.c ****   }
 128:quantum/quantum.c **** }
 469               		.loc 1 128 0
 470 0024 DF91      		pop r29
 471 0026 CF91      		pop r28
 472               	.LVL27:
 126:quantum/quantum.c ****   }
 473               		.loc 1 126 0
 474 0028 0C94 0000 		jmp do_code16
 475               	.LVL28:
 476               		.cfi_endproc
 477               	.LFE34:
 479               		.section	.text.process_action_kb,"ax",@progbits
 480               		.weak	process_action_kb
 482               	process_action_kb:
 483               	.LFB35:
 129:quantum/quantum.c **** 
 130:quantum/quantum.c **** __attribute__ ((weak))
 131:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 484               		.loc 1 131 0
 485               		.cfi_startproc
 486               	.LVL29:
 487               	/* prologue: function */
 488               	/* frame size = 0 */
 489               	/* stack size = 0 */
 490               	.L__stack_usage = 0
 132:quantum/quantum.c ****   return true;
 133:quantum/quantum.c **** }
 491               		.loc 1 133 0
 492 0000 81E0      		ldi r24,lo8(1)
 493               	.LVL30:
 494 0002 0895      		ret
 495               		.cfi_endproc
 496               	.LFE35:
 498               		.section	.text.process_record_user,"ax",@progbits
 499               		.weak	process_record_user
 501               	process_record_user:
 502               	.LFB37:
 134:quantum/quantum.c **** 
 135:quantum/quantum.c **** __attribute__ ((weak))
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 138:quantum/quantum.c **** }
 139:quantum/quantum.c **** 
 140:quantum/quantum.c **** __attribute__ ((weak))
 141:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 503               		.loc 1 141 0
 504               		.cfi_startproc
 505               	.LVL31:
 506               	/* prologue: function */
 507               	/* frame size = 0 */
 508               	/* stack size = 0 */
 509               	.L__stack_usage = 0
 142:quantum/quantum.c ****   return true;
 143:quantum/quantum.c **** }
 510               		.loc 1 143 0
 511 0000 81E0      		ldi r24,lo8(1)
 512               	.LVL32:
 513 0002 0895      		ret
 514               		.cfi_endproc
 515               	.LFE37:
 517               		.section	.text.process_record_kb,"ax",@progbits
 518               		.weak	process_record_kb
 520               	process_record_kb:
 521               	.LFB36:
 136:quantum/quantum.c ****   return process_record_user(keycode, record);
 522               		.loc 1 136 0
 523               		.cfi_startproc
 524               	.LVL33:
 525               	/* prologue: function */
 526               	/* frame size = 0 */
 527               	/* stack size = 0 */
 528               	.L__stack_usage = 0
 137:quantum/quantum.c **** }
 529               		.loc 1 137 0
 530 0000 0C94 0000 		jmp process_record_user
 531               	.LVL34:
 532               		.cfi_endproc
 533               	.LFE36:
 535               		.section	.text.reset_keyboard,"ax",@progbits
 536               	.global	reset_keyboard
 538               	reset_keyboard:
 539               	.LFB38:
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** void reset_keyboard(void) {
 540               		.loc 1 145 0
 541               		.cfi_startproc
 542               	/* prologue: function */
 543               	/* frame size = 0 */
 544               	/* stack size = 0 */
 545               	.L__stack_usage = 0
 146:quantum/quantum.c ****   clear_keyboard();
 546               		.loc 1 146 0
 547 0000 0E94 0000 		call clear_keyboard
 548               	.LVL35:
 549               	.LBB27:
 550               	.LBB28:
 551               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 552               		.loc 2 187 0
 553 0004 2FEF      		ldi r18,lo8(799999)
 554 0006 84E3      		ldi r24,hi8(799999)
 555 0008 9CE0      		ldi r25,hlo8(799999)
 556 000a 2150      	1:	subi r18,1
 557 000c 8040      		sbci r24,0
 558 000e 9040      		sbci r25,0
 559 0010 01F4      		brne 1b
 560 0012 00C0      		rjmp .
 561 0014 0000      		nop
 562               	.LVL36:
 563               	.LBE28:
 564               	.LBE27:
 147:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 148:quantum/quantum.c ****   process_midi_all_notes_off();
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 151:quantum/quantum.c ****   music_all_notes_off();
 152:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 153:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 154:quantum/quantum.c ****   shutdown_user();
 155:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 156:quantum/quantum.c ****     wait_ms(1);
 157:quantum/quantum.c ****   stop_all_notes();
 158:quantum/quantum.c **** #else
 159:quantum/quantum.c ****   wait_ms(250);
 160:quantum/quantum.c **** #endif
 161:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 162:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 163:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 565               		.loc 1 163 0
 566 0016 87E7      		ldi r24,lo8(119)
 567 0018 97E7      		ldi r25,lo8(119)
 568 001a 9093 0108 		sts 2048+1,r25
 569 001e 8093 0008 		sts 2048,r24
 164:quantum/quantum.c **** #endif
 165:quantum/quantum.c ****   bootloader_jump();
 570               		.loc 1 165 0
 571 0022 0C94 0000 		jmp bootloader_jump
 572               	.LVL37:
 573               		.cfi_endproc
 574               	.LFE38:
 576               		.section	.text.process_record_quantum,"ax",@progbits
 577               	.global	process_record_quantum
 579               	process_record_quantum:
 580               	.LFB39:
 166:quantum/quantum.c **** }
 167:quantum/quantum.c **** 
 168:quantum/quantum.c **** // Shift / paren setup
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** #ifndef LSPO_KEY
 171:quantum/quantum.c ****   #define LSPO_KEY KC_9
 172:quantum/quantum.c **** #endif
 173:quantum/quantum.c **** #ifndef RSPC_KEY
 174:quantum/quantum.c ****   #define RSPC_KEY KC_0
 175:quantum/quantum.c **** #endif
 176:quantum/quantum.c **** 
 177:quantum/quantum.c **** // Shift / Enter setup
 178:quantum/quantum.c **** #ifndef SFTENT_KEY
 179:quantum/quantum.c ****   #define SFTENT_KEY KC_ENT
 180:quantum/quantum.c **** #endif
 181:quantum/quantum.c **** 
 182:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 183:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 184:quantum/quantum.c **** 
 185:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 186:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 187:quantum/quantum.c ****  */
 188:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 581               		.loc 1 190 0
 582               		.cfi_startproc
 583               	.LVL38:
 584 0000 0F93      		push r16
 585               	.LCFI8:
 586               		.cfi_def_cfa_offset 3
 587               		.cfi_offset 16, -2
 588 0002 1F93      		push r17
 589               	.LCFI9:
 590               		.cfi_def_cfa_offset 4
 591               		.cfi_offset 17, -3
 592 0004 CF93      		push r28
 593               	.LCFI10:
 594               		.cfi_def_cfa_offset 5
 595               		.cfi_offset 28, -4
 596 0006 DF93      		push r29
 597               	.LCFI11:
 598               		.cfi_def_cfa_offset 6
 599               		.cfi_offset 29, -5
 600               	/* prologue: function */
 601               	/* frame size = 0 */
 602               	/* stack size = 4 */
 603               	.L__stack_usage = 4
 604 0008 8C01      		movw r16,r24
 191:quantum/quantum.c **** 
 192:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 193:quantum/quantum.c ****   keypos_t key = record->event.key;
 605               		.loc 1 193 0
 606 000a FC01      		movw r30,r24
 607 000c C081      		ld r28,Z
 608 000e D181      		ldd r29,Z+1
 609               	.LVL39:
 194:quantum/quantum.c ****   uint16_t keycode;
 195:quantum/quantum.c **** 
 196:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 197:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 198:quantum/quantum.c ****     if (!disable_action_cache) {
 199:quantum/quantum.c ****       uint8_t layer;
 200:quantum/quantum.c **** 
 201:quantum/quantum.c ****       if (record->event.pressed) {
 202:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 203:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 204:quantum/quantum.c ****       } else {
 205:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 206:quantum/quantum.c ****       }
 207:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 208:quantum/quantum.c ****     } else
 209:quantum/quantum.c ****   #endif
 210:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 610               		.loc 1 210 0
 611 0010 CE01      		movw r24,r28
 612               	.LVL40:
 613 0012 0E94 0000 		call layer_switch_get_layer
 614               	.LVL41:
 615 0016 BE01      		movw r22,r28
 616 0018 0E94 0000 		call keymap_key_to_keycode
 617               	.LVL42:
 618 001c EC01      		movw r28,r24
 619               	.LVL43:
 211:quantum/quantum.c **** 
 212:quantum/quantum.c ****     // This is how you use actions here
 213:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 214:quantum/quantum.c ****     //   action_t action;
 215:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 216:quantum/quantum.c ****     //   process_action(record, action);
 217:quantum/quantum.c ****     //   return false;
 218:quantum/quantum.c ****     // }
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 221:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 620               		.loc 1 221 0
 621 001e B801      		movw r22,r16
 622 0020 0E94 0000 		call preprocess_tap_dance
 623               	.LVL44:
 222:quantum/quantum.c ****   #endif
 223:quantum/quantum.c **** 
 224:quantum/quantum.c ****   if (!(
 225:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 226:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 227:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 228:quantum/quantum.c ****   #endif
 229:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 230:quantum/quantum.c ****       process_clicky(keycode, record) &&
 231:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 624               		.loc 1 232 0
 625 0024 B801      		movw r22,r16
 626 0026 CE01      		movw r24,r28
 627 0028 0E94 0000 		call process_record_kb
 628               	.LVL45:
 233:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 234:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 235:quantum/quantum.c ****   #endif
 236:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 237:quantum/quantum.c ****     process_midi(keycode, record) &&
 238:quantum/quantum.c ****   #endif
 239:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 240:quantum/quantum.c ****     process_audio(keycode, record) &&
 241:quantum/quantum.c ****   #endif
 242:quantum/quantum.c ****   #ifdef STENO_ENABLE
 243:quantum/quantum.c ****     process_steno(keycode, record) &&
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c ****   #if ( defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSI
 246:quantum/quantum.c ****     process_music(keycode, record) &&
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 629               		.loc 1 249 0
 630 002c 8823      		tst r24
 631 002e 01F4      		brne .+2
 632 0030 00C0      		rjmp .L121
 633               		.loc 1 249 0 is_stmt 0 discriminator 2
 634 0032 B801      		movw r22,r16
 635 0034 CE01      		movw r24,r28
 636 0036 0E94 0000 		call process_tap_dance
 637               	.LVL46:
 232:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 638               		.loc 1 232 0 is_stmt 1 discriminator 2
 639 003a 8823      		tst r24
 640 003c 01F4      		brne .+2
 641 003e 00C0      		rjmp .L121
 250:quantum/quantum.c ****   #endif
 251:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 252:quantum/quantum.c ****     process_leader(keycode, record) &&
 642               		.loc 1 252 0 discriminator 3
 643 0040 B801      		movw r22,r16
 644 0042 CE01      		movw r24,r28
 645 0044 0E94 0000 		call process_leader
 646               	.LVL47:
 249:quantum/quantum.c ****   #endif
 647               		.loc 1 249 0 discriminator 3
 648 0048 8823      		tst r24
 649 004a 01F4      		brne .+2
 650 004c 00C0      		rjmp .L121
 253:quantum/quantum.c ****   #endif
 254:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 255:quantum/quantum.c ****     process_chording(keycode, record) &&
 256:quantum/quantum.c ****   #endif
 257:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 258:quantum/quantum.c ****     process_combo(keycode, record) &&
 259:quantum/quantum.c ****   #endif
 260:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 261:quantum/quantum.c ****     process_unicode(keycode, record) &&
 262:quantum/quantum.c ****   #endif
 263:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 264:quantum/quantum.c ****     process_ucis(keycode, record) &&
 265:quantum/quantum.c ****   #endif
 266:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 267:quantum/quantum.c ****     process_printer(keycode, record) &&
 268:quantum/quantum.c ****   #endif
 269:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 270:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 271:quantum/quantum.c ****   #endif
 272:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 273:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 274:quantum/quantum.c ****   #endif
 275:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 276:quantum/quantum.c ****     process_terminal(keycode, record) &&
 277:quantum/quantum.c ****   #endif
 278:quantum/quantum.c ****       true)) {
 279:quantum/quantum.c ****     return false;
 280:quantum/quantum.c ****   }
 281:quantum/quantum.c **** 
 282:quantum/quantum.c ****   // Shift / paren setup
 283:quantum/quantum.c **** 
 284:quantum/quantum.c ****   switch(keycode) {
 651               		.loc 1 284 0
 652 004e C531      		cpi r28,21
 653 0050 FCE5      		ldi r31,92
 654 0052 DF07      		cpc r29,r31
 655 0054 01F4      		brne .L135
 656               	.LBB29:
 285:quantum/quantum.c ****     case RESET:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 287:quantum/quantum.c ****         reset_keyboard();
 288:quantum/quantum.c ****       }
 289:quantum/quantum.c ****     return false;
 290:quantum/quantum.c ****     case DEBUG:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 292:quantum/quantum.c ****           debug_enable = true;
 293:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 294:quantum/quantum.c ****       }
 295:quantum/quantum.c ****     return false;
 296:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 297:quantum/quantum.c ****   case FC_TOG:
 298:quantum/quantum.c ****     if (record->event.pressed) {
 299:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 300:quantum/quantum.c ****     }
 301:quantum/quantum.c ****     return false;
 302:quantum/quantum.c ****   case FC_ON:
 303:quantum/quantum.c ****     if (record->event.pressed) {
 304:quantum/quantum.c ****       FAUXCLICKY_ON;
 305:quantum/quantum.c ****     }
 306:quantum/quantum.c ****     return false;
 307:quantum/quantum.c ****   case FC_OFF:
 308:quantum/quantum.c ****     if (record->event.pressed) {
 309:quantum/quantum.c ****       FAUXCLICKY_OFF;
 310:quantum/quantum.c ****     }
 311:quantum/quantum.c ****     return false;
 312:quantum/quantum.c ****   #endif
 313:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 314:quantum/quantum.c ****   case RGB_TOG:
 315:quantum/quantum.c ****     if (record->event.pressed) {
 316:quantum/quantum.c ****       rgblight_toggle();
 317:quantum/quantum.c ****     }
 318:quantum/quantum.c ****     return false;
 319:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 320:quantum/quantum.c ****     if (record->event.pressed) {
 321:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 322:quantum/quantum.c ****       if(shifted) {
 323:quantum/quantum.c ****         rgblight_step_reverse();
 324:quantum/quantum.c ****       }
 325:quantum/quantum.c ****       else {
 326:quantum/quantum.c ****         rgblight_step();
 327:quantum/quantum.c ****       }
 328:quantum/quantum.c ****     }
 329:quantum/quantum.c ****     return false;
 330:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 331:quantum/quantum.c ****     if (record->event.pressed) {
 332:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 333:quantum/quantum.c ****       if(shifted) {
 334:quantum/quantum.c ****         rgblight_step();
 335:quantum/quantum.c ****       }
 336:quantum/quantum.c ****       else {
 337:quantum/quantum.c ****         rgblight_step_reverse();
 338:quantum/quantum.c ****       }
 339:quantum/quantum.c ****     }
 340:quantum/quantum.c ****     return false;
 341:quantum/quantum.c ****   case RGB_HUI:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 343:quantum/quantum.c ****       rgblight_increase_hue();
 344:quantum/quantum.c ****     }
 345:quantum/quantum.c ****     return false;
 346:quantum/quantum.c ****   case RGB_HUD:
 347:quantum/quantum.c ****     if (record->event.pressed) {
 348:quantum/quantum.c ****       rgblight_decrease_hue();
 349:quantum/quantum.c ****     }
 350:quantum/quantum.c ****     return false;
 351:quantum/quantum.c ****   case RGB_SAI:
 352:quantum/quantum.c ****     if (record->event.pressed) {
 353:quantum/quantum.c ****       rgblight_increase_sat();
 354:quantum/quantum.c ****     }
 355:quantum/quantum.c ****     return false;
 356:quantum/quantum.c ****   case RGB_SAD:
 357:quantum/quantum.c ****     if (record->event.pressed) {
 358:quantum/quantum.c ****       rgblight_decrease_sat();
 359:quantum/quantum.c ****     }
 360:quantum/quantum.c ****     return false;
 361:quantum/quantum.c ****   case RGB_VAI:
 362:quantum/quantum.c ****     if (record->event.pressed) {
 363:quantum/quantum.c ****       rgblight_increase_val();
 364:quantum/quantum.c ****     }
 365:quantum/quantum.c ****     return false;
 366:quantum/quantum.c ****   case RGB_VAD:
 367:quantum/quantum.c ****     if (record->event.pressed) {
 368:quantum/quantum.c ****       rgblight_decrease_val();
 369:quantum/quantum.c ****     }
 370:quantum/quantum.c ****     return false;
 371:quantum/quantum.c ****   case RGB_SPI:
 372:quantum/quantum.c ****     if (record->event.pressed) {
 373:quantum/quantum.c ****       rgblight_increase_speed();
 374:quantum/quantum.c ****     }
 375:quantum/quantum.c ****     return false;
 376:quantum/quantum.c ****   case RGB_SPD:
 377:quantum/quantum.c ****     if (record->event.pressed) {
 378:quantum/quantum.c ****       rgblight_decrease_speed();
 379:quantum/quantum.c ****     }
 380:quantum/quantum.c ****     return false;
 381:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 382:quantum/quantum.c ****     if (record->event.pressed) {
 383:quantum/quantum.c ****       rgblight_mode(1);
 384:quantum/quantum.c ****     }
 385:quantum/quantum.c ****     return false;
 386:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 387:quantum/quantum.c ****     if (record->event.pressed) {
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 389:quantum/quantum.c ****         rgblight_step();
 390:quantum/quantum.c ****       } else {
 391:quantum/quantum.c ****         rgblight_mode(2);
 392:quantum/quantum.c ****       }
 393:quantum/quantum.c ****     }
 394:quantum/quantum.c ****     return false;
 395:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 396:quantum/quantum.c ****     if (record->event.pressed) {
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 398:quantum/quantum.c ****         rgblight_step();
 399:quantum/quantum.c ****       } else {
 400:quantum/quantum.c ****         rgblight_mode(6);
 401:quantum/quantum.c ****       }
 402:quantum/quantum.c ****     }
 403:quantum/quantum.c ****     return false;
 404:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 405:quantum/quantum.c ****     if (record->event.pressed) {
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 407:quantum/quantum.c ****         rgblight_step();
 408:quantum/quantum.c ****       } else {
 409:quantum/quantum.c ****         rgblight_mode(9);
 410:quantum/quantum.c ****       }
 411:quantum/quantum.c ****     }
 412:quantum/quantum.c ****     return false;
 413:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 414:quantum/quantum.c ****     if (record->event.pressed) {
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 416:quantum/quantum.c ****         rgblight_step();
 417:quantum/quantum.c ****       } else {
 418:quantum/quantum.c ****         rgblight_mode(15);
 419:quantum/quantum.c ****       }
 420:quantum/quantum.c ****     }
 421:quantum/quantum.c ****     return false;
 422:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 423:quantum/quantum.c ****     if (record->event.pressed) {
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 425:quantum/quantum.c ****         rgblight_step();
 426:quantum/quantum.c ****       } else {
 427:quantum/quantum.c ****         rgblight_mode(21);
 428:quantum/quantum.c ****       }
 429:quantum/quantum.c ****     }
 430:quantum/quantum.c ****     return false;
 431:quantum/quantum.c ****   case RGB_MODE_XMAS:
 432:quantum/quantum.c ****     if (record->event.pressed) {
 433:quantum/quantum.c ****       rgblight_mode(24);
 434:quantum/quantum.c ****     }
 435:quantum/quantum.c ****     return false;
 436:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 437:quantum/quantum.c ****     if (record->event.pressed) {
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 439:quantum/quantum.c ****         rgblight_step();
 440:quantum/quantum.c ****       } else {
 441:quantum/quantum.c ****         rgblight_mode(25);
 442:quantum/quantum.c ****       }
 443:quantum/quantum.c ****     }
 444:quantum/quantum.c ****     return false;
 445:quantum/quantum.c ****   #endif
 446:quantum/quantum.c ****     #ifdef PROTOCOL_LUFA
 447:quantum/quantum.c ****     case OUT_AUTO:
 448:quantum/quantum.c ****       if (record->event.pressed) {
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 450:quantum/quantum.c ****       }
 451:quantum/quantum.c ****       return false;
 452:quantum/quantum.c ****     case OUT_USB:
 453:quantum/quantum.c ****       if (record->event.pressed) {
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 455:quantum/quantum.c ****       }
 456:quantum/quantum.c ****       return false;
 457:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 458:quantum/quantum.c ****     case OUT_BT:
 459:quantum/quantum.c ****       if (record->event.pressed) {
 460:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 461:quantum/quantum.c ****       }
 462:quantum/quantum.c ****       return false;
 463:quantum/quantum.c ****     #endif
 464:quantum/quantum.c ****     #endif
 465:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 466:quantum/quantum.c ****       if (record->event.pressed) {
 467:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 468:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 469:quantum/quantum.c ****             eeconfig_init();
 470:quantum/quantum.c ****         }
 471:quantum/quantum.c ****         /* keymap config */
 472:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 473:quantum/quantum.c ****         switch (keycode)
 474:quantum/quantum.c ****         {
 475:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 476:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 477:quantum/quantum.c ****             break;
 478:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 479:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 480:quantum/quantum.c ****             break;
 481:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 482:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 483:quantum/quantum.c ****             break;
 484:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 485:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 486:quantum/quantum.c ****             break;
 487:quantum/quantum.c ****           case MAGIC_NO_GUI:
 488:quantum/quantum.c ****             keymap_config.no_gui = true;
 489:quantum/quantum.c ****             break;
 490:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 491:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 492:quantum/quantum.c ****             break;
 493:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 494:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 495:quantum/quantum.c ****             break;
 496:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 497:quantum/quantum.c ****             keymap_config.nkro = true;
 498:quantum/quantum.c ****             break;
 499:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 500:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 501:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 502:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 503:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 504:quantum/quantum.c ****             #endif
 505:quantum/quantum.c ****             break;
 506:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 507:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 508:quantum/quantum.c ****             break;
 509:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 510:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 511:quantum/quantum.c ****             break;
 512:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 513:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 514:quantum/quantum.c ****             break;
 515:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 516:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 517:quantum/quantum.c ****             break;
 518:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 519:quantum/quantum.c ****             keymap_config.no_gui = false;
 520:quantum/quantum.c ****             break;
 521:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 522:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 523:quantum/quantum.c ****             break;
 524:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 525:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 526:quantum/quantum.c ****             break;
 527:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 528:quantum/quantum.c ****             keymap_config.nkro = false;
 529:quantum/quantum.c ****             break;
 530:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 531:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 532:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 533:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 534:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 535:quantum/quantum.c ****             #endif
 536:quantum/quantum.c ****             break;
 537:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 538:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 539:quantum/quantum.c ****             break;
 540:quantum/quantum.c ****           default:
 541:quantum/quantum.c ****             break;
 542:quantum/quantum.c ****         }
 543:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 544:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 545:quantum/quantum.c **** 
 546:quantum/quantum.c ****         return false;
 547:quantum/quantum.c ****       }
 548:quantum/quantum.c ****       break;
 549:quantum/quantum.c ****     case KC_LSPO: {
 550:quantum/quantum.c ****       if (record->event.pressed) {
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 554:quantum/quantum.c ****       }
 555:quantum/quantum.c ****       else {
 556:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 557:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 558:quantum/quantum.c ****             shift_interrupted[0] = true;
 559:quantum/quantum.c ****             shift_interrupted[1] = true;
 560:quantum/quantum.c ****           }
 561:quantum/quantum.c ****         #endif
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 565:quantum/quantum.c ****         }
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 567:quantum/quantum.c ****       }
 568:quantum/quantum.c ****       return false;
 569:quantum/quantum.c ****     }
 570:quantum/quantum.c **** 
 571:quantum/quantum.c ****     case KC_RSPC: {
 572:quantum/quantum.c ****       if (record->event.pressed) {
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 576:quantum/quantum.c ****       }
 577:quantum/quantum.c ****       else {
 578:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 579:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 580:quantum/quantum.c ****             shift_interrupted[0] = true;
 581:quantum/quantum.c ****             shift_interrupted[1] = true;
 582:quantum/quantum.c ****           }
 583:quantum/quantum.c ****         #endif
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 587:quantum/quantum.c ****         }
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 589:quantum/quantum.c ****       }
 590:quantum/quantum.c ****       return false;
 591:quantum/quantum.c ****     }
 592:quantum/quantum.c **** 
 593:quantum/quantum.c ****     case KC_SFTENT: {
 594:quantum/quantum.c ****       if (record->event.pressed) {
 595:quantum/quantum.c ****         shift_interrupted[1] = false;
 596:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 597:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 598:quantum/quantum.c ****       }
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 603:quantum/quantum.c ****       }
 604:quantum/quantum.c ****       else {
 605:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 606:quantum/quantum.c ****       }
 607:quantum/quantum.c ****       return false;
 608:quantum/quantum.c ****     }
 609:quantum/quantum.c **** 
 610:quantum/quantum.c ****     case GRAVE_ESC: {
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 657               		.loc 1 611 0
 658 0056 0E94 0000 		call get_mods
 659               	.LVL48:
 660 005a 982F      		mov r25,r24
 661               	.LVL49:
 612:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 613:quantum/quantum.c **** 
 614:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 615:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 616:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 617:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 618:quantum/quantum.c ****         shifted = 0;
 619:quantum/quantum.c ****       }
 620:quantum/quantum.c **** #endif
 621:quantum/quantum.c **** 
 622:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 623:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 624:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 625:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 626:quantum/quantum.c ****         shifted = 0;
 627:quantum/quantum.c ****       }
 628:quantum/quantum.c **** #endif
 629:quantum/quantum.c **** 
 630:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 631:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 632:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 633:quantum/quantum.c ****         shifted = 0;
 634:quantum/quantum.c ****       }
 635:quantum/quantum.c **** #endif
 636:quantum/quantum.c **** 
 637:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 638:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 639:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 640:quantum/quantum.c ****         shifted = 0;
 641:quantum/quantum.c ****       }
 642:quantum/quantum.c **** #endif
 643:quantum/quantum.c **** 
 644:quantum/quantum.c ****       if (record->event.pressed) {
 662               		.loc 1 644 0
 663 005c F801      		movw r30,r16
 664 005e 8281      		ldd r24,Z+2
 665               	.LVL50:
 666 0060 2091 0000 		lds r18,keyboard_report
 667 0064 3091 0000 		lds r19,keyboard_report+1
 668 0068 8823      		tst r24
 669 006a 01F0      		breq .L97
 611:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 670               		.loc 1 611 0
 671 006c 9A7A      		andi r25,lo8(-86)
 672               	.LVL51:
 645:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 673               		.loc 1 645 0
 674 006e 81E0      		ldi r24,lo8(1)
 675 0070 01F4      		brne .L98
 676 0072 80E0      		ldi r24,0
 677               	.L98:
 678 0074 8093 0000 		sts grave_esc_was_shifted,r24
 646:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 679               		.loc 1 646 0
 680 0078 9111      		cpse r25,__zero_reg__
 681 007a 00C0      		rjmp .L105
 682 007c 69E2      		ldi r22,lo8(41)
 683 007e 00C0      		rjmp .L99
 684               	.L105:
 685 0080 65E3      		ldi r22,lo8(53)
 686               	.L99:
 687               	.LVL52:
 688               	.LBB30:
 689               	.LBB31:
 690               		.file 3 "./tmk_core/common/action_util.h"
   1:./tmk_core/common/action_util.h **** /*
   2:./tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action_util.h **** 
   4:./tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action_util.h **** (at your option) any later version.
   8:./tmk_core/common/action_util.h **** 
   9:./tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:./tmk_core/common/action_util.h **** 
  14:./tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action_util.h **** */
  17:./tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:./tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:./tmk_core/common/action_util.h **** 
  20:./tmk_core/common/action_util.h **** #include <stdint.h>
  21:./tmk_core/common/action_util.h **** #include "report.h"
  22:./tmk_core/common/action_util.h **** 
  23:./tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:./tmk_core/common/action_util.h **** extern "C" {
  25:./tmk_core/common/action_util.h **** #endif
  26:./tmk_core/common/action_util.h **** 
  27:./tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:./tmk_core/common/action_util.h **** 
  29:./tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:./tmk_core/common/action_util.h **** 
  31:./tmk_core/common/action_util.h **** /* key */
  32:./tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 691               		.loc 3 33 0 discriminator 4
 692 0082 C901      		movw r24,r18
 693 0084 0E94 0000 		call add_key_to_report
 694               	.LVL53:
 695 0088 00C0      		rjmp .L100
 696               	.LVL54:
 697               	.L97:
 698               	.LBE31:
 699               	.LBE30:
 647:quantum/quantum.c ****       }
 648:quantum/quantum.c ****       else {
 649:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 700               		.loc 1 649 0
 701 008a 8091 0000 		lds r24,grave_esc_was_shifted
 702 008e 8111      		cpse r24,__zero_reg__
 703 0090 00C0      		rjmp .L106
 704 0092 69E2      		ldi r22,lo8(41)
 705 0094 00C0      		rjmp .L101
 706               	.L106:
 707 0096 65E3      		ldi r22,lo8(53)
 708               	.L101:
 709               	.LVL55:
 710               	.LBB32:
 711               	.LBB33:
  34:./tmk_core/common/action_util.h **** }
  35:./tmk_core/common/action_util.h **** 
  36:./tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:./tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 712               		.loc 3 37 0 discriminator 4
 713 0098 C901      		movw r24,r18
 714 009a 0E94 0000 		call del_key_from_report
 715               	.LVL56:
 716               	.L100:
 717               	.LBE33:
 718               	.LBE32:
 650:quantum/quantum.c ****       }
 651:quantum/quantum.c **** 
 652:quantum/quantum.c ****       send_keyboard_report();
 719               		.loc 1 652 0
 720 009e 0E94 0000 		call send_keyboard_report
 721               	.LVL57:
 653:quantum/quantum.c ****       return false;
 722               		.loc 1 653 0
 723 00a2 00C0      		rjmp .L121
 724               	.L135:
 725               	.LBE29:
 284:quantum/quantum.c ****     case RESET:
 726               		.loc 1 284 0
 727 00a4 C631      		cpi r28,22
 728 00a6 8CE5      		ldi r24,92
 729 00a8 D807      		cpc r29,r24
 730 00aa 00F0      		brlo .+2
 731 00ac 00C0      		rjmp .L103
 732 00ae C130      		cpi r28,1
 733 00b0 ECE5      		ldi r30,92
 734 00b2 DE07      		cpc r29,r30
 735 00b4 01F4      		brne .L136
 291:quantum/quantum.c ****           debug_enable = true;
 736               		.loc 1 291 0
 737 00b6 F801      		movw r30,r16
 738 00b8 8281      		ldd r24,Z+2
 739 00ba 8823      		tst r24
 740 00bc 01F4      		brne .+2
 741 00be 00C0      		rjmp .L121
 292:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 742               		.loc 1 292 0
 743 00c0 8091 0000 		lds r24,debug_config
 744 00c4 8160      		ori r24,lo8(1<<0)
 745 00c6 8093 0000 		sts debug_config,r24
 746 00ca 00C0      		rjmp .L121
 747               	.L136:
 284:quantum/quantum.c ****     case RESET:
 748               		.loc 1 284 0
 749 00cc C230      		cpi r28,2
 750 00ce FCE5      		ldi r31,92
 751 00d0 DF07      		cpc r29,r31
 752 00d2 00F4      		brsh .+2
 753 00d4 00C0      		rjmp .L137
 466:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 754               		.loc 1 466 0
 755 00d6 F801      		movw r30,r16
 756 00d8 8281      		ldd r24,Z+2
 757 00da 8823      		tst r24
 758 00dc 01F4      		brne .+2
 759 00de 00C0      		rjmp .L61
 468:quantum/quantum.c ****             eeconfig_init();
 760               		.loc 1 468 0
 761 00e0 0E94 0000 		call eeconfig_is_enabled
 762               	.LVL58:
 763 00e4 8111      		cpse r24,__zero_reg__
 764 00e6 00C0      		rjmp .L62
 469:quantum/quantum.c ****         }
 765               		.loc 1 469 0
 766 00e8 0E94 0000 		call eeconfig_init
 767               	.LVL59:
 768               	.L62:
 472:quantum/quantum.c ****         switch (keycode)
 769               		.loc 1 472 0
 770 00ec 0E94 0000 		call eeconfig_read_keymap
 771               	.LVL60:
 772 00f0 90E0      		ldi r25,0
 773 00f2 9093 0000 		sts keymap_config+1,r25
 774 00f6 8093 0000 		sts keymap_config,r24
 473:quantum/quantum.c ****         {
 775               		.loc 1 473 0
 776 00fa FE01      		movw r30,r28
 777 00fc E350      		subi r30,3
 778 00fe FC45      		sbci r31,92
 779 0100 E231      		cpi r30,18
 780 0102 F105      		cpc r31,__zero_reg__
 781 0104 00F4      		brsh .L63
 782 0106 E050      		subi r30,lo8(-(gs(.L65)))
 783 0108 F040      		sbci r31,hi8(-(gs(.L65)))
 538:quantum/quantum.c ****             break;
 784               		.loc 1 538 0
 785 010a 8091 0000 		lds r24,keymap_config
 473:quantum/quantum.c ****         {
 786               		.loc 1 473 0
 787 010e 0C94 0000 		jmp __tablejump2__
 788               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 789               		.p2align	1
 790               	.L65:
 791 0000 0000      		.word gs(.L64)
 792 0002 0000      		.word gs(.L66)
 793 0004 0000      		.word gs(.L134)
 794 0006 0000      		.word gs(.L68)
 795 0008 0000      		.word gs(.L69)
 796 000a 0000      		.word gs(.L70)
 797 000c 0000      		.word gs(.L71)
 798 000e 0000      		.word gs(.L72)
 799 0010 0000      		.word gs(.L73)
 800 0012 0000      		.word gs(.L74)
 801 0014 0000      		.word gs(.L75)
 802 0016 0000      		.word gs(.L133)
 803 0018 0000      		.word gs(.L77)
 804 001a 0000      		.word gs(.L78)
 805 001c 0000      		.word gs(.L79)
 806 001e 0000      		.word gs(.L80)
 807 0020 0000      		.word gs(.L81)
 808 0022 0000      		.word gs(.L82)
 809               		.section	.text.process_record_quantum
 810               	.L63:
 476:quantum/quantum.c ****             break;
 811               		.loc 1 476 0
 812 0112 8091 0000 		lds r24,keymap_config
 813 0116 8160      		ori r24,lo8(1<<0)
 814 0118 00C0      		rjmp .L129
 815               	.L64:
 479:quantum/quantum.c ****             break;
 816               		.loc 1 479 0
 817 011a 8260      		ori r24,lo8(1<<1)
 818 011c 00C0      		rjmp .L129
 819               	.L66:
 482:quantum/quantum.c ****             break;
 820               		.loc 1 482 0
 821 011e 8460      		ori r24,lo8(1<<2)
 822 0120 00C0      		rjmp .L129
 823               	.L68:
 488:quantum/quantum.c ****             break;
 824               		.loc 1 488 0
 825 0122 8061      		ori r24,lo8(1<<4)
 826 0124 00C0      		rjmp .L129
 827               	.L69:
 491:quantum/quantum.c ****             break;
 828               		.loc 1 491 0
 829 0126 8062      		ori r24,lo8(1<<5)
 830 0128 00C0      		rjmp .L129
 831               	.L70:
 494:quantum/quantum.c ****             break;
 832               		.loc 1 494 0
 833 012a 8064      		ori r24,lo8(1<<6)
 834 012c 00C0      		rjmp .L129
 835               	.L71:
 497:quantum/quantum.c ****             break;
 836               		.loc 1 497 0
 837 012e 8068      		ori r24,lo8(1<<7)
 838 0130 00C0      		rjmp .L129
 839               	.L72:
 501:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 840               		.loc 1 501 0
 841 0132 8460      		ori r24,lo8(4)
 842               	.L134:
 843 0134 8860      		ori r24,lo8(1<<3)
 844 0136 00C0      		rjmp .L129
 845               	.L73:
 507:quantum/quantum.c ****             break;
 846               		.loc 1 507 0
 847 0138 8E7F      		andi r24,lo8(~(1<<0))
 848 013a 00C0      		rjmp .L129
 849               	.L74:
 510:quantum/quantum.c ****             break;
 850               		.loc 1 510 0
 851 013c 8D7F      		andi r24,lo8(~(1<<1))
 852 013e 00C0      		rjmp .L129
 853               	.L75:
 513:quantum/quantum.c ****             break;
 854               		.loc 1 513 0
 855 0140 8B7F      		andi r24,lo8(~(1<<2))
 856 0142 00C0      		rjmp .L129
 857               	.L77:
 519:quantum/quantum.c ****             break;
 858               		.loc 1 519 0
 859 0144 8F7E      		andi r24,lo8(~(1<<4))
 860 0146 00C0      		rjmp .L129
 861               	.L78:
 522:quantum/quantum.c ****             break;
 862               		.loc 1 522 0
 863 0148 8F7D      		andi r24,lo8(~(1<<5))
 864 014a 00C0      		rjmp .L129
 865               	.L79:
 525:quantum/quantum.c ****             break;
 866               		.loc 1 525 0
 867 014c 8F7B      		andi r24,lo8(~(1<<6))
 868 014e 00C0      		rjmp .L129
 869               	.L80:
 528:quantum/quantum.c ****             break;
 870               		.loc 1 528 0
 871 0150 8F77      		andi r24,lo8(~(1<<7))
 872 0152 00C0      		rjmp .L129
 873               	.L81:
 532:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 874               		.loc 1 532 0
 875 0154 8B7F      		andi r24,lo8(-5)
 876               	.L133:
 877 0156 877F      		andi r24,lo8(~(1<<3))
 878 0158 00C0      		rjmp .L129
 879               	.L82:
 538:quantum/quantum.c ****             break;
 880               		.loc 1 538 0
 881 015a 87FB      		bst r24,7
 882 015c 2227      		clr r18
 883 015e 20F9      		bld r18,0
 884 0160 91E0      		ldi r25,lo8(1)
 885 0162 9227      		eor r25,r18
 886 0164 90FB      		bst r25,0
 887 0166 87F9      		bld r24,7
 888               	.L129:
 889 0168 8093 0000 		sts keymap_config,r24
 543:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 890               		.loc 1 543 0
 891 016c 8091 0000 		lds r24,keymap_config
 892 0170 0E94 0000 		call eeconfig_update_keymap
 893               	.LVL61:
 544:quantum/quantum.c **** 
 894               		.loc 1 544 0
 895 0174 0E94 0000 		call clear_keyboard
 896               	.LVL62:
 546:quantum/quantum.c ****       }
 897               		.loc 1 546 0
 898 0178 00C0      		rjmp .L121
 899               	.L137:
 284:quantum/quantum.c ****     case RESET:
 900               		.loc 1 284 0
 901 017a C115      		cp r28,__zero_reg__
 902 017c DC45      		sbci r29,92
 903 017e 01F0      		breq .L54
 904               	.L102:
 654:quantum/quantum.c ****     }
 655:quantum/quantum.c **** 
 656:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 657:quantum/quantum.c ****     case BL_BRTG: {
 658:quantum/quantum.c ****       if (record->event.pressed)
 659:quantum/quantum.c ****         breathing_toggle();
 660:quantum/quantum.c ****       return false;
 661:quantum/quantum.c ****     }
 662:quantum/quantum.c **** #endif
 663:quantum/quantum.c **** 
 664:quantum/quantum.c ****     default: {
 665:quantum/quantum.c ****       shift_interrupted[0] = true;
 905               		.loc 1 665 0
 906 0180 81E0      		ldi r24,lo8(1)
 907 0182 8093 0000 		sts shift_interrupted,r24
 666:quantum/quantum.c ****       shift_interrupted[1] = true;
 908               		.loc 1 666 0
 909 0186 8093 0000 		sts shift_interrupted+1,r24
 910               	.L61:
 667:quantum/quantum.c ****       break;
 668:quantum/quantum.c ****     }
 669:quantum/quantum.c ****   }
 670:quantum/quantum.c **** 
 671:quantum/quantum.c ****   return process_action_kb(record);
 911               		.loc 1 671 0
 912 018a C801      		movw r24,r16
 913               	/* epilogue start */
 672:quantum/quantum.c **** }
 914               		.loc 1 672 0
 915 018c DF91      		pop r29
 916 018e CF91      		pop r28
 917               	.LVL63:
 918 0190 1F91      		pop r17
 919 0192 0F91      		pop r16
 920               	.LVL64:
 671:quantum/quantum.c **** }
 921               		.loc 1 671 0
 922 0194 0C94 0000 		jmp process_action_kb
 923               	.LVL65:
 924               	.L54:
 286:quantum/quantum.c ****         reset_keyboard();
 925               		.loc 1 286 0
 926 0198 F801      		movw r30,r16
 927 019a 8281      		ldd r24,Z+2
 928 019c 8823      		tst r24
 929 019e 01F4      		brne .+2
 930 01a0 00C0      		rjmp .L121
 287:quantum/quantum.c ****       }
 931               		.loc 1 287 0
 932 01a2 0E94 0000 		call reset_keyboard
 933               	.LVL66:
 934 01a6 00C0      		rjmp .L121
 935               	.L103:
 284:quantum/quantum.c ****     case RESET:
 936               		.loc 1 284 0
 937 01a8 C53D      		cpi r28,-43
 938 01aa ECE5      		ldi r30,92
 939 01ac DE07      		cpc r29,r30
 940 01ae 01F4      		brne .L138
 594:quantum/quantum.c ****         shift_interrupted[1] = false;
 941               		.loc 1 594 0
 942 01b0 F801      		movw r30,r16
 943 01b2 8281      		ldd r24,Z+2
 944 01b4 8823      		tst r24
 945 01b6 01F0      		breq .L139
 946               	.L95:
 573:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 947               		.loc 1 573 0
 948 01b8 1092 0000 		sts shift_interrupted+1,__zero_reg__
 574:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 949               		.loc 1 574 0
 950 01bc 0E94 0000 		call timer_read
 951               	.LVL67:
 952 01c0 9093 0000 		sts scs_timer+2+1,r25
 953 01c4 8093 0000 		sts scs_timer+2,r24
 575:quantum/quantum.c ****       }
 954               		.loc 1 575 0
 955 01c8 80E2      		ldi r24,lo8(32)
 956               	.L131:
 957 01ca 0E94 0000 		call register_mods
 958               	.LVL68:
 959 01ce 00C0      		rjmp .L121
 960               	.L139:
 599:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 961               		.loc 1 599 0
 962 01d0 8091 0000 		lds r24,shift_interrupted+1
 963 01d4 8823      		tst r24
 964 01d6 01F0      		breq .L140
 965               	.L92:
 588:quantum/quantum.c ****       }
 966               		.loc 1 588 0
 967 01d8 80E2      		ldi r24,lo8(32)
 968               	.L132:
 969 01da 0E94 0000 		call unregister_mods
 970               	.LVL69:
 971 01de 00C0      		rjmp .L121
 972               	.L140:
 599:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 973               		.loc 1 599 0 discriminator 1
 974 01e0 8091 0000 		lds r24,scs_timer+2
 975 01e4 9091 0000 		lds r25,scs_timer+2+1
 976 01e8 0E94 0000 		call timer_elapsed
 977               	.LVL70:
 978 01ec 8639      		cpi r24,-106
 979 01ee 9105      		cpc r25,__zero_reg__
 980 01f0 00F4      		brsh .L92
 600:quantum/quantum.c ****         register_code(SFTENT_KEY);
 981               		.loc 1 600 0
 982 01f2 80E2      		ldi r24,lo8(32)
 983 01f4 0E94 0000 		call unregister_mods
 984               	.LVL71:
 601:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 985               		.loc 1 601 0
 986 01f8 88E2      		ldi r24,lo8(40)
 987 01fa 0E94 0000 		call register_code
 988               	.LVL72:
 602:quantum/quantum.c ****       }
 989               		.loc 1 602 0
 990 01fe 88E2      		ldi r24,lo8(40)
 991 0200 0E94 0000 		call unregister_code
 992               	.LVL73:
 993 0204 00C0      		rjmp .L121
 994               	.L138:
 284:quantum/quantum.c ****     case RESET:
 995               		.loc 1 284 0
 996 0206 C63D      		cpi r28,-42
 997 0208 FCE5      		ldi r31,92
 998 020a DF07      		cpc r29,r31
 999 020c 00F0      		brlo .+2
 1000 020e 00C0      		rjmp .L104
 1001 0210 C33D      		cpi r28,-45
 1002 0212 8CE5      		ldi r24,92
 1003 0214 D807      		cpc r29,r24
 1004 0216 01F4      		brne .L141
 550:quantum/quantum.c ****         shift_interrupted[0] = false;
 1005               		.loc 1 550 0
 1006 0218 F801      		movw r30,r16
 1007 021a 8281      		ldd r24,Z+2
 1008 021c 8823      		tst r24
 1009 021e 01F0      		breq .L85
 551:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 1010               		.loc 1 551 0
 1011 0220 1092 0000 		sts shift_interrupted,__zero_reg__
 552:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 1012               		.loc 1 552 0
 1013 0224 0E94 0000 		call timer_read
 1014               	.LVL74:
 1015 0228 9093 0000 		sts scs_timer+1,r25
 1016 022c 8093 0000 		sts scs_timer,r24
 553:quantum/quantum.c ****       }
 1017               		.loc 1 553 0
 1018 0230 82E0      		ldi r24,lo8(2)
 1019 0232 00C0      		rjmp .L131
 1020               	.L85:
 562:quantum/quantum.c ****           register_code(LSPO_KEY);
 1021               		.loc 1 562 0
 1022 0234 8091 0000 		lds r24,shift_interrupted
 1023 0238 8111      		cpse r24,__zero_reg__
 1024 023a 00C0      		rjmp .L87
 562:quantum/quantum.c ****           register_code(LSPO_KEY);
 1025               		.loc 1 562 0 is_stmt 0 discriminator 1
 1026 023c 8091 0000 		lds r24,scs_timer
 1027 0240 9091 0000 		lds r25,scs_timer+1
 1028 0244 0E94 0000 		call timer_elapsed
 1029               	.LVL75:
 1030 0248 8639      		cpi r24,-106
 1031 024a 9105      		cpc r25,__zero_reg__
 1032 024c 00F4      		brsh .L87
 563:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 1033               		.loc 1 563 0 is_stmt 1
 1034 024e 86E2      		ldi r24,lo8(38)
 1035 0250 0E94 0000 		call register_code
 1036               	.LVL76:
 564:quantum/quantum.c ****         }
 1037               		.loc 1 564 0
 1038 0254 86E2      		ldi r24,lo8(38)
 1039 0256 0E94 0000 		call unregister_code
 1040               	.LVL77:
 1041               	.L87:
 566:quantum/quantum.c ****       }
 1042               		.loc 1 566 0
 1043 025a 82E0      		ldi r24,lo8(2)
 1044 025c 00C0      		rjmp .L132
 1045               	.L141:
 284:quantum/quantum.c ****     case RESET:
 1046               		.loc 1 284 0
 1047 025e C43D      		cpi r28,-44
 1048 0260 DC45      		sbci r29,92
 1049 0262 01F0      		breq .+2
 1050 0264 00C0      		rjmp .L102
 572:quantum/quantum.c ****         shift_interrupted[1] = false;
 1051               		.loc 1 572 0
 1052 0266 F801      		movw r30,r16
 1053 0268 8281      		ldd r24,Z+2
 1054 026a 8111      		cpse r24,__zero_reg__
 1055 026c 00C0      		rjmp .L95
 584:quantum/quantum.c ****           register_code(RSPC_KEY);
 1056               		.loc 1 584 0
 1057 026e 8091 0000 		lds r24,shift_interrupted+1
 1058 0272 8111      		cpse r24,__zero_reg__
 1059 0274 00C0      		rjmp .L92
 584:quantum/quantum.c ****           register_code(RSPC_KEY);
 1060               		.loc 1 584 0 is_stmt 0 discriminator 1
 1061 0276 8091 0000 		lds r24,scs_timer+2
 1062 027a 9091 0000 		lds r25,scs_timer+2+1
 1063 027e 0E94 0000 		call timer_elapsed
 1064               	.LVL78:
 1065 0282 8639      		cpi r24,-106
 1066 0284 9105      		cpc r25,__zero_reg__
 1067 0286 00F0      		brlo .+2
 1068 0288 00C0      		rjmp .L92
 585:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 1069               		.loc 1 585 0 is_stmt 1
 1070 028a 87E2      		ldi r24,lo8(39)
 1071 028c 0E94 0000 		call register_code
 1072               	.LVL79:
 586:quantum/quantum.c ****         }
 1073               		.loc 1 586 0
 1074 0290 87E2      		ldi r24,lo8(39)
 1075 0292 0E94 0000 		call unregister_code
 1076               	.LVL80:
 1077 0296 00C0      		rjmp .L92
 1078               	.L104:
 284:quantum/quantum.c ****     case RESET:
 1079               		.loc 1 284 0
 1080 0298 C83D      		cpi r28,-40
 1081 029a FCE5      		ldi r31,92
 1082 029c DF07      		cpc r29,r31
 1083 029e 01F4      		brne .L142
 448:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 1084               		.loc 1 448 0
 1085 02a0 F801      		movw r30,r16
 1086 02a2 8281      		ldd r24,Z+2
 1087 02a4 8823      		tst r24
 1088 02a6 01F0      		breq .L121
 449:quantum/quantum.c ****       }
 1089               		.loc 1 449 0
 1090 02a8 80E0      		ldi r24,0
 1091 02aa 00C0      		rjmp .L130
 1092               	.L142:
 284:quantum/quantum.c ****     case RESET:
 1093               		.loc 1 284 0
 1094 02ac C93D      		cpi r28,-39
 1095 02ae DC45      		sbci r29,92
 1096 02b0 01F0      		breq .+2
 1097 02b2 00C0      		rjmp .L102
 453:quantum/quantum.c ****         set_output(OUTPUT_USB);
 1098               		.loc 1 453 0
 1099 02b4 F801      		movw r30,r16
 1100 02b6 8281      		ldd r24,Z+2
 1101 02b8 8823      		tst r24
 1102 02ba 01F0      		breq .L121
 454:quantum/quantum.c ****       }
 1103               		.loc 1 454 0
 1104 02bc 82E0      		ldi r24,lo8(2)
 1105               	.L130:
 1106 02be 0E94 0000 		call set_output
 1107               	.LVL81:
 1108               	.L121:
 1109               		.loc 1 672 0
 1110 02c2 80E0      		ldi r24,0
 1111               	/* epilogue start */
 1112 02c4 DF91      		pop r29
 1113 02c6 CF91      		pop r28
 1114               	.LVL82:
 1115 02c8 1F91      		pop r17
 1116 02ca 0F91      		pop r16
 1117               	.LVL83:
 1118 02cc 0895      		ret
 1119               		.cfi_endproc
 1120               	.LFE39:
 1122               		.section	.text.send_char,"ax",@progbits
 1123               	.global	send_char
 1125               	send_char:
 1126               	.LFB44:
 673:quantum/quantum.c **** 
 674:quantum/quantum.c **** __attribute__ ((weak))
 675:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 676:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 677:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 678:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 679:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 680:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 681:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 682:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 683:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 684:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 685:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 686:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 687:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 688:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 689:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 690:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 691:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 692:quantum/quantum.c **** };
 693:quantum/quantum.c **** 
 694:quantum/quantum.c **** __attribute__ ((weak))
 695:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 696:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 697:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 698:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 699:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 700:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 701:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 702:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 703:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 704:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 705:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 706:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 707:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 708:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 709:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 710:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 711:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 712:quantum/quantum.c **** };
 713:quantum/quantum.c **** 
 714:quantum/quantum.c **** void send_string(const char *str) {
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 716:quantum/quantum.c **** }
 717:quantum/quantum.c **** 
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 720:quantum/quantum.c **** }
 721:quantum/quantum.c **** 
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 723:quantum/quantum.c ****     while (1) {
 724:quantum/quantum.c ****         char ascii_code = *str;
 725:quantum/quantum.c ****         if (!ascii_code) break;
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 727:quantum/quantum.c ****           // tap
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 729:quantum/quantum.c ****           register_code(keycode);
 730:quantum/quantum.c ****           unregister_code(keycode);
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 732:quantum/quantum.c ****           // down
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 734:quantum/quantum.c ****           register_code(keycode);
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 736:quantum/quantum.c ****           // up
 737:quantum/quantum.c ****           uint8_t keycode = *(++str);
 738:quantum/quantum.c ****           unregister_code(keycode);
 739:quantum/quantum.c ****         } else {
 740:quantum/quantum.c ****           send_char(ascii_code);
 741:quantum/quantum.c ****         }
 742:quantum/quantum.c ****         ++str;
 743:quantum/quantum.c ****         // interval
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 745:quantum/quantum.c ****     }
 746:quantum/quantum.c **** }
 747:quantum/quantum.c **** 
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 749:quantum/quantum.c ****     while (1) {
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 751:quantum/quantum.c ****         if (!ascii_code) break;
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 753:quantum/quantum.c ****           // tap
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 755:quantum/quantum.c ****           register_code(keycode);
 756:quantum/quantum.c ****           unregister_code(keycode);
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 758:quantum/quantum.c ****           // down
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 760:quantum/quantum.c ****           register_code(keycode);
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 762:quantum/quantum.c ****           // up
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 764:quantum/quantum.c ****           unregister_code(keycode);
 765:quantum/quantum.c ****         } else {
 766:quantum/quantum.c ****           send_char(ascii_code);
 767:quantum/quantum.c ****         }
 768:quantum/quantum.c ****         ++str;
 769:quantum/quantum.c ****         // interval
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 771:quantum/quantum.c ****     }
 772:quantum/quantum.c **** }
 773:quantum/quantum.c **** 
 774:quantum/quantum.c **** void send_char(char ascii_code) {
 1127               		.loc 1 774 0
 1128               		.cfi_startproc
 1129               	.LVL84:
 1130 0000 CF93      		push r28
 1131               	.LCFI12:
 1132               		.cfi_def_cfa_offset 3
 1133               		.cfi_offset 28, -2
 1134               	/* prologue: function */
 1135               	/* frame size = 0 */
 1136               	/* stack size = 1 */
 1137               	.L__stack_usage = 1
 1138               	.LBB34:
 775:quantum/quantum.c ****   uint8_t keycode;
 776:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 1139               		.loc 1 776 0
 1140 0002 90E0      		ldi r25,0
 1141               	.LVL85:
 1142 0004 FC01      		movw r30,r24
 1143 0006 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 1144 0008 F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 1145               	.LVL86:
 1146               	/* #APP */
 1147               	 ;  776 "quantum/quantum.c" 1
 1148 000a C491      		lpm r28, Z
 1149               		
 1150               	 ;  0 "" 2
 1151               	.LVL87:
 1152               	/* #NOAPP */
 1153               	.LBE34:
 1154               	.LBB35:
 777:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 1155               		.loc 1 777 0
 1156 000c FC01      		movw r30,r24
 1157               	.LVL88:
 1158 000e E050      		subi r30,lo8(-(ascii_to_shift_lut))
 1159 0010 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 1160               	.LVL89:
 1161               	/* #APP */
 1162               	 ;  777 "quantum/quantum.c" 1
 1163 0012 8491      		lpm r24, Z
 1164               		
 1165               	 ;  0 "" 2
 1166               	.LVL90:
 1167               	/* #NOAPP */
 1168               	.LBE35:
 1169 0014 8823      		tst r24
 1170 0016 01F0      		breq .L144
 778:quantum/quantum.c ****       register_code(KC_LSFT);
 1171               		.loc 1 778 0
 1172 0018 81EE      		ldi r24,lo8(-31)
 1173               	.LVL91:
 1174 001a 0E94 0000 		call register_code
 1175               	.LVL92:
 779:quantum/quantum.c ****       register_code(keycode);
 1176               		.loc 1 779 0
 1177 001e 8C2F      		mov r24,r28
 1178 0020 0E94 0000 		call register_code
 1179               	.LVL93:
 780:quantum/quantum.c ****       unregister_code(keycode);
 1180               		.loc 1 780 0
 1181 0024 8C2F      		mov r24,r28
 1182 0026 0E94 0000 		call unregister_code
 1183               	.LVL94:
 781:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1184               		.loc 1 781 0
 1185 002a 81EE      		ldi r24,lo8(-31)
 1186 002c 00C0      		rjmp .L145
 1187               	.LVL95:
 1188               	.L144:
 782:quantum/quantum.c ****   } else {
 783:quantum/quantum.c ****       register_code(keycode);
 1189               		.loc 1 783 0
 1190 002e 8C2F      		mov r24,r28
 1191               	.LVL96:
 1192 0030 0E94 0000 		call register_code
 1193               	.LVL97:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1194               		.loc 1 784 0
 1195 0034 8C2F      		mov r24,r28
 1196               	.L145:
 1197               	/* epilogue start */
 785:quantum/quantum.c ****   }
 786:quantum/quantum.c **** }
 1198               		.loc 1 786 0
 1199 0036 CF91      		pop r28
 1200               	.LVL98:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1201               		.loc 1 784 0
 1202 0038 0C94 0000 		jmp unregister_code
 1203               	.LVL99:
 1204               		.cfi_endproc
 1205               	.LFE44:
 1207               		.section	.text.send_string_with_delay,"ax",@progbits
 1208               	.global	send_string_with_delay
 1210               	send_string_with_delay:
 1211               	.LFB42:
 722:quantum/quantum.c ****     while (1) {
 1212               		.loc 1 722 0
 1213               		.cfi_startproc
 1214               	.LVL100:
 1215 0000 FF92      		push r15
 1216               	.LCFI13:
 1217               		.cfi_def_cfa_offset 3
 1218               		.cfi_offset 15, -2
 1219 0002 0F93      		push r16
 1220               	.LCFI14:
 1221               		.cfi_def_cfa_offset 4
 1222               		.cfi_offset 16, -3
 1223 0004 1F93      		push r17
 1224               	.LCFI15:
 1225               		.cfi_def_cfa_offset 5
 1226               		.cfi_offset 17, -4
 1227 0006 CF93      		push r28
 1228               	.LCFI16:
 1229               		.cfi_def_cfa_offset 6
 1230               		.cfi_offset 28, -5
 1231 0008 DF93      		push r29
 1232               	.LCFI17:
 1233               		.cfi_def_cfa_offset 7
 1234               		.cfi_offset 29, -6
 1235               	/* prologue: function */
 1236               	/* frame size = 0 */
 1237               	/* stack size = 5 */
 1238               	.L__stack_usage = 5
 1239 000a EC01      		movw r28,r24
 1240 000c F62E      		mov r15,r22
 1241               	.LVL101:
 1242               	.L154:
 1243               	.LBB36:
 724:quantum/quantum.c ****         if (!ascii_code) break;
 1244               		.loc 1 724 0
 1245 000e 8881      		ld r24,Y
 1246               	.LVL102:
 725:quantum/quantum.c ****         if (ascii_code == 1) {
 1247               		.loc 1 725 0
 1248 0010 8823      		tst r24
 1249 0012 01F0      		breq .L146
 1250 0014 8E01      		movw r16,r28
 1251 0016 0F5F      		subi r16,-1
 1252 0018 1F4F      		sbci r17,-1
 726:quantum/quantum.c ****           // tap
 1253               		.loc 1 726 0
 1254 001a 8130      		cpi r24,lo8(1)
 1255 001c 01F4      		brne .L148
 1256               	.LVL103:
 1257               	.LBB37:
 728:quantum/quantum.c ****           register_code(keycode);
 1258               		.loc 1 728 0
 1259 001e C981      		ldd r28,Y+1
 1260               	.LVL104:
 729:quantum/quantum.c ****           unregister_code(keycode);
 1261               		.loc 1 729 0
 1262 0020 8C2F      		mov r24,r28
 1263               	.LVL105:
 1264 0022 0E94 0000 		call register_code
 1265               	.LVL106:
 730:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1266               		.loc 1 730 0
 1267 0026 8C2F      		mov r24,r28
 1268 0028 00C0      		rjmp .L156
 1269               	.LVL107:
 1270               	.L148:
 1271               	.LBE37:
 731:quantum/quantum.c ****           // down
 1272               		.loc 1 731 0
 1273 002a 8230      		cpi r24,lo8(2)
 1274 002c 01F4      		brne .L150
 1275               	.LVL108:
 1276               	.LBB38:
 734:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1277               		.loc 1 734 0
 1278 002e 8981      		ldd r24,Y+1
 1279               	.LVL109:
 1280 0030 0E94 0000 		call register_code
 1281               	.LVL110:
 1282               	.L155:
 733:quantum/quantum.c ****           register_code(keycode);
 1283               		.loc 1 733 0
 1284 0034 E801      		movw r28,r16
 1285               	.LBE38:
 1286 0036 00C0      		rjmp .L149
 1287               	.LVL111:
 1288               	.L150:
 735:quantum/quantum.c ****           // up
 1289               		.loc 1 735 0
 1290 0038 8330      		cpi r24,lo8(3)
 1291 003a 01F4      		brne .L151
 1292               	.LVL112:
 1293               	.LBB39:
 738:quantum/quantum.c ****         } else {
 1294               		.loc 1 738 0
 1295 003c 8981      		ldd r24,Y+1
 1296               	.LVL113:
 1297               	.L156:
 1298 003e 0E94 0000 		call unregister_code
 1299               	.LVL114:
 1300 0042 00C0      		rjmp .L155
 1301               	.LVL115:
 1302               	.L151:
 1303               	.LBE39:
 740:quantum/quantum.c ****         }
 1304               		.loc 1 740 0
 1305 0044 0E94 0000 		call send_char
 1306               	.LVL116:
 1307               	.L149:
 742:quantum/quantum.c ****         // interval
 1308               		.loc 1 742 0
 1309 0048 2196      		adiw r28,1
 1310               	.LVL117:
 1311               	.LBB40:
 744:quantum/quantum.c ****     }
 1312               		.loc 1 744 0
 1313 004a 8F2D      		mov r24,r15
 1314               	.LVL118:
 1315               	.L152:
 744:quantum/quantum.c ****     }
 1316               		.loc 1 744 0 is_stmt 0 discriminator 1
 1317 004c 8823      		tst r24
 1318 004e 01F0      		breq .L154
 1319               	.LVL119:
 1320               	.LBB41:
 1321               	.LBB42:
 1322               		.loc 2 187 0 is_stmt 1
 1323 0050 EFE9      		ldi r30,lo8(3999)
 1324 0052 FFE0      		ldi r31,hi8(3999)
 1325 0054 3197      	1:	sbiw r30,1
 1326 0056 01F4      		brne 1b
 1327 0058 00C0      		rjmp .
 1328 005a 0000      		nop
 1329 005c 8150      		subi r24,lo8(-(-1))
 1330               	.LVL120:
 1331 005e 00C0      		rjmp .L152
 1332               	.LVL121:
 1333               	.L146:
 1334               	/* epilogue start */
 1335               	.LBE42:
 1336               	.LBE41:
 1337               	.LBE40:
 1338               	.LBE36:
 746:quantum/quantum.c **** 
 1339               		.loc 1 746 0
 1340 0060 DF91      		pop r29
 1341 0062 CF91      		pop r28
 1342               	.LVL122:
 1343 0064 1F91      		pop r17
 1344 0066 0F91      		pop r16
 1345 0068 FF90      		pop r15
 1346               	.LVL123:
 1347 006a 0895      		ret
 1348               		.cfi_endproc
 1349               	.LFE42:
 1351               		.section	.text.send_string,"ax",@progbits
 1352               	.global	send_string
 1354               	send_string:
 1355               	.LFB40:
 714:quantum/quantum.c ****   send_string_with_delay(str, 0);
 1356               		.loc 1 714 0
 1357               		.cfi_startproc
 1358               	.LVL124:
 1359               	/* prologue: function */
 1360               	/* frame size = 0 */
 1361               	/* stack size = 0 */
 1362               	.L__stack_usage = 0
 715:quantum/quantum.c **** }
 1363               		.loc 1 715 0
 1364 0000 60E0      		ldi r22,0
 1365 0002 0C94 0000 		jmp send_string_with_delay
 1366               	.LVL125:
 1367               		.cfi_endproc
 1368               	.LFE40:
 1370               		.section	.text.send_string_with_delay_P,"ax",@progbits
 1371               	.global	send_string_with_delay_P
 1373               	send_string_with_delay_P:
 1374               	.LFB43:
 748:quantum/quantum.c ****     while (1) {
 1375               		.loc 1 748 0
 1376               		.cfi_startproc
 1377               	.LVL126:
 1378 0000 0F93      		push r16
 1379               	.LCFI18:
 1380               		.cfi_def_cfa_offset 3
 1381               		.cfi_offset 16, -2
 1382 0002 1F93      		push r17
 1383               	.LCFI19:
 1384               		.cfi_def_cfa_offset 4
 1385               		.cfi_offset 17, -3
 1386 0004 CF93      		push r28
 1387               	.LCFI20:
 1388               		.cfi_def_cfa_offset 5
 1389               		.cfi_offset 28, -4
 1390 0006 DF93      		push r29
 1391               	.LCFI21:
 1392               		.cfi_def_cfa_offset 6
 1393               		.cfi_offset 29, -5
 1394               	/* prologue: function */
 1395               	/* frame size = 0 */
 1396               	/* stack size = 4 */
 1397               	.L__stack_usage = 4
 1398 0008 EC01      		movw r28,r24
 1399 000a 062F      		mov r16,r22
 1400               	.LVL127:
 1401               	.L166:
 1402               	.LBB43:
 1403               	.LBB44:
 750:quantum/quantum.c ****         if (!ascii_code) break;
 1404               		.loc 1 750 0
 1405 000c FE01      		movw r30,r28
 1406               	/* #APP */
 1407               	 ;  750 "quantum/quantum.c" 1
 1408 000e 8491      		lpm r24, Z
 1409               		
 1410               	 ;  0 "" 2
 1411               	.LVL128:
 1412               	/* #NOAPP */
 1413               	.LBE44:
 751:quantum/quantum.c ****         if (ascii_code == 1) {
 1414               		.loc 1 751 0
 1415 0010 8823      		tst r24
 1416 0012 01F0      		breq .L158
 1417 0014 9E01      		movw r18,r28
 1418 0016 2F5F      		subi r18,-1
 1419 0018 3F4F      		sbci r19,-1
 752:quantum/quantum.c ****           // tap
 1420               		.loc 1 752 0
 1421 001a 8130      		cpi r24,lo8(1)
 1422 001c 01F4      		brne .L160
 1423               	.LBB45:
 1424               	.LBB46:
 754:quantum/quantum.c ****           register_code(keycode);
 1425               		.loc 1 754 0
 1426 001e E901      		movw r28,r18
 1427               	.LVL129:
 1428 0020 F901      		movw r30,r18
 1429               	.LVL130:
 1430               	/* #APP */
 1431               	 ;  754 "quantum/quantum.c" 1
 1432 0022 1491      		lpm r17, Z
 1433               		
 1434               	 ;  0 "" 2
 1435               	.LVL131:
 1436               	/* #NOAPP */
 1437               	.LBE46:
 755:quantum/quantum.c ****           unregister_code(keycode);
 1438               		.loc 1 755 0
 1439 0024 812F      		mov r24,r17
 1440               	.LVL132:
 1441 0026 0E94 0000 		call register_code
 1442               	.LVL133:
 756:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1443               		.loc 1 756 0
 1444 002a 812F      		mov r24,r17
 1445 002c 00C0      		rjmp .L167
 1446               	.LVL134:
 1447               	.L160:
 1448               	.LBE45:
 757:quantum/quantum.c ****           // down
 1449               		.loc 1 757 0
 1450 002e 8230      		cpi r24,lo8(2)
 1451 0030 01F4      		brne .L162
 1452               	.LBB47:
 1453               	.LBB48:
 759:quantum/quantum.c ****           register_code(keycode);
 1454               		.loc 1 759 0
 1455 0032 E901      		movw r28,r18
 1456               	.LVL135:
 1457 0034 F901      		movw r30,r18
 1458               	.LVL136:
 1459               	/* #APP */
 1460               	 ;  759 "quantum/quantum.c" 1
 1461 0036 8491      		lpm r24, Z
 1462               		
 1463               	 ;  0 "" 2
 1464               	.LVL137:
 1465               	/* #NOAPP */
 1466               	.LBE48:
 760:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1467               		.loc 1 760 0
 1468 0038 0E94 0000 		call register_code
 1469               	.LVL138:
 1470               	.LBE47:
 1471 003c 00C0      		rjmp .L161
 1472               	.LVL139:
 1473               	.L162:
 761:quantum/quantum.c ****           // up
 1474               		.loc 1 761 0
 1475 003e 8330      		cpi r24,lo8(3)
 1476 0040 01F4      		brne .L163
 1477               	.LBB49:
 1478               	.LBB50:
 763:quantum/quantum.c ****           unregister_code(keycode);
 1479               		.loc 1 763 0
 1480 0042 E901      		movw r28,r18
 1481               	.LVL140:
 1482 0044 F901      		movw r30,r18
 1483               	.LVL141:
 1484               	/* #APP */
 1485               	 ;  763 "quantum/quantum.c" 1
 1486 0046 8491      		lpm r24, Z
 1487               		
 1488               	 ;  0 "" 2
 1489               	.LVL142:
 1490               	/* #NOAPP */
 1491               	.L167:
 1492               	.LBE50:
 764:quantum/quantum.c ****         } else {
 1493               		.loc 1 764 0
 1494 0048 0E94 0000 		call unregister_code
 1495               	.LVL143:
 1496               	.LBE49:
 1497 004c 00C0      		rjmp .L161
 1498               	.LVL144:
 1499               	.L163:
 766:quantum/quantum.c ****         }
 1500               		.loc 1 766 0
 1501 004e 0E94 0000 		call send_char
 1502               	.LVL145:
 1503               	.L161:
 768:quantum/quantum.c ****         // interval
 1504               		.loc 1 768 0
 1505 0052 2196      		adiw r28,1
 1506               	.LVL146:
 1507               	.LBB51:
 770:quantum/quantum.c ****     }
 1508               		.loc 1 770 0
 1509 0054 802F      		mov r24,r16
 1510               	.LVL147:
 1511               	.L164:
 770:quantum/quantum.c ****     }
 1512               		.loc 1 770 0 is_stmt 0 discriminator 1
 1513 0056 8823      		tst r24
 1514 0058 01F0      		breq .L166
 1515               	.LVL148:
 1516               	.LBB52:
 1517               	.LBB53:
 1518               		.loc 2 187 0 is_stmt 1
 1519 005a EFE9      		ldi r30,lo8(3999)
 1520 005c FFE0      		ldi r31,hi8(3999)
 1521 005e 3197      	1:	sbiw r30,1
 1522 0060 01F4      		brne 1b
 1523 0062 00C0      		rjmp .
 1524 0064 0000      		nop
 1525 0066 8150      		subi r24,lo8(-(-1))
 1526               	.LVL149:
 1527 0068 00C0      		rjmp .L164
 1528               	.LVL150:
 1529               	.L158:
 1530               	/* epilogue start */
 1531               	.LBE53:
 1532               	.LBE52:
 1533               	.LBE51:
 1534               	.LBE43:
 772:quantum/quantum.c **** 
 1535               		.loc 1 772 0
 1536 006a DF91      		pop r29
 1537 006c CF91      		pop r28
 1538               	.LVL151:
 1539 006e 1F91      		pop r17
 1540 0070 0F91      		pop r16
 1541               	.LVL152:
 1542 0072 0895      		ret
 1543               		.cfi_endproc
 1544               	.LFE43:
 1546               		.section	.text.send_string_P,"ax",@progbits
 1547               	.global	send_string_P
 1549               	send_string_P:
 1550               	.LFB41:
 718:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1551               		.loc 1 718 0
 1552               		.cfi_startproc
 1553               	.LVL153:
 1554               	/* prologue: function */
 1555               	/* frame size = 0 */
 1556               	/* stack size = 0 */
 1557               	.L__stack_usage = 0
 719:quantum/quantum.c **** }
 1558               		.loc 1 719 0
 1559 0000 60E0      		ldi r22,0
 1560 0002 0C94 0000 		jmp send_string_with_delay_P
 1561               	.LVL154:
 1562               		.cfi_endproc
 1563               	.LFE41:
 1565               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1566               	.global	set_single_persistent_default_layer
 1568               	set_single_persistent_default_layer:
 1569               	.LFB45:
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1570               		.loc 1 788 0
 1571               		.cfi_startproc
 1572               	.LVL155:
 1573 0000 CF93      		push r28
 1574               	.LCFI22:
 1575               		.cfi_def_cfa_offset 3
 1576               		.cfi_offset 28, -2
 1577 0002 DF93      		push r29
 1578               	.LCFI23:
 1579               		.cfi_def_cfa_offset 4
 1580               		.cfi_offset 29, -3
 1581               	/* prologue: function */
 1582               	/* frame size = 0 */
 1583               	/* stack size = 2 */
 1584               	.L__stack_usage = 2
 789:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 790:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 791:quantum/quantum.c ****   #endif
 792:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1585               		.loc 1 792 0
 1586 0004 61E0      		ldi r22,lo8(1)
 1587 0006 70E0      		ldi r23,0
 1588 0008 EB01      		movw r28,r22
 1589 000a 00C0      		rjmp 2f
 1590               		1:
 1591 000c CC0F      		lsl r28
 1592 000e DD1F      		rol r29
 1593               		2:
 1594 0010 8A95      		dec r24
 1595 0012 02F4      		brpl 1b
 1596 0014 8C2F      		mov r24,r28
 1597               	.LVL156:
 1598 0016 0E94 0000 		call eeconfig_update_default_layer
 1599               	.LVL157:
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1600               		.loc 1 793 0
 1601 001a BE01      		movw r22,r28
 1602 001c 80E0      		ldi r24,0
 1603 001e 90E0      		ldi r25,0
 1604               	/* epilogue start */
 794:quantum/quantum.c **** }
 1605               		.loc 1 794 0
 1606 0020 DF91      		pop r29
 1607 0022 CF91      		pop r28
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1608               		.loc 1 793 0
 1609 0024 0C94 0000 		jmp default_layer_set
 1610               	.LVL158:
 1611               		.cfi_endproc
 1612               	.LFE45:
 1614               		.section	.text.update_tri_layer_state,"ax",@progbits
 1615               	.global	update_tri_layer_state
 1617               	update_tri_layer_state:
 1618               	.LFB46:
 795:quantum/quantum.c **** 
 796:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1619               		.loc 1 796 0
 1620               		.cfi_startproc
 1621               	.LVL159:
 1622 0000 8F92      		push r8
 1623               	.LCFI24:
 1624               		.cfi_def_cfa_offset 3
 1625               		.cfi_offset 8, -2
 1626 0002 9F92      		push r9
 1627               	.LCFI25:
 1628               		.cfi_def_cfa_offset 4
 1629               		.cfi_offset 9, -3
 1630 0004 AF92      		push r10
 1631               	.LCFI26:
 1632               		.cfi_def_cfa_offset 5
 1633               		.cfi_offset 10, -4
 1634 0006 BF92      		push r11
 1635               	.LCFI27:
 1636               		.cfi_def_cfa_offset 6
 1637               		.cfi_offset 11, -5
 1638 0008 CF92      		push r12
 1639               	.LCFI28:
 1640               		.cfi_def_cfa_offset 7
 1641               		.cfi_offset 12, -6
 1642 000a DF92      		push r13
 1643               	.LCFI29:
 1644               		.cfi_def_cfa_offset 8
 1645               		.cfi_offset 13, -7
 1646 000c EF92      		push r14
 1647               	.LCFI30:
 1648               		.cfi_def_cfa_offset 9
 1649               		.cfi_offset 14, -8
 1650 000e FF92      		push r15
 1651               	.LCFI31:
 1652               		.cfi_def_cfa_offset 10
 1653               		.cfi_offset 15, -9
 1654 0010 0F93      		push r16
 1655               	.LCFI32:
 1656               		.cfi_def_cfa_offset 11
 1657               		.cfi_offset 16, -10
 1658 0012 1F93      		push r17
 1659               	.LCFI33:
 1660               		.cfi_def_cfa_offset 12
 1661               		.cfi_offset 17, -11
 1662               	/* prologue: function */
 1663               	/* frame size = 0 */
 1664               	/* stack size = 10 */
 1665               	.L__stack_usage = 10
 1666 0014 6B01      		movw r12,r22
 1667 0016 7C01      		movw r14,r24
 797:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 1668               		.loc 1 797 0
 1669 0018 81E0      		ldi r24,lo8(1)
 1670 001a 90E0      		ldi r25,0
 1671 001c A0E0      		ldi r26,0
 1672 001e B0E0      		ldi r27,0
 1673 0020 4C01      		movw r8,r24
 1674 0022 5D01      		movw r10,r26
 1675 0024 00C0      		rjmp 2f
 1676               		1:
 1677 0026 880C      		lsl r8
 1678 0028 991C      		rol r9
 1679 002a AA1C      		rol r10
 1680 002c BB1C      		rol r11
 1681               		2:
 1682 002e 4A95      		dec r20
 1683 0030 02F4      		brpl 1b
 1684 0032 AC01      		movw r20,r24
 1685 0034 BD01      		movw r22,r26
 1686               	.LVL160:
 1687 0036 00C0      		rjmp 2f
 1688               		1:
 1689 0038 440F      		lsl r20
 1690 003a 551F      		rol r21
 1691 003c 661F      		rol r22
 1692 003e 771F      		rol r23
 1693               		2:
 1694 0040 2A95      		dec r18
 1695 0042 02F4      		brpl 1b
 1696 0044 4829      		or r20,r8
 1697 0046 5929      		or r21,r9
 1698 0048 6A29      		or r22,r10
 1699 004a 7B29      		or r23,r11
 1700               	.LVL161:
 798:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 1701               		.loc 1 798 0
 1702 004c 00C0      		rjmp 2f
 1703               		1:
 1704 004e 880F      		lsl r24
 1705 0050 991F      		rol r25
 1706 0052 AA1F      		rol r26
 1707 0054 BB1F      		rol r27
 1708               		2:
 1709 0056 0A95      		dec r16
 1710 0058 02F4      		brpl 1b
 1711               	.LVL162:
 799:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1712               		.loc 1 799 0
 1713 005a 8A01      		movw r16,r20
 1714 005c 9B01      		movw r18,r22
 1715               	.LVL163:
 1716 005e 0C21      		and r16,r12
 1717 0060 1D21      		and r17,r13
 1718 0062 2E21      		and r18,r14
 1719 0064 3F21      		and r19,r15
 1720 0066 4017      		cp r20,r16
 1721 0068 5107      		cpc r21,r17
 1722 006a 6207      		cpc r22,r18
 1723 006c 7307      		cpc r23,r19
 1724 006e 01F4      		brne .L171
 1725               		.loc 1 799 0 is_stmt 0 discriminator 1
 1726 0070 BC01      		movw r22,r24
 1727 0072 CD01      		movw r24,r26
 1728               	.LVL164:
 1729 0074 6C29      		or r22,r12
 1730 0076 7D29      		or r23,r13
 1731 0078 8E29      		or r24,r14
 1732 007a 9F29      		or r25,r15
 1733 007c 00C0      		rjmp .L172
 1734               	.L171:
 1735               		.loc 1 799 0 discriminator 2
 1736 007e 8095      		com r24
 1737 0080 9095      		com r25
 1738 0082 A095      		com r26
 1739 0084 B095      		com r27
 1740               	.LVL165:
 1741 0086 BC01      		movw r22,r24
 1742 0088 CD01      		movw r24,r26
 1743 008a 6C21      		and r22,r12
 1744 008c 7D21      		and r23,r13
 1745 008e 8E21      		and r24,r14
 1746 0090 9F21      		and r25,r15
 1747               	.LVL166:
 1748               	.L172:
 1749               	/* epilogue start */
 800:quantum/quantum.c **** }
 1750               		.loc 1 800 0 is_stmt 1 discriminator 4
 1751 0092 1F91      		pop r17
 1752               	.LVL167:
 1753 0094 0F91      		pop r16
 1754               	.LVL168:
 1755 0096 FF90      		pop r15
 1756 0098 EF90      		pop r14
 1757 009a DF90      		pop r13
 1758 009c CF90      		pop r12
 1759               	.LVL169:
 1760 009e BF90      		pop r11
 1761 00a0 AF90      		pop r10
 1762 00a2 9F90      		pop r9
 1763 00a4 8F90      		pop r8
 1764               	.LVL170:
 1765 00a6 0895      		ret
 1766               		.cfi_endproc
 1767               	.LFE46:
 1769               		.section	.text.update_tri_layer,"ax",@progbits
 1770               	.global	update_tri_layer
 1772               	update_tri_layer:
 1773               	.LFB47:
 801:quantum/quantum.c **** 
 802:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1774               		.loc 1 802 0
 1775               		.cfi_startproc
 1776               	.LVL171:
 1777 0000 0F93      		push r16
 1778               	.LCFI34:
 1779               		.cfi_def_cfa_offset 3
 1780               		.cfi_offset 16, -2
 1781               	/* prologue: function */
 1782               	/* frame size = 0 */
 1783               	/* stack size = 1 */
 1784               	.L__stack_usage = 1
 1785 0002 382F      		mov r19,r24
 1786 0004 262F      		mov r18,r22
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1787               		.loc 1 803 0
 1788 0006 6091 0000 		lds r22,layer_state
 1789 000a 7091 0000 		lds r23,layer_state+1
 1790 000e 8091 0000 		lds r24,layer_state+2
 1791 0012 9091 0000 		lds r25,layer_state+3
 1792               	.LVL172:
 1793 0016 042F      		mov r16,r20
 1794 0018 432F      		mov r20,r19
 1795               	.LVL173:
 1796 001a 0E94 0000 		call update_tri_layer_state
 1797               	.LVL174:
 1798               	/* epilogue start */
 804:quantum/quantum.c **** }
 1799               		.loc 1 804 0
 1800 001e 0F91      		pop r16
 1801               	.LVL175:
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1802               		.loc 1 803 0
 1803 0020 0C94 0000 		jmp layer_state_set
 1804               	.LVL176:
 1805               		.cfi_endproc
 1806               	.LFE47:
 1808               		.section	.text.tap_random_base64,"ax",@progbits
 1809               	.global	tap_random_base64
 1811               	tap_random_base64:
 1812               	.LFB48:
 805:quantum/quantum.c **** 
 806:quantum/quantum.c **** void tap_random_base64(void) {
 1813               		.loc 1 806 0
 1814               		.cfi_startproc
 1815 0000 CF93      		push r28
 1816               	.LCFI35:
 1817               		.cfi_def_cfa_offset 3
 1818               		.cfi_offset 28, -2
 1819 0002 DF93      		push r29
 1820               	.LCFI36:
 1821               		.cfi_def_cfa_offset 4
 1822               		.cfi_offset 29, -3
 1823               	/* prologue: function */
 1824               	/* frame size = 0 */
 1825               	/* stack size = 2 */
 1826               	.L__stack_usage = 2
 807:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 808:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1827               		.loc 1 808 0
 1828 0004 26B5      		in r18,0x26
 1829 0006 C091 8400 		lds r28,132
 1830 000a D091 8500 		lds r29,132+1
 1831 000e 4091 9400 		lds r20,148
 1832 0012 5091 9500 		lds r21,148+1
 1833 0016 8091 BE00 		lds r24,190
 1834 001a 9091 BF00 		lds r25,190+1
 1835 001e C40F      		add r28,r20
 1836 0020 C20F      		add r28,r18
 1837 0022 8C0F      		add r24,r28
 1838 0024 C82F      		mov r28,r24
 1839 0026 CF73      		andi r28,lo8(63)
 1840               	.LVL177:
 809:quantum/quantum.c ****   #else
 810:quantum/quantum.c ****     uint8_t key = rand() % 64;
 811:quantum/quantum.c ****   #endif
 812:quantum/quantum.c ****   switch (key) {
 1841               		.loc 1 812 0
 1842 0028 CE33      		cpi r28,lo8(62)
 1843 002a 00F4      		brsh .L176
 1844 002c C533      		cpi r28,lo8(53)
 1845 002e 00F4      		brsh .L177
 1846 0030 CA31      		cpi r28,lo8(26)
 1847 0032 00F0      		brlo .L175
 1848 0034 C433      		cpi r28,lo8(52)
 1849 0036 00F4      		brsh .L182
 813:quantum/quantum.c ****     case 0 ... 25:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 815:quantum/quantum.c ****       register_code(key + KC_A);
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 817:quantum/quantum.c ****       unregister_code(KC_LSFT);
 818:quantum/quantum.c ****       break;
 819:quantum/quantum.c ****     case 26 ... 51:
 820:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 1850               		.loc 1 820 0
 1851 0038 C651      		subi r28,lo8(-(-22))
 1852               	.LVL178:
 1853 003a 00C0      		rjmp .L185
 1854               	.LVL179:
 1855               	.L176:
 812:quantum/quantum.c ****     case 0 ... 25:
 1856               		.loc 1 812 0
 1857 003c CE33      		cpi r28,lo8(62)
 1858 003e 01F0      		breq .L180
 1859 0040 CF33      		cpi r28,lo8(63)
 1860 0042 01F0      		breq .L181
 1861               	.L175:
 814:quantum/quantum.c ****       register_code(key + KC_A);
 1862               		.loc 1 814 0
 1863 0044 81EE      		ldi r24,lo8(-31)
 1864 0046 0E94 0000 		call register_code
 1865               	.LVL180:
 815:quantum/quantum.c ****       unregister_code(key + KC_A);
 1866               		.loc 1 815 0
 1867 004a CC5F      		subi r28,lo8(-(4))
 1868               	.LVL181:
 1869 004c 8C2F      		mov r24,r28
 1870 004e 0E94 0000 		call register_code
 1871               	.LVL182:
 816:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1872               		.loc 1 816 0
 1873 0052 8C2F      		mov r24,r28
 1874 0054 00C0      		rjmp .L184
 1875               	.LVL183:
 1876               	.L182:
 821:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 822:quantum/quantum.c ****       break;
 823:quantum/quantum.c ****     case 52:
 824:quantum/quantum.c ****       register_code(KC_0);
 1877               		.loc 1 824 0
 1878 0056 87E2      		ldi r24,lo8(39)
 1879 0058 0E94 0000 		call register_code
 1880               	.LVL184:
 825:quantum/quantum.c ****       unregister_code(KC_0);
 1881               		.loc 1 825 0
 1882 005c 87E2      		ldi r24,lo8(39)
 1883 005e 00C0      		rjmp .L183
 1884               	.L177:
 826:quantum/quantum.c ****       break;
 827:quantum/quantum.c ****     case 53 ... 61:
 828:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 1885               		.loc 1 828 0
 1886 0060 C751      		subi r28,lo8(-(-23))
 1887               	.LVL185:
 1888               	.L185:
 1889 0062 8C2F      		mov r24,r28
 1890               	.LVL186:
 1891 0064 0E94 0000 		call register_code
 1892               	.LVL187:
 829:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1893               		.loc 1 829 0
 1894 0068 8C2F      		mov r24,r28
 1895 006a 00C0      		rjmp .L183
 1896               	.LVL188:
 1897               	.L180:
 830:quantum/quantum.c ****       break;
 831:quantum/quantum.c ****     case 62:
 832:quantum/quantum.c ****       register_code(KC_LSFT);
 1898               		.loc 1 832 0
 1899 006c 81EE      		ldi r24,lo8(-31)
 1900 006e 0E94 0000 		call register_code
 1901               	.LVL189:
 833:quantum/quantum.c ****       register_code(KC_EQL);
 1902               		.loc 1 833 0
 1903 0072 8EE2      		ldi r24,lo8(46)
 1904 0074 0E94 0000 		call register_code
 1905               	.LVL190:
 834:quantum/quantum.c ****       unregister_code(KC_EQL);
 1906               		.loc 1 834 0
 1907 0078 8EE2      		ldi r24,lo8(46)
 1908               	.LVL191:
 1909               	.L184:
 1910 007a 0E94 0000 		call unregister_code
 1911               	.LVL192:
 835:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1912               		.loc 1 835 0
 1913 007e 81EE      		ldi r24,lo8(-31)
 1914 0080 00C0      		rjmp .L183
 1915               	.LVL193:
 1916               	.L181:
 836:quantum/quantum.c ****       break;
 837:quantum/quantum.c ****     case 63:
 838:quantum/quantum.c ****       register_code(KC_SLSH);
 1917               		.loc 1 838 0
 1918 0082 88E3      		ldi r24,lo8(56)
 1919 0084 0E94 0000 		call register_code
 1920               	.LVL194:
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1921               		.loc 1 839 0
 1922 0088 88E3      		ldi r24,lo8(56)
 1923               	.LVL195:
 1924               	.L183:
 1925               	/* epilogue start */
 840:quantum/quantum.c ****       break;
 841:quantum/quantum.c ****   }
 842:quantum/quantum.c **** }
 1926               		.loc 1 842 0
 1927 008a DF91      		pop r29
 1928 008c CF91      		pop r28
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1929               		.loc 1 839 0
 1930 008e 0C94 0000 		jmp unregister_code
 1931               	.LVL196:
 1932               		.cfi_endproc
 1933               	.LFE48:
 1935               		.section	.text.matrix_init_quantum,"ax",@progbits
 1936               	.global	matrix_init_quantum
 1938               	matrix_init_quantum:
 1939               	.LFB49:
 843:quantum/quantum.c **** 
 844:quantum/quantum.c **** void matrix_init_quantum() {
 1940               		.loc 1 844 0
 1941               		.cfi_startproc
 1942               	/* prologue: function */
 1943               	/* frame size = 0 */
 1944               	/* stack size = 0 */
 1945               	.L__stack_usage = 0
 845:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 846:quantum/quantum.c ****     backlight_init_ports();
 847:quantum/quantum.c ****   #endif
 848:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 849:quantum/quantum.c ****     audio_init();
 850:quantum/quantum.c ****   #endif
 851:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 852:quantum/quantum.c ****     rgb_matrix_init_drivers();
 853:quantum/quantum.c ****   #endif
 854:quantum/quantum.c ****   matrix_init_kb();
 1946               		.loc 1 854 0
 1947 0000 0C94 0000 		jmp matrix_init_kb
 1948               	.LVL197:
 1949               		.cfi_endproc
 1950               	.LFE49:
 1952               		.section	.text.matrix_scan_quantum,"ax",@progbits
 1953               	.global	matrix_scan_quantum
 1955               	matrix_scan_quantum:
 1956               	.LFB50:
 855:quantum/quantum.c **** }
 856:quantum/quantum.c **** 
 857:quantum/quantum.c **** uint8_t rgb_matrix_task_counter = 0;
 858:quantum/quantum.c **** 
 859:quantum/quantum.c **** #ifndef RGB_MATRIX_SKIP_FRAMES
 860:quantum/quantum.c ****   #define RGB_MATRIX_SKIP_FRAMES 1
 861:quantum/quantum.c **** #endif
 862:quantum/quantum.c **** 
 863:quantum/quantum.c **** void matrix_scan_quantum() {
 1957               		.loc 1 863 0
 1958               		.cfi_startproc
 1959               	/* prologue: function */
 1960               	/* frame size = 0 */
 1961               	/* stack size = 0 */
 1962               	.L__stack_usage = 0
 864:quantum/quantum.c ****   #if defined(AUDIO_ENABLE)
 865:quantum/quantum.c ****     matrix_scan_music();
 866:quantum/quantum.c ****   #endif
 867:quantum/quantum.c **** 
 868:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 869:quantum/quantum.c ****     matrix_scan_tap_dance();
 1963               		.loc 1 869 0
 1964 0000 0E94 0000 		call matrix_scan_tap_dance
 1965               	.LVL198:
 870:quantum/quantum.c ****   #endif
 871:quantum/quantum.c **** 
 872:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 873:quantum/quantum.c ****     matrix_scan_combo();
 874:quantum/quantum.c ****   #endif
 875:quantum/quantum.c **** 
 876:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 877:quantum/quantum.c ****     backlight_task();
 878:quantum/quantum.c ****   #endif
 879:quantum/quantum.c **** 
 880:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 881:quantum/quantum.c ****     rgb_matrix_task();
 882:quantum/quantum.c ****     if (rgb_matrix_task_counter == 0) {
 883:quantum/quantum.c ****       rgb_matrix_update_pwm_buffers();
 884:quantum/quantum.c ****     }
 885:quantum/quantum.c ****     rgb_matrix_task_counter = ((rgb_matrix_task_counter + 1) % (RGB_MATRIX_SKIP_FRAMES + 1));
 886:quantum/quantum.c ****   #endif
 887:quantum/quantum.c **** 
 888:quantum/quantum.c ****   matrix_scan_kb();
 1966               		.loc 1 888 0
 1967 0004 0C94 0000 		jmp matrix_scan_kb
 1968               	.LVL199:
 1969               		.cfi_endproc
 1970               	.LFE50:
 1972               		.section	.text.backlight_init_ports,"ax",@progbits
 1973               		.weak	backlight_init_ports
 1975               	backlight_init_ports:
 1976               	.LFB70:
 1977               		.cfi_startproc
 1978               	/* prologue: function */
 1979               	/* frame size = 0 */
 1980               	/* stack size = 0 */
 1981               	.L__stack_usage = 0
 1982 0000 0895      		ret
 1983               		.cfi_endproc
 1984               	.LFE70:
 1986               		.section	.text.send_nibble,"ax",@progbits
 1987               	.global	send_nibble
 1989               	send_nibble:
 1990               	.LFB56:
 889:quantum/quantum.c **** }
 890:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 891:quantum/quantum.c **** 
 892:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 893:quantum/quantum.c **** 
 894:quantum/quantum.c **** // depending on the pin, we use a different output compare unit
 895:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 896:quantum/quantum.c **** #  define COM1x1 COM1C1
 897:quantum/quantum.c **** #  define OCR1x  OCR1C
 898:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 899:quantum/quantum.c **** #  define COM1x1 COM1B1
 900:quantum/quantum.c **** #  define OCR1x  OCR1B
 901:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 902:quantum/quantum.c **** #  define COM1x1 COM1A1
 903:quantum/quantum.c **** #  define OCR1x  OCR1A
 904:quantum/quantum.c **** #else
 905:quantum/quantum.c **** #  define NO_HARDWARE_PWM
 906:quantum/quantum.c **** #endif
 907:quantum/quantum.c **** 
 908:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
 909:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
 910:quantum/quantum.c **** #endif
 911:quantum/quantum.c **** 
 912:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM // pwm through software
 913:quantum/quantum.c **** 
 914:quantum/quantum.c **** __attribute__ ((weak))
 915:quantum/quantum.c **** void backlight_init_ports(void)
 916:quantum/quantum.c **** {
 917:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
 918:quantum/quantum.c ****   // DDRx |= n
 919:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 920:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
 921:quantum/quantum.c ****     // PORTx &= ~n
 922:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 923:quantum/quantum.c ****   #else
 924:quantum/quantum.c ****     // PORTx |= n
 925:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 926:quantum/quantum.c ****   #endif
 927:quantum/quantum.c **** }
 928:quantum/quantum.c **** 
 929:quantum/quantum.c **** __attribute__ ((weak))
 930:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 931:quantum/quantum.c **** 
 932:quantum/quantum.c **** uint8_t backlight_tick = 0;
 933:quantum/quantum.c **** 
 934:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 935:quantum/quantum.c **** void backlight_task(void) {
 936:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
 937:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 938:quantum/quantum.c ****       // PORTx &= ~n
 939:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 940:quantum/quantum.c ****     #else
 941:quantum/quantum.c ****       // PORTx |= n
 942:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 943:quantum/quantum.c ****     #endif
 944:quantum/quantum.c ****   } else {
 945:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 946:quantum/quantum.c ****       // PORTx |= n
 947:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 948:quantum/quantum.c ****     #else
 949:quantum/quantum.c ****       // PORTx &= ~n
 950:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 951:quantum/quantum.c ****     #endif
 952:quantum/quantum.c ****   }
 953:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
 954:quantum/quantum.c **** }
 955:quantum/quantum.c **** #endif
 956:quantum/quantum.c **** 
 957:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 958:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
 959:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
 960:quantum/quantum.c ****   #endif
 961:quantum/quantum.c **** #endif
 962:quantum/quantum.c **** 
 963:quantum/quantum.c **** #else // pwm through timer
 964:quantum/quantum.c **** 
 965:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
 966:quantum/quantum.c **** 
 967:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
 968:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
 969:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
 970:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 971:quantum/quantum.c ****   else {
 972:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
 973:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
 974:quantum/quantum.c ****     // and revert what we've done again after squaring.
 975:quantum/quantum.c ****     y = y * y * y >> 8;
 976:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 977:quantum/quantum.c ****       return 0xFFFFU;
 978:quantum/quantum.c ****     else
 979:quantum/quantum.c ****       return (uint16_t) y;
 980:quantum/quantum.c ****   }
 981:quantum/quantum.c **** }
 982:quantum/quantum.c **** 
 983:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
 984:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
 985:quantum/quantum.c ****   OCR1x = val;
 986:quantum/quantum.c **** }
 987:quantum/quantum.c **** 
 988:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 989:quantum/quantum.c **** __attribute__ ((weak))
 990:quantum/quantum.c **** void backlight_set(uint8_t level) {
 991:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
 992:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 993:quantum/quantum.c **** 
 994:quantum/quantum.c ****   if (level == 0) {
 995:quantum/quantum.c ****     // Turn off PWM control on backlight pin
 996:quantum/quantum.c ****     TCCR1A &= ~(_BV(COM1x1));
 997:quantum/quantum.c ****   } else {
 998:quantum/quantum.c ****     // Turn on PWM control of backlight pin
 999:quantum/quantum.c ****     TCCR1A |= _BV(COM1x1);
1000:quantum/quantum.c ****   }
1001:quantum/quantum.c ****   // Set the brightness
1002:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
1003:quantum/quantum.c **** }
1004:quantum/quantum.c **** 
1005:quantum/quantum.c **** void backlight_task(void) {}
1006:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1007:quantum/quantum.c **** 
1008:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1009:quantum/quantum.c **** 
1010:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1011:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1012:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1013:quantum/quantum.c **** #define BREATHING_STEPS 128
1014:quantum/quantum.c **** 
1015:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1016:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1017:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1018:quantum/quantum.c **** 
1019:quantum/quantum.c **** bool is_breathing(void) {
1020:quantum/quantum.c ****     return !!(TIMSK1 & _BV(TOIE1));
1021:quantum/quantum.c **** }
1022:quantum/quantum.c **** 
1023:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSK1 |= _BV(TOIE1);} while (0)
1024:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSK1 &= ~_BV(TOIE1);} while (0)
1025:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1026:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1027:quantum/quantum.c **** 
1028:quantum/quantum.c **** void breathing_enable(void)
1029:quantum/quantum.c **** {
1030:quantum/quantum.c ****   breathing_counter = 0;
1031:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1032:quantum/quantum.c ****   breathing_interrupt_enable();
1033:quantum/quantum.c **** }
1034:quantum/quantum.c **** 
1035:quantum/quantum.c **** void breathing_pulse(void)
1036:quantum/quantum.c **** {
1037:quantum/quantum.c ****     if (get_backlight_level() == 0)
1038:quantum/quantum.c ****       breathing_min();
1039:quantum/quantum.c ****     else
1040:quantum/quantum.c ****       breathing_max();
1041:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1042:quantum/quantum.c ****     breathing_interrupt_enable();
1043:quantum/quantum.c **** }
1044:quantum/quantum.c **** 
1045:quantum/quantum.c **** void breathing_disable(void)
1046:quantum/quantum.c **** {
1047:quantum/quantum.c ****     breathing_interrupt_disable();
1048:quantum/quantum.c ****     // Restore backlight level
1049:quantum/quantum.c ****     backlight_set(get_backlight_level());
1050:quantum/quantum.c **** }
1051:quantum/quantum.c **** 
1052:quantum/quantum.c **** void breathing_self_disable(void)
1053:quantum/quantum.c **** {
1054:quantum/quantum.c ****   if (get_backlight_level() == 0)
1055:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1056:quantum/quantum.c ****   else
1057:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1058:quantum/quantum.c **** }
1059:quantum/quantum.c **** 
1060:quantum/quantum.c **** void breathing_toggle(void) {
1061:quantum/quantum.c ****   if (is_breathing())
1062:quantum/quantum.c ****     breathing_disable();
1063:quantum/quantum.c ****   else
1064:quantum/quantum.c ****     breathing_enable();
1065:quantum/quantum.c **** }
1066:quantum/quantum.c **** 
1067:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1068:quantum/quantum.c **** {
1069:quantum/quantum.c ****   if (!value)
1070:quantum/quantum.c ****     value = 1;
1071:quantum/quantum.c ****   breathing_period = value;
1072:quantum/quantum.c **** }
1073:quantum/quantum.c **** 
1074:quantum/quantum.c **** void breathing_period_default(void) {
1075:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1076:quantum/quantum.c **** }
1077:quantum/quantum.c **** 
1078:quantum/quantum.c **** void breathing_period_inc(void)
1079:quantum/quantum.c **** {
1080:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1081:quantum/quantum.c **** }
1082:quantum/quantum.c **** 
1083:quantum/quantum.c **** void breathing_period_dec(void)
1084:quantum/quantum.c **** {
1085:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1086:quantum/quantum.c **** }
1087:quantum/quantum.c **** 
1088:quantum/quantum.c **** /* To generate breathing curve in python:
1089:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1090:quantum/quantum.c ****  */
1091:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1092:quantum/quantum.c **** 
1093:quantum/quantum.c **** // Use this before the cie_lightness function.
1094:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1095:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1096:quantum/quantum.c **** }
1097:quantum/quantum.c **** 
1098:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1099:quantum/quantum.c ****  * about 244 times per second.
1100:quantum/quantum.c ****  */
1101:quantum/quantum.c **** ISR(TIMER1_OVF_vect)
1102:quantum/quantum.c **** {
1103:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1104:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1105:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1106:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1107:quantum/quantum.c **** 
1108:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1109:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1110:quantum/quantum.c ****   {
1111:quantum/quantum.c ****       breathing_interrupt_disable();
1112:quantum/quantum.c ****   }
1113:quantum/quantum.c **** 
1114:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1115:quantum/quantum.c **** }
1116:quantum/quantum.c **** 
1117:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1118:quantum/quantum.c **** 
1119:quantum/quantum.c **** __attribute__ ((weak))
1120:quantum/quantum.c **** void backlight_init_ports(void)
1121:quantum/quantum.c **** {
1122:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1123:quantum/quantum.c ****   // DDRx |= n
1124:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
1125:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1126:quantum/quantum.c ****     // PORTx &= ~n
1127:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1128:quantum/quantum.c ****   #else
1129:quantum/quantum.c ****     // PORTx |= n
1130:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1131:quantum/quantum.c ****   #endif
1132:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1133:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1134:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1135:quantum/quantum.c **** 
1136:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1137:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1138:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1139:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1140:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1141:quantum/quantum.c **** 
1142:quantum/quantum.c ****   /*
1143:quantum/quantum.c ****   14.8.3:
1144:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1145:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1146:quantum/quantum.c ****   */
1147:quantum/quantum.c **** 
1148:quantum/quantum.c ****   TCCR1A = _BV(COM1x1) | _BV(WGM11); // = 0b00001010;
1149:quantum/quantum.c ****   TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1150:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1151:quantum/quantum.c ****   ICR1 = TIMER_TOP;
1152:quantum/quantum.c **** 
1153:quantum/quantum.c ****   backlight_init();
1154:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1155:quantum/quantum.c ****     breathing_enable();
1156:quantum/quantum.c ****   #endif
1157:quantum/quantum.c **** }
1158:quantum/quantum.c **** 
1159:quantum/quantum.c **** #endif // NO_HARDWARE_PWM
1160:quantum/quantum.c **** 
1161:quantum/quantum.c **** #else // backlight
1162:quantum/quantum.c **** 
1163:quantum/quantum.c **** __attribute__ ((weak))
1164:quantum/quantum.c **** void backlight_init_ports(void) {}
1165:quantum/quantum.c **** 
1166:quantum/quantum.c **** __attribute__ ((weak))
1167:quantum/quantum.c **** void backlight_set(uint8_t level) {}
1168:quantum/quantum.c **** 
1169:quantum/quantum.c **** #endif // backlight
1170:quantum/quantum.c **** 
1171:quantum/quantum.c **** 
1172:quantum/quantum.c **** // Functions for spitting out values
1173:quantum/quantum.c **** //
1174:quantum/quantum.c **** 
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1176:quantum/quantum.c ****     uint16_t word = (number >> 16);
1177:quantum/quantum.c ****     send_word(word);
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1179:quantum/quantum.c **** }
1180:quantum/quantum.c **** 
1181:quantum/quantum.c **** void send_word(uint16_t number) {
1182:quantum/quantum.c ****     uint8_t byte = number >> 8;
1183:quantum/quantum.c ****     send_byte(byte);
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
1185:quantum/quantum.c **** }
1186:quantum/quantum.c **** 
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
1188:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1189:quantum/quantum.c ****     send_nibble(nibble);
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
1191:quantum/quantum.c **** }
1192:quantum/quantum.c **** 
1193:quantum/quantum.c **** void send_nibble(uint8_t number) {
 1991               		.loc 1 1193 0
 1992               		.cfi_startproc
 1993               	.LVL200:
 1994               		.loc 1 1193 0
 1995 0000 CF93      		push r28
 1996               	.LCFI37:
 1997               		.cfi_def_cfa_offset 3
 1998               		.cfi_offset 28, -2
 1999               	/* prologue: function */
 2000               	/* frame size = 0 */
 2001               	/* stack size = 1 */
 2002               	.L__stack_usage = 1
1194:quantum/quantum.c ****     switch (number) {
 2003               		.loc 1 1194 0
 2004 0002 8A30      		cpi r24,lo8(10)
 2005 0004 00F4      		brsh .L191
 2006 0006 8130      		cpi r24,lo8(1)
 2007 0008 00F4      		brsh .L199
1195:quantum/quantum.c ****         case 0:
1196:quantum/quantum.c ****             register_code(KC_0);
 2008               		.loc 1 1196 0
 2009 000a 87E2      		ldi r24,lo8(39)
 2010               	.LVL201:
 2011 000c 0E94 0000 		call register_code
 2012               	.LVL202:
1197:quantum/quantum.c ****             unregister_code(KC_0);
 2013               		.loc 1 1197 0
 2014 0010 87E2      		ldi r24,lo8(39)
 2015 0012 00C0      		rjmp .L197
 2016               	.LVL203:
 2017               	.L191:
1194:quantum/quantum.c ****     switch (number) {
 2018               		.loc 1 1194 0
 2019 0014 8031      		cpi r24,lo8(16)
 2020 0016 00F4      		brsh .L200
1198:quantum/quantum.c ****             break;
1199:quantum/quantum.c ****         case 1 ... 9:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1201:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1202:quantum/quantum.c ****             break;
1203:quantum/quantum.c ****         case 0xA ... 0xF:
1204:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 2021               		.loc 1 1204 0
 2022 0018 CAEF      		ldi r28,lo8(-6)
 2023 001a 00C0      		rjmp .L198
 2024               	.L199:
1200:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
 2025               		.loc 1 1200 0
 2026 001c CDE1      		ldi r28,lo8(29)
 2027               	.L198:
 2028               		.loc 1 1204 0
 2029 001e C80F      		add r28,r24
 2030 0020 8C2F      		mov r24,r28
 2031               	.LVL204:
 2032 0022 0E94 0000 		call register_code
 2033               	.LVL205:
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2034               		.loc 1 1205 0
 2035 0026 8C2F      		mov r24,r28
 2036               	.L197:
 2037               	/* epilogue start */
1206:quantum/quantum.c ****             break;
1207:quantum/quantum.c ****     }
1208:quantum/quantum.c **** }
 2038               		.loc 1 1208 0
 2039 0028 CF91      		pop r28
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2040               		.loc 1 1205 0
 2041 002a 0C94 0000 		jmp unregister_code
 2042               	.LVL206:
 2043               	.L200:
 2044               	/* epilogue start */
 2045               		.loc 1 1208 0
 2046 002e CF91      		pop r28
 2047 0030 0895      		ret
 2048               		.cfi_endproc
 2049               	.LFE56:
 2051               		.section	.text.send_byte,"ax",@progbits
 2052               	.global	send_byte
 2054               	send_byte:
 2055               	.LFB55:
1187:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 2056               		.loc 1 1187 0
 2057               		.cfi_startproc
 2058               	.LVL207:
 2059 0000 CF93      		push r28
 2060               	.LCFI38:
 2061               		.cfi_def_cfa_offset 3
 2062               		.cfi_offset 28, -2
 2063               	/* prologue: function */
 2064               	/* frame size = 0 */
 2065               	/* stack size = 1 */
 2066               	.L__stack_usage = 1
 2067 0002 C82F      		mov r28,r24
 2068               	.LVL208:
1189:quantum/quantum.c ****     send_nibble(number & 0xF);
 2069               		.loc 1 1189 0
 2070 0004 8295      		swap r24
 2071               	.LVL209:
 2072 0006 8F70      		andi r24,lo8(15)
 2073 0008 0E94 0000 		call send_nibble
 2074               	.LVL210:
1190:quantum/quantum.c **** }
 2075               		.loc 1 1190 0
 2076 000c 8C2F      		mov r24,r28
 2077 000e 8F70      		andi r24,lo8(15)
 2078               	/* epilogue start */
1191:quantum/quantum.c **** 
 2079               		.loc 1 1191 0
 2080 0010 CF91      		pop r28
 2081               	.LVL211:
1190:quantum/quantum.c **** }
 2082               		.loc 1 1190 0
 2083 0012 0C94 0000 		jmp send_nibble
 2084               	.LVL212:
 2085               		.cfi_endproc
 2086               	.LFE55:
 2088               		.section	.text.send_word,"ax",@progbits
 2089               	.global	send_word
 2091               	send_word:
 2092               	.LFB54:
1181:quantum/quantum.c ****     uint8_t byte = number >> 8;
 2093               		.loc 1 1181 0
 2094               		.cfi_startproc
 2095               	.LVL213:
 2096 0000 CF93      		push r28
 2097               	.LCFI39:
 2098               		.cfi_def_cfa_offset 3
 2099               		.cfi_offset 28, -2
 2100               	/* prologue: function */
 2101               	/* frame size = 0 */
 2102               	/* stack size = 1 */
 2103               	.L__stack_usage = 1
 2104 0002 C82F      		mov r28,r24
 2105               	.LVL214:
1183:quantum/quantum.c ****     send_byte(number & 0xFF);
 2106               		.loc 1 1183 0
 2107 0004 892F      		mov r24,r25
 2108               	.LVL215:
 2109 0006 0E94 0000 		call send_byte
 2110               	.LVL216:
1184:quantum/quantum.c **** }
 2111               		.loc 1 1184 0
 2112 000a 8C2F      		mov r24,r28
 2113               	/* epilogue start */
1185:quantum/quantum.c **** 
 2114               		.loc 1 1185 0
 2115 000c CF91      		pop r28
1184:quantum/quantum.c **** }
 2116               		.loc 1 1184 0
 2117 000e 0C94 0000 		jmp send_byte
 2118               	.LVL217:
 2119               		.cfi_endproc
 2120               	.LFE54:
 2122               		.section	.text.send_dword,"ax",@progbits
 2123               	.global	send_dword
 2125               	send_dword:
 2126               	.LFB53:
1175:quantum/quantum.c ****     uint16_t word = (number >> 16);
 2127               		.loc 1 1175 0
 2128               		.cfi_startproc
 2129               	.LVL218:
 2130 0000 CF92      		push r12
 2131               	.LCFI40:
 2132               		.cfi_def_cfa_offset 3
 2133               		.cfi_offset 12, -2
 2134 0002 DF92      		push r13
 2135               	.LCFI41:
 2136               		.cfi_def_cfa_offset 4
 2137               		.cfi_offset 13, -3
 2138 0004 EF92      		push r14
 2139               	.LCFI42:
 2140               		.cfi_def_cfa_offset 5
 2141               		.cfi_offset 14, -4
 2142 0006 FF92      		push r15
 2143               	.LCFI43:
 2144               		.cfi_def_cfa_offset 6
 2145               		.cfi_offset 15, -5
 2146               	/* prologue: function */
 2147               	/* frame size = 0 */
 2148               	/* stack size = 4 */
 2149               	.L__stack_usage = 4
 2150 0008 6B01      		movw r12,r22
 2151 000a 7C01      		movw r14,r24
 2152               	.LVL219:
1177:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2153               		.loc 1 1177 0
 2154 000c C701      		movw r24,r14
 2155 000e 0E94 0000 		call send_word
 2156               	.LVL220:
1178:quantum/quantum.c **** }
 2157               		.loc 1 1178 0
 2158 0012 C601      		movw r24,r12
 2159               	/* epilogue start */
1179:quantum/quantum.c **** 
 2160               		.loc 1 1179 0
 2161 0014 FF90      		pop r15
 2162 0016 EF90      		pop r14
 2163 0018 DF90      		pop r13
 2164 001a CF90      		pop r12
 2165               	.LVL221:
1178:quantum/quantum.c **** }
 2166               		.loc 1 1178 0
 2167 001c 0C94 0000 		jmp send_word
 2168               	.LVL222:
 2169               		.cfi_endproc
 2170               	.LFE53:
 2172               		.section	.text.hex_to_keycode,"ax",@progbits
 2173               		.weak	hex_to_keycode
 2175               	hex_to_keycode:
 2176               	.LFB57:
1209:quantum/quantum.c **** 
1210:quantum/quantum.c **** 
1211:quantum/quantum.c **** __attribute__((weak))
1212:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1213:quantum/quantum.c **** {
 2177               		.loc 1 1213 0
 2178               		.cfi_startproc
 2179               	.LVL223:
 2180               	/* prologue: function */
 2181               	/* frame size = 0 */
 2182               	/* stack size = 0 */
 2183               	.L__stack_usage = 0
1214:quantum/quantum.c ****   hex = hex & 0xF;
 2184               		.loc 1 1214 0
 2185 0000 282F      		mov r18,r24
 2186 0002 2F70      		andi r18,lo8(15)
 2187               	.LVL224:
1215:quantum/quantum.c ****   if (hex == 0x0) {
 2188               		.loc 1 1215 0
 2189 0004 01F0      		breq .L207
 2190 0006 822F      		mov r24,r18
 2191 0008 90E0      		ldi r25,0
1216:quantum/quantum.c ****     return KC_0;
1217:quantum/quantum.c ****   } else if (hex < 0xA) {
 2192               		.loc 1 1217 0
 2193 000a 2A30      		cpi r18,lo8(10)
 2194 000c 00F4      		brsh .L206
1218:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 2195               		.loc 1 1218 0
 2196 000e 4D96      		adiw r24,29
 2197 0010 0895      		ret
 2198               	.L206:
1219:quantum/quantum.c ****   } else {
1220:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 2199               		.loc 1 1220 0
 2200 0012 0697      		sbiw r24,6
 2201 0014 0895      		ret
 2202               	.L207:
1216:quantum/quantum.c ****   } else if (hex < 0xA) {
 2203               		.loc 1 1216 0
 2204 0016 87E2      		ldi r24,lo8(39)
 2205 0018 90E0      		ldi r25,0
1221:quantum/quantum.c ****   }
1222:quantum/quantum.c **** }
 2206               		.loc 1 1222 0
 2207 001a 0895      		ret
 2208               		.cfi_endproc
 2209               	.LFE57:
 2211               		.section	.text.api_send_unicode,"ax",@progbits
 2212               	.global	api_send_unicode
 2214               	api_send_unicode:
 2215               	.LFB58:
1223:quantum/quantum.c **** 
1224:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 2216               		.loc 1 1224 0
 2217               		.cfi_startproc
 2218               	.LVL225:
 2219               	/* prologue: function */
 2220               	/* frame size = 0 */
 2221               	/* stack size = 0 */
 2222               	.L__stack_usage = 0
 2223 0000 0895      		ret
 2224               		.cfi_endproc
 2225               	.LFE58:
 2227               		.section	.text.led_set_user,"ax",@progbits
 2228               		.weak	led_set_user
 2230               	led_set_user:
 2231               	.LFB59:
1225:quantum/quantum.c **** #ifdef API_ENABLE
1226:quantum/quantum.c ****     uint8_t chunk[4];
1227:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1228:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1229:quantum/quantum.c **** #endif
1230:quantum/quantum.c **** }
1231:quantum/quantum.c **** 
1232:quantum/quantum.c **** __attribute__ ((weak))
1233:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 2232               		.loc 1 1233 0
 2233               		.cfi_startproc
 2234               	.LVL226:
 2235               	/* prologue: function */
 2236               	/* frame size = 0 */
 2237               	/* stack size = 0 */
 2238               	.L__stack_usage = 0
 2239 0000 0895      		ret
 2240               		.cfi_endproc
 2241               	.LFE59:
 2243               		.set	led_set_user.localalias.1,led_set_user
 2244               		.section	.text.backlight_set,"ax",@progbits
 2245               		.weak	backlight_set
 2247               	backlight_set:
 2248               	.LFB94:
 2249               		.cfi_startproc
 2250               	/* prologue: function */
 2251               	/* frame size = 0 */
 2252               	/* stack size = 0 */
 2253               	.L__stack_usage = 0
 2254 0000 0C94 0000 		jmp led_set_user.localalias.1
 2255               		.cfi_endproc
 2256               	.LFE94:
 2258               		.section	.text.led_set_kb,"ax",@progbits
 2259               		.weak	led_set_kb
 2261               	led_set_kb:
 2262               	.LFB60:
1234:quantum/quantum.c **** 
1235:quantum/quantum.c **** }
1236:quantum/quantum.c **** 
1237:quantum/quantum.c **** __attribute__ ((weak))
1238:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 2263               		.loc 1 1238 0
 2264               		.cfi_startproc
 2265               	.LVL227:
 2266               	/* prologue: function */
 2267               	/* frame size = 0 */
 2268               	/* stack size = 0 */
 2269               	.L__stack_usage = 0
1239:quantum/quantum.c ****     led_set_user(usb_led);
 2270               		.loc 1 1239 0
 2271 0000 0C94 0000 		jmp led_set_user
 2272               	.LVL228:
 2273               		.cfi_endproc
 2274               	.LFE60:
 2276               		.section	.text.led_init_ports,"ax",@progbits
 2277               		.weak	led_init_ports
 2279               	led_init_ports:
 2280               	.LFB68:
 2281               		.cfi_startproc
 2282               	/* prologue: function */
 2283               	/* frame size = 0 */
 2284               	/* stack size = 0 */
 2285               	.L__stack_usage = 0
 2286 0000 0895      		ret
 2287               		.cfi_endproc
 2288               	.LFE68:
 2290               		.section	.text.led_set,"ax",@progbits
 2291               		.weak	led_set
 2293               	led_set:
 2294               	.LFB62:
1240:quantum/quantum.c **** }
1241:quantum/quantum.c **** 
1242:quantum/quantum.c **** __attribute__ ((weak))
1243:quantum/quantum.c **** void led_init_ports(void)
1244:quantum/quantum.c **** {
1245:quantum/quantum.c **** 
1246:quantum/quantum.c **** }
1247:quantum/quantum.c **** 
1248:quantum/quantum.c **** __attribute__ ((weak))
1249:quantum/quantum.c **** void led_set(uint8_t usb_led)
1250:quantum/quantum.c **** {
 2295               		.loc 1 1250 0
 2296               		.cfi_startproc
 2297               	.LVL229:
 2298               	/* prologue: function */
 2299               	/* frame size = 0 */
 2300               	/* stack size = 0 */
 2301               	.L__stack_usage = 0
1251:quantum/quantum.c **** 
1252:quantum/quantum.c ****   // Example LED Code
1253:quantum/quantum.c ****   //
1254:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1255:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1256:quantum/quantum.c ****     // {
1257:quantum/quantum.c ****     //     // Output high.
1258:quantum/quantum.c ****     //     DDRE |= (1<<6);
1259:quantum/quantum.c ****     //     PORTE |= (1<<6);
1260:quantum/quantum.c ****     // }
1261:quantum/quantum.c ****     // else
1262:quantum/quantum.c ****     // {
1263:quantum/quantum.c ****     //     // Output low.
1264:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1265:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1266:quantum/quantum.c ****     // }
1267:quantum/quantum.c **** 
1268:quantum/quantum.c ****   led_set_kb(usb_led);
 2302               		.loc 1 1268 0
 2303 0000 0C94 0000 		jmp led_set_kb
 2304               	.LVL230:
 2305               		.cfi_endproc
 2306               	.LFE62:
 2308               		.section	.text.startup_user,"ax",@progbits
 2309               		.weak	startup_user
 2311               	startup_user:
 2312               	.LFB66:
 2313               		.cfi_startproc
 2314               	/* prologue: function */
 2315               	/* frame size = 0 */
 2316               	/* stack size = 0 */
 2317               	.L__stack_usage = 0
 2318 0000 0895      		ret
 2319               		.cfi_endproc
 2320               	.LFE66:
 2322               		.section	.text.shutdown_user,"ax",@progbits
 2323               		.weak	shutdown_user
 2325               	shutdown_user:
 2326               	.LFB64:
1269:quantum/quantum.c **** }
1270:quantum/quantum.c **** 
1271:quantum/quantum.c **** 
1272:quantum/quantum.c **** //------------------------------------------------------------------------------
1273:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1274:quantum/quantum.c **** // different events such as startup and bootloader jump
1275:quantum/quantum.c **** 
1276:quantum/quantum.c **** __attribute__ ((weak))
1277:quantum/quantum.c **** void startup_user() {}
1278:quantum/quantum.c **** 
1279:quantum/quantum.c **** __attribute__ ((weak))
1280:quantum/quantum.c **** void shutdown_user() {}
 2327               		.loc 1 1280 0
 2328               		.cfi_startproc
 2329               	/* prologue: function */
 2330               	/* frame size = 0 */
 2331               	/* stack size = 0 */
 2332               	.L__stack_usage = 0
 2333 0000 0895      		ret
 2334               		.cfi_endproc
 2335               	.LFE64:
 2337               	.global	rgb_matrix_task_counter
 2338               		.section	.bss.rgb_matrix_task_counter,"aw",@nobits
 2341               	rgb_matrix_task_counter:
 2342 0000 00        		.zero	1
 2343               		.weak	ascii_to_keycode_lut
 2344               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2347               	ascii_to_keycode_lut:
 2348 0000 00        		.byte	0
 2349 0001 00        		.byte	0
 2350 0002 00        		.byte	0
 2351 0003 00        		.byte	0
 2352 0004 00        		.byte	0
 2353 0005 00        		.byte	0
 2354 0006 00        		.byte	0
 2355 0007 00        		.byte	0
 2356 0008 2A        		.byte	42
 2357 0009 2B        		.byte	43
 2358 000a 28        		.byte	40
 2359 000b 00        		.byte	0
 2360 000c 00        		.byte	0
 2361 000d 00        		.byte	0
 2362 000e 00        		.byte	0
 2363 000f 00        		.byte	0
 2364 0010 00        		.byte	0
 2365 0011 00        		.byte	0
 2366 0012 00        		.byte	0
 2367 0013 00        		.byte	0
 2368 0014 00        		.byte	0
 2369 0015 00        		.byte	0
 2370 0016 00        		.byte	0
 2371 0017 00        		.byte	0
 2372 0018 00        		.byte	0
 2373 0019 00        		.byte	0
 2374 001a 00        		.byte	0
 2375 001b 29        		.byte	41
 2376 001c 00        		.byte	0
 2377 001d 00        		.byte	0
 2378 001e 00        		.byte	0
 2379 001f 00        		.byte	0
 2380 0020 2C        		.byte	44
 2381 0021 1E        		.byte	30
 2382 0022 34        		.byte	52
 2383 0023 20        		.byte	32
 2384 0024 21        		.byte	33
 2385 0025 22        		.byte	34
 2386 0026 24        		.byte	36
 2387 0027 34        		.byte	52
 2388 0028 26        		.byte	38
 2389 0029 27        		.byte	39
 2390 002a 25        		.byte	37
 2391 002b 2E        		.byte	46
 2392 002c 36        		.byte	54
 2393 002d 2D        		.byte	45
 2394 002e 37        		.byte	55
 2395 002f 38        		.byte	56
 2396 0030 27        		.byte	39
 2397 0031 1E        		.byte	30
 2398 0032 1F        		.byte	31
 2399 0033 20        		.byte	32
 2400 0034 21        		.byte	33
 2401 0035 22        		.byte	34
 2402 0036 23        		.byte	35
 2403 0037 24        		.byte	36
 2404 0038 25        		.byte	37
 2405 0039 26        		.byte	38
 2406 003a 33        		.byte	51
 2407 003b 33        		.byte	51
 2408 003c 36        		.byte	54
 2409 003d 2E        		.byte	46
 2410 003e 37        		.byte	55
 2411 003f 38        		.byte	56
 2412 0040 1F        		.byte	31
 2413 0041 04        		.byte	4
 2414 0042 05        		.byte	5
 2415 0043 06        		.byte	6
 2416 0044 07        		.byte	7
 2417 0045 08        		.byte	8
 2418 0046 09        		.byte	9
 2419 0047 0A        		.byte	10
 2420 0048 0B        		.byte	11
 2421 0049 0C        		.byte	12
 2422 004a 0D        		.byte	13
 2423 004b 0E        		.byte	14
 2424 004c 0F        		.byte	15
 2425 004d 10        		.byte	16
 2426 004e 11        		.byte	17
 2427 004f 12        		.byte	18
 2428 0050 13        		.byte	19
 2429 0051 14        		.byte	20
 2430 0052 15        		.byte	21
 2431 0053 16        		.byte	22
 2432 0054 17        		.byte	23
 2433 0055 18        		.byte	24
 2434 0056 19        		.byte	25
 2435 0057 1A        		.byte	26
 2436 0058 1B        		.byte	27
 2437 0059 1C        		.byte	28
 2438 005a 1D        		.byte	29
 2439 005b 2F        		.byte	47
 2440 005c 31        		.byte	49
 2441 005d 30        		.byte	48
 2442 005e 23        		.byte	35
 2443 005f 2D        		.byte	45
 2444 0060 35        		.byte	53
 2445 0061 04        		.byte	4
 2446 0062 05        		.byte	5
 2447 0063 06        		.byte	6
 2448 0064 07        		.byte	7
 2449 0065 08        		.byte	8
 2450 0066 09        		.byte	9
 2451 0067 0A        		.byte	10
 2452 0068 0B        		.byte	11
 2453 0069 0C        		.byte	12
 2454 006a 0D        		.byte	13
 2455 006b 0E        		.byte	14
 2456 006c 0F        		.byte	15
 2457 006d 10        		.byte	16
 2458 006e 11        		.byte	17
 2459 006f 12        		.byte	18
 2460 0070 13        		.byte	19
 2461 0071 14        		.byte	20
 2462 0072 15        		.byte	21
 2463 0073 16        		.byte	22
 2464 0074 17        		.byte	23
 2465 0075 18        		.byte	24
 2466 0076 19        		.byte	25
 2467 0077 1A        		.byte	26
 2468 0078 1B        		.byte	27
 2469 0079 1C        		.byte	28
 2470 007a 1D        		.byte	29
 2471 007b 2F        		.byte	47
 2472 007c 31        		.byte	49
 2473 007d 30        		.byte	48
 2474 007e 35        		.byte	53
 2475 007f 4C        		.byte	76
 2476               		.weak	ascii_to_shift_lut
 2477               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2480               	ascii_to_shift_lut:
 2481 0000 00        		.byte	0
 2482 0001 00        		.byte	0
 2483 0002 00        		.byte	0
 2484 0003 00        		.byte	0
 2485 0004 00        		.byte	0
 2486 0005 00        		.byte	0
 2487 0006 00        		.byte	0
 2488 0007 00        		.byte	0
 2489 0008 00        		.byte	0
 2490 0009 00        		.byte	0
 2491 000a 00        		.byte	0
 2492 000b 00        		.byte	0
 2493 000c 00        		.byte	0
 2494 000d 00        		.byte	0
 2495 000e 00        		.byte	0
 2496 000f 00        		.byte	0
 2497 0010 00        		.byte	0
 2498 0011 00        		.byte	0
 2499 0012 00        		.byte	0
 2500 0013 00        		.byte	0
 2501 0014 00        		.byte	0
 2502 0015 00        		.byte	0
 2503 0016 00        		.byte	0
 2504 0017 00        		.byte	0
 2505 0018 00        		.byte	0
 2506 0019 00        		.byte	0
 2507 001a 00        		.byte	0
 2508 001b 00        		.byte	0
 2509 001c 00        		.byte	0
 2510 001d 00        		.byte	0
 2511 001e 00        		.byte	0
 2512 001f 00        		.byte	0
 2513 0020 00        		.byte	0
 2514 0021 01        		.byte	1
 2515 0022 01        		.byte	1
 2516 0023 01        		.byte	1
 2517 0024 01        		.byte	1
 2518 0025 01        		.byte	1
 2519 0026 01        		.byte	1
 2520 0027 00        		.byte	0
 2521 0028 01        		.byte	1
 2522 0029 01        		.byte	1
 2523 002a 01        		.byte	1
 2524 002b 01        		.byte	1
 2525 002c 00        		.byte	0
 2526 002d 00        		.byte	0
 2527 002e 00        		.byte	0
 2528 002f 00        		.byte	0
 2529 0030 00        		.byte	0
 2530 0031 00        		.byte	0
 2531 0032 00        		.byte	0
 2532 0033 00        		.byte	0
 2533 0034 00        		.byte	0
 2534 0035 00        		.byte	0
 2535 0036 00        		.byte	0
 2536 0037 00        		.byte	0
 2537 0038 00        		.byte	0
 2538 0039 00        		.byte	0
 2539 003a 01        		.byte	1
 2540 003b 00        		.byte	0
 2541 003c 01        		.byte	1
 2542 003d 00        		.byte	0
 2543 003e 01        		.byte	1
 2544 003f 01        		.byte	1
 2545 0040 01        		.byte	1
 2546 0041 01        		.byte	1
 2547 0042 01        		.byte	1
 2548 0043 01        		.byte	1
 2549 0044 01        		.byte	1
 2550 0045 01        		.byte	1
 2551 0046 01        		.byte	1
 2552 0047 01        		.byte	1
 2553 0048 01        		.byte	1
 2554 0049 01        		.byte	1
 2555 004a 01        		.byte	1
 2556 004b 01        		.byte	1
 2557 004c 01        		.byte	1
 2558 004d 01        		.byte	1
 2559 004e 01        		.byte	1
 2560 004f 01        		.byte	1
 2561 0050 01        		.byte	1
 2562 0051 01        		.byte	1
 2563 0052 01        		.byte	1
 2564 0053 01        		.byte	1
 2565 0054 01        		.byte	1
 2566 0055 01        		.byte	1
 2567 0056 01        		.byte	1
 2568 0057 01        		.byte	1
 2569 0058 01        		.byte	1
 2570 0059 01        		.byte	1
 2571 005a 01        		.byte	1
 2572 005b 00        		.byte	0
 2573 005c 00        		.byte	0
 2574 005d 00        		.byte	0
 2575 005e 01        		.byte	1
 2576 005f 01        		.byte	1
 2577 0060 00        		.byte	0
 2578 0061 00        		.byte	0
 2579 0062 00        		.byte	0
 2580 0063 00        		.byte	0
 2581 0064 00        		.byte	0
 2582 0065 00        		.byte	0
 2583 0066 00        		.byte	0
 2584 0067 00        		.byte	0
 2585 0068 00        		.byte	0
 2586 0069 00        		.byte	0
 2587 006a 00        		.byte	0
 2588 006b 00        		.byte	0
 2589 006c 00        		.byte	0
 2590 006d 00        		.byte	0
 2591 006e 00        		.byte	0
 2592 006f 00        		.byte	0
 2593 0070 00        		.byte	0
 2594 0071 00        		.byte	0
 2595 0072 00        		.byte	0
 2596 0073 00        		.byte	0
 2597 0074 00        		.byte	0
 2598 0075 00        		.byte	0
 2599 0076 00        		.byte	0
 2600 0077 00        		.byte	0
 2601 0078 00        		.byte	0
 2602 0079 00        		.byte	0
 2603 007a 00        		.byte	0
 2604 007b 01        		.byte	1
 2605 007c 01        		.byte	1
 2606 007d 01        		.byte	1
 2607 007e 01        		.byte	1
 2608 007f 00        		.byte	0
 2609               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2612               	grave_esc_was_shifted:
 2613 0000 00        		.zero	1
 2614               		.section	.bss.scs_timer,"aw",@nobits
 2617               	scs_timer:
 2618 0000 0000 0000 		.zero	4
 2619               		.section	.bss.shift_interrupted,"aw",@nobits
 2622               	shift_interrupted:
 2623 0000 0000      		.zero	2
 2624               		.text
 2625               	.Letext0:
 2626               		.file 4 "/usr/lib/avr/include/stdint.h"
 2627               		.file 5 "./tmk_core/common/keyboard.h"
 2628               		.file 6 "./tmk_core/common/action.h"
 2629               		.file 7 "./tmk_core/common/report.h"
 2630               		.file 8 "./tmk_core/common/debug.h"
 2631               		.file 9 "quantum/keycode_config.h"
 2632               		.file 10 "./tmk_core/common/keycode.h"
 2633               		.file 11 "quantum/quantum_keycodes.h"
 2634               		.file 12 "./tmk_core/protocol/lufa/outputselect.h"
 2635               		.file 13 "quantum/quantum.h"
 2636               		.file 14 "./tmk_core/common/bootloader.h"
 2637               		.file 15 "./tmk_core/common/action_layer.h"
 2638               		.file 16 "quantum/keymap.h"
 2639               		.file 17 "./quantum/process_keycode/process_tap_dance.h"
 2640               		.file 18 "./quantum/process_keycode/process_leader.h"
 2641               		.file 19 "./tmk_core/common/eeconfig.h"
 2642               		.file 20 "./tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/ccH8e2DI.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccH8e2DI.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccH8e2DI.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccH8e2DI.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccH8e2DI.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccH8e2DI.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/ccH8e2DI.s:129    .text.qk_register_mods:0000000000000000 qk_register_mods
     /tmp/ccH8e2DI.s:159    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
     /tmp/ccH8e2DI.s:172    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
     /tmp/ccH8e2DI.s:202    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
     /tmp/ccH8e2DI.s:216    .text.rgblight_toggle:0000000000000000 rgblight_toggle
     /tmp/ccH8e2DI.s:230    .text.rgblight_step:0000000000000000 rgblight_step
     /tmp/ccH8e2DI.s:244    .text.rgblight_step_reverse:0000000000000000 rgblight_step_reverse
     /tmp/ccH8e2DI.s:258    .text.rgblight_increase_hue:0000000000000000 rgblight_increase_hue
     /tmp/ccH8e2DI.s:272    .text.rgblight_decrease_hue:0000000000000000 rgblight_decrease_hue
     /tmp/ccH8e2DI.s:286    .text.rgblight_increase_sat:0000000000000000 rgblight_increase_sat
     /tmp/ccH8e2DI.s:300    .text.rgblight_decrease_sat:0000000000000000 rgblight_decrease_sat
     /tmp/ccH8e2DI.s:314    .text.rgblight_increase_val:0000000000000000 rgblight_increase_val
     /tmp/ccH8e2DI.s:328    .text.rgblight_decrease_val:0000000000000000 rgblight_decrease_val
     /tmp/ccH8e2DI.s:342    .text.rgblight_increase_speed:0000000000000000 rgblight_increase_speed
     /tmp/ccH8e2DI.s:356    .text.rgblight_decrease_speed:0000000000000000 rgblight_decrease_speed
     /tmp/ccH8e2DI.s:370    .text.register_code16:0000000000000000 register_code16
     /tmp/ccH8e2DI.s:427    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/ccH8e2DI.s:482    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/ccH8e2DI.s:501    .text.process_record_user:0000000000000000 process_record_user
     /tmp/ccH8e2DI.s:520    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/ccH8e2DI.s:538    .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/ccH8e2DI.s:579    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccH8e2DI.s:2612   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted
     /tmp/ccH8e2DI.s:2622   .bss.shift_interrupted:0000000000000000 shift_interrupted
     /tmp/ccH8e2DI.s:2617   .bss.scs_timer:0000000000000000 scs_timer
     /tmp/ccH8e2DI.s:1125   .text.send_char:0000000000000000 send_char
     /tmp/ccH8e2DI.s:2347   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
     /tmp/ccH8e2DI.s:2480   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
     /tmp/ccH8e2DI.s:1210   .text.send_string_with_delay:0000000000000000 send_string_with_delay
     /tmp/ccH8e2DI.s:1354   .text.send_string:0000000000000000 send_string
     /tmp/ccH8e2DI.s:1373   .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
     /tmp/ccH8e2DI.s:1549   .text.send_string_P:0000000000000000 send_string_P
     /tmp/ccH8e2DI.s:1568   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/ccH8e2DI.s:1617   .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
     /tmp/ccH8e2DI.s:1772   .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/ccH8e2DI.s:1811   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/ccH8e2DI.s:1938   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccH8e2DI.s:1955   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccH8e2DI.s:1975   .text.backlight_init_ports:0000000000000000 backlight_init_ports
     /tmp/ccH8e2DI.s:1989   .text.send_nibble:0000000000000000 send_nibble
     /tmp/ccH8e2DI.s:2054   .text.send_byte:0000000000000000 send_byte
     /tmp/ccH8e2DI.s:2091   .text.send_word:0000000000000000 send_word
     /tmp/ccH8e2DI.s:2125   .text.send_dword:0000000000000000 send_dword
     /tmp/ccH8e2DI.s:2175   .text.hex_to_keycode:0000000000000000 hex_to_keycode
     /tmp/ccH8e2DI.s:2214   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/ccH8e2DI.s:2230   .text.led_set_user:0000000000000000 led_set_user
     /tmp/ccH8e2DI.s:2230   .text.led_set_user:0000000000000000 led_set_user.localalias.1
     /tmp/ccH8e2DI.s:2247   .text.backlight_set:0000000000000000 backlight_set
     /tmp/ccH8e2DI.s:2261   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/ccH8e2DI.s:2279   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/ccH8e2DI.s:2293   .text.led_set:0000000000000000 led_set
     /tmp/ccH8e2DI.s:2311   .text.startup_user:0000000000000000 startup_user
     /tmp/ccH8e2DI.s:2325   .text.shutdown_user:0000000000000000 shutdown_user
     /tmp/ccH8e2DI.s:2341   .bss.rgb_matrix_task_counter:0000000000000000 rgb_matrix_task_counter

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
clear_keyboard
bootloader_jump
layer_switch_get_layer
keymap_key_to_keycode
preprocess_tap_dance
process_tap_dance
process_leader
get_mods
keyboard_report
add_key_to_report
del_key_from_report
debug_config
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
timer_read
register_mods
unregister_mods
timer_elapsed
set_output
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_init_kb
matrix_scan_tap_dance
matrix_scan_kb
__do_clear_bss
