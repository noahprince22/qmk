   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_scan_user,"ax",@progbits
  11               		.weak	matrix_scan_user
  13               	matrix_scan_user:
  14               	.LFB12:
  15               		.file 1 "keyboards/Dactylv2/matrix.c"
   1:keyboards/Dactylv2/matrix.c **** /*
   2:keyboards/Dactylv2/matrix.c **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:keyboards/Dactylv2/matrix.c **** 
   4:keyboards/Dactylv2/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:keyboards/Dactylv2/matrix.c **** it under the terms of the GNU General Public License as published by
   6:keyboards/Dactylv2/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:keyboards/Dactylv2/matrix.c **** (at your option) any later version.
   8:keyboards/Dactylv2/matrix.c **** 
   9:keyboards/Dactylv2/matrix.c **** This program is distributed in the hope that it will be useful,
  10:keyboards/Dactylv2/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:keyboards/Dactylv2/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:keyboards/Dactylv2/matrix.c **** GNU General Public License for more details.
  13:keyboards/Dactylv2/matrix.c **** 
  14:keyboards/Dactylv2/matrix.c **** You should have received a copy of the GNU General Public License
  15:keyboards/Dactylv2/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:keyboards/Dactylv2/matrix.c **** */
  17:keyboards/Dactylv2/matrix.c **** 
  18:keyboards/Dactylv2/matrix.c **** /*
  19:keyboards/Dactylv2/matrix.c ****  * scan matrix
  20:keyboards/Dactylv2/matrix.c ****  */
  21:keyboards/Dactylv2/matrix.c **** #include <stdint.h>
  22:keyboards/Dactylv2/matrix.c **** #include <stdbool.h>
  23:keyboards/Dactylv2/matrix.c **** #include <avr/io.h>
  24:keyboards/Dactylv2/matrix.c **** #include "wait.h"
  25:keyboards/Dactylv2/matrix.c **** #include "print.h"
  26:keyboards/Dactylv2/matrix.c **** #include "debug.h"
  27:keyboards/Dactylv2/matrix.c **** #include "util.h"
  28:keyboards/Dactylv2/matrix.c **** #include "matrix.h"
  29:keyboards/Dactylv2/matrix.c **** #include "split_util.h"
  30:keyboards/Dactylv2/matrix.c **** #include "pro_micro.h"
  31:keyboards/Dactylv2/matrix.c **** #include "config.h"
  32:keyboards/Dactylv2/matrix.c **** #include "timer.h"
  33:keyboards/Dactylv2/matrix.c **** 
  34:keyboards/Dactylv2/matrix.c **** #ifdef USE_I2C
  35:keyboards/Dactylv2/matrix.c **** #  include "i2c.h"
  36:keyboards/Dactylv2/matrix.c **** #else // USE_SERIAL
  37:keyboards/Dactylv2/matrix.c **** #  include "serial.h"
  38:keyboards/Dactylv2/matrix.c **** #endif
  39:keyboards/Dactylv2/matrix.c **** 
  40:keyboards/Dactylv2/matrix.c **** #ifndef DEBOUNCING_DELAY
  41:keyboards/Dactylv2/matrix.c **** #   define DEBOUNCING_DELAY 5
  42:keyboards/Dactylv2/matrix.c **** #endif
  43:keyboards/Dactylv2/matrix.c **** 
  44:keyboards/Dactylv2/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  45:keyboards/Dactylv2/matrix.c ****     static uint16_t debouncing_time;
  46:keyboards/Dactylv2/matrix.c ****     static bool debouncing = false;
  47:keyboards/Dactylv2/matrix.c **** #endif
  48:keyboards/Dactylv2/matrix.c **** 
  49:keyboards/Dactylv2/matrix.c **** #if (MATRIX_COLS <= 8)
  50:keyboards/Dactylv2/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  51:keyboards/Dactylv2/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  52:keyboards/Dactylv2/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  53:keyboards/Dactylv2/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  54:keyboards/Dactylv2/matrix.c **** #else
  55:keyboards/Dactylv2/matrix.c **** #    error "Currently only supports 8 COLS"
  56:keyboards/Dactylv2/matrix.c **** #endif
  57:keyboards/Dactylv2/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  58:keyboards/Dactylv2/matrix.c **** 
  59:keyboards/Dactylv2/matrix.c **** #define ERROR_DISCONNECT_COUNT 5
  60:keyboards/Dactylv2/matrix.c **** 
  61:keyboards/Dactylv2/matrix.c **** #define ROWS_PER_HAND (MATRIX_ROWS/2)
  62:keyboards/Dactylv2/matrix.c **** 
  63:keyboards/Dactylv2/matrix.c **** static uint8_t error_count = 0;
  64:keyboards/Dactylv2/matrix.c **** 
  65:keyboards/Dactylv2/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  66:keyboards/Dactylv2/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  67:keyboards/Dactylv2/matrix.c **** 
  68:keyboards/Dactylv2/matrix.c **** /* matrix state(1:on, 0:off) */
  69:keyboards/Dactylv2/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  70:keyboards/Dactylv2/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:keyboards/Dactylv2/matrix.c **** 
  72:keyboards/Dactylv2/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  73:keyboards/Dactylv2/matrix.c ****     static void init_cols(void);
  74:keyboards/Dactylv2/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  75:keyboards/Dactylv2/matrix.c ****     static void unselect_rows(void);
  76:keyboards/Dactylv2/matrix.c ****     static void select_row(uint8_t row);
  77:keyboards/Dactylv2/matrix.c ****     static void unselect_row(uint8_t row);
  78:keyboards/Dactylv2/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
  79:keyboards/Dactylv2/matrix.c ****     static void init_rows(void);
  80:keyboards/Dactylv2/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  81:keyboards/Dactylv2/matrix.c ****     static void unselect_cols(void);
  82:keyboards/Dactylv2/matrix.c ****     static void unselect_col(uint8_t col);
  83:keyboards/Dactylv2/matrix.c ****     static void select_col(uint8_t col);
  84:keyboards/Dactylv2/matrix.c **** #endif
  85:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
  86:keyboards/Dactylv2/matrix.c **** void matrix_init_quantum(void) {
  87:keyboards/Dactylv2/matrix.c ****     matrix_init_kb();
  88:keyboards/Dactylv2/matrix.c **** }
  89:keyboards/Dactylv2/matrix.c **** 
  90:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
  91:keyboards/Dactylv2/matrix.c **** void matrix_scan_quantum(void) {
  92:keyboards/Dactylv2/matrix.c ****     matrix_scan_kb();
  93:keyboards/Dactylv2/matrix.c **** }
  94:keyboards/Dactylv2/matrix.c **** 
  95:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
  96:keyboards/Dactylv2/matrix.c **** void matrix_init_kb(void) {
  97:keyboards/Dactylv2/matrix.c ****     matrix_init_user();
  98:keyboards/Dactylv2/matrix.c **** }
  99:keyboards/Dactylv2/matrix.c **** 
 100:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
 101:keyboards/Dactylv2/matrix.c **** void matrix_scan_kb(void) {
 102:keyboards/Dactylv2/matrix.c ****     matrix_scan_user();
 103:keyboards/Dactylv2/matrix.c **** }
 104:keyboards/Dactylv2/matrix.c **** 
 105:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
 106:keyboards/Dactylv2/matrix.c **** void matrix_init_user(void) {
 107:keyboards/Dactylv2/matrix.c **** }
 108:keyboards/Dactylv2/matrix.c **** 
 109:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
 110:keyboards/Dactylv2/matrix.c **** void matrix_scan_user(void) {
  16               		.loc 1 110 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 0895      		ret
  23               		.cfi_endproc
  24               	.LFE12:
  26               		.set	matrix_scan_user.localalias.0,matrix_scan_user
  27               		.section	.text.matrix_init_user,"ax",@progbits
  28               		.weak	matrix_init_user
  30               	matrix_init_user:
  31               	.LFB31:
  32               		.cfi_startproc
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
  37 0000 0C94 0000 		jmp matrix_scan_user.localalias.0
  38               		.cfi_endproc
  39               	.LFE31:
  41               		.section	.text.matrix_init_kb,"ax",@progbits
  42               		.weak	matrix_init_kb
  44               	matrix_init_kb:
  45               	.LFB9:
  96:keyboards/Dactylv2/matrix.c ****     matrix_init_user();
  46               		.loc 1 96 0
  47               		.cfi_startproc
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 0 */
  51               	.L__stack_usage = 0
  97:keyboards/Dactylv2/matrix.c **** }
  52               		.loc 1 97 0
  53 0000 0C94 0000 		jmp matrix_init_user
  54               	.LVL0:
  55               		.cfi_endproc
  56               	.LFE9:
  58               		.section	.text.matrix_init_quantum,"ax",@progbits
  59               		.weak	matrix_init_quantum
  61               	matrix_init_quantum:
  62               	.LFB7:
  86:keyboards/Dactylv2/matrix.c ****     matrix_init_kb();
  63               		.loc 1 86 0
  64               		.cfi_startproc
  65               	/* prologue: function */
  66               	/* frame size = 0 */
  67               	/* stack size = 0 */
  68               	.L__stack_usage = 0
  87:keyboards/Dactylv2/matrix.c **** }
  69               		.loc 1 87 0
  70 0000 0C94 0000 		jmp matrix_init_kb
  71               	.LVL1:
  72               		.cfi_endproc
  73               	.LFE7:
  75               		.section	.text.matrix_scan_kb,"ax",@progbits
  76               		.weak	matrix_scan_kb
  78               	matrix_scan_kb:
  79               	.LFB10:
 101:keyboards/Dactylv2/matrix.c ****     matrix_scan_user();
  80               		.loc 1 101 0
  81               		.cfi_startproc
  82               	/* prologue: function */
  83               	/* frame size = 0 */
  84               	/* stack size = 0 */
  85               	.L__stack_usage = 0
 102:keyboards/Dactylv2/matrix.c **** }
  86               		.loc 1 102 0
  87 0000 0C94 0000 		jmp matrix_scan_user
  88               	.LVL2:
  89               		.cfi_endproc
  90               	.LFE10:
  92               		.section	.text.matrix_scan_quantum,"ax",@progbits
  93               		.weak	matrix_scan_quantum
  95               	matrix_scan_quantum:
  96               	.LFB8:
  91:keyboards/Dactylv2/matrix.c ****     matrix_scan_kb();
  97               		.loc 1 91 0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
  92:keyboards/Dactylv2/matrix.c **** }
 103               		.loc 1 92 0
 104 0000 0C94 0000 		jmp matrix_scan_kb
 105               	.LVL3:
 106               		.cfi_endproc
 107               	.LFE8:
 109               		.section	.text.matrix_rows,"ax",@progbits
 110               	.global	matrix_rows
 112               	matrix_rows:
 113               	.LFB13:
 111:keyboards/Dactylv2/matrix.c **** }
 112:keyboards/Dactylv2/matrix.c **** 
 113:keyboards/Dactylv2/matrix.c **** inline
 114:keyboards/Dactylv2/matrix.c **** uint8_t matrix_rows(void)
 115:keyboards/Dactylv2/matrix.c **** {
 114               		.loc 1 115 0
 115               		.cfi_startproc
 116               	/* prologue: function */
 117               	/* frame size = 0 */
 118               	/* stack size = 0 */
 119               	.L__stack_usage = 0
 116:keyboards/Dactylv2/matrix.c ****     return MATRIX_ROWS;
 117:keyboards/Dactylv2/matrix.c **** }
 120               		.loc 1 117 0
 121 0000 8EE0      		ldi r24,lo8(14)
 122 0002 0895      		ret
 123               		.cfi_endproc
 124               	.LFE13:
 126               		.section	.text.matrix_cols,"ax",@progbits
 127               	.global	matrix_cols
 129               	matrix_cols:
 130               	.LFB14:
 118:keyboards/Dactylv2/matrix.c **** 
 119:keyboards/Dactylv2/matrix.c **** inline
 120:keyboards/Dactylv2/matrix.c **** uint8_t matrix_cols(void)
 121:keyboards/Dactylv2/matrix.c **** {
 131               		.loc 1 121 0
 132               		.cfi_startproc
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
 122:keyboards/Dactylv2/matrix.c ****     return MATRIX_COLS;
 123:keyboards/Dactylv2/matrix.c **** }
 137               		.loc 1 123 0
 138 0000 86E0      		ldi r24,lo8(6)
 139 0002 0895      		ret
 140               		.cfi_endproc
 141               	.LFE14:
 143               		.section	.text.matrix_init,"ax",@progbits
 144               	.global	matrix_init
 146               	matrix_init:
 147               	.LFB15:
 124:keyboards/Dactylv2/matrix.c **** 
 125:keyboards/Dactylv2/matrix.c **** void matrix_init(void)
 126:keyboards/Dactylv2/matrix.c **** {
 148               		.loc 1 126 0
 149               		.cfi_startproc
 150 0000 CF93      		push r28
 151               	.LCFI0:
 152               		.cfi_def_cfa_offset 3
 153               		.cfi_offset 28, -2
 154 0002 DF93      		push r29
 155               	.LCFI1:
 156               		.cfi_def_cfa_offset 4
 157               		.cfi_offset 29, -3
 158               	/* prologue: function */
 159               	/* frame size = 0 */
 160               	/* stack size = 2 */
 161               	.L__stack_usage = 2
 127:keyboards/Dactylv2/matrix.c ****     debug_enable = true;
 162               		.loc 1 127 0
 163 0004 8091 0000 		lds r24,debug_config
 128:keyboards/Dactylv2/matrix.c ****     debug_matrix = true;
 129:keyboards/Dactylv2/matrix.c ****     debug_mouse = true;
 164               		.loc 1 129 0
 165 0008 8360      		ori r24,lo8(3)
 166 000a 8860      		ori r24,lo8(1<<3)
 167 000c 8093 0000 		sts debug_config,r24
 168               	.LVL4:
 169 0010 A0E0      		ldi r26,lo8(row_pins)
 170 0012 B0E0      		ldi r27,hi8(row_pins)
 171 0014 40E0      		ldi r20,lo8(row_pins+7)
 172 0016 50E0      		ldi r21,hi8(row_pins+7)
 173               	.LBB15:
 174               	.LBB16:
 175               	.LBB17:
 130:keyboards/Dactylv2/matrix.c ****     // initialize row and col
 131:keyboards/Dactylv2/matrix.c ****     unselect_rows();
 132:keyboards/Dactylv2/matrix.c ****     init_cols();
 133:keyboards/Dactylv2/matrix.c **** 
 134:keyboards/Dactylv2/matrix.c ****     TX_RX_LED_INIT;
 135:keyboards/Dactylv2/matrix.c **** 
 136:keyboards/Dactylv2/matrix.c ****     // initialize matrix state: all keys off
 137:keyboards/Dactylv2/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 138:keyboards/Dactylv2/matrix.c ****         matrix[i] = 0;
 139:keyboards/Dactylv2/matrix.c ****         matrix_debouncing[i] = 0;
 140:keyboards/Dactylv2/matrix.c ****     }
 141:keyboards/Dactylv2/matrix.c **** 
 142:keyboards/Dactylv2/matrix.c ****     matrix_init_quantum();
 143:keyboards/Dactylv2/matrix.c **** 
 144:keyboards/Dactylv2/matrix.c **** }
 145:keyboards/Dactylv2/matrix.c **** 
 146:keyboards/Dactylv2/matrix.c **** uint8_t _matrix_scan(void)
 147:keyboards/Dactylv2/matrix.c **** {
 148:keyboards/Dactylv2/matrix.c ****     int offset = isLeftHand ? 0 : (ROWS_PER_HAND);
 149:keyboards/Dactylv2/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 150:keyboards/Dactylv2/matrix.c ****     // Set row, read cols
 151:keyboards/Dactylv2/matrix.c ****     for (uint8_t current_row = 0; current_row < ROWS_PER_HAND; current_row++) {
 152:keyboards/Dactylv2/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 153:keyboards/Dactylv2/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing+offset, current_row);
 154:keyboards/Dactylv2/matrix.c **** 
 155:keyboards/Dactylv2/matrix.c ****             if (matrix_changed) {
 156:keyboards/Dactylv2/matrix.c ****                 debouncing = true;
 157:keyboards/Dactylv2/matrix.c ****                 debouncing_time = timer_read();
 158:keyboards/Dactylv2/matrix.c ****                 PORTD ^= (1 << 2);
 159:keyboards/Dactylv2/matrix.c ****             }
 160:keyboards/Dactylv2/matrix.c **** 
 161:keyboards/Dactylv2/matrix.c **** #       else
 162:keyboards/Dactylv2/matrix.c ****             read_cols_on_row(matrix+offset, current_row);
 163:keyboards/Dactylv2/matrix.c **** #       endif
 164:keyboards/Dactylv2/matrix.c **** 
 165:keyboards/Dactylv2/matrix.c ****     }
 166:keyboards/Dactylv2/matrix.c **** 
 167:keyboards/Dactylv2/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 168:keyboards/Dactylv2/matrix.c ****     // Set col, read rows
 169:keyboards/Dactylv2/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 170:keyboards/Dactylv2/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 171:keyboards/Dactylv2/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing+offset, current_col);
 172:keyboards/Dactylv2/matrix.c ****             if (matrix_changed) {
 173:keyboards/Dactylv2/matrix.c ****                 debouncing = true;
 174:keyboards/Dactylv2/matrix.c ****                 debouncing_time = timer_read();
 175:keyboards/Dactylv2/matrix.c ****             }
 176:keyboards/Dactylv2/matrix.c **** #       else
 177:keyboards/Dactylv2/matrix.c ****              read_rows_on_col(matrix+offset, current_col);
 178:keyboards/Dactylv2/matrix.c **** #       endif
 179:keyboards/Dactylv2/matrix.c **** 
 180:keyboards/Dactylv2/matrix.c ****     }
 181:keyboards/Dactylv2/matrix.c **** #endif
 182:keyboards/Dactylv2/matrix.c **** 
 183:keyboards/Dactylv2/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 184:keyboards/Dactylv2/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 185:keyboards/Dactylv2/matrix.c ****             for (uint8_t i = 0; i < ROWS_PER_HAND; i++) {
 186:keyboards/Dactylv2/matrix.c ****                 matrix[i+offset] = matrix_debouncing[i+offset];
 187:keyboards/Dactylv2/matrix.c ****             }
 188:keyboards/Dactylv2/matrix.c ****             debouncing = false;
 189:keyboards/Dactylv2/matrix.c ****         }
 190:keyboards/Dactylv2/matrix.c **** #   endif
 191:keyboards/Dactylv2/matrix.c **** 
 192:keyboards/Dactylv2/matrix.c ****     return 1;
 193:keyboards/Dactylv2/matrix.c **** }
 194:keyboards/Dactylv2/matrix.c **** 
 195:keyboards/Dactylv2/matrix.c **** #ifdef USE_I2C
 196:keyboards/Dactylv2/matrix.c **** 
 197:keyboards/Dactylv2/matrix.c **** // Get rows from other half over i2c
 198:keyboards/Dactylv2/matrix.c **** int i2c_transaction(void) {
 199:keyboards/Dactylv2/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 200:keyboards/Dactylv2/matrix.c **** 
 201:keyboards/Dactylv2/matrix.c ****     int err = i2c_master_start(SLAVE_I2C_ADDRESS + I2C_WRITE);
 202:keyboards/Dactylv2/matrix.c ****     if (err) goto i2c_error;
 203:keyboards/Dactylv2/matrix.c **** 
 204:keyboards/Dactylv2/matrix.c ****     // start of matrix stored at 0x00
 205:keyboards/Dactylv2/matrix.c ****     err = i2c_master_write(0x00);
 206:keyboards/Dactylv2/matrix.c ****     if (err) goto i2c_error;
 207:keyboards/Dactylv2/matrix.c **** 
 208:keyboards/Dactylv2/matrix.c ****     // Start read
 209:keyboards/Dactylv2/matrix.c ****     err = i2c_master_start(SLAVE_I2C_ADDRESS + I2C_READ);
 210:keyboards/Dactylv2/matrix.c ****     if (err) goto i2c_error;
 211:keyboards/Dactylv2/matrix.c **** 
 212:keyboards/Dactylv2/matrix.c ****     if (!err) {
 213:keyboards/Dactylv2/matrix.c ****         int i;
 214:keyboards/Dactylv2/matrix.c ****         for (i = 0; i < ROWS_PER_HAND-1; ++i) {
 215:keyboards/Dactylv2/matrix.c ****             matrix[slaveOffset+i] = i2c_master_read(I2C_ACK);
 216:keyboards/Dactylv2/matrix.c ****         }
 217:keyboards/Dactylv2/matrix.c ****         matrix[slaveOffset+i] = i2c_master_read(I2C_NACK);
 218:keyboards/Dactylv2/matrix.c ****         i2c_master_stop();
 219:keyboards/Dactylv2/matrix.c ****     } else {
 220:keyboards/Dactylv2/matrix.c **** i2c_error: // the cable is disconnceted, or something else went wrong
 221:keyboards/Dactylv2/matrix.c ****         i2c_reset_state();
 222:keyboards/Dactylv2/matrix.c ****         return err;
 223:keyboards/Dactylv2/matrix.c ****     }
 224:keyboards/Dactylv2/matrix.c **** 
 225:keyboards/Dactylv2/matrix.c ****     return 0;
 226:keyboards/Dactylv2/matrix.c **** }
 227:keyboards/Dactylv2/matrix.c **** 
 228:keyboards/Dactylv2/matrix.c **** #else // USE_SERIAL
 229:keyboards/Dactylv2/matrix.c **** 
 230:keyboards/Dactylv2/matrix.c **** int serial_transaction(void) {
 231:keyboards/Dactylv2/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 232:keyboards/Dactylv2/matrix.c **** 
 233:keyboards/Dactylv2/matrix.c ****     if (serial_update_buffers()) {
 234:keyboards/Dactylv2/matrix.c ****         return 1;
 235:keyboards/Dactylv2/matrix.c ****     }
 236:keyboards/Dactylv2/matrix.c **** 
 237:keyboards/Dactylv2/matrix.c ****     for (int i = 0; i < ROWS_PER_HAND; ++i) {
 238:keyboards/Dactylv2/matrix.c ****         matrix[slaveOffset+i] = serial_slave_buffer[i];
 239:keyboards/Dactylv2/matrix.c ****     }
 240:keyboards/Dactylv2/matrix.c ****     return 0;
 241:keyboards/Dactylv2/matrix.c **** }
 242:keyboards/Dactylv2/matrix.c **** #endif
 243:keyboards/Dactylv2/matrix.c **** 
 244:keyboards/Dactylv2/matrix.c **** uint8_t matrix_scan(void)
 245:keyboards/Dactylv2/matrix.c **** {
 246:keyboards/Dactylv2/matrix.c ****     uint8_t ret = _matrix_scan();
 247:keyboards/Dactylv2/matrix.c **** 
 248:keyboards/Dactylv2/matrix.c **** #ifdef USE_I2C
 249:keyboards/Dactylv2/matrix.c ****     if( i2c_transaction() ) {
 250:keyboards/Dactylv2/matrix.c **** #else // USE_SERIAL
 251:keyboards/Dactylv2/matrix.c ****     if( serial_transaction() ) {
 252:keyboards/Dactylv2/matrix.c **** #endif
 253:keyboards/Dactylv2/matrix.c ****         // turn on the indicator led when halves are disconnected
 254:keyboards/Dactylv2/matrix.c ****         TXLED1;
 255:keyboards/Dactylv2/matrix.c **** 
 256:keyboards/Dactylv2/matrix.c ****         error_count++;
 257:keyboards/Dactylv2/matrix.c **** 
 258:keyboards/Dactylv2/matrix.c ****         if (error_count > ERROR_DISCONNECT_COUNT) {
 259:keyboards/Dactylv2/matrix.c ****             // reset other half if disconnected
 260:keyboards/Dactylv2/matrix.c ****             int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 261:keyboards/Dactylv2/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 262:keyboards/Dactylv2/matrix.c ****                 matrix[slaveOffset+i] = 0;
 263:keyboards/Dactylv2/matrix.c ****             }
 264:keyboards/Dactylv2/matrix.c ****         }
 265:keyboards/Dactylv2/matrix.c ****     } else {
 266:keyboards/Dactylv2/matrix.c ****         // turn off the indicator led on no error
 267:keyboards/Dactylv2/matrix.c ****         TXLED0;
 268:keyboards/Dactylv2/matrix.c ****         error_count = 0;
 269:keyboards/Dactylv2/matrix.c ****     }
 270:keyboards/Dactylv2/matrix.c ****     matrix_scan_quantum();
 271:keyboards/Dactylv2/matrix.c ****     return ret;
 272:keyboards/Dactylv2/matrix.c **** }
 273:keyboards/Dactylv2/matrix.c **** 
 274:keyboards/Dactylv2/matrix.c **** void matrix_slave_scan(void) {
 275:keyboards/Dactylv2/matrix.c ****     _matrix_scan();
 276:keyboards/Dactylv2/matrix.c **** 
 277:keyboards/Dactylv2/matrix.c ****     int offset = (isLeftHand) ? 0 : ROWS_PER_HAND;
 278:keyboards/Dactylv2/matrix.c **** 
 279:keyboards/Dactylv2/matrix.c **** #ifdef USE_I2C
 280:keyboards/Dactylv2/matrix.c ****     for (int i = 0; i < ROWS_PER_HAND; ++i) {
 281:keyboards/Dactylv2/matrix.c ****         i2c_slave_buffer[i] = matrix[offset+i];
 282:keyboards/Dactylv2/matrix.c ****     }
 283:keyboards/Dactylv2/matrix.c **** #else // USE_SERIAL
 284:keyboards/Dactylv2/matrix.c ****     for (int i = 0; i < ROWS_PER_HAND; ++i) {
 285:keyboards/Dactylv2/matrix.c ****         serial_slave_buffer[i] = matrix[offset+i];
 286:keyboards/Dactylv2/matrix.c ****     }
 287:keyboards/Dactylv2/matrix.c **** #endif
 288:keyboards/Dactylv2/matrix.c **** }
 289:keyboards/Dactylv2/matrix.c **** 
 290:keyboards/Dactylv2/matrix.c **** bool matrix_is_modified(void)
 291:keyboards/Dactylv2/matrix.c **** {
 292:keyboards/Dactylv2/matrix.c ****     if (debouncing) return false;
 293:keyboards/Dactylv2/matrix.c ****     return true;
 294:keyboards/Dactylv2/matrix.c **** }
 295:keyboards/Dactylv2/matrix.c **** 
 296:keyboards/Dactylv2/matrix.c **** inline
 297:keyboards/Dactylv2/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 298:keyboards/Dactylv2/matrix.c **** {
 299:keyboards/Dactylv2/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 300:keyboards/Dactylv2/matrix.c **** }
 301:keyboards/Dactylv2/matrix.c **** 
 302:keyboards/Dactylv2/matrix.c **** inline
 303:keyboards/Dactylv2/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 304:keyboards/Dactylv2/matrix.c **** {
 305:keyboards/Dactylv2/matrix.c ****     return matrix[row];
 306:keyboards/Dactylv2/matrix.c **** }
 307:keyboards/Dactylv2/matrix.c **** 
 308:keyboards/Dactylv2/matrix.c **** void matrix_print(void)
 309:keyboards/Dactylv2/matrix.c **** {
 310:keyboards/Dactylv2/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 311:keyboards/Dactylv2/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 312:keyboards/Dactylv2/matrix.c ****         phex(row); print(": ");
 313:keyboards/Dactylv2/matrix.c ****         pbin_reverse16(matrix_get_row(row));
 314:keyboards/Dactylv2/matrix.c ****         print("\n");
 315:keyboards/Dactylv2/matrix.c ****     }
 316:keyboards/Dactylv2/matrix.c **** }
 317:keyboards/Dactylv2/matrix.c **** 
 318:keyboards/Dactylv2/matrix.c **** uint8_t matrix_key_count(void)
 319:keyboards/Dactylv2/matrix.c **** {
 320:keyboards/Dactylv2/matrix.c ****     uint8_t count = 0;
 321:keyboards/Dactylv2/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 322:keyboards/Dactylv2/matrix.c ****         count += bitpop16(matrix[i]);
 323:keyboards/Dactylv2/matrix.c ****     }
 324:keyboards/Dactylv2/matrix.c ****     return count;
 325:keyboards/Dactylv2/matrix.c **** }
 326:keyboards/Dactylv2/matrix.c **** 
 327:keyboards/Dactylv2/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 328:keyboards/Dactylv2/matrix.c **** 
 329:keyboards/Dactylv2/matrix.c **** static void init_cols(void)
 330:keyboards/Dactylv2/matrix.c **** {
 331:keyboards/Dactylv2/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 332:keyboards/Dactylv2/matrix.c ****         uint8_t pin = col_pins[x];
 333:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 334:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 335:keyboards/Dactylv2/matrix.c ****     }
 336:keyboards/Dactylv2/matrix.c **** }
 337:keyboards/Dactylv2/matrix.c **** 
 338:keyboards/Dactylv2/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 339:keyboards/Dactylv2/matrix.c **** {
 340:keyboards/Dactylv2/matrix.c ****     // Store last value of row prior to reading
 341:keyboards/Dactylv2/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 342:keyboards/Dactylv2/matrix.c **** 
 343:keyboards/Dactylv2/matrix.c ****     // Clear data in matrix row
 344:keyboards/Dactylv2/matrix.c ****     current_matrix[current_row] = 0;
 345:keyboards/Dactylv2/matrix.c **** 
 346:keyboards/Dactylv2/matrix.c ****     // Select row and wait for row selecton to stabilize
 347:keyboards/Dactylv2/matrix.c ****     select_row(current_row);
 348:keyboards/Dactylv2/matrix.c ****     wait_us(30);
 349:keyboards/Dactylv2/matrix.c **** 
 350:keyboards/Dactylv2/matrix.c ****     // For each col...
 351:keyboards/Dactylv2/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 352:keyboards/Dactylv2/matrix.c **** 
 353:keyboards/Dactylv2/matrix.c ****         // Select the col pin to read (active low)
 354:keyboards/Dactylv2/matrix.c ****         uint8_t pin = col_pins[col_index];
 355:keyboards/Dactylv2/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 356:keyboards/Dactylv2/matrix.c **** 
 357:keyboards/Dactylv2/matrix.c ****         // Populate the matrix row with the state of the col pin
 358:keyboards/Dactylv2/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 359:keyboards/Dactylv2/matrix.c ****     }
 360:keyboards/Dactylv2/matrix.c **** 
 361:keyboards/Dactylv2/matrix.c ****     // Unselect row
 362:keyboards/Dactylv2/matrix.c ****     unselect_row(current_row);
 363:keyboards/Dactylv2/matrix.c **** 
 364:keyboards/Dactylv2/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 365:keyboards/Dactylv2/matrix.c **** }
 366:keyboards/Dactylv2/matrix.c **** 
 367:keyboards/Dactylv2/matrix.c **** static void select_row(uint8_t row)
 368:keyboards/Dactylv2/matrix.c **** {
 369:keyboards/Dactylv2/matrix.c ****     uint8_t pin = row_pins[row];
 370:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 371:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 372:keyboards/Dactylv2/matrix.c **** }
 373:keyboards/Dactylv2/matrix.c **** 
 374:keyboards/Dactylv2/matrix.c **** static void unselect_row(uint8_t row)
 375:keyboards/Dactylv2/matrix.c **** {
 376:keyboards/Dactylv2/matrix.c ****     uint8_t pin = row_pins[row];
 377:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 378:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 379:keyboards/Dactylv2/matrix.c **** }
 380:keyboards/Dactylv2/matrix.c **** 
 381:keyboards/Dactylv2/matrix.c **** static void unselect_rows(void)
 382:keyboards/Dactylv2/matrix.c **** {
 383:keyboards/Dactylv2/matrix.c ****     for(uint8_t x = 0; x < ROWS_PER_HAND; x++) {
 384:keyboards/Dactylv2/matrix.c ****         uint8_t pin = row_pins[x];
 385:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 176               		.loc 1 385 0
 177 0018 61E0      		ldi r22,lo8(1)
 178 001a 70E0      		ldi r23,0
 179               	.LVL5:
 180               	.L10:
 384:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 181               		.loc 1 384 0
 182 001c 8D91      		ld r24,X+
 183               	.LVL6:
 184               		.loc 1 385 0
 185 001e E82F      		mov r30,r24
 186 0020 E295      		swap r30
 187 0022 EF70      		andi r30,lo8(15)
 188 0024 F0E0      		ldi r31,0
 189 0026 21A1      		ldd r18,Z+33
 190 0028 8F70      		andi r24,lo8(15)
 191               	.LVL7:
 192 002a EB01      		movw r28,r22
 193 002c 00C0      		rjmp 2f
 194               		1:
 195 002e CC0F      		lsl r28
 196 0030 DD1F      		rol r29
 197               		2:
 198 0032 8A95      		dec r24
 199 0034 02F4      		brpl 1b
 200 0036 CE01      		movw r24,r28
 201 0038 9C2F      		mov r25,r28
 202 003a 9095      		com r25
 203 003c 9223      		and r25,r18
 204 003e 91A3      		std Z+33,r25
 205               	.LVL8:
 386:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 206               		.loc 1 386 0
 207 0040 92A1      		ldd r25,Z+34
 208 0042 892B      		or r24,r25
 209 0044 82A3      		std Z+34,r24
 210               	.LVL9:
 211               	.LBE17:
 383:keyboards/Dactylv2/matrix.c ****         uint8_t pin = row_pins[x];
 212               		.loc 1 383 0
 213 0046 4A17      		cp r20,r26
 214 0048 5B07      		cpc r21,r27
 215 004a 01F4      		brne .L10
 216 004c A0E0      		ldi r26,lo8(col_pins)
 217 004e B0E0      		ldi r27,hi8(col_pins)
 218               	.LVL10:
 219 0050 40E0      		ldi r20,lo8(col_pins+6)
 220 0052 50E0      		ldi r21,hi8(col_pins+6)
 221               	.LBE16:
 222               	.LBE15:
 223               	.LBB18:
 224               	.LBB19:
 225               	.LBB20:
 333:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 226               		.loc 1 333 0
 227 0054 61E0      		ldi r22,lo8(1)
 228 0056 70E0      		ldi r23,0
 229               	.L11:
 230               	.LVL11:
 332:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 231               		.loc 1 332 0
 232 0058 8D91      		ld r24,X+
 233               	.LVL12:
 333:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 234               		.loc 1 333 0
 235 005a E82F      		mov r30,r24
 236 005c E295      		swap r30
 237 005e EF70      		andi r30,lo8(15)
 238 0060 F0E0      		ldi r31,0
 239 0062 21A1      		ldd r18,Z+33
 240 0064 8F70      		andi r24,lo8(15)
 241               	.LVL13:
 242 0066 EB01      		movw r28,r22
 243 0068 00C0      		rjmp 2f
 244               		1:
 245 006a CC0F      		lsl r28
 246 006c DD1F      		rol r29
 247               		2:
 248 006e 8A95      		dec r24
 249 0070 02F4      		brpl 1b
 250 0072 CE01      		movw r24,r28
 251 0074 9C2F      		mov r25,r28
 252 0076 9095      		com r25
 253 0078 9223      		and r25,r18
 254 007a 91A3      		std Z+33,r25
 255               	.LVL14:
 334:keyboards/Dactylv2/matrix.c ****     }
 256               		.loc 1 334 0
 257 007c 92A1      		ldd r25,Z+34
 258 007e 892B      		or r24,r25
 259 0080 82A3      		std Z+34,r24
 260               	.LVL15:
 261               	.LBE20:
 331:keyboards/Dactylv2/matrix.c ****         uint8_t pin = col_pins[x];
 262               		.loc 1 331 0
 263 0082 4A17      		cp r20,r26
 264 0084 5B07      		cpc r21,r27
 265 0086 01F4      		brne .L11
 266               	.LVL16:
 267               	.LBE19:
 268               	.LBE18:
 134:keyboards/Dactylv2/matrix.c **** 
 269               		.loc 1 134 0
 270 0088 559A      		sbi 0xa,5
 271 008a 209A      		sbi 0x4,0
 272               	.LVL17:
 273 008c E0E0      		ldi r30,lo8(matrix)
 274 008e F0E0      		ldi r31,hi8(matrix)
 275 0090 A0E0      		ldi r26,lo8(matrix_debouncing)
 276 0092 B0E0      		ldi r27,hi8(matrix_debouncing)
 277 0094 80E0      		ldi r24,lo8(matrix+14)
 278 0096 90E0      		ldi r25,hi8(matrix+14)
 279               	.LVL18:
 280               	.L12:
 281               	.LBB21:
 138:keyboards/Dactylv2/matrix.c ****         matrix_debouncing[i] = 0;
 282               		.loc 1 138 0 discriminator 3
 283 0098 1192      		st Z+,__zero_reg__
 284               	.LVL19:
 139:keyboards/Dactylv2/matrix.c ****     }
 285               		.loc 1 139 0 discriminator 3
 286 009a 1D92      		st X+,__zero_reg__
 287               	.LVL20:
 137:keyboards/Dactylv2/matrix.c ****         matrix[i] = 0;
 288               		.loc 1 137 0 discriminator 3
 289 009c 8E17      		cp r24,r30
 290 009e 9F07      		cpc r25,r31
 291 00a0 01F4      		brne .L12
 292               	/* epilogue start */
 293               	.LBE21:
 144:keyboards/Dactylv2/matrix.c **** 
 294               		.loc 1 144 0
 295 00a2 DF91      		pop r29
 296 00a4 CF91      		pop r28
 142:keyboards/Dactylv2/matrix.c **** 
 297               		.loc 1 142 0
 298 00a6 0C94 0000 		jmp matrix_init_quantum
 299               	.LVL21:
 300               		.cfi_endproc
 301               	.LFE15:
 303               		.section	.text._matrix_scan,"ax",@progbits
 304               	.global	_matrix_scan
 306               	_matrix_scan:
 307               	.LFB16:
 147:keyboards/Dactylv2/matrix.c ****     int offset = isLeftHand ? 0 : (ROWS_PER_HAND);
 308               		.loc 1 147 0
 309               		.cfi_startproc
 310 0000 2F92      		push r2
 311               	.LCFI2:
 312               		.cfi_def_cfa_offset 3
 313               		.cfi_offset 2, -2
 314 0002 3F92      		push r3
 315               	.LCFI3:
 316               		.cfi_def_cfa_offset 4
 317               		.cfi_offset 3, -3
 318 0004 4F92      		push r4
 319               	.LCFI4:
 320               		.cfi_def_cfa_offset 5
 321               		.cfi_offset 4, -4
 322 0006 5F92      		push r5
 323               	.LCFI5:
 324               		.cfi_def_cfa_offset 6
 325               		.cfi_offset 5, -5
 326 0008 6F92      		push r6
 327               	.LCFI6:
 328               		.cfi_def_cfa_offset 7
 329               		.cfi_offset 6, -6
 330 000a 7F92      		push r7
 331               	.LCFI7:
 332               		.cfi_def_cfa_offset 8
 333               		.cfi_offset 7, -7
 334 000c 8F92      		push r8
 335               	.LCFI8:
 336               		.cfi_def_cfa_offset 9
 337               		.cfi_offset 8, -8
 338 000e 9F92      		push r9
 339               	.LCFI9:
 340               		.cfi_def_cfa_offset 10
 341               		.cfi_offset 9, -9
 342 0010 AF92      		push r10
 343               	.LCFI10:
 344               		.cfi_def_cfa_offset 11
 345               		.cfi_offset 10, -10
 346 0012 BF92      		push r11
 347               	.LCFI11:
 348               		.cfi_def_cfa_offset 12
 349               		.cfi_offset 11, -11
 350 0014 CF92      		push r12
 351               	.LCFI12:
 352               		.cfi_def_cfa_offset 13
 353               		.cfi_offset 12, -12
 354 0016 DF92      		push r13
 355               	.LCFI13:
 356               		.cfi_def_cfa_offset 14
 357               		.cfi_offset 13, -13
 358 0018 EF92      		push r14
 359               	.LCFI14:
 360               		.cfi_def_cfa_offset 15
 361               		.cfi_offset 14, -14
 362 001a FF92      		push r15
 363               	.LCFI15:
 364               		.cfi_def_cfa_offset 16
 365               		.cfi_offset 15, -15
 366 001c 0F93      		push r16
 367               	.LCFI16:
 368               		.cfi_def_cfa_offset 17
 369               		.cfi_offset 16, -16
 370 001e 1F93      		push r17
 371               	.LCFI17:
 372               		.cfi_def_cfa_offset 18
 373               		.cfi_offset 17, -17
 374 0020 CF93      		push r28
 375               	.LCFI18:
 376               		.cfi_def_cfa_offset 19
 377               		.cfi_offset 28, -18
 378 0022 DF93      		push r29
 379               	.LCFI19:
 380               		.cfi_def_cfa_offset 20
 381               		.cfi_offset 29, -19
 382 0024 00D0      		rcall .
 383 0026 00D0      		rcall .
 384               	.LCFI20:
 385               		.cfi_def_cfa_offset 24
 386 0028 CDB7      		in r28,__SP_L__
 387 002a DEB7      		in r29,__SP_H__
 388               	.LCFI21:
 389               		.cfi_def_cfa_register 28
 390               	/* prologue: function */
 391               	/* frame size = 4 */
 392               	/* stack size = 22 */
 393               	.L__stack_usage = 22
 148:keyboards/Dactylv2/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 394               		.loc 1 148 0
 395 002c 8091 0000 		lds r24,isLeftHand
 396 0030 8111      		cpse r24,__zero_reg__
 397 0032 00C0      		rjmp .L27
 398 0034 07E0      		ldi r16,lo8(7)
 399 0036 10E0      		ldi r17,0
 400 0038 00C0      		rjmp .L18
 401               	.L27:
 402 003a 00E0      		ldi r16,0
 403 003c 10E0      		ldi r17,0
 404               	.L18:
 405               	.LVL22:
 406 003e 80E0      		ldi r24,lo8(row_pins)
 407 0040 C82E      		mov r12,r24
 408 0042 80E0      		ldi r24,hi8(row_pins)
 409 0044 D82E      		mov r13,r24
 410 0046 9801      		movw r18,r16
 411 0048 2050      		subi r18,lo8(-(matrix_debouncing))
 412 004a 3040      		sbci r19,hi8(-(matrix_debouncing))
 413 004c 7901      		movw r14,r18
 414 004e 90E0      		ldi r25,lo8(row_pins+7)
 415 0050 892E      		mov r8,r25
 416 0052 90E0      		ldi r25,hi8(row_pins+7)
 417 0054 992E      		mov r9,r25
 148:keyboards/Dactylv2/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 418               		.loc 1 148 0 is_stmt 0 discriminator 4
 419 0056 3C83      		std Y+4,r19
 420 0058 2B83      		std Y+3,r18
 421               	.LBB35:
 422               	.LBB36:
 423               	.LBB37:
 424               	.LBB38:
 425               	.LBB39:
 426               	.LBB40:
 370:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 427               		.loc 1 370 0 is_stmt 1 discriminator 4
 428 005a AA24      		clr r10
 429 005c A394      		inc r10
 430 005e B12C      		mov r11,__zero_reg__
 431               	.LBE40:
 432               	.LBE39:
 433               	.LBE38:
 434               	.LBE37:
 158:keyboards/Dactylv2/matrix.c ****             }
 435               		.loc 1 158 0 discriminator 4
 436 0060 34E0      		ldi r19,lo8(4)
 437 0062 732E      		mov r7,r19
 438               	.LVL23:
 439               	.L22:
 440 0064 6B81      		ldd r22,Y+3
 441 0066 7C81      		ldd r23,Y+4
 442               	.LBB50:
 443               	.LBB49:
 341:keyboards/Dactylv2/matrix.c **** 
 444               		.loc 1 341 0
 445 0068 DB01      		movw r26,r22
 446 006a 4C90      		ld r4,X
 447               	.LVL24:
 344:keyboards/Dactylv2/matrix.c **** 
 448               		.loc 1 344 0
 449 006c 1C92      		st X,__zero_reg__
 450               	.LVL25:
 451               	.LBB42:
 452               	.LBB41:
 369:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 453               		.loc 1 369 0
 454 006e F601      		movw r30,r12
 455 0070 8191      		ld r24,Z+
 456 0072 6F01      		movw r12,r30
 457               	.LVL26:
 370:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 458               		.loc 1 370 0
 459 0074 E82F      		mov r30,r24
 460 0076 E295      		swap r30
 461 0078 EF70      		andi r30,lo8(15)
 462 007a F0E0      		ldi r31,0
 463 007c 21A1      		ldd r18,Z+33
 464 007e 8F70      		andi r24,lo8(15)
 465               	.LVL27:
 466 0080 A501      		movw r20,r10
 467 0082 00C0      		rjmp 2f
 468               		1:
 469 0084 440F      		lsl r20
 470 0086 551F      		rol r21
 471               		2:
 472 0088 8A95      		dec r24
 473 008a 02F4      		brpl 1b
 474 008c CA01      		movw r24,r20
 475 008e 242B      		or r18,r20
 476 0090 21A3      		std Z+33,r18
 477               	.LVL28:
 371:keyboards/Dactylv2/matrix.c **** }
 478               		.loc 1 371 0
 479 0092 22A1      		ldd r18,Z+34
 480 0094 642E      		mov r6,r20
 481 0096 6094      		com r6
 482 0098 2621      		and r18,r6
 483 009a 22A3      		std Z+34,r18
 484               	.LVL29:
 485               	.LBE41:
 486               	.LBE42:
 487               	.LBB43:
 488               	.LBB44:
 489               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 490               		.loc 2 276 0
 491 009c 50EA      		ldi r21,lo8(-96)
 492 009e 5A95      	1:	dec r21
 493 00a0 01F4      		brne 1b
 494               	.LVL30:
 495 00a2 A0E0      		ldi r26,lo8(col_pins)
 496 00a4 B0E0      		ldi r27,hi8(col_pins)
 497 00a6 BA83      		std Y+2,r27
 498 00a8 A983      		std Y+1,r26
 499 00aa 20E0      		ldi r18,0
 500 00ac 30E0      		ldi r19,0
 501               	.LVL31:
 502               	.L20:
 503               	.LBE44:
 504               	.LBE43:
 505               	.LBB45:
 506               	.LBB46:
 354:keyboards/Dactylv2/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 507               		.loc 1 354 0
 508 00ae A981      		ldd r26,Y+1
 509 00b0 BA81      		ldd r27,Y+2
 510 00b2 5D90      		ld r5,X+
 511 00b4 BA83      		std Y+2,r27
 512 00b6 A983      		std Y+1,r26
 513               	.LVL32:
 355:keyboards/Dactylv2/matrix.c **** 
 514               		.loc 1 355 0
 515 00b8 452D      		mov r20,r5
 516 00ba 4295      		swap r20
 517 00bc 4F70      		andi r20,lo8(15)
 518 00be 50E0      		ldi r21,0
 519 00c0 DA01      		movw r26,r20
 520 00c2 9096      		adiw r26,32
 521 00c4 2C90      		ld r2,X
 522               	.LVL33:
 358:keyboards/Dactylv2/matrix.c ****     }
 523               		.loc 1 358 0
 524 00c6 AB81      		ldd r26,Y+3
 525 00c8 BC81      		ldd r27,Y+4
 526 00ca 3C90      		ld r3,X
 527 00cc 452D      		mov r20,r5
 528 00ce 4F70      		andi r20,lo8(15)
 529               	.LVL34:
 530 00d0 D501      		movw r26,r10
 531 00d2 00C0      		rjmp 2f
 532               		1:
 533 00d4 AA0F      		lsl r26
 534 00d6 BB1F      		rol r27
 535               		2:
 536 00d8 4A95      		dec r20
 537 00da 02F4      		brpl 1b
 538 00dc AD01      		movw r20,r26
 539               	.LVL35:
 540 00de 4221      		and r20,r2
 541 00e0 01F4      		brne .L28
 542 00e2 4A2D      		mov r20,r10
 543 00e4 022E      		mov r0,r18
 544 00e6 00C0      		rjmp 2f
 545               		1:
 546 00e8 440F      		lsl r20
 547               		2:
 548 00ea 0A94      		dec r0
 549 00ec 02F4      		brpl 1b
 550 00ee 00C0      		rjmp .L19
 551               	.L28:
 552 00f0 40E0      		ldi r20,0
 553               	.L19:
 554 00f2 342A      		or r3,r20
 555 00f4 AB81      		ldd r26,Y+3
 556 00f6 BC81      		ldd r27,Y+4
 557 00f8 3C92      		st X,r3
 558               	.LVL36:
 559 00fa 2F5F      		subi r18,-1
 560 00fc 3F4F      		sbci r19,-1
 561               	.LVL37:
 562               	.LBE46:
 351:keyboards/Dactylv2/matrix.c **** 
 563               		.loc 1 351 0
 564 00fe 2630      		cpi r18,6
 565 0100 3105      		cpc r19,__zero_reg__
 566 0102 01F4      		brne .L20
 567               	.LVL38:
 568               	.LBE45:
 569               	.LBB47:
 570               	.LBB48:
 377:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 571               		.loc 1 377 0
 572 0104 91A1      		ldd r25,Z+33
 573 0106 6922      		and r6,r25
 574 0108 61A2      		std Z+33,r6
 378:keyboards/Dactylv2/matrix.c **** }
 575               		.loc 1 378 0
 576 010a 92A1      		ldd r25,Z+34
 577 010c 892B      		or r24,r25
 578 010e 82A3      		std Z+34,r24
 579 0110 1196      		adiw r26,1
 580 0112 BC83      		std Y+4,r27
 581 0114 AB83      		std Y+3,r26
 582               	.LVL39:
 583               	.LBE48:
 584               	.LBE47:
 585               	.LBE49:
 586               	.LBE50:
 155:keyboards/Dactylv2/matrix.c ****                 debouncing = true;
 587               		.loc 1 155 0
 588 0116 FB01      		movw r30,r22
 589 0118 8081      		ld r24,Z
 590 011a 4816      		cp r4,r24
 591 011c 01F0      		breq .L21
 156:keyboards/Dactylv2/matrix.c ****                 debouncing_time = timer_read();
 592               		.loc 1 156 0
 593 011e F1E0      		ldi r31,lo8(1)
 594 0120 F093 0000 		sts debouncing,r31
 157:keyboards/Dactylv2/matrix.c ****                 PORTD ^= (1 << 2);
 595               		.loc 1 157 0
 596 0124 0E94 0000 		call timer_read
 597               	.LVL40:
 598 0128 9093 0000 		sts debouncing_time+1,r25
 599 012c 8093 0000 		sts debouncing_time,r24
 158:keyboards/Dactylv2/matrix.c ****             }
 600               		.loc 1 158 0
 601 0130 8BB1      		in r24,0xb
 602 0132 8725      		eor r24,r7
 603 0134 8BB9      		out 0xb,r24
 604               	.L21:
 605               	.LBE36:
 151:keyboards/Dactylv2/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 606               		.loc 1 151 0 discriminator 2
 607 0136 8C14      		cp r8,r12
 608 0138 9D04      		cpc r9,r13
 609 013a 01F0      		breq .+2
 610 013c 00C0      		rjmp .L22
 611               	.LBE35:
 184:keyboards/Dactylv2/matrix.c ****             for (uint8_t i = 0; i < ROWS_PER_HAND; i++) {
 612               		.loc 1 184 0
 613 013e 8091 0000 		lds r24,debouncing
 614 0142 8823      		tst r24
 615 0144 01F0      		breq .L24
 184:keyboards/Dactylv2/matrix.c ****             for (uint8_t i = 0; i < ROWS_PER_HAND; i++) {
 616               		.loc 1 184 0 is_stmt 0 discriminator 1
 617 0146 8091 0000 		lds r24,debouncing_time
 618 014a 9091 0000 		lds r25,debouncing_time+1
 619 014e 0E94 0000 		call timer_elapsed
 620               	.LVL41:
 621 0152 0697      		sbiw r24,6
 622 0154 00F0      		brlo .L24
 623 0156 F801      		movw r30,r16
 624 0158 E050      		subi r30,lo8(-(matrix))
 625 015a F040      		sbci r31,hi8(-(matrix))
 184:keyboards/Dactylv2/matrix.c ****             for (uint8_t i = 0; i < ROWS_PER_HAND; i++) {
 626               		.loc 1 184 0
 627 015c 80E0      		ldi r24,0
 628               	.L26:
 629               	.LVL42:
 630               	.LBB51:
 186:keyboards/Dactylv2/matrix.c ****             }
 631               		.loc 1 186 0 is_stmt 1 discriminator 3
 632 015e D701      		movw r26,r14
 633 0160 9D91      		ld r25,X+
 634 0162 7D01      		movw r14,r26
 635 0164 9193      		st Z+,r25
 185:keyboards/Dactylv2/matrix.c ****                 matrix[i+offset] = matrix_debouncing[i+offset];
 636               		.loc 1 185 0 discriminator 3
 637 0166 8F5F      		subi r24,lo8(-(1))
 638               	.LVL43:
 639 0168 8730      		cpi r24,lo8(7)
 640 016a 01F4      		brne .L26
 641               	.LBE51:
 188:keyboards/Dactylv2/matrix.c ****         }
 642               		.loc 1 188 0
 643 016c 1092 0000 		sts debouncing,__zero_reg__
 644               	.LVL44:
 645               	.L24:
 193:keyboards/Dactylv2/matrix.c **** 
 646               		.loc 1 193 0
 647 0170 81E0      		ldi r24,lo8(1)
 648               	/* epilogue start */
 649 0172 0F90      		pop __tmp_reg__
 650 0174 0F90      		pop __tmp_reg__
 651 0176 0F90      		pop __tmp_reg__
 652 0178 0F90      		pop __tmp_reg__
 653 017a DF91      		pop r29
 654 017c CF91      		pop r28
 655 017e 1F91      		pop r17
 656 0180 0F91      		pop r16
 657 0182 FF90      		pop r15
 658 0184 EF90      		pop r14
 659 0186 DF90      		pop r13
 660 0188 CF90      		pop r12
 661 018a BF90      		pop r11
 662 018c AF90      		pop r10
 663 018e 9F90      		pop r9
 664 0190 8F90      		pop r8
 665 0192 7F90      		pop r7
 666 0194 6F90      		pop r6
 667 0196 5F90      		pop r5
 668               	.LVL45:
 669 0198 4F90      		pop r4
 670 019a 3F90      		pop r3
 671 019c 2F90      		pop r2
 672 019e 0895      		ret
 673               		.cfi_endproc
 674               	.LFE16:
 676               		.section	.text.serial_transaction,"ax",@progbits
 677               	.global	serial_transaction
 679               	serial_transaction:
 680               	.LFB17:
 230:keyboards/Dactylv2/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 681               		.loc 1 230 0
 682               		.cfi_startproc
 683 0000 CF93      		push r28
 684               	.LCFI22:
 685               		.cfi_def_cfa_offset 3
 686               		.cfi_offset 28, -2
 687 0002 DF93      		push r29
 688               	.LCFI23:
 689               		.cfi_def_cfa_offset 4
 690               		.cfi_offset 29, -3
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 2 */
 694               	.L__stack_usage = 2
 231:keyboards/Dactylv2/matrix.c **** 
 695               		.loc 1 231 0
 696 0004 8091 0000 		lds r24,isLeftHand
 697 0008 8111      		cpse r24,__zero_reg__
 698 000a 00C0      		rjmp .L36
 699 000c C0E0      		ldi r28,0
 700 000e D0E0      		ldi r29,0
 701 0010 00C0      		rjmp .L33
 702               	.L36:
 703 0012 C7E0      		ldi r28,lo8(7)
 704 0014 D0E0      		ldi r29,0
 705               	.L33:
 706               	.LVL46:
 233:keyboards/Dactylv2/matrix.c ****         return 1;
 707               		.loc 1 233 0 discriminator 4
 708 0016 0E94 0000 		call serial_update_buffers
 709               	.LVL47:
 710 001a 0097      		sbiw r24,0
 711 001c 01F4      		brne .L37
 712 001e C050      		subi r28,lo8(-(matrix))
 713 0020 D040      		sbci r29,hi8(-(matrix))
 714               	.LVL48:
 233:keyboards/Dactylv2/matrix.c ****         return 1;
 715               		.loc 1 233 0 is_stmt 0
 716 0022 20E0      		ldi r18,0
 717 0024 30E0      		ldi r19,0
 718               	.LVL49:
 719               	.L35:
 720               	.LBB52:
 238:keyboards/Dactylv2/matrix.c ****     }
 721               		.loc 1 238 0 is_stmt 1 discriminator 3
 722 0026 F901      		movw r30,r18
 723 0028 E050      		subi r30,lo8(-(serial_slave_buffer))
 724 002a F040      		sbci r31,hi8(-(serial_slave_buffer))
 725 002c 4081      		ld r20,Z
 726 002e 4993      		st Y+,r20
 237:keyboards/Dactylv2/matrix.c ****         matrix[slaveOffset+i] = serial_slave_buffer[i];
 727               		.loc 1 237 0 discriminator 3
 728 0030 2F5F      		subi r18,-1
 729 0032 3F4F      		sbci r19,-1
 730               	.LVL50:
 731 0034 2730      		cpi r18,7
 732 0036 3105      		cpc r19,__zero_reg__
 733 0038 01F4      		brne .L35
 734 003a 00C0      		rjmp .L34
 735               	.LVL51:
 736               	.L37:
 737               	.LBE52:
 234:keyboards/Dactylv2/matrix.c ****     }
 738               		.loc 1 234 0
 739 003c 81E0      		ldi r24,lo8(1)
 740 003e 90E0      		ldi r25,0
 741               	.LVL52:
 742               	.L34:
 743               	/* epilogue start */
 241:keyboards/Dactylv2/matrix.c **** #endif
 744               		.loc 1 241 0
 745 0040 DF91      		pop r29
 746 0042 CF91      		pop r28
 747 0044 0895      		ret
 748               		.cfi_endproc
 749               	.LFE17:
 751               		.section	.text.matrix_scan,"ax",@progbits
 752               	.global	matrix_scan
 754               	matrix_scan:
 755               	.LFB18:
 245:keyboards/Dactylv2/matrix.c ****     uint8_t ret = _matrix_scan();
 756               		.loc 1 245 0
 757               		.cfi_startproc
 758 0000 CF93      		push r28
 759               	.LCFI24:
 760               		.cfi_def_cfa_offset 3
 761               		.cfi_offset 28, -2
 762               	/* prologue: function */
 763               	/* frame size = 0 */
 764               	/* stack size = 1 */
 765               	.L__stack_usage = 1
 246:keyboards/Dactylv2/matrix.c **** 
 766               		.loc 1 246 0
 767 0002 0E94 0000 		call _matrix_scan
 768               	.LVL53:
 769 0006 C82F      		mov r28,r24
 770               	.LVL54:
 251:keyboards/Dactylv2/matrix.c **** #endif
 771               		.loc 1 251 0
 772 0008 0E94 0000 		call serial_transaction
 773               	.LVL55:
 774 000c 892B      		or r24,r25
 775 000e 01F0      		breq .L40
 254:keyboards/Dactylv2/matrix.c **** 
 776               		.loc 1 254 0
 777 0010 5D98      		cbi 0xb,5
 256:keyboards/Dactylv2/matrix.c **** 
 778               		.loc 1 256 0
 779 0012 8091 0000 		lds r24,error_count
 780 0016 8F5F      		subi r24,lo8(-(1))
 781 0018 8093 0000 		sts error_count,r24
 258:keyboards/Dactylv2/matrix.c ****             // reset other half if disconnected
 782               		.loc 1 258 0
 783 001c 8630      		cpi r24,lo8(6)
 784 001e 00F0      		brlo .L42
 785               	.LBB53:
 260:keyboards/Dactylv2/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 786               		.loc 1 260 0
 787 0020 8091 0000 		lds r24,isLeftHand
 788 0024 8111      		cpse r24,__zero_reg__
 789 0026 00C0      		rjmp .L46
 790 0028 E0E0      		ldi r30,0
 791 002a F0E0      		ldi r31,0
 792 002c 00C0      		rjmp .L43
 793               	.L46:
 794 002e E7E0      		ldi r30,lo8(7)
 795 0030 F0E0      		ldi r31,0
 796               	.L43:
 797               	.LVL56:
 798 0032 E050      		subi r30,lo8(-(matrix))
 799 0034 F040      		sbci r31,hi8(-(matrix))
 800               	.LVL57:
 801               	.LBB54:
 261:keyboards/Dactylv2/matrix.c ****                 matrix[slaveOffset+i] = 0;
 802               		.loc 1 261 0 discriminator 4
 803 0036 80E0      		ldi r24,0
 804 0038 90E0      		ldi r25,0
 805               	.LVL58:
 806               	.L44:
 262:keyboards/Dactylv2/matrix.c ****             }
 807               		.loc 1 262 0 discriminator 3
 808 003a 1192      		st Z+,__zero_reg__
 261:keyboards/Dactylv2/matrix.c ****                 matrix[slaveOffset+i] = 0;
 809               		.loc 1 261 0 discriminator 3
 810 003c 0196      		adiw r24,1
 811               	.LVL59:
 812 003e 8730      		cpi r24,7
 813 0040 9105      		cpc r25,__zero_reg__
 814 0042 01F4      		brne .L44
 815 0044 00C0      		rjmp .L42
 816               	.LVL60:
 817               	.L40:
 818               	.LBE54:
 819               	.LBE53:
 267:keyboards/Dactylv2/matrix.c ****         error_count = 0;
 820               		.loc 1 267 0
 821 0046 5D9A      		sbi 0xb,5
 268:keyboards/Dactylv2/matrix.c ****     }
 822               		.loc 1 268 0
 823 0048 1092 0000 		sts error_count,__zero_reg__
 824               	.L42:
 270:keyboards/Dactylv2/matrix.c ****     return ret;
 825               		.loc 1 270 0
 826 004c 0E94 0000 		call matrix_scan_quantum
 827               	.LVL61:
 272:keyboards/Dactylv2/matrix.c **** 
 828               		.loc 1 272 0
 829 0050 8C2F      		mov r24,r28
 830               	/* epilogue start */
 831 0052 CF91      		pop r28
 832               	.LVL62:
 833 0054 0895      		ret
 834               		.cfi_endproc
 835               	.LFE18:
 837               		.section	.text.matrix_slave_scan,"ax",@progbits
 838               	.global	matrix_slave_scan
 840               	matrix_slave_scan:
 841               	.LFB19:
 274:keyboards/Dactylv2/matrix.c ****     _matrix_scan();
 842               		.loc 1 274 0
 843               		.cfi_startproc
 844               	/* prologue: function */
 845               	/* frame size = 0 */
 846               	/* stack size = 0 */
 847               	.L__stack_usage = 0
 275:keyboards/Dactylv2/matrix.c **** 
 848               		.loc 1 275 0
 849 0000 0E94 0000 		call _matrix_scan
 850               	.LVL63:
 277:keyboards/Dactylv2/matrix.c **** 
 851               		.loc 1 277 0
 852 0004 8091 0000 		lds r24,isLeftHand
 853 0008 8111      		cpse r24,__zero_reg__
 854 000a 00C0      		rjmp .L51
 855 000c E7E0      		ldi r30,lo8(7)
 856 000e F0E0      		ldi r31,0
 857 0010 00C0      		rjmp .L49
 858               	.L51:
 859 0012 E0E0      		ldi r30,0
 860 0014 F0E0      		ldi r31,0
 861               	.L49:
 862               	.LVL64:
 863 0016 E050      		subi r30,lo8(-(matrix))
 864 0018 F040      		sbci r31,hi8(-(matrix))
 865               	.LVL65:
 866               	.LBB55:
 284:keyboards/Dactylv2/matrix.c ****         serial_slave_buffer[i] = matrix[offset+i];
 867               		.loc 1 284 0 discriminator 4
 868 001a 80E0      		ldi r24,0
 869 001c 90E0      		ldi r25,0
 870               	.LVL66:
 871               	.L50:
 285:keyboards/Dactylv2/matrix.c ****     }
 872               		.loc 1 285 0 discriminator 3
 873 001e 2191      		ld r18,Z+
 874 0020 DC01      		movw r26,r24
 875 0022 A050      		subi r26,lo8(-(serial_slave_buffer))
 876 0024 B040      		sbci r27,hi8(-(serial_slave_buffer))
 877 0026 2C93      		st X,r18
 284:keyboards/Dactylv2/matrix.c ****         serial_slave_buffer[i] = matrix[offset+i];
 878               		.loc 1 284 0 discriminator 3
 879 0028 0196      		adiw r24,1
 880               	.LVL67:
 881 002a 8730      		cpi r24,7
 882 002c 9105      		cpc r25,__zero_reg__
 883 002e 01F4      		brne .L50
 884               	/* epilogue start */
 885               	.LBE55:
 288:keyboards/Dactylv2/matrix.c **** 
 886               		.loc 1 288 0
 887 0030 0895      		ret
 888               		.cfi_endproc
 889               	.LFE19:
 891               		.section	.text.matrix_is_modified,"ax",@progbits
 892               	.global	matrix_is_modified
 894               	matrix_is_modified:
 895               	.LFB20:
 291:keyboards/Dactylv2/matrix.c ****     if (debouncing) return false;
 896               		.loc 1 291 0
 897               		.cfi_startproc
 898               	/* prologue: function */
 899               	/* frame size = 0 */
 900               	/* stack size = 0 */
 901               	.L__stack_usage = 0
 902 0000 9091 0000 		lds r25,debouncing
 294:keyboards/Dactylv2/matrix.c **** 
 903               		.loc 1 294 0
 904 0004 81E0      		ldi r24,lo8(1)
 905 0006 8927      		eor r24,r25
 906 0008 0895      		ret
 907               		.cfi_endproc
 908               	.LFE20:
 910               		.section	.text.matrix_is_on,"ax",@progbits
 911               	.global	matrix_is_on
 913               	matrix_is_on:
 914               	.LFB21:
 298:keyboards/Dactylv2/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 915               		.loc 1 298 0
 916               		.cfi_startproc
 917               	.LVL68:
 918               	/* prologue: function */
 919               	/* frame size = 0 */
 920               	/* stack size = 0 */
 921               	.L__stack_usage = 0
 299:keyboards/Dactylv2/matrix.c **** }
 922               		.loc 1 299 0
 923 0000 E82F      		mov r30,r24
 924 0002 F0E0      		ldi r31,0
 925 0004 E050      		subi r30,lo8(-(matrix))
 926 0006 F040      		sbci r31,hi8(-(matrix))
 927 0008 2081      		ld r18,Z
 928 000a 822F      		mov r24,r18
 929               	.LVL69:
 930 000c 90E0      		ldi r25,0
 931 000e 21E0      		ldi r18,lo8(1)
 932 0010 30E0      		ldi r19,0
 933 0012 00C0      		rjmp 2f
 934               		1:
 935 0014 220F      		lsl r18
 936 0016 331F      		rol r19
 937               		2:
 938 0018 6A95      		dec r22
 939 001a 02F4      		brpl 1b
 940 001c 2823      		and r18,r24
 941 001e 3923      		and r19,r25
 942 0020 81E0      		ldi r24,lo8(1)
 943 0022 232B      		or r18,r19
 944 0024 01F4      		brne .L55
 945 0026 80E0      		ldi r24,0
 946               	.L55:
 300:keyboards/Dactylv2/matrix.c **** 
 947               		.loc 1 300 0
 948 0028 0895      		ret
 949               		.cfi_endproc
 950               	.LFE21:
 952               		.section	.text.matrix_get_row,"ax",@progbits
 953               	.global	matrix_get_row
 955               	matrix_get_row:
 956               	.LFB22:
 304:keyboards/Dactylv2/matrix.c ****     return matrix[row];
 957               		.loc 1 304 0
 958               		.cfi_startproc
 959               	.LVL70:
 960               	/* prologue: function */
 961               	/* frame size = 0 */
 962               	/* stack size = 0 */
 963               	.L__stack_usage = 0
 305:keyboards/Dactylv2/matrix.c **** }
 964               		.loc 1 305 0
 965 0000 E82F      		mov r30,r24
 966 0002 F0E0      		ldi r31,0
 967 0004 E050      		subi r30,lo8(-(matrix))
 968 0006 F040      		sbci r31,hi8(-(matrix))
 306:keyboards/Dactylv2/matrix.c **** 
 969               		.loc 1 306 0
 970 0008 8081      		ld r24,Z
 971               	.LVL71:
 972 000a 0895      		ret
 973               		.cfi_endproc
 974               	.LFE22:
 976               		.section	.text.matrix_print,"ax",@progbits
 977               	.global	matrix_print
 979               	matrix_print:
 980               	.LFB23:
 309:keyboards/Dactylv2/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 981               		.loc 1 309 0
 982               		.cfi_startproc
 983               	/* prologue: function */
 984               	/* frame size = 0 */
 985               	/* stack size = 0 */
 986               	.L__stack_usage = 0
 987               	.LVL72:
 988 0000 0895      		ret
 989               		.cfi_endproc
 990               	.LFE23:
 992               		.section	.text.matrix_key_count,"ax",@progbits
 993               	.global	matrix_key_count
 995               	matrix_key_count:
 996               	.LFB24:
 319:keyboards/Dactylv2/matrix.c ****     uint8_t count = 0;
 997               		.loc 1 319 0
 998               		.cfi_startproc
 319:keyboards/Dactylv2/matrix.c ****     uint8_t count = 0;
 999               		.loc 1 319 0
 1000 0000 0F93      		push r16
 1001               	.LCFI25:
 1002               		.cfi_def_cfa_offset 3
 1003               		.cfi_offset 16, -2
 1004 0002 1F93      		push r17
 1005               	.LCFI26:
 1006               		.cfi_def_cfa_offset 4
 1007               		.cfi_offset 17, -3
 1008 0004 CF93      		push r28
 1009               	.LCFI27:
 1010               		.cfi_def_cfa_offset 5
 1011               		.cfi_offset 28, -4
 1012               	/* prologue: function */
 1013               	/* frame size = 0 */
 1014               	/* stack size = 3 */
 1015               	.L__stack_usage = 3
 1016               	.LVL73:
 1017 0006 00E0      		ldi r16,lo8(matrix)
 1018 0008 10E0      		ldi r17,hi8(matrix)
 320:keyboards/Dactylv2/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 1019               		.loc 1 320 0
 1020 000a C0E0      		ldi r28,0
 1021               	.LVL74:
 1022               	.L59:
 1023               	.LBB56:
 322:keyboards/Dactylv2/matrix.c ****     }
 1024               		.loc 1 322 0 discriminator 3
 1025 000c F801      		movw r30,r16
 1026 000e 8191      		ld r24,Z+
 1027 0010 8F01      		movw r16,r30
 1028               	.LVL75:
 1029 0012 90E0      		ldi r25,0
 1030 0014 0E94 0000 		call bitpop16
 1031               	.LVL76:
 1032 0018 C80F      		add r28,r24
 1033               	.LVL77:
 321:keyboards/Dactylv2/matrix.c ****         count += bitpop16(matrix[i]);
 1034               		.loc 1 321 0 discriminator 3
 1035 001a F0E0      		ldi r31,hi8(matrix+14)
 1036 001c 0030      		cpi r16,lo8(matrix+14)
 1037 001e 1F07      		cpc r17,r31
 1038 0020 01F4      		brne .L59
 1039               	.LBE56:
 325:keyboards/Dactylv2/matrix.c **** 
 1040               		.loc 1 325 0
 1041 0022 8C2F      		mov r24,r28
 1042               	/* epilogue start */
 1043 0024 CF91      		pop r28
 1044               	.LVL78:
 1045 0026 1F91      		pop r17
 1046 0028 0F91      		pop r16
 1047               	.LVL79:
 1048 002a 0895      		ret
 1049               		.cfi_endproc
 1050               	.LFE24:
 1052               		.section	.bss.matrix,"aw",@nobits
 1055               	matrix:
 1056 0000 0000 0000 		.zero	14
 1056      0000 0000 
 1056      0000 0000 
 1056      0000 
 1057               		.section	.rodata.col_pins,"a",@progbits
 1060               	col_pins:
 1061 0000 35        		.byte	53
 1062 0001 34        		.byte	52
 1063 0002 C6        		.byte	-58
 1064 0003 97        		.byte	-105
 1065 0004 66        		.byte	102
 1066 0005 94        		.byte	-108
 1067               		.section	.rodata.row_pins,"a",@progbits
 1070               	row_pins:
 1071 0000 36        		.byte	54
 1072 0001 32        		.byte	50
 1073 0002 33        		.byte	51
 1074 0003 31        		.byte	49
 1075 0004 F7        		.byte	-9
 1076 0005 F6        		.byte	-10
 1077 0006 F5        		.byte	-11
 1078 0007 0000 0000 		.zero	7
 1078      0000 00
 1079               		.section	.bss.error_count,"aw",@nobits
 1082               	error_count:
 1083 0000 00        		.zero	1
 1084               		.section	.bss.matrix_debouncing,"aw",@nobits
 1087               	matrix_debouncing:
 1088 0000 0000 0000 		.zero	14
 1088      0000 0000 
 1088      0000 0000 
 1088      0000 
 1089               		.section	.bss.debouncing,"aw",@nobits
 1092               	debouncing:
 1093 0000 00        		.zero	1
 1094               		.section	.bss.debouncing_time,"aw",@nobits
 1097               	debouncing_time:
 1098 0000 0000      		.zero	2
 1099               		.text
 1100               	.Letext0:
 1101               		.file 3 "/usr/lib/avr/include/stdint.h"
 1102               		.file 4 "./tmk_core/common/debug.h"
 1103               		.file 5 "./tmk_core/common/matrix.h"
 1104               		.file 6 "./drivers/avr/pro_micro.h"
 1105               		.file 7 "keyboards/Dactylv2/split_util.h"
 1106               		.file 8 "keyboards/Dactylv2/serial.h"
 1107               		.file 9 "./tmk_core/common/timer.h"
 1108               		.file 10 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/cc2eYojl.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc2eYojl.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc2eYojl.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc2eYojl.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc2eYojl.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc2eYojl.s:13     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/cc2eYojl.s:13     .text.matrix_scan_user:0000000000000000 matrix_scan_user.localalias.0
     /tmp/cc2eYojl.s:30     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/cc2eYojl.s:44     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/cc2eYojl.s:61     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/cc2eYojl.s:78     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/cc2eYojl.s:95     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/cc2eYojl.s:112    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/cc2eYojl.s:129    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/cc2eYojl.s:146    .text.matrix_init:0000000000000000 matrix_init
     /tmp/cc2eYojl.s:1070   .rodata.row_pins:0000000000000000 row_pins
     /tmp/cc2eYojl.s:1060   .rodata.col_pins:0000000000000000 col_pins
     /tmp/cc2eYojl.s:1055   .bss.matrix:0000000000000000 matrix
     /tmp/cc2eYojl.s:1087   .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/cc2eYojl.s:306    .text._matrix_scan:0000000000000000 _matrix_scan
     /tmp/cc2eYojl.s:1092   .bss.debouncing:0000000000000000 debouncing
     /tmp/cc2eYojl.s:1097   .bss.debouncing_time:0000000000000000 debouncing_time
     /tmp/cc2eYojl.s:679    .text.serial_transaction:0000000000000000 serial_transaction
     /tmp/cc2eYojl.s:754    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/cc2eYojl.s:1082   .bss.error_count:0000000000000000 error_count
     /tmp/cc2eYojl.s:840    .text.matrix_slave_scan:0000000000000000 matrix_slave_scan
     /tmp/cc2eYojl.s:894    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/cc2eYojl.s:913    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/cc2eYojl.s:955    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/cc2eYojl.s:979    .text.matrix_print:0000000000000000 matrix_print
     /tmp/cc2eYojl.s:995    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
isLeftHand
timer_read
timer_elapsed
serial_update_buffers
serial_slave_buffer
bitpop16
__do_copy_data
__do_clear_bss
