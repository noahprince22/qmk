   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init_user,"ax",@progbits
  11               		.weak	matrix_init_user
  13               	matrix_init_user:
  14               	.LFB11:
  15               		.file 1 "keyboards/Dactylv2/matrix.c"
   1:keyboards/Dactylv2/matrix.c **** /*
   2:keyboards/Dactylv2/matrix.c **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:keyboards/Dactylv2/matrix.c **** 
   4:keyboards/Dactylv2/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:keyboards/Dactylv2/matrix.c **** it under the terms of the GNU General Public License as published by
   6:keyboards/Dactylv2/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:keyboards/Dactylv2/matrix.c **** (at your option) any later version.
   8:keyboards/Dactylv2/matrix.c **** 
   9:keyboards/Dactylv2/matrix.c **** This program is distributed in the hope that it will be useful,
  10:keyboards/Dactylv2/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:keyboards/Dactylv2/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:keyboards/Dactylv2/matrix.c **** GNU General Public License for more details.
  13:keyboards/Dactylv2/matrix.c **** 
  14:keyboards/Dactylv2/matrix.c **** You should have received a copy of the GNU General Public License
  15:keyboards/Dactylv2/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:keyboards/Dactylv2/matrix.c **** */
  17:keyboards/Dactylv2/matrix.c **** 
  18:keyboards/Dactylv2/matrix.c **** /*
  19:keyboards/Dactylv2/matrix.c ****  * scan matrix
  20:keyboards/Dactylv2/matrix.c ****  */
  21:keyboards/Dactylv2/matrix.c **** #include <stdint.h>
  22:keyboards/Dactylv2/matrix.c **** #include <stdbool.h>
  23:keyboards/Dactylv2/matrix.c **** #include <avr/io.h>
  24:keyboards/Dactylv2/matrix.c **** #include "wait.h"
  25:keyboards/Dactylv2/matrix.c **** #include "print.h"
  26:keyboards/Dactylv2/matrix.c **** #include "debug.h"
  27:keyboards/Dactylv2/matrix.c **** #include "util.h"
  28:keyboards/Dactylv2/matrix.c **** #include "matrix.h"
  29:keyboards/Dactylv2/matrix.c **** #include "split_util.h"
  30:keyboards/Dactylv2/matrix.c **** #include "pro_micro.h"
  31:keyboards/Dactylv2/matrix.c **** #include "config.h"
  32:keyboards/Dactylv2/matrix.c **** #include "timer.h"
  33:keyboards/Dactylv2/matrix.c **** 
  34:keyboards/Dactylv2/matrix.c **** #ifdef USE_I2C
  35:keyboards/Dactylv2/matrix.c **** #  include "i2c.h"
  36:keyboards/Dactylv2/matrix.c **** #else // USE_SERIAL
  37:keyboards/Dactylv2/matrix.c **** #  include "serial.h"
  38:keyboards/Dactylv2/matrix.c **** #endif
  39:keyboards/Dactylv2/matrix.c **** 
  40:keyboards/Dactylv2/matrix.c **** #ifndef DEBOUNCING_DELAY
  41:keyboards/Dactylv2/matrix.c **** #   define DEBOUNCING_DELAY 5
  42:keyboards/Dactylv2/matrix.c **** #endif
  43:keyboards/Dactylv2/matrix.c **** 
  44:keyboards/Dactylv2/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  45:keyboards/Dactylv2/matrix.c ****     static uint16_t debouncing_time;
  46:keyboards/Dactylv2/matrix.c ****     static bool debouncing = false;
  47:keyboards/Dactylv2/matrix.c **** #endif
  48:keyboards/Dactylv2/matrix.c **** 
  49:keyboards/Dactylv2/matrix.c **** #if (MATRIX_COLS <= 8)
  50:keyboards/Dactylv2/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  51:keyboards/Dactylv2/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  52:keyboards/Dactylv2/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  53:keyboards/Dactylv2/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  54:keyboards/Dactylv2/matrix.c **** #else
  55:keyboards/Dactylv2/matrix.c **** #    error "Currently only supports 8 COLS"
  56:keyboards/Dactylv2/matrix.c **** #endif
  57:keyboards/Dactylv2/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  58:keyboards/Dactylv2/matrix.c **** 
  59:keyboards/Dactylv2/matrix.c **** #define ERROR_DISCONNECT_COUNT 5
  60:keyboards/Dactylv2/matrix.c **** 
  61:keyboards/Dactylv2/matrix.c **** #define ROWS_PER_HAND (MATRIX_ROWS/2)
  62:keyboards/Dactylv2/matrix.c **** 
  63:keyboards/Dactylv2/matrix.c **** static uint8_t error_count = 0;
  64:keyboards/Dactylv2/matrix.c **** 
  65:keyboards/Dactylv2/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  66:keyboards/Dactylv2/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  67:keyboards/Dactylv2/matrix.c **** 
  68:keyboards/Dactylv2/matrix.c **** /* matrix state(1:on, 0:off) */
  69:keyboards/Dactylv2/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  70:keyboards/Dactylv2/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:keyboards/Dactylv2/matrix.c **** 
  72:keyboards/Dactylv2/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  73:keyboards/Dactylv2/matrix.c ****     static void init_cols(void);
  74:keyboards/Dactylv2/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  75:keyboards/Dactylv2/matrix.c ****     static void unselect_rows(void);
  76:keyboards/Dactylv2/matrix.c ****     static void select_row(uint8_t row);
  77:keyboards/Dactylv2/matrix.c ****     static void unselect_row(uint8_t row);
  78:keyboards/Dactylv2/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
  79:keyboards/Dactylv2/matrix.c ****     static void init_rows(void);
  80:keyboards/Dactylv2/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  81:keyboards/Dactylv2/matrix.c ****     static void unselect_cols(void);
  82:keyboards/Dactylv2/matrix.c ****     static void unselect_col(uint8_t col);
  83:keyboards/Dactylv2/matrix.c ****     static void select_col(uint8_t col);
  84:keyboards/Dactylv2/matrix.c **** #endif
  85:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
  86:keyboards/Dactylv2/matrix.c **** void matrix_init_quantum(void) {
  87:keyboards/Dactylv2/matrix.c ****     matrix_init_kb();
  88:keyboards/Dactylv2/matrix.c **** }
  89:keyboards/Dactylv2/matrix.c **** 
  90:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
  91:keyboards/Dactylv2/matrix.c **** void matrix_scan_quantum(void) {
  92:keyboards/Dactylv2/matrix.c ****     matrix_scan_kb();
  93:keyboards/Dactylv2/matrix.c **** }
  94:keyboards/Dactylv2/matrix.c **** 
  95:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
  96:keyboards/Dactylv2/matrix.c **** void matrix_init_kb(void) {
  97:keyboards/Dactylv2/matrix.c ****     matrix_init_user();
  98:keyboards/Dactylv2/matrix.c **** }
  99:keyboards/Dactylv2/matrix.c **** 
 100:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
 101:keyboards/Dactylv2/matrix.c **** void matrix_scan_kb(void) {
 102:keyboards/Dactylv2/matrix.c ****     matrix_scan_user();
 103:keyboards/Dactylv2/matrix.c **** }
 104:keyboards/Dactylv2/matrix.c **** 
 105:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
 106:keyboards/Dactylv2/matrix.c **** void matrix_init_user(void) {
  16               		.loc 1 106 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22               	/* epilogue start */
 107:keyboards/Dactylv2/matrix.c **** }
  23               		.loc 1 107 0
  24 0000 0895      		ret
  25               		.cfi_endproc
  26               	.LFE11:
  28               		.set	matrix_init_user.localalias.0,matrix_init_user
  29               		.section	.text.matrix_init_kb,"ax",@progbits
  30               		.weak	matrix_init_kb
  32               	matrix_init_kb:
  33               	.LFB9:
  96:keyboards/Dactylv2/matrix.c ****     matrix_init_user();
  34               		.loc 1 96 0
  35               		.cfi_startproc
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
  97:keyboards/Dactylv2/matrix.c **** }
  40               		.loc 1 97 0
  41 0000 0C94 0000 		jmp matrix_init_user
  42               	.LVL0:
  43               		.cfi_endproc
  44               	.LFE9:
  46               		.section	.text.matrix_init_quantum,"ax",@progbits
  47               		.weak	matrix_init_quantum
  49               	matrix_init_quantum:
  50               	.LFB7:
  86:keyboards/Dactylv2/matrix.c ****     matrix_init_kb();
  51               		.loc 1 86 0
  52               		.cfi_startproc
  53               	/* prologue: function */
  54               	/* frame size = 0 */
  55               	/* stack size = 0 */
  56               	.L__stack_usage = 0
  87:keyboards/Dactylv2/matrix.c **** }
  57               		.loc 1 87 0
  58 0000 0C94 0000 		jmp matrix_init_kb
  59               	.LVL1:
  60               		.cfi_endproc
  61               	.LFE7:
  63               		.section	.text.matrix_scan_user,"ax",@progbits
  64               		.weak	matrix_scan_user
  66               	matrix_scan_user:
  67               	.LFB31:
  68               		.cfi_startproc
  69               	/* prologue: function */
  70               	/* frame size = 0 */
  71               	/* stack size = 0 */
  72               	.L__stack_usage = 0
  73               	/* epilogue start */
  74 0000 0895      		ret
  75               		.cfi_endproc
  76               	.LFE31:
  78               		.section	.text.matrix_scan_kb,"ax",@progbits
  79               		.weak	matrix_scan_kb
  81               	matrix_scan_kb:
  82               	.LFB10:
 101:keyboards/Dactylv2/matrix.c ****     matrix_scan_user();
  83               		.loc 1 101 0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
 102:keyboards/Dactylv2/matrix.c **** }
  89               		.loc 1 102 0
  90 0000 0C94 0000 		jmp matrix_scan_user
  91               	.LVL2:
  92               		.cfi_endproc
  93               	.LFE10:
  95               		.section	.text.matrix_scan_quantum,"ax",@progbits
  96               		.weak	matrix_scan_quantum
  98               	matrix_scan_quantum:
  99               	.LFB8:
  91:keyboards/Dactylv2/matrix.c ****     matrix_scan_kb();
 100               		.loc 1 91 0
 101               		.cfi_startproc
 102               	/* prologue: function */
 103               	/* frame size = 0 */
 104               	/* stack size = 0 */
 105               	.L__stack_usage = 0
  92:keyboards/Dactylv2/matrix.c **** }
 106               		.loc 1 92 0
 107 0000 0C94 0000 		jmp matrix_scan_kb
 108               	.LVL3:
 109               		.cfi_endproc
 110               	.LFE8:
 112               		.section	.text.matrix_rows,"ax",@progbits
 113               	.global	matrix_rows
 115               	matrix_rows:
 116               	.LFB13:
 108:keyboards/Dactylv2/matrix.c **** 
 109:keyboards/Dactylv2/matrix.c **** __attribute__ ((weak))
 110:keyboards/Dactylv2/matrix.c **** void matrix_scan_user(void) {
 111:keyboards/Dactylv2/matrix.c **** }
 112:keyboards/Dactylv2/matrix.c **** 
 113:keyboards/Dactylv2/matrix.c **** inline
 114:keyboards/Dactylv2/matrix.c **** uint8_t matrix_rows(void)
 115:keyboards/Dactylv2/matrix.c **** {
 117               		.loc 1 115 0
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 116:keyboards/Dactylv2/matrix.c ****     return MATRIX_ROWS;
 117:keyboards/Dactylv2/matrix.c **** }
 123               		.loc 1 117 0
 124 0000 8EE0      		ldi r24,lo8(14)
 125               	/* epilogue start */
 126 0002 0895      		ret
 127               		.cfi_endproc
 128               	.LFE13:
 130               		.section	.text.matrix_cols,"ax",@progbits
 131               	.global	matrix_cols
 133               	matrix_cols:
 134               	.LFB14:
 118:keyboards/Dactylv2/matrix.c **** 
 119:keyboards/Dactylv2/matrix.c **** inline
 120:keyboards/Dactylv2/matrix.c **** uint8_t matrix_cols(void)
 121:keyboards/Dactylv2/matrix.c **** {
 135               		.loc 1 121 0
 136               		.cfi_startproc
 137               	/* prologue: function */
 138               	/* frame size = 0 */
 139               	/* stack size = 0 */
 140               	.L__stack_usage = 0
 122:keyboards/Dactylv2/matrix.c ****     return MATRIX_COLS;
 123:keyboards/Dactylv2/matrix.c **** }
 141               		.loc 1 123 0
 142 0000 86E0      		ldi r24,lo8(6)
 143               	/* epilogue start */
 144 0002 0895      		ret
 145               		.cfi_endproc
 146               	.LFE14:
 148               		.section	.text.matrix_init,"ax",@progbits
 149               	.global	matrix_init
 151               	matrix_init:
 152               	.LFB15:
 124:keyboards/Dactylv2/matrix.c **** 
 125:keyboards/Dactylv2/matrix.c **** void matrix_init(void)
 126:keyboards/Dactylv2/matrix.c **** {
 153               		.loc 1 126 0
 154               		.cfi_startproc
 155               	/* prologue: function */
 156               	/* frame size = 0 */
 157               	/* stack size = 0 */
 158               	.L__stack_usage = 0
 127:keyboards/Dactylv2/matrix.c ****     debug_enable = true;
 159               		.loc 1 127 0
 160 0000 8091 0000 		lds r24,debug_config
 128:keyboards/Dactylv2/matrix.c ****     debug_matrix = true;
 129:keyboards/Dactylv2/matrix.c ****     debug_mouse = true;
 161               		.loc 1 129 0
 162 0004 8360      		ori r24,lo8(3)
 163 0006 8860      		ori r24,lo8(1<<3)
 164 0008 8093 0000 		sts debug_config,r24
 165               	.LVL4:
 166 000c A0E0      		ldi r26,lo8(row_pins)
 167 000e B0E0      		ldi r27,hi8(row_pins)
 168               	.LBB15:
 169               	.LBB16:
 170               	.LBB17:
 130:keyboards/Dactylv2/matrix.c ****     // initialize row and col
 131:keyboards/Dactylv2/matrix.c ****     unselect_rows();
 132:keyboards/Dactylv2/matrix.c ****     init_cols();
 133:keyboards/Dactylv2/matrix.c **** 
 134:keyboards/Dactylv2/matrix.c ****     TX_RX_LED_INIT;
 135:keyboards/Dactylv2/matrix.c **** 
 136:keyboards/Dactylv2/matrix.c ****     // initialize matrix state: all keys off
 137:keyboards/Dactylv2/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 138:keyboards/Dactylv2/matrix.c ****         matrix[i] = 0;
 139:keyboards/Dactylv2/matrix.c ****         matrix_debouncing[i] = 0;
 140:keyboards/Dactylv2/matrix.c ****     }
 141:keyboards/Dactylv2/matrix.c **** 
 142:keyboards/Dactylv2/matrix.c ****     matrix_init_quantum();
 143:keyboards/Dactylv2/matrix.c **** 
 144:keyboards/Dactylv2/matrix.c **** }
 145:keyboards/Dactylv2/matrix.c **** 
 146:keyboards/Dactylv2/matrix.c **** uint8_t _matrix_scan(void)
 147:keyboards/Dactylv2/matrix.c **** {
 148:keyboards/Dactylv2/matrix.c ****     int offset = isLeftHand ? 0 : (ROWS_PER_HAND);
 149:keyboards/Dactylv2/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 150:keyboards/Dactylv2/matrix.c ****     // Set row, read cols
 151:keyboards/Dactylv2/matrix.c ****     for (uint8_t current_row = 0; current_row < ROWS_PER_HAND; current_row++) {
 152:keyboards/Dactylv2/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 153:keyboards/Dactylv2/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing+offset, current_row);
 154:keyboards/Dactylv2/matrix.c **** 
 155:keyboards/Dactylv2/matrix.c ****             if (matrix_changed) {
 156:keyboards/Dactylv2/matrix.c ****                 debouncing = true;
 157:keyboards/Dactylv2/matrix.c ****                 debouncing_time = timer_read();
 158:keyboards/Dactylv2/matrix.c ****                 PORTD ^= (1 << 2);
 159:keyboards/Dactylv2/matrix.c ****             }
 160:keyboards/Dactylv2/matrix.c **** 
 161:keyboards/Dactylv2/matrix.c **** #       else
 162:keyboards/Dactylv2/matrix.c ****             read_cols_on_row(matrix+offset, current_row);
 163:keyboards/Dactylv2/matrix.c **** #       endif
 164:keyboards/Dactylv2/matrix.c **** 
 165:keyboards/Dactylv2/matrix.c ****     }
 166:keyboards/Dactylv2/matrix.c **** 
 167:keyboards/Dactylv2/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 168:keyboards/Dactylv2/matrix.c ****     // Set col, read rows
 169:keyboards/Dactylv2/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 170:keyboards/Dactylv2/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 171:keyboards/Dactylv2/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing+offset, current_col);
 172:keyboards/Dactylv2/matrix.c ****             if (matrix_changed) {
 173:keyboards/Dactylv2/matrix.c ****                 debouncing = true;
 174:keyboards/Dactylv2/matrix.c ****                 debouncing_time = timer_read();
 175:keyboards/Dactylv2/matrix.c ****             }
 176:keyboards/Dactylv2/matrix.c **** #       else
 177:keyboards/Dactylv2/matrix.c ****              read_rows_on_col(matrix+offset, current_col);
 178:keyboards/Dactylv2/matrix.c **** #       endif
 179:keyboards/Dactylv2/matrix.c **** 
 180:keyboards/Dactylv2/matrix.c ****     }
 181:keyboards/Dactylv2/matrix.c **** #endif
 182:keyboards/Dactylv2/matrix.c **** 
 183:keyboards/Dactylv2/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 184:keyboards/Dactylv2/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 185:keyboards/Dactylv2/matrix.c ****             for (uint8_t i = 0; i < ROWS_PER_HAND; i++) {
 186:keyboards/Dactylv2/matrix.c ****                 matrix[i+offset] = matrix_debouncing[i+offset];
 187:keyboards/Dactylv2/matrix.c ****             }
 188:keyboards/Dactylv2/matrix.c ****             debouncing = false;
 189:keyboards/Dactylv2/matrix.c ****         }
 190:keyboards/Dactylv2/matrix.c **** #   endif
 191:keyboards/Dactylv2/matrix.c **** 
 192:keyboards/Dactylv2/matrix.c ****     return 1;
 193:keyboards/Dactylv2/matrix.c **** }
 194:keyboards/Dactylv2/matrix.c **** 
 195:keyboards/Dactylv2/matrix.c **** #ifdef USE_I2C
 196:keyboards/Dactylv2/matrix.c **** 
 197:keyboards/Dactylv2/matrix.c **** // Get rows from other half over i2c
 198:keyboards/Dactylv2/matrix.c **** int i2c_transaction(void) {
 199:keyboards/Dactylv2/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 200:keyboards/Dactylv2/matrix.c **** 
 201:keyboards/Dactylv2/matrix.c ****     int err = i2c_master_start(SLAVE_I2C_ADDRESS + I2C_WRITE);
 202:keyboards/Dactylv2/matrix.c ****     if (err) goto i2c_error;
 203:keyboards/Dactylv2/matrix.c **** 
 204:keyboards/Dactylv2/matrix.c ****     // start of matrix stored at 0x00
 205:keyboards/Dactylv2/matrix.c ****     err = i2c_master_write(0x00);
 206:keyboards/Dactylv2/matrix.c ****     if (err) goto i2c_error;
 207:keyboards/Dactylv2/matrix.c **** 
 208:keyboards/Dactylv2/matrix.c ****     // Start read
 209:keyboards/Dactylv2/matrix.c ****     err = i2c_master_start(SLAVE_I2C_ADDRESS + I2C_READ);
 210:keyboards/Dactylv2/matrix.c ****     if (err) goto i2c_error;
 211:keyboards/Dactylv2/matrix.c **** 
 212:keyboards/Dactylv2/matrix.c ****     if (!err) {
 213:keyboards/Dactylv2/matrix.c ****         int i;
 214:keyboards/Dactylv2/matrix.c ****         for (i = 0; i < ROWS_PER_HAND-1; ++i) {
 215:keyboards/Dactylv2/matrix.c ****             matrix[slaveOffset+i] = i2c_master_read(I2C_ACK);
 216:keyboards/Dactylv2/matrix.c ****         }
 217:keyboards/Dactylv2/matrix.c ****         matrix[slaveOffset+i] = i2c_master_read(I2C_NACK);
 218:keyboards/Dactylv2/matrix.c ****         i2c_master_stop();
 219:keyboards/Dactylv2/matrix.c ****     } else {
 220:keyboards/Dactylv2/matrix.c **** i2c_error: // the cable is disconnceted, or something else went wrong
 221:keyboards/Dactylv2/matrix.c ****         i2c_reset_state();
 222:keyboards/Dactylv2/matrix.c ****         return err;
 223:keyboards/Dactylv2/matrix.c ****     }
 224:keyboards/Dactylv2/matrix.c **** 
 225:keyboards/Dactylv2/matrix.c ****     return 0;
 226:keyboards/Dactylv2/matrix.c **** }
 227:keyboards/Dactylv2/matrix.c **** 
 228:keyboards/Dactylv2/matrix.c **** #else // USE_SERIAL
 229:keyboards/Dactylv2/matrix.c **** 
 230:keyboards/Dactylv2/matrix.c **** int serial_transaction(void) {
 231:keyboards/Dactylv2/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 232:keyboards/Dactylv2/matrix.c **** 
 233:keyboards/Dactylv2/matrix.c ****     if (serial_update_buffers()) {
 234:keyboards/Dactylv2/matrix.c ****         return 1;
 235:keyboards/Dactylv2/matrix.c ****     }
 236:keyboards/Dactylv2/matrix.c **** 
 237:keyboards/Dactylv2/matrix.c ****     for (int i = 0; i < ROWS_PER_HAND; ++i) {
 238:keyboards/Dactylv2/matrix.c ****         matrix[slaveOffset+i] = serial_slave_buffer[i];
 239:keyboards/Dactylv2/matrix.c ****     }
 240:keyboards/Dactylv2/matrix.c ****     return 0;
 241:keyboards/Dactylv2/matrix.c **** }
 242:keyboards/Dactylv2/matrix.c **** #endif
 243:keyboards/Dactylv2/matrix.c **** 
 244:keyboards/Dactylv2/matrix.c **** uint8_t matrix_scan(void)
 245:keyboards/Dactylv2/matrix.c **** {
 246:keyboards/Dactylv2/matrix.c ****     uint8_t ret = _matrix_scan();
 247:keyboards/Dactylv2/matrix.c **** 
 248:keyboards/Dactylv2/matrix.c **** #ifdef USE_I2C
 249:keyboards/Dactylv2/matrix.c ****     if( i2c_transaction() ) {
 250:keyboards/Dactylv2/matrix.c **** #else // USE_SERIAL
 251:keyboards/Dactylv2/matrix.c ****     if( serial_transaction() ) {
 252:keyboards/Dactylv2/matrix.c **** #endif
 253:keyboards/Dactylv2/matrix.c ****         // turn on the indicator led when halves are disconnected
 254:keyboards/Dactylv2/matrix.c ****         TXLED1;
 255:keyboards/Dactylv2/matrix.c **** 
 256:keyboards/Dactylv2/matrix.c ****         error_count++;
 257:keyboards/Dactylv2/matrix.c **** 
 258:keyboards/Dactylv2/matrix.c ****         if (error_count > ERROR_DISCONNECT_COUNT) {
 259:keyboards/Dactylv2/matrix.c ****             // reset other half if disconnected
 260:keyboards/Dactylv2/matrix.c ****             int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 261:keyboards/Dactylv2/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 262:keyboards/Dactylv2/matrix.c ****                 matrix[slaveOffset+i] = 0;
 263:keyboards/Dactylv2/matrix.c ****             }
 264:keyboards/Dactylv2/matrix.c ****         }
 265:keyboards/Dactylv2/matrix.c ****     } else {
 266:keyboards/Dactylv2/matrix.c ****         // turn off the indicator led on no error
 267:keyboards/Dactylv2/matrix.c ****         TXLED0;
 268:keyboards/Dactylv2/matrix.c ****         error_count = 0;
 269:keyboards/Dactylv2/matrix.c ****     }
 270:keyboards/Dactylv2/matrix.c ****     matrix_scan_quantum();
 271:keyboards/Dactylv2/matrix.c ****     return ret;
 272:keyboards/Dactylv2/matrix.c **** }
 273:keyboards/Dactylv2/matrix.c **** 
 274:keyboards/Dactylv2/matrix.c **** void matrix_slave_scan(void) {
 275:keyboards/Dactylv2/matrix.c ****     _matrix_scan();
 276:keyboards/Dactylv2/matrix.c **** 
 277:keyboards/Dactylv2/matrix.c ****     int offset = (isLeftHand) ? 0 : ROWS_PER_HAND;
 278:keyboards/Dactylv2/matrix.c **** 
 279:keyboards/Dactylv2/matrix.c **** #ifdef USE_I2C
 280:keyboards/Dactylv2/matrix.c ****     for (int i = 0; i < ROWS_PER_HAND; ++i) {
 281:keyboards/Dactylv2/matrix.c ****         i2c_slave_buffer[i] = matrix[offset+i];
 282:keyboards/Dactylv2/matrix.c ****     }
 283:keyboards/Dactylv2/matrix.c **** #else // USE_SERIAL
 284:keyboards/Dactylv2/matrix.c ****     for (int i = 0; i < ROWS_PER_HAND; ++i) {
 285:keyboards/Dactylv2/matrix.c ****         serial_slave_buffer[i] = matrix[offset+i];
 286:keyboards/Dactylv2/matrix.c ****     }
 287:keyboards/Dactylv2/matrix.c **** #endif
 288:keyboards/Dactylv2/matrix.c **** }
 289:keyboards/Dactylv2/matrix.c **** 
 290:keyboards/Dactylv2/matrix.c **** bool matrix_is_modified(void)
 291:keyboards/Dactylv2/matrix.c **** {
 292:keyboards/Dactylv2/matrix.c ****     if (debouncing) return false;
 293:keyboards/Dactylv2/matrix.c ****     return true;
 294:keyboards/Dactylv2/matrix.c **** }
 295:keyboards/Dactylv2/matrix.c **** 
 296:keyboards/Dactylv2/matrix.c **** inline
 297:keyboards/Dactylv2/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 298:keyboards/Dactylv2/matrix.c **** {
 299:keyboards/Dactylv2/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 300:keyboards/Dactylv2/matrix.c **** }
 301:keyboards/Dactylv2/matrix.c **** 
 302:keyboards/Dactylv2/matrix.c **** inline
 303:keyboards/Dactylv2/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 304:keyboards/Dactylv2/matrix.c **** {
 305:keyboards/Dactylv2/matrix.c ****     return matrix[row];
 306:keyboards/Dactylv2/matrix.c **** }
 307:keyboards/Dactylv2/matrix.c **** 
 308:keyboards/Dactylv2/matrix.c **** void matrix_print(void)
 309:keyboards/Dactylv2/matrix.c **** {
 310:keyboards/Dactylv2/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 311:keyboards/Dactylv2/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 312:keyboards/Dactylv2/matrix.c ****         phex(row); print(": ");
 313:keyboards/Dactylv2/matrix.c ****         pbin_reverse16(matrix_get_row(row));
 314:keyboards/Dactylv2/matrix.c ****         print("\n");
 315:keyboards/Dactylv2/matrix.c ****     }
 316:keyboards/Dactylv2/matrix.c **** }
 317:keyboards/Dactylv2/matrix.c **** 
 318:keyboards/Dactylv2/matrix.c **** uint8_t matrix_key_count(void)
 319:keyboards/Dactylv2/matrix.c **** {
 320:keyboards/Dactylv2/matrix.c ****     uint8_t count = 0;
 321:keyboards/Dactylv2/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 322:keyboards/Dactylv2/matrix.c ****         count += bitpop16(matrix[i]);
 323:keyboards/Dactylv2/matrix.c ****     }
 324:keyboards/Dactylv2/matrix.c ****     return count;
 325:keyboards/Dactylv2/matrix.c **** }
 326:keyboards/Dactylv2/matrix.c **** 
 327:keyboards/Dactylv2/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 328:keyboards/Dactylv2/matrix.c **** 
 329:keyboards/Dactylv2/matrix.c **** static void init_cols(void)
 330:keyboards/Dactylv2/matrix.c **** {
 331:keyboards/Dactylv2/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 332:keyboards/Dactylv2/matrix.c ****         uint8_t pin = col_pins[x];
 333:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 334:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 335:keyboards/Dactylv2/matrix.c ****     }
 336:keyboards/Dactylv2/matrix.c **** }
 337:keyboards/Dactylv2/matrix.c **** 
 338:keyboards/Dactylv2/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 339:keyboards/Dactylv2/matrix.c **** {
 340:keyboards/Dactylv2/matrix.c ****     // Store last value of row prior to reading
 341:keyboards/Dactylv2/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 342:keyboards/Dactylv2/matrix.c **** 
 343:keyboards/Dactylv2/matrix.c ****     // Clear data in matrix row
 344:keyboards/Dactylv2/matrix.c ****     current_matrix[current_row] = 0;
 345:keyboards/Dactylv2/matrix.c **** 
 346:keyboards/Dactylv2/matrix.c ****     // Select row and wait for row selecton to stabilize
 347:keyboards/Dactylv2/matrix.c ****     select_row(current_row);
 348:keyboards/Dactylv2/matrix.c ****     wait_us(30);
 349:keyboards/Dactylv2/matrix.c **** 
 350:keyboards/Dactylv2/matrix.c ****     // For each col...
 351:keyboards/Dactylv2/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 352:keyboards/Dactylv2/matrix.c **** 
 353:keyboards/Dactylv2/matrix.c ****         // Select the col pin to read (active low)
 354:keyboards/Dactylv2/matrix.c ****         uint8_t pin = col_pins[col_index];
 355:keyboards/Dactylv2/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 356:keyboards/Dactylv2/matrix.c **** 
 357:keyboards/Dactylv2/matrix.c ****         // Populate the matrix row with the state of the col pin
 358:keyboards/Dactylv2/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 359:keyboards/Dactylv2/matrix.c ****     }
 360:keyboards/Dactylv2/matrix.c **** 
 361:keyboards/Dactylv2/matrix.c ****     // Unselect row
 362:keyboards/Dactylv2/matrix.c ****     unselect_row(current_row);
 363:keyboards/Dactylv2/matrix.c **** 
 364:keyboards/Dactylv2/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 365:keyboards/Dactylv2/matrix.c **** }
 366:keyboards/Dactylv2/matrix.c **** 
 367:keyboards/Dactylv2/matrix.c **** static void select_row(uint8_t row)
 368:keyboards/Dactylv2/matrix.c **** {
 369:keyboards/Dactylv2/matrix.c ****     uint8_t pin = row_pins[row];
 370:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 371:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 372:keyboards/Dactylv2/matrix.c **** }
 373:keyboards/Dactylv2/matrix.c **** 
 374:keyboards/Dactylv2/matrix.c **** static void unselect_row(uint8_t row)
 375:keyboards/Dactylv2/matrix.c **** {
 376:keyboards/Dactylv2/matrix.c ****     uint8_t pin = row_pins[row];
 377:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 378:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 379:keyboards/Dactylv2/matrix.c **** }
 380:keyboards/Dactylv2/matrix.c **** 
 381:keyboards/Dactylv2/matrix.c **** static void unselect_rows(void)
 382:keyboards/Dactylv2/matrix.c **** {
 383:keyboards/Dactylv2/matrix.c ****     for(uint8_t x = 0; x < ROWS_PER_HAND; x++) {
 384:keyboards/Dactylv2/matrix.c ****         uint8_t pin = row_pins[x];
 385:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 171               		.loc 1 385 0
 172 0010 61E0      		ldi r22,lo8(1)
 173 0012 70E0      		ldi r23,0
 174               	.LVL5:
 175               	.L10:
 384:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 176               		.loc 1 384 0
 177 0014 8D91      		ld r24,X+
 178               	.LVL6:
 179               		.loc 1 385 0
 180 0016 E82F      		mov r30,r24
 181 0018 E295      		swap r30
 182 001a EF70      		andi r30,lo8(15)
 183 001c F0E0      		ldi r31,0
 184 001e 41A1      		ldd r20,Z+33
 185 0020 8F70      		andi r24,lo8(15)
 186               	.LVL7:
 187 0022 9B01      		movw r18,r22
 188 0024 00C0      		rjmp 2f
 189               		1:
 190 0026 220F      		lsl r18
 191               		2:
 192 0028 8A95      		dec r24
 193 002a 02F4      		brpl 1b
 194 002c 922F      		mov r25,r18
 195 002e 9095      		com r25
 196 0030 9423      		and r25,r20
 197 0032 91A3      		std Z+33,r25
 198               	.LVL8:
 386:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 199               		.loc 1 386 0
 200 0034 82A1      		ldd r24,Z+34
 201 0036 822B      		or r24,r18
 202 0038 82A3      		std Z+34,r24
 203               	.LVL9:
 204               	.LBE17:
 383:keyboards/Dactylv2/matrix.c ****         uint8_t pin = row_pins[x];
 205               		.loc 1 383 0
 206 003a 80E0      		ldi r24,hi8(row_pins+7)
 207 003c A030      		cpi r26,lo8(row_pins+7)
 208 003e B807      		cpc r27,r24
 209 0040 01F4      		brne .L10
 210 0042 A0E0      		ldi r26,lo8(col_pins)
 211 0044 B0E0      		ldi r27,hi8(col_pins)
 212               	.LVL10:
 213               	.LBE16:
 214               	.LBE15:
 215               	.LBB18:
 216               	.LBB19:
 217               	.LBB20:
 333:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 218               		.loc 1 333 0
 219 0046 61E0      		ldi r22,lo8(1)
 220 0048 70E0      		ldi r23,0
 221               	.L11:
 222               	.LVL11:
 332:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 223               		.loc 1 332 0
 224 004a 8D91      		ld r24,X+
 225               	.LVL12:
 333:keyboards/Dactylv2/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 226               		.loc 1 333 0
 227 004c E82F      		mov r30,r24
 228 004e E295      		swap r30
 229 0050 EF70      		andi r30,lo8(15)
 230 0052 F0E0      		ldi r31,0
 231 0054 41A1      		ldd r20,Z+33
 232 0056 8F70      		andi r24,lo8(15)
 233               	.LVL13:
 234 0058 9B01      		movw r18,r22
 235 005a 00C0      		rjmp 2f
 236               		1:
 237 005c 220F      		lsl r18
 238               		2:
 239 005e 8A95      		dec r24
 240 0060 02F4      		brpl 1b
 241 0062 922F      		mov r25,r18
 242 0064 9095      		com r25
 243 0066 9423      		and r25,r20
 244 0068 91A3      		std Z+33,r25
 245               	.LVL14:
 334:keyboards/Dactylv2/matrix.c ****     }
 246               		.loc 1 334 0
 247 006a 82A1      		ldd r24,Z+34
 248 006c 822B      		or r24,r18
 249 006e 82A3      		std Z+34,r24
 250               	.LVL15:
 251               	.LBE20:
 331:keyboards/Dactylv2/matrix.c ****         uint8_t pin = col_pins[x];
 252               		.loc 1 331 0
 253 0070 80E0      		ldi r24,hi8(col_pins+6)
 254 0072 A030      		cpi r26,lo8(col_pins+6)
 255 0074 B807      		cpc r27,r24
 256 0076 01F4      		brne .L11
 257               	.LVL16:
 258               	.LBE19:
 259               	.LBE18:
 134:keyboards/Dactylv2/matrix.c **** 
 260               		.loc 1 134 0
 261 0078 559A      		sbi 0xa,5
 262 007a 209A      		sbi 0x4,0
 263               	.LVL17:
 264 007c E0E0      		ldi r30,lo8(matrix)
 265 007e F0E0      		ldi r31,hi8(matrix)
 266 0080 A0E0      		ldi r26,lo8(matrix_debouncing)
 267 0082 B0E0      		ldi r27,hi8(matrix_debouncing)
 268 0084 80E0      		ldi r24,lo8(matrix+14)
 269 0086 90E0      		ldi r25,hi8(matrix+14)
 270               	.LVL18:
 271               	.L12:
 272               	.LBB21:
 138:keyboards/Dactylv2/matrix.c ****         matrix_debouncing[i] = 0;
 273               		.loc 1 138 0 discriminator 3
 274 0088 1192      		st Z+,__zero_reg__
 275               	.LVL19:
 139:keyboards/Dactylv2/matrix.c ****     }
 276               		.loc 1 139 0 discriminator 3
 277 008a 1D92      		st X+,__zero_reg__
 278               	.LVL20:
 137:keyboards/Dactylv2/matrix.c ****         matrix[i] = 0;
 279               		.loc 1 137 0 discriminator 3
 280 008c 8E17      		cp r24,r30
 281 008e 9F07      		cpc r25,r31
 282 0090 01F4      		brne .L12
 283               	.LBE21:
 142:keyboards/Dactylv2/matrix.c **** 
 284               		.loc 1 142 0
 285 0092 0C94 0000 		jmp matrix_init_quantum
 286               	.LVL21:
 287               		.cfi_endproc
 288               	.LFE15:
 290               		.section	.text._matrix_scan,"ax",@progbits
 291               	.global	_matrix_scan
 293               	_matrix_scan:
 294               	.LFB16:
 147:keyboards/Dactylv2/matrix.c ****     int offset = isLeftHand ? 0 : (ROWS_PER_HAND);
 295               		.loc 1 147 0
 296               		.cfi_startproc
 297 0000 4F92      		push r4
 298               	.LCFI0:
 299               		.cfi_def_cfa_offset 3
 300               		.cfi_offset 4, -2
 301 0002 5F92      		push r5
 302               	.LCFI1:
 303               		.cfi_def_cfa_offset 4
 304               		.cfi_offset 5, -3
 305 0004 6F92      		push r6
 306               	.LCFI2:
 307               		.cfi_def_cfa_offset 5
 308               		.cfi_offset 6, -4
 309 0006 7F92      		push r7
 310               	.LCFI3:
 311               		.cfi_def_cfa_offset 6
 312               		.cfi_offset 7, -5
 313 0008 8F92      		push r8
 314               	.LCFI4:
 315               		.cfi_def_cfa_offset 7
 316               		.cfi_offset 8, -6
 317 000a 9F92      		push r9
 318               	.LCFI5:
 319               		.cfi_def_cfa_offset 8
 320               		.cfi_offset 9, -7
 321 000c AF92      		push r10
 322               	.LCFI6:
 323               		.cfi_def_cfa_offset 9
 324               		.cfi_offset 10, -8
 325 000e BF92      		push r11
 326               	.LCFI7:
 327               		.cfi_def_cfa_offset 10
 328               		.cfi_offset 11, -9
 329 0010 CF92      		push r12
 330               	.LCFI8:
 331               		.cfi_def_cfa_offset 11
 332               		.cfi_offset 12, -10
 333 0012 DF92      		push r13
 334               	.LCFI9:
 335               		.cfi_def_cfa_offset 12
 336               		.cfi_offset 13, -11
 337 0014 EF92      		push r14
 338               	.LCFI10:
 339               		.cfi_def_cfa_offset 13
 340               		.cfi_offset 14, -12
 341 0016 FF92      		push r15
 342               	.LCFI11:
 343               		.cfi_def_cfa_offset 14
 344               		.cfi_offset 15, -13
 345 0018 0F93      		push r16
 346               	.LCFI12:
 347               		.cfi_def_cfa_offset 15
 348               		.cfi_offset 16, -14
 349 001a 1F93      		push r17
 350               	.LCFI13:
 351               		.cfi_def_cfa_offset 16
 352               		.cfi_offset 17, -15
 353 001c CF93      		push r28
 354               	.LCFI14:
 355               		.cfi_def_cfa_offset 17
 356               		.cfi_offset 28, -16
 357 001e DF93      		push r29
 358               	.LCFI15:
 359               		.cfi_def_cfa_offset 18
 360               		.cfi_offset 29, -17
 361               	/* prologue: function */
 362               	/* frame size = 0 */
 363               	/* stack size = 16 */
 364               	.L__stack_usage = 16
 148:keyboards/Dactylv2/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 365               		.loc 1 148 0
 366 0020 8091 0000 		lds r24,isLeftHand
 367 0024 07E0      		ldi r16,lo8(7)
 368 0026 10E0      		ldi r17,0
 369 0028 8823      		tst r24
 370 002a 01F0      		breq .L17
 371 002c 10E0      		ldi r17,0
 372 002e 00E0      		ldi r16,0
 373               	.L17:
 374               	.LVL22:
 375 0030 C801      		movw r24,r16
 376 0032 8050      		subi r24,lo8(-(matrix_debouncing))
 377 0034 9040      		sbci r25,hi8(-(matrix_debouncing))
 378 0036 7C01      		movw r14,r24
 379 0038 80E0      		ldi r24,lo8(row_pins)
 380 003a C82E      		mov r12,r24
 381 003c 80E0      		ldi r24,hi8(row_pins)
 382 003e D82E      		mov r13,r24
 148:keyboards/Dactylv2/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 383               		.loc 1 148 0 is_stmt 0 discriminator 4
 384 0040 E701      		movw r28,r14
 385               	.LBB35:
 386               	.LBB36:
 387               	.LBB37:
 388               	.LBB38:
 389               	.LBB39:
 390               	.LBB40:
 370:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 391               		.loc 1 370 0 is_stmt 1 discriminator 4
 392 0042 AA24      		clr r10
 393 0044 A394      		inc r10
 394 0046 B12C      		mov r11,__zero_reg__
 395               	.LBE40:
 396               	.LBE39:
 397               	.LBE38:
 398               	.LBE37:
 156:keyboards/Dactylv2/matrix.c ****                 debouncing_time = timer_read();
 399               		.loc 1 156 0 discriminator 4
 400 0048 8824      		clr r8
 401 004a 8394      		inc r8
 158:keyboards/Dactylv2/matrix.c ****             }
 402               		.loc 1 158 0 discriminator 4
 403 004c 24E0      		ldi r18,lo8(4)
 404 004e 922E      		mov r9,r18
 405               	.LVL23:
 406               	.L21:
 407               	.LBB53:
 408               	.LBB51:
 341:keyboards/Dactylv2/matrix.c **** 
 409               		.loc 1 341 0
 410 0050 7880      		ld r7,Y
 411               	.LVL24:
 344:keyboards/Dactylv2/matrix.c **** 
 412               		.loc 1 344 0
 413 0052 1882      		st Y,__zero_reg__
 414               	.LVL25:
 415               	.LBB42:
 416               	.LBB41:
 369:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 417               		.loc 1 369 0
 418 0054 D601      		movw r26,r12
 419 0056 8D91      		ld r24,X+
 420 0058 6D01      		movw r12,r26
 421               	.LVL26:
 370:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 422               		.loc 1 370 0
 423 005a E82F      		mov r30,r24
 424 005c E295      		swap r30
 425 005e EF70      		andi r30,lo8(15)
 426 0060 F0E0      		ldi r31,0
 427 0062 91A1      		ldd r25,Z+33
 428 0064 8F70      		andi r24,lo8(15)
 429               	.LVL27:
 430 0066 9501      		movw r18,r10
 431 0068 00C0      		rjmp 2f
 432               		1:
 433 006a 220F      		lsl r18
 434               		2:
 435 006c 8A95      		dec r24
 436 006e 02F4      		brpl 1b
 437 0070 892F      		mov r24,r25
 438 0072 822B      		or r24,r18
 439 0074 81A3      		std Z+33,r24
 440               	.LVL28:
 371:keyboards/Dactylv2/matrix.c **** }
 441               		.loc 1 371 0
 442 0076 82A1      		ldd r24,Z+34
 443 0078 622E      		mov r6,r18
 444 007a 6094      		com r6
 445 007c 8621      		and r24,r6
 446 007e 82A3      		std Z+34,r24
 447               	.LVL29:
 448               	.LBE41:
 449               	.LBE42:
 450               	.LBB43:
 451               	.LBB44:
 452               		.file 2 "/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 189:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #else
 190:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	{
 196:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		{
 200:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		}
 204:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		return;
 205:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	}
 206:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	else
 207:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #endif
 210:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** }
 211:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 212:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /**
 213:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 215:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 217:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 220:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 222:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 226:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 231:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 236:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    respectively.
 240:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 241:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \note
 242:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 243:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 253:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****  */
 254:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** void
 255:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** {
 257:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 265:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 268:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 271:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#else
 272:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		//round up by default
 273:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#endif
 275:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 276:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 453               		.loc 2 276 0
 454 0080 B0EA      		ldi r27,lo8(-96)
 455 0082 BA95      	1:	dec r27
 456 0084 01F4      		brne 1b
 457               	.LVL30:
 458 0086 40E0      		ldi r20,lo8(col_pins)
 459 0088 50E0      		ldi r21,hi8(col_pins)
 460 008a 90E0      		ldi r25,0
 461 008c 80E0      		ldi r24,0
 462               	.LVL31:
 463               	.L19:
 464               	.LBE44:
 465               	.LBE43:
 466               	.LBB45:
 467               	.LBB46:
 354:keyboards/Dactylv2/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 468               		.loc 1 354 0
 469 008e DA01      		movw r26,r20
 470 0090 7D91      		ld r23,X+
 471 0092 AD01      		movw r20,r26
 472               	.LVL32:
 355:keyboards/Dactylv2/matrix.c **** 
 473               		.loc 1 355 0
 474 0094 A72F      		mov r26,r23
 475 0096 A295      		swap r26
 476 0098 AF70      		andi r26,lo8(15)
 477 009a B0E0      		ldi r27,0
 478 009c 9096      		adiw r26,32
 479 009e BC91      		ld r27,X
 480               	.LVL33:
 358:keyboards/Dactylv2/matrix.c ****     }
 481               		.loc 1 358 0
 482 00a0 A881      		ld r26,Y
 355:keyboards/Dactylv2/matrix.c **** 
 483               		.loc 1 355 0
 484 00a2 7F70      		andi r23,lo8(15)
 485               	.LVL34:
 486 00a4 2501      		movw r4,r10
 487 00a6 00C0      		rjmp 2f
 488               		1:
 489 00a8 440C      		lsl r4
 490 00aa 551C      		rol r5
 491               		2:
 492 00ac 7A95      		dec r23
 493 00ae 02F4      		brpl 1b
 494 00b0 B201      		movw r22,r4
 495 00b2 6B23      		and r22,r27
 358:keyboards/Dactylv2/matrix.c ****     }
 496               		.loc 1 358 0
 497 00b4 01F0      		breq .+2
 498 00b6 00C0      		rjmp .L27
 499 00b8 6A2D      		mov r22,r10
 500 00ba 082E      		mov r0,r24
 501 00bc 00C0      		rjmp 2f
 502               		1:
 503 00be 660F      		lsl r22
 504               		2:
 505 00c0 0A94      		dec r0
 506 00c2 02F4      		brpl 1b
 507               	.L18:
 508 00c4 6A2B      		or r22,r26
 509 00c6 6883      		st Y,r22
 510               	.LVL35:
 511 00c8 0196      		adiw r24,1
 512               	.LVL36:
 513               	.LBE46:
 351:keyboards/Dactylv2/matrix.c **** 
 514               		.loc 1 351 0
 515 00ca 8630      		cpi r24,6
 516 00cc 9105      		cpc r25,__zero_reg__
 517 00ce 01F4      		brne .L19
 518               	.LVL37:
 519               	.LBE45:
 520               	.LBB48:
 521               	.LBB49:
 377:keyboards/Dactylv2/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 522               		.loc 1 377 0
 523 00d0 81A1      		ldd r24,Z+33
 524               	.LVL38:
 525 00d2 8621      		and r24,r6
 526 00d4 81A3      		std Z+33,r24
 527               	.LVL39:
 378:keyboards/Dactylv2/matrix.c **** }
 528               		.loc 1 378 0
 529 00d6 82A1      		ldd r24,Z+34
 530 00d8 282B      		or r18,r24
 531 00da 22A3      		std Z+34,r18
 532               	.LVL40:
 533               	.LBE49:
 534               	.LBE48:
 535               	.LBE51:
 536               	.LBE53:
 155:keyboards/Dactylv2/matrix.c ****                 debouncing = true;
 537               		.loc 1 155 0
 538 00dc 8881      		ld r24,Y
 539 00de 7816      		cp r7,r24
 540 00e0 01F0      		breq .L20
 156:keyboards/Dactylv2/matrix.c ****                 debouncing_time = timer_read();
 541               		.loc 1 156 0
 542 00e2 8092 0000 		sts debouncing,r8
 157:keyboards/Dactylv2/matrix.c ****                 PORTD ^= (1 << 2);
 543               		.loc 1 157 0
 544 00e6 0E94 0000 		call timer_read
 545               	.LVL41:
 546 00ea 9093 0000 		sts debouncing_time+1,r25
 547 00ee 8093 0000 		sts debouncing_time,r24
 158:keyboards/Dactylv2/matrix.c ****             }
 548               		.loc 1 158 0
 549 00f2 8BB1      		in r24,0xb
 550 00f4 8925      		eor r24,r9
 551 00f6 8BB9      		out 0xb,r24
 552               	.L20:
 553 00f8 2196      		adiw r28,1
 554               	.LBE36:
 151:keyboards/Dactylv2/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 555               		.loc 1 151 0 discriminator 2
 556 00fa 80E0      		ldi r24,lo8(row_pins+7)
 557 00fc C816      		cp r12,r24
 558 00fe 80E0      		ldi r24,hi8(row_pins+7)
 559 0100 D806      		cpc r13,r24
 560 0102 01F0      		breq .+2
 561 0104 00C0      		rjmp .L21
 562               	.LBE35:
 184:keyboards/Dactylv2/matrix.c ****             for (uint8_t i = 0; i < ROWS_PER_HAND; i++) {
 563               		.loc 1 184 0
 564 0106 8091 0000 		lds r24,debouncing
 565 010a 8823      		tst r24
 566 010c 01F0      		breq .L23
 184:keyboards/Dactylv2/matrix.c ****             for (uint8_t i = 0; i < ROWS_PER_HAND; i++) {
 567               		.loc 1 184 0 is_stmt 0 discriminator 1
 568 010e 8091 0000 		lds r24,debouncing_time
 569 0112 9091 0000 		lds r25,debouncing_time+1
 570 0116 0E94 0000 		call timer_elapsed
 571               	.LVL42:
 572 011a 0697      		sbiw r24,6
 573 011c 00F0      		brlo .L23
 574 011e F801      		movw r30,r16
 575 0120 E050      		subi r30,lo8(-(matrix))
 576 0122 F040      		sbci r31,hi8(-(matrix))
 577               	.LBB56:
 185:keyboards/Dactylv2/matrix.c ****                 matrix[i+offset] = matrix_debouncing[i+offset];
 578               		.loc 1 185 0 is_stmt 1
 579 0124 80E0      		ldi r24,0
 580               	.L25:
 581               	.LVL43:
 186:keyboards/Dactylv2/matrix.c ****             }
 582               		.loc 1 186 0 discriminator 3
 583 0126 D701      		movw r26,r14
 584 0128 9D91      		ld r25,X+
 585 012a 7D01      		movw r14,r26
 586 012c 9193      		st Z+,r25
 185:keyboards/Dactylv2/matrix.c ****                 matrix[i+offset] = matrix_debouncing[i+offset];
 587               		.loc 1 185 0 discriminator 3
 588 012e 8F5F      		subi r24,lo8(-(1))
 589               	.LVL44:
 590 0130 8730      		cpi r24,lo8(7)
 591 0132 01F4      		brne .L25
 592               	.LBE56:
 188:keyboards/Dactylv2/matrix.c ****         }
 593               		.loc 1 188 0
 594 0134 1092 0000 		sts debouncing,__zero_reg__
 595               	.LVL45:
 596               	.L23:
 193:keyboards/Dactylv2/matrix.c **** 
 597               		.loc 1 193 0
 598 0138 81E0      		ldi r24,lo8(1)
 599               	/* epilogue start */
 600 013a DF91      		pop r29
 601 013c CF91      		pop r28
 602 013e 1F91      		pop r17
 603 0140 0F91      		pop r16
 604 0142 FF90      		pop r15
 605 0144 EF90      		pop r14
 606 0146 DF90      		pop r13
 607 0148 CF90      		pop r12
 608 014a BF90      		pop r11
 609 014c AF90      		pop r10
 610 014e 9F90      		pop r9
 611 0150 8F90      		pop r8
 612 0152 7F90      		pop r7
 613 0154 6F90      		pop r6
 614 0156 5F90      		pop r5
 615 0158 4F90      		pop r4
 616 015a 0895      		ret
 617               	.LVL46:
 618               	.L27:
 619               	.LBB57:
 620               	.LBB55:
 621               	.LBB54:
 622               	.LBB52:
 623               	.LBB50:
 624               	.LBB47:
 358:keyboards/Dactylv2/matrix.c ****     }
 625               		.loc 1 358 0
 626 015c 60E0      		ldi r22,0
 627 015e 00C0      		rjmp .L18
 628               	.LBE47:
 629               	.LBE50:
 630               	.LBE52:
 631               	.LBE54:
 632               	.LBE55:
 633               	.LBE57:
 634               		.cfi_endproc
 635               	.LFE16:
 637               		.section	.text.serial_transaction,"ax",@progbits
 638               	.global	serial_transaction
 640               	serial_transaction:
 641               	.LFB17:
 230:keyboards/Dactylv2/matrix.c ****     int slaveOffset = (isLeftHand) ? (ROWS_PER_HAND) : 0;
 642               		.loc 1 230 0
 643               		.cfi_startproc
 644 0000 CF93      		push r28
 645               	.LCFI16:
 646               		.cfi_def_cfa_offset 3
 647               		.cfi_offset 28, -2
 648 0002 DF93      		push r29
 649               	.LCFI17:
 650               		.cfi_def_cfa_offset 4
 651               		.cfi_offset 29, -3
 652               	/* prologue: function */
 653               	/* frame size = 0 */
 654               	/* stack size = 2 */
 655               	.L__stack_usage = 2
 231:keyboards/Dactylv2/matrix.c **** 
 656               		.loc 1 231 0
 657 0004 8091 0000 		lds r24,isLeftHand
 658 0008 D0E0      		ldi r29,0
 659 000a C0E0      		ldi r28,0
 660 000c 8823      		tst r24
 661 000e 01F0      		breq .L32
 662 0010 C7E0      		ldi r28,lo8(7)
 663 0012 D0E0      		ldi r29,0
 664               	.L32:
 665               	.LVL47:
 233:keyboards/Dactylv2/matrix.c ****         return 1;
 666               		.loc 1 233 0 discriminator 4
 667 0014 0E94 0000 		call serial_update_buffers
 668               	.LVL48:
 669 0018 0097      		sbiw r24,0
 670 001a 01F4      		brne .L36
 671 001c C050      		subi r28,lo8(-(matrix))
 672 001e D040      		sbci r29,hi8(-(matrix))
 673               	.LVL49:
 674               	.LBB58:
 237:keyboards/Dactylv2/matrix.c ****         matrix[slaveOffset+i] = serial_slave_buffer[i];
 675               		.loc 1 237 0
 676 0020 30E0      		ldi r19,0
 677 0022 20E0      		ldi r18,0
 678               	.LVL50:
 679               	.L34:
 238:keyboards/Dactylv2/matrix.c ****     }
 680               		.loc 1 238 0 discriminator 3
 681 0024 F901      		movw r30,r18
 682 0026 E050      		subi r30,lo8(-(serial_slave_buffer))
 683 0028 F040      		sbci r31,hi8(-(serial_slave_buffer))
 684 002a 4081      		ld r20,Z
 685 002c 4993      		st Y+,r20
 237:keyboards/Dactylv2/matrix.c ****         matrix[slaveOffset+i] = serial_slave_buffer[i];
 686               		.loc 1 237 0 discriminator 3
 687 002e 2F5F      		subi r18,-1
 688 0030 3F4F      		sbci r19,-1
 689               	.LVL51:
 690 0032 2730      		cpi r18,7
 691 0034 3105      		cpc r19,__zero_reg__
 692 0036 01F4      		brne .L34
 693               	.LVL52:
 694               	.L31:
 695               	/* epilogue start */
 696               	.LBE58:
 241:keyboards/Dactylv2/matrix.c **** #endif
 697               		.loc 1 241 0
 698 0038 DF91      		pop r29
 699 003a CF91      		pop r28
 700 003c 0895      		ret
 701               	.LVL53:
 702               	.L36:
 234:keyboards/Dactylv2/matrix.c ****     }
 703               		.loc 1 234 0
 704 003e 81E0      		ldi r24,lo8(1)
 705 0040 90E0      		ldi r25,0
 706 0042 00C0      		rjmp .L31
 707               		.cfi_endproc
 708               	.LFE17:
 710               		.section	.text.matrix_scan,"ax",@progbits
 711               	.global	matrix_scan
 713               	matrix_scan:
 714               	.LFB18:
 245:keyboards/Dactylv2/matrix.c ****     uint8_t ret = _matrix_scan();
 715               		.loc 1 245 0
 716               		.cfi_startproc
 717 0000 CF93      		push r28
 718               	.LCFI18:
 719               		.cfi_def_cfa_offset 3
 720               		.cfi_offset 28, -2
 721               	/* prologue: function */
 722               	/* frame size = 0 */
 723               	/* stack size = 1 */
 724               	.L__stack_usage = 1
 246:keyboards/Dactylv2/matrix.c **** 
 725               		.loc 1 246 0
 726 0002 0E94 0000 		call _matrix_scan
 727               	.LVL54:
 728 0006 C82F      		mov r28,r24
 729               	.LVL55:
 251:keyboards/Dactylv2/matrix.c **** #endif
 730               		.loc 1 251 0
 731 0008 0E94 0000 		call serial_transaction
 732               	.LVL56:
 733 000c 892B      		or r24,r25
 734 000e 01F0      		breq .L39
 254:keyboards/Dactylv2/matrix.c **** 
 735               		.loc 1 254 0
 736 0010 5D98      		cbi 0xb,5
 256:keyboards/Dactylv2/matrix.c **** 
 737               		.loc 1 256 0
 738 0012 8091 0000 		lds r24,error_count
 739 0016 8F5F      		subi r24,lo8(-(1))
 740 0018 8093 0000 		sts error_count,r24
 258:keyboards/Dactylv2/matrix.c ****             // reset other half if disconnected
 741               		.loc 1 258 0
 742 001c 8630      		cpi r24,lo8(6)
 743 001e 00F0      		brlo .L41
 744               	.LBB59:
 260:keyboards/Dactylv2/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 745               		.loc 1 260 0
 746 0020 8091 0000 		lds r24,isLeftHand
 747 0024 F0E0      		ldi r31,0
 748 0026 E0E0      		ldi r30,0
 749 0028 8823      		tst r24
 750 002a 01F0      		breq .L42
 751 002c E7E0      		ldi r30,lo8(7)
 752 002e F0E0      		ldi r31,0
 753               	.L42:
 754               	.LVL57:
 755 0030 E050      		subi r30,lo8(-(matrix))
 756 0032 F040      		sbci r31,hi8(-(matrix))
 260:keyboards/Dactylv2/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 757               		.loc 1 260 0 is_stmt 0 discriminator 4
 758 0034 87E0      		ldi r24,lo8(7)
 759 0036 90E0      		ldi r25,0
 760               	.LVL58:
 761               	.L43:
 762               	.LBB60:
 262:keyboards/Dactylv2/matrix.c ****             }
 763               		.loc 1 262 0 is_stmt 1 discriminator 3
 764 0038 1192      		st Z+,__zero_reg__
 765 003a 0197      		sbiw r24,1
 261:keyboards/Dactylv2/matrix.c ****                 matrix[slaveOffset+i] = 0;
 766               		.loc 1 261 0 discriminator 3
 767 003c 01F4      		brne .L43
 768               	.L41:
 769               	.LBE60:
 770               	.LBE59:
 270:keyboards/Dactylv2/matrix.c ****     return ret;
 771               		.loc 1 270 0
 772 003e 0E94 0000 		call matrix_scan_quantum
 773               	.LVL59:
 272:keyboards/Dactylv2/matrix.c **** 
 774               		.loc 1 272 0
 775 0042 8C2F      		mov r24,r28
 776               	/* epilogue start */
 777 0044 CF91      		pop r28
 778               	.LVL60:
 779 0046 0895      		ret
 780               	.LVL61:
 781               	.L39:
 267:keyboards/Dactylv2/matrix.c ****         error_count = 0;
 782               		.loc 1 267 0
 783 0048 5D9A      		sbi 0xb,5
 268:keyboards/Dactylv2/matrix.c ****     }
 784               		.loc 1 268 0
 785 004a 1092 0000 		sts error_count,__zero_reg__
 786 004e 00C0      		rjmp .L41
 787               		.cfi_endproc
 788               	.LFE18:
 790               		.section	.text.matrix_slave_scan,"ax",@progbits
 791               	.global	matrix_slave_scan
 793               	matrix_slave_scan:
 794               	.LFB19:
 274:keyboards/Dactylv2/matrix.c ****     _matrix_scan();
 795               		.loc 1 274 0
 796               		.cfi_startproc
 797               	/* prologue: function */
 798               	/* frame size = 0 */
 799               	/* stack size = 0 */
 800               	.L__stack_usage = 0
 275:keyboards/Dactylv2/matrix.c **** 
 801               		.loc 1 275 0
 802 0000 0E94 0000 		call _matrix_scan
 803               	.LVL62:
 277:keyboards/Dactylv2/matrix.c **** 
 804               		.loc 1 277 0
 805 0004 8091 0000 		lds r24,isLeftHand
 806 0008 E7E0      		ldi r30,lo8(7)
 807 000a F0E0      		ldi r31,0
 808 000c 8823      		tst r24
 809 000e 01F0      		breq .L48
 810 0010 F0E0      		ldi r31,0
 811 0012 E0E0      		ldi r30,0
 812               	.L48:
 813               	.LVL63:
 814 0014 E050      		subi r30,lo8(-(matrix))
 815 0016 F040      		sbci r31,hi8(-(matrix))
 816               	.LVL64:
 817               	.LBB61:
 284:keyboards/Dactylv2/matrix.c ****         serial_slave_buffer[i] = matrix[offset+i];
 818               		.loc 1 284 0 discriminator 4
 819 0018 90E0      		ldi r25,0
 820 001a 80E0      		ldi r24,0
 821               	.LVL65:
 822               	.L49:
 285:keyboards/Dactylv2/matrix.c ****     }
 823               		.loc 1 285 0 discriminator 3
 824 001c 2191      		ld r18,Z+
 825 001e DC01      		movw r26,r24
 826 0020 A050      		subi r26,lo8(-(serial_slave_buffer))
 827 0022 B040      		sbci r27,hi8(-(serial_slave_buffer))
 828 0024 2C93      		st X,r18
 284:keyboards/Dactylv2/matrix.c ****         serial_slave_buffer[i] = matrix[offset+i];
 829               		.loc 1 284 0 discriminator 3
 830 0026 0196      		adiw r24,1
 831               	.LVL66:
 832 0028 8730      		cpi r24,7
 833 002a 9105      		cpc r25,__zero_reg__
 834 002c 01F4      		brne .L49
 835               	/* epilogue start */
 836               	.LBE61:
 288:keyboards/Dactylv2/matrix.c **** 
 837               		.loc 1 288 0
 838 002e 0895      		ret
 839               		.cfi_endproc
 840               	.LFE19:
 842               		.section	.text.matrix_is_modified,"ax",@progbits
 843               	.global	matrix_is_modified
 845               	matrix_is_modified:
 846               	.LFB20:
 291:keyboards/Dactylv2/matrix.c ****     if (debouncing) return false;
 847               		.loc 1 291 0
 848               		.cfi_startproc
 849               	/* prologue: function */
 850               	/* frame size = 0 */
 851               	/* stack size = 0 */
 852               	.L__stack_usage = 0
 292:keyboards/Dactylv2/matrix.c ****     return true;
 853               		.loc 1 292 0
 854 0000 9091 0000 		lds r25,debouncing
 294:keyboards/Dactylv2/matrix.c **** 
 855               		.loc 1 294 0
 856 0004 81E0      		ldi r24,lo8(1)
 857 0006 8927      		eor r24,r25
 858               	/* epilogue start */
 859 0008 0895      		ret
 860               		.cfi_endproc
 861               	.LFE20:
 863               		.section	.text.matrix_is_on,"ax",@progbits
 864               	.global	matrix_is_on
 866               	matrix_is_on:
 867               	.LFB21:
 298:keyboards/Dactylv2/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<<col));
 868               		.loc 1 298 0
 869               		.cfi_startproc
 870               	.LVL67:
 871               	/* prologue: function */
 872               	/* frame size = 0 */
 873               	/* stack size = 0 */
 874               	.L__stack_usage = 0
 299:keyboards/Dactylv2/matrix.c **** }
 875               		.loc 1 299 0
 876 0000 E82F      		mov r30,r24
 877 0002 F0E0      		ldi r31,0
 878 0004 E050      		subi r30,lo8(-(matrix))
 879 0006 F040      		sbci r31,hi8(-(matrix))
 880 0008 2081      		ld r18,Z
 881 000a 30E0      		ldi r19,0
 882 000c 81E0      		ldi r24,lo8(1)
 883 000e 90E0      		ldi r25,0
 884               	.LVL68:
 885 0010 00C0      		rjmp 2f
 886               		1:
 887 0012 880F      		lsl r24
 888 0014 991F      		rol r25
 889               		2:
 890 0016 6A95      		dec r22
 891 0018 02F4      		brpl 1b
 892 001a 2823      		and r18,r24
 893 001c 3923      		and r19,r25
 894 001e 81E0      		ldi r24,lo8(1)
 895 0020 232B      		or r18,r19
 896 0022 01F4      		brne .L54
 897 0024 80E0      		ldi r24,0
 898               	.L54:
 899               	/* epilogue start */
 300:keyboards/Dactylv2/matrix.c **** 
 900               		.loc 1 300 0
 901 0026 0895      		ret
 902               		.cfi_endproc
 903               	.LFE21:
 905               		.section	.text.matrix_get_row,"ax",@progbits
 906               	.global	matrix_get_row
 908               	matrix_get_row:
 909               	.LFB22:
 304:keyboards/Dactylv2/matrix.c ****     return matrix[row];
 910               		.loc 1 304 0
 911               		.cfi_startproc
 912               	.LVL69:
 913               	/* prologue: function */
 914               	/* frame size = 0 */
 915               	/* stack size = 0 */
 916               	.L__stack_usage = 0
 305:keyboards/Dactylv2/matrix.c **** }
 917               		.loc 1 305 0
 918 0000 E82F      		mov r30,r24
 919 0002 F0E0      		ldi r31,0
 920 0004 E050      		subi r30,lo8(-(matrix))
 921 0006 F040      		sbci r31,hi8(-(matrix))
 306:keyboards/Dactylv2/matrix.c **** 
 922               		.loc 1 306 0
 923 0008 8081      		ld r24,Z
 924               	.LVL70:
 925               	/* epilogue start */
 926 000a 0895      		ret
 927               		.cfi_endproc
 928               	.LFE22:
 930               		.section	.text.matrix_print,"ax",@progbits
 931               	.global	matrix_print
 933               	matrix_print:
 934               	.LFB23:
 309:keyboards/Dactylv2/matrix.c ****     print("\nr/c 0123456789ABCDEF\n");
 935               		.loc 1 309 0
 936               		.cfi_startproc
 937               	/* prologue: function */
 938               	/* frame size = 0 */
 939               	/* stack size = 0 */
 940               	.L__stack_usage = 0
 941               	.LVL71:
 942               	/* epilogue start */
 316:keyboards/Dactylv2/matrix.c **** 
 943               		.loc 1 316 0
 944 0000 0895      		ret
 945               		.cfi_endproc
 946               	.LFE23:
 948               		.section	.text.matrix_key_count,"ax",@progbits
 949               	.global	matrix_key_count
 951               	matrix_key_count:
 952               	.LFB24:
 319:keyboards/Dactylv2/matrix.c ****     uint8_t count = 0;
 953               		.loc 1 319 0
 954               		.cfi_startproc
 955 0000 0F93      		push r16
 956               	.LCFI19:
 957               		.cfi_def_cfa_offset 3
 958               		.cfi_offset 16, -2
 959 0002 1F93      		push r17
 960               	.LCFI20:
 961               		.cfi_def_cfa_offset 4
 962               		.cfi_offset 17, -3
 963 0004 CF93      		push r28
 964               	.LCFI21:
 965               		.cfi_def_cfa_offset 5
 966               		.cfi_offset 28, -4
 967               	/* prologue: function */
 968               	/* frame size = 0 */
 969               	/* stack size = 3 */
 970               	.L__stack_usage = 3
 971               	.LVL72:
 972 0006 00E0      		ldi r16,lo8(matrix)
 973 0008 10E0      		ldi r17,hi8(matrix)
 320:keyboards/Dactylv2/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 974               		.loc 1 320 0
 975 000a C0E0      		ldi r28,0
 976               	.LVL73:
 977               	.L58:
 978               	.LBB62:
 322:keyboards/Dactylv2/matrix.c ****     }
 979               		.loc 1 322 0 discriminator 3
 980 000c F801      		movw r30,r16
 981 000e 8191      		ld r24,Z+
 982 0010 8F01      		movw r16,r30
 983               	.LVL74:
 984 0012 90E0      		ldi r25,0
 985 0014 0E94 0000 		call bitpop16
 986               	.LVL75:
 987 0018 C80F      		add r28,r24
 988               	.LVL76:
 321:keyboards/Dactylv2/matrix.c ****         count += bitpop16(matrix[i]);
 989               		.loc 1 321 0 discriminator 3
 990 001a F0E0      		ldi r31,hi8(matrix+14)
 991 001c 0030      		cpi r16,lo8(matrix+14)
 992 001e 1F07      		cpc r17,r31
 993 0020 01F4      		brne .L58
 994               	.LBE62:
 325:keyboards/Dactylv2/matrix.c **** 
 995               		.loc 1 325 0
 996 0022 8C2F      		mov r24,r28
 997               	/* epilogue start */
 998 0024 CF91      		pop r28
 999               	.LVL77:
 1000 0026 1F91      		pop r17
 1001 0028 0F91      		pop r16
 1002               	.LVL78:
 1003 002a 0895      		ret
 1004               		.cfi_endproc
 1005               	.LFE24:
 1007               		.section	.bss.matrix,"aw",@nobits
 1010               	matrix:
 1011 0000 0000 0000 		.zero	14
 1011      0000 0000 
 1011      0000 0000 
 1011      0000 
 1012               		.section	.rodata.col_pins,"a",@progbits
 1015               	col_pins:
 1016 0000 35        		.byte	53
 1017 0001 34        		.byte	52
 1018 0002 C6        		.byte	-58
 1019 0003 97        		.byte	-105
 1020 0004 66        		.byte	102
 1021 0005 94        		.byte	-108
 1022               		.section	.rodata.row_pins,"a",@progbits
 1025               	row_pins:
 1026 0000 36        		.byte	54
 1027 0001 32        		.byte	50
 1028 0002 33        		.byte	51
 1029 0003 31        		.byte	49
 1030 0004 F7        		.byte	-9
 1031 0005 F6        		.byte	-10
 1032 0006 F5        		.byte	-11
 1033 0007 0000 0000 		.zero	7
 1033      0000 00
 1034               		.section	.bss.error_count,"aw",@nobits
 1037               	error_count:
 1038 0000 00        		.zero	1
 1039               		.section	.bss.matrix_debouncing,"aw",@nobits
 1042               	matrix_debouncing:
 1043 0000 0000 0000 		.zero	14
 1043      0000 0000 
 1043      0000 0000 
 1043      0000 
 1044               		.section	.bss.debouncing,"aw",@nobits
 1047               	debouncing:
 1048 0000 00        		.zero	1
 1049               		.section	.bss.debouncing_time,"aw",@nobits
 1052               	debouncing_time:
 1053 0000 0000      		.zero	2
 1054               		.text
 1055               	.Letext0:
 1056               		.file 3 "/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/stdint.h"
 1057               		.file 4 "./tmk_core/common/debug.h"
 1058               		.file 5 "./tmk_core/common/matrix.h"
 1059               		.file 6 "keyboards/Dactylv2/split_util.h"
 1060               		.file 7 "./drivers/avr/pro_micro.h"
 1061               		.file 8 "./tmk_core/common/timer.h"
 1062               		.file 9 "keyboards/Dactylv2/serial.h"
 1063               		.file 10 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:4      *ABS*:000000000000003f __SREG__
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user.localalias.0
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:32     .text.matrix_init_kb:0000000000000000 matrix_init_kb
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:49     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:66     .text.matrix_scan_user:0000000000000000 matrix_scan_user
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:81     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:98     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:115    .text.matrix_rows:0000000000000000 matrix_rows
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:133    .text.matrix_cols:0000000000000000 matrix_cols
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:151    .text.matrix_init:0000000000000000 matrix_init
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:1025   .rodata.row_pins:0000000000000000 row_pins
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:1015   .rodata.col_pins:0000000000000000 col_pins
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:1010   .bss.matrix:0000000000000000 matrix
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:1042   .bss.matrix_debouncing:0000000000000000 matrix_debouncing
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:293    .text._matrix_scan:0000000000000000 _matrix_scan
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:1047   .bss.debouncing:0000000000000000 debouncing
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:1052   .bss.debouncing_time:0000000000000000 debouncing_time
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:640    .text.serial_transaction:0000000000000000 serial_transaction
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:713    .text.matrix_scan:0000000000000000 matrix_scan
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:1037   .bss.error_count:0000000000000000 error_count
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:793    .text.matrix_slave_scan:0000000000000000 matrix_slave_scan
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:845    .text.matrix_is_modified:0000000000000000 matrix_is_modified
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:866    .text.matrix_is_on:0000000000000000 matrix_is_on
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:908    .text.matrix_get_row:0000000000000000 matrix_get_row
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:933    .text.matrix_print:0000000000000000 matrix_print
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cciNv2y0.s:951    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
isLeftHand
timer_read
timer_elapsed
serial_update_buffers
serial_slave_buffer
bitpop16
__do_copy_data
__do_clear_bss
