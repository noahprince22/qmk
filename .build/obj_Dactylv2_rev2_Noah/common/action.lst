   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "./tmk_core/common/action.c"
   1:./tmk_core/common/action.c **** /*
   2:./tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action.c **** 
   4:./tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action.c **** (at your option) any later version.
   8:./tmk_core/common/action.c **** 
   9:./tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action.c **** GNU General Public License for more details.
  13:./tmk_core/common/action.c **** 
  14:./tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action.c **** */
  17:./tmk_core/common/action.c **** #include "host.h"
  18:./tmk_core/common/action.c **** #include "keycode.h"
  19:./tmk_core/common/action.c **** #include "keyboard.h"
  20:./tmk_core/common/action.c **** #include "mousekey.h"
  21:./tmk_core/common/action.c **** #include "command.h"
  22:./tmk_core/common/action.c **** #include "led.h"
  23:./tmk_core/common/action.c **** #include "backlight.h"
  24:./tmk_core/common/action.c **** #include "action_layer.h"
  25:./tmk_core/common/action.c **** #include "action_tapping.h"
  26:./tmk_core/common/action.c **** #include "action_macro.h"
  27:./tmk_core/common/action.c **** #include "action_util.h"
  28:./tmk_core/common/action.c **** #include "action.h"
  29:./tmk_core/common/action.c **** #include "wait.h"
  30:./tmk_core/common/action.c **** 
  31:./tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:./tmk_core/common/action.c **** #include "debug.h"
  33:./tmk_core/common/action.c **** #else
  34:./tmk_core/common/action.c **** #include "nodebug.h"
  35:./tmk_core/common/action.c **** #endif
  36:./tmk_core/common/action.c **** 
  37:./tmk_core/common/action.c **** int tp_buttons;
  38:./tmk_core/common/action.c **** 
  39:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:./tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:./tmk_core/common/action.c **** #endif
  42:./tmk_core/common/action.c **** 
  43:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:./tmk_core/common/action.c **** #include <fauxclicky.h>
  45:./tmk_core/common/action.c **** #endif
  46:./tmk_core/common/action.c **** 
  47:./tmk_core/common/action.c **** /** \brief Called to execute an action.
  48:./tmk_core/common/action.c ****  *
  49:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
  50:./tmk_core/common/action.c ****  */
  51:./tmk_core/common/action.c **** void action_exec(keyevent_t event)
  52:./tmk_core/common/action.c **** {
  16               		.loc 1 52 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  53:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  54:./tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  55:./tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  56:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  57:./tmk_core/common/action.c ****         retro_tapping_counter++;
  58:./tmk_core/common/action.c **** #endif
  59:./tmk_core/common/action.c ****     }
  60:./tmk_core/common/action.c **** 
  61:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  62:./tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  63:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  64:./tmk_core/common/action.c ****     }
  65:./tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  66:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  67:./tmk_core/common/action.c ****     }
  68:./tmk_core/common/action.c ****     fauxclicky_check();
  69:./tmk_core/common/action.c **** #endif
  70:./tmk_core/common/action.c **** 
  71:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  72:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  73:./tmk_core/common/action.c ****         process_hand_swap(&event);
  74:./tmk_core/common/action.c ****     }
  75:./tmk_core/common/action.c **** #endif
  76:./tmk_core/common/action.c **** 
  77:./tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  48               		.loc 1 77 0
  49 001e DE01      		movw r26,r28
  50 0020 1196      		adiw r26,1
  51 0022 86E0      		ldi r24,lo8(6)
  52 0024 FD01      		movw r30,r26
  53               		0:
  54 0026 1192      		st Z+,__zero_reg__
  55 0028 8A95      		dec r24
  56 002a 01F4      		brne 0b
  57 002c 85E0      		ldi r24,lo8(5)
  58 002e FE01      		movw r30,r28
  59 0030 3796      		adiw r30,7
  60               		0:
  61 0032 0190      		ld r0,Z+
  62 0034 0D92      		st X+,r0
  63 0036 8A95      		dec r24
  64 0038 01F4      		brne 0b
  78:./tmk_core/common/action.c **** 
  79:./tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  80:./tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  81:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  82:./tmk_core/common/action.c ****     }
  83:./tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  84:./tmk_core/common/action.c ****         clear_oneshot_mods();
  85:./tmk_core/common/action.c ****     }
  86:./tmk_core/common/action.c **** #endif
  87:./tmk_core/common/action.c **** 
  88:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  89:./tmk_core/common/action.c ****     action_tapping_process(record);
  65               		.loc 1 89 0
  66 003a 4981      		ldd r20,Y+1
  67               	.LVL1:
  68 003c 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70 003e 6B81      		ldd r22,Y+3
  71 0040 7C81      		ldd r23,Y+4
  72 0042 8D81      		ldd r24,Y+5
  73 0044 9E81      		ldd r25,Y+6
  74 0046 0E94 0000 		call action_tapping_process
  75               	.LVL3:
  76               	/* epilogue start */
  90:./tmk_core/common/action.c **** #else
  91:./tmk_core/common/action.c ****     process_record(&record);
  92:./tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  93:./tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
  94:./tmk_core/common/action.c ****     }
  95:./tmk_core/common/action.c **** #endif
  96:./tmk_core/common/action.c **** }
  77               		.loc 1 96 0
  78 004a 2B96      		adiw r28,11
  79 004c 0FB6      		in __tmp_reg__,__SREG__
  80 004e F894      		cli
  81 0050 DEBF      		out __SP_H__,r29
  82 0052 0FBE      		out __SREG__,__tmp_reg__
  83 0054 CDBF      		out __SP_L__,r28
  84 0056 DF91      		pop r29
  85 0058 CF91      		pop r28
  86 005a 0895      		ret
  87               		.cfi_endproc
  88               	.LFE13:
  90               		.section	.text.process_record_quantum,"ax",@progbits
  91               		.weak	process_record_quantum
  93               	process_record_quantum:
  94               	.LFB15:
  97:./tmk_core/common/action.c **** 
  98:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  99:./tmk_core/common/action.c **** bool swap_hands = false;
 100:./tmk_core/common/action.c **** bool swap_held = false;
 101:./tmk_core/common/action.c **** 
 102:./tmk_core/common/action.c **** /** \brief Process Hand Swap
 103:./tmk_core/common/action.c ****  *
 104:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 105:./tmk_core/common/action.c ****  */
 106:./tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 107:./tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 108:./tmk_core/common/action.c **** 
 109:./tmk_core/common/action.c ****     keypos_t pos = event->key;
 110:./tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1<<pos.col;
 111:./tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
 112:./tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 113:./tmk_core/common/action.c **** 
 114:./tmk_core/common/action.c ****     if (do_swap) {
 115:./tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 116:./tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 117:./tmk_core/common/action.c ****     } else {
 118:./tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 119:./tmk_core/common/action.c ****     }
 120:./tmk_core/common/action.c **** }
 121:./tmk_core/common/action.c **** #endif
 122:./tmk_core/common/action.c **** 
 123:./tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 124:./tmk_core/common/action.c **** bool disable_action_cache = false;
 125:./tmk_core/common/action.c **** 
 126:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 127:./tmk_core/common/action.c **** {
 128:./tmk_core/common/action.c ****     disable_action_cache = true;
 129:./tmk_core/common/action.c ****     process_record(record);
 130:./tmk_core/common/action.c ****     disable_action_cache = false;
 131:./tmk_core/common/action.c **** }
 132:./tmk_core/common/action.c **** #else
 133:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 134:./tmk_core/common/action.c **** {
 135:./tmk_core/common/action.c ****     process_record(record);
 136:./tmk_core/common/action.c **** }
 137:./tmk_core/common/action.c **** #endif
 138:./tmk_core/common/action.c **** 
 139:./tmk_core/common/action.c **** __attribute__ ((weak))
 140:./tmk_core/common/action.c **** bool process_record_quantum(keyrecord_t *record) {
  95               		.loc 1 140 0
  96               		.cfi_startproc
  97               	.LVL4:
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 0 */
 101               	.L__stack_usage = 0
 141:./tmk_core/common/action.c ****     return true;
 142:./tmk_core/common/action.c **** }
 102               		.loc 1 142 0
 103 0000 81E0      		ldi r24,lo8(1)
 104               	.LVL5:
 105 0002 0895      		ret
 106               		.cfi_endproc
 107               	.LFE15:
 109               		.section	.text.process_record_tap_hint,"ax",@progbits
 110               	.global	process_record_tap_hint
 112               	process_record_tap_hint:
 113               	.LFB16:
 143:./tmk_core/common/action.c **** 
 144:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 145:./tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 146:./tmk_core/common/action.c ****  *
 147:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 148:./tmk_core/common/action.c ****  */
 149:./tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record)
 150:./tmk_core/common/action.c **** {
 114               		.loc 1 150 0
 115               		.cfi_startproc
 116               	.LVL6:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 151:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 121               		.loc 1 151 0
 122 0000 FC01      		movw r30,r24
 123 0002 8081      		ld r24,Z
 124 0004 9181      		ldd r25,Z+1
 125               	.LVL7:
 126 0006 0E94 0000 		call layer_switch_get_action
 127               	.LVL8:
 128 000a 0895      		ret
 129               		.cfi_endproc
 130               	.LFE16:
 132               		.section	.text.register_code,"ax",@progbits
 133               	.global	register_code
 135               	register_code:
 136               	.LFB19:
 152:./tmk_core/common/action.c **** 
 153:./tmk_core/common/action.c ****     switch (action.kind.id) {
 154:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 155:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 156:./tmk_core/common/action.c ****             switch (action.swap.code) {
 157:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 158:./tmk_core/common/action.c ****                 default:
 159:./tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 160:./tmk_core/common/action.c ****                     swap_held = true;
 161:./tmk_core/common/action.c ****             }
 162:./tmk_core/common/action.c ****             break;
 163:./tmk_core/common/action.c **** #endif
 164:./tmk_core/common/action.c ****     }
 165:./tmk_core/common/action.c **** }
 166:./tmk_core/common/action.c **** #endif
 167:./tmk_core/common/action.c **** 
 168:./tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 169:./tmk_core/common/action.c ****  *
 170:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 171:./tmk_core/common/action.c ****  */
 172:./tmk_core/common/action.c **** void process_record(keyrecord_t *record)
 173:./tmk_core/common/action.c **** {
 174:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 175:./tmk_core/common/action.c **** 
 176:./tmk_core/common/action.c ****     if(!process_record_quantum(record))
 177:./tmk_core/common/action.c ****         return;
 178:./tmk_core/common/action.c **** 
 179:./tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 180:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 181:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 182:./tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 183:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 184:./tmk_core/common/action.c **** #endif
 185:./tmk_core/common/action.c ****     dprintln();
 186:./tmk_core/common/action.c **** 
 187:./tmk_core/common/action.c ****     process_action(record, action);
 188:./tmk_core/common/action.c **** }
 189:./tmk_core/common/action.c **** 
 190:./tmk_core/common/action.c **** /** \brief Take an action and processes it.
 191:./tmk_core/common/action.c ****  *
 192:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 193:./tmk_core/common/action.c ****  */
 194:./tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action)
 195:./tmk_core/common/action.c **** {
 196:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 197:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 198:./tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 199:./tmk_core/common/action.c **** #endif
 200:./tmk_core/common/action.c **** 
 201:./tmk_core/common/action.c ****     if (event.pressed) {
 202:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 203:./tmk_core/common/action.c ****         clear_weak_mods();
 204:./tmk_core/common/action.c ****     }
 205:./tmk_core/common/action.c **** 
 206:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 207:./tmk_core/common/action.c ****     bool do_release_oneshot = false;
 208:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 209:./tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 210:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 211:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 212:./tmk_core/common/action.c ****     }
 213:./tmk_core/common/action.c **** #endif
 214:./tmk_core/common/action.c **** 
 215:./tmk_core/common/action.c ****     switch (action.kind.id) {
 216:./tmk_core/common/action.c ****         /* Key and Mods */
 217:./tmk_core/common/action.c ****         case ACT_LMODS:
 218:./tmk_core/common/action.c ****         case ACT_RMODS:
 219:./tmk_core/common/action.c ****             {
 220:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 221:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 222:./tmk_core/common/action.c ****                 if (event.pressed) {
 223:./tmk_core/common/action.c ****                     if (mods) {
 224:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 225:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 226:./tmk_core/common/action.c ****                             // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSF
 227:./tmk_core/common/action.c ****                             // Same applies for some keys like KC_MEH which are declared as MEH(KC_
 228:./tmk_core/common/action.c ****                             add_mods(mods);
 229:./tmk_core/common/action.c ****                         } else {
 230:./tmk_core/common/action.c ****                             add_weak_mods(mods);
 231:./tmk_core/common/action.c ****                         }
 232:./tmk_core/common/action.c ****                         send_keyboard_report();
 233:./tmk_core/common/action.c ****                     }
 234:./tmk_core/common/action.c ****                     register_code(action.key.code);
 235:./tmk_core/common/action.c ****                 } else {
 236:./tmk_core/common/action.c ****                     unregister_code(action.key.code);
 237:./tmk_core/common/action.c ****                     if (mods) {
 238:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 239:./tmk_core/common/action.c ****                             del_mods(mods);
 240:./tmk_core/common/action.c ****                         } else {
 241:./tmk_core/common/action.c ****                             del_weak_mods(mods);
 242:./tmk_core/common/action.c ****                         }
 243:./tmk_core/common/action.c ****                         send_keyboard_report();
 244:./tmk_core/common/action.c ****                     }
 245:./tmk_core/common/action.c ****                 }
 246:./tmk_core/common/action.c ****             }
 247:./tmk_core/common/action.c ****             break;
 248:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 249:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 250:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 251:./tmk_core/common/action.c ****             {
 252:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 253:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 254:./tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 255:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 256:./tmk_core/common/action.c ****                     case MODS_ONESHOT:
 257:./tmk_core/common/action.c ****                         // Oneshot modifier
 258:./tmk_core/common/action.c ****                         if (event.pressed) {
 259:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 260:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 261:./tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 262:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 263:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 264:./tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 265:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 266:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 267:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Toggling oneshot");
 268:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 269:./tmk_core/common/action.c ****                                 set_oneshot_locked_mods(mods);
 270:./tmk_core/common/action.c ****                                 register_mods(mods);
 271:./tmk_core/common/action.c ****                     #endif
 272:./tmk_core/common/action.c ****                             } else {
 273:./tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 274:./tmk_core/common/action.c ****                             }
 275:./tmk_core/common/action.c ****                         } else {
 276:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 277:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 278:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 279:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 280:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 281:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 282:./tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 283:./tmk_core/common/action.c ****                                     clear_oneshot_locked_mods();
 284:./tmk_core/common/action.c ****                                     clear_oneshot_mods();
 285:./tmk_core/common/action.c ****                                     unregister_mods(mods);
 286:./tmk_core/common/action.c ****                                 }
 287:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 288:./tmk_core/common/action.c ****                                 // Toggle Oneshot Layer
 289:./tmk_core/common/action.c ****                     #endif
 290:./tmk_core/common/action.c ****                             } else {
 291:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 292:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 293:./tmk_core/common/action.c ****                             }
 294:./tmk_core/common/action.c ****                         }
 295:./tmk_core/common/action.c ****                         break;
 296:./tmk_core/common/action.c ****     #endif
 297:./tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 298:./tmk_core/common/action.c ****                         if (event.pressed) {
 299:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 300:./tmk_core/common/action.c ****                                 register_mods(mods);
 301:./tmk_core/common/action.c ****                             }
 302:./tmk_core/common/action.c ****                         } else {
 303:./tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 304:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 305:./tmk_core/common/action.c ****                             }
 306:./tmk_core/common/action.c ****                         }
 307:./tmk_core/common/action.c ****                         break;
 308:./tmk_core/common/action.c ****                     default:
 309:./tmk_core/common/action.c ****                         if (event.pressed) {
 310:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 311:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 312:./tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 313:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 314:./tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 315:./tmk_core/common/action.c ****                                     record->tap.count = 0;
 316:./tmk_core/common/action.c ****                                     register_mods(mods);
 317:./tmk_core/common/action.c ****                                 } else
 318:./tmk_core/common/action.c **** #endif
 319:./tmk_core/common/action.c ****                                 {
 320:./tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 321:./tmk_core/common/action.c ****                                     register_code(action.key.code);
 322:./tmk_core/common/action.c ****                                 }
 323:./tmk_core/common/action.c ****                             } else {
 324:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 325:./tmk_core/common/action.c ****                                 register_mods(mods);
 326:./tmk_core/common/action.c ****                             }
 327:./tmk_core/common/action.c ****                         } else {
 328:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 329:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 330:./tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 331:./tmk_core/common/action.c ****                             } else {
 332:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 333:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 334:./tmk_core/common/action.c ****                             }
 335:./tmk_core/common/action.c ****                         }
 336:./tmk_core/common/action.c ****                         break;
 337:./tmk_core/common/action.c ****                 }
 338:./tmk_core/common/action.c ****             }
 339:./tmk_core/common/action.c ****             break;
 340:./tmk_core/common/action.c **** #endif
 341:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 342:./tmk_core/common/action.c ****         /* other HID usage */
 343:./tmk_core/common/action.c ****         case ACT_USAGE:
 344:./tmk_core/common/action.c ****             switch (action.usage.page) {
 345:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 346:./tmk_core/common/action.c ****                     if (event.pressed) {
 347:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 348:./tmk_core/common/action.c ****                     } else {
 349:./tmk_core/common/action.c ****                         host_system_send(0);
 350:./tmk_core/common/action.c ****                     }
 351:./tmk_core/common/action.c ****                     break;
 352:./tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 353:./tmk_core/common/action.c ****                     if (event.pressed) {
 354:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 355:./tmk_core/common/action.c ****                     } else {
 356:./tmk_core/common/action.c ****                         host_consumer_send(0);
 357:./tmk_core/common/action.c ****                     }
 358:./tmk_core/common/action.c ****                     break;
 359:./tmk_core/common/action.c ****             }
 360:./tmk_core/common/action.c ****             break;
 361:./tmk_core/common/action.c **** #endif
 362:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 363:./tmk_core/common/action.c ****         /* Mouse key */
 364:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 365:./tmk_core/common/action.c ****             if (event.pressed) {
 366:./tmk_core/common/action.c ****                 switch (action.key.code) {
 367:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 368:./tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 369:./tmk_core/common/action.c ****                         break;
 370:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 371:./tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 372:./tmk_core/common/action.c ****                         break;
 373:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 374:./tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 375:./tmk_core/common/action.c ****                         break;
 376:./tmk_core/common/action.c ****                     default:
 377:./tmk_core/common/action.c ****                         break;
 378:./tmk_core/common/action.c ****                 }
 379:./tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 380:./tmk_core/common/action.c ****                 mousekey_send();
 381:./tmk_core/common/action.c ****             } else {
 382:./tmk_core/common/action.c ****                 switch (action.key.code) {
 383:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 384:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 385:./tmk_core/common/action.c ****                         break;
 386:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 387:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 388:./tmk_core/common/action.c ****                         break;
 389:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 390:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 391:./tmk_core/common/action.c ****                         break;
 392:./tmk_core/common/action.c ****                     default:
 393:./tmk_core/common/action.c ****                         break;
 394:./tmk_core/common/action.c ****                 }
 395:./tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 396:./tmk_core/common/action.c ****                 mousekey_send();
 397:./tmk_core/common/action.c ****             }
 398:./tmk_core/common/action.c ****             break;
 399:./tmk_core/common/action.c **** #endif
 400:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 401:./tmk_core/common/action.c ****         case ACT_LAYER:
 402:./tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 403:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 404:./tmk_core/common/action.c ****                 if (!event.pressed) {
 405:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 406:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 407:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 408:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 409:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 410:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 411:./tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 412:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 413:./tmk_core/common/action.c ****                     }
 414:./tmk_core/common/action.c ****                 }
 415:./tmk_core/common/action.c ****             } else {
 416:./tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 417:./tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 418:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 419:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 420:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 421:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 422:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 423:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 424:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 425:./tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 426:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 427:./tmk_core/common/action.c ****                     }
 428:./tmk_core/common/action.c ****                 }
 429:./tmk_core/common/action.c ****             }
 430:./tmk_core/common/action.c ****             break;
 431:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 432:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 433:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 434:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 435:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 436:./tmk_core/common/action.c ****                     /* layer On/Off with modifiers(left only) */
 437:./tmk_core/common/action.c ****                     if (event.pressed) {
 438:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 439:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 440:./tmk_core/common/action.c ****                     } else {
 441:./tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 442:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 443:./tmk_core/common/action.c ****                     }
 444:./tmk_core/common/action.c ****                     break;
 445:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 446:./tmk_core/common/action.c ****                     /* tap toggle */
 447:./tmk_core/common/action.c ****                     if (event.pressed) {
 448:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 449:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 450:./tmk_core/common/action.c ****                         }
 451:./tmk_core/common/action.c ****                     } else {
 452:./tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 453:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 454:./tmk_core/common/action.c ****                         }
 455:./tmk_core/common/action.c ****                     }
 456:./tmk_core/common/action.c ****                     break;
 457:./tmk_core/common/action.c ****                 case OP_ON_OFF:
 458:./tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 459:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 460:./tmk_core/common/action.c ****                     break;
 461:./tmk_core/common/action.c ****                 case OP_OFF_ON:
 462:./tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 463:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 464:./tmk_core/common/action.c ****                     break;
 465:./tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 466:./tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 467:./tmk_core/common/action.c ****                                     layer_clear();
 468:./tmk_core/common/action.c ****                     break;
 469:./tmk_core/common/action.c ****             #ifndef NO_ACTION_ONESHOT
 470:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 471:./tmk_core/common/action.c ****                     // Oneshot modifier
 472:./tmk_core/common/action.c ****                 #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 473:./tmk_core/common/action.c ****                     do_release_oneshot = false;
 474:./tmk_core/common/action.c ****                     if (event.pressed) {
 475:./tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 476:./tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 477:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 478:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 479:./tmk_core/common/action.c ****                             break;
 480:./tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 481:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 482:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 483:./tmk_core/common/action.c ****                         }
 484:./tmk_core/common/action.c ****                     } else {
 485:./tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 486:./tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 487:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 488:./tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 489:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 490:./tmk_core/common/action.c ****                         } else {
 491:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 492:./tmk_core/common/action.c ****                         }
 493:./tmk_core/common/action.c ****                     }
 494:./tmk_core/common/action.c ****                 #else
 495:./tmk_core/common/action.c ****                     if (event.pressed) {
 496:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 497:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 498:./tmk_core/common/action.c ****                     } else {
 499:./tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 500:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 501:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 502:./tmk_core/common/action.c ****                         }
 503:./tmk_core/common/action.c ****                     }
 504:./tmk_core/common/action.c ****                 #endif
 505:./tmk_core/common/action.c ****                     break;
 506:./tmk_core/common/action.c ****             #endif
 507:./tmk_core/common/action.c ****                 default:
 508:./tmk_core/common/action.c ****                     /* tap key */
 509:./tmk_core/common/action.c ****                     if (event.pressed) {
 510:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 511:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 512:./tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 513:./tmk_core/common/action.c ****                         } else {
 514:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 515:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 516:./tmk_core/common/action.c ****                         }
 517:./tmk_core/common/action.c ****                     } else {
 518:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 519:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 520:./tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 521:./tmk_core/common/action.c ****                                 wait_ms(80);
 522:./tmk_core/common/action.c ****                             }
 523:./tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 524:./tmk_core/common/action.c ****                         } else {
 525:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 526:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 527:./tmk_core/common/action.c ****                         }
 528:./tmk_core/common/action.c ****                     }
 529:./tmk_core/common/action.c ****                     break;
 530:./tmk_core/common/action.c ****             }
 531:./tmk_core/common/action.c ****             break;
 532:./tmk_core/common/action.c ****     #endif
 533:./tmk_core/common/action.c **** #endif
 534:./tmk_core/common/action.c ****         /* Extentions */
 535:./tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 536:./tmk_core/common/action.c ****         case ACT_MACRO:
 537:./tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 538:./tmk_core/common/action.c ****             break;
 539:./tmk_core/common/action.c **** #endif
 540:./tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
 541:./tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 542:./tmk_core/common/action.c ****             if (!event.pressed) {
 543:./tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 544:./tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 545:./tmk_core/common/action.c ****                         backlight_increase();
 546:./tmk_core/common/action.c ****                         break;
 547:./tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 548:./tmk_core/common/action.c ****                         backlight_decrease();
 549:./tmk_core/common/action.c ****                         break;
 550:./tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 551:./tmk_core/common/action.c ****                         backlight_toggle();
 552:./tmk_core/common/action.c ****                         break;
 553:./tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 554:./tmk_core/common/action.c ****                         backlight_step();
 555:./tmk_core/common/action.c ****                         break;
 556:./tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 557:./tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 558:./tmk_core/common/action.c ****                         break;
 559:./tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 560:./tmk_core/common/action.c ****                         backlight_level(0);
 561:./tmk_core/common/action.c ****                         break;
 562:./tmk_core/common/action.c ****                 }
 563:./tmk_core/common/action.c ****             }
 564:./tmk_core/common/action.c ****             break;
 565:./tmk_core/common/action.c **** #endif
 566:./tmk_core/common/action.c ****         case ACT_COMMAND:
 567:./tmk_core/common/action.c ****             break;
 568:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 569:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 570:./tmk_core/common/action.c ****             switch (action.swap.code) {
 571:./tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 572:./tmk_core/common/action.c ****                     if (event.pressed) {
 573:./tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 574:./tmk_core/common/action.c ****                     }
 575:./tmk_core/common/action.c ****                     break;
 576:./tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 577:./tmk_core/common/action.c ****                     swap_hands = event.pressed;
 578:./tmk_core/common/action.c ****                     break;
 579:./tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 580:./tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 581:./tmk_core/common/action.c ****                     break;
 582:./tmk_core/common/action.c ****                 case OP_SH_ON:
 583:./tmk_core/common/action.c ****                     if (!event.pressed) {
 584:./tmk_core/common/action.c ****                         swap_hands = true;
 585:./tmk_core/common/action.c ****                     }
 586:./tmk_core/common/action.c ****                     break;
 587:./tmk_core/common/action.c ****                 case OP_SH_OFF:
 588:./tmk_core/common/action.c ****                     if (!event.pressed) {
 589:./tmk_core/common/action.c ****                         swap_hands = false;
 590:./tmk_core/common/action.c ****                     }
 591:./tmk_core/common/action.c ****                     break;
 592:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 593:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 594:./tmk_core/common/action.c ****                     /* tap toggle */
 595:./tmk_core/common/action.c **** 
 596:./tmk_core/common/action.c ****                     if (event.pressed) {
 597:./tmk_core/common/action.c ****                         if (swap_held) {
 598:./tmk_core/common/action.c ****                             swap_held = false;
 599:./tmk_core/common/action.c ****                         } else {
 600:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 601:./tmk_core/common/action.c ****                         }
 602:./tmk_core/common/action.c ****                     } else {
 603:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 604:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 605:./tmk_core/common/action.c ****                         }
 606:./tmk_core/common/action.c ****                     }
 607:./tmk_core/common/action.c ****                     break;
 608:./tmk_core/common/action.c ****                 default:
 609:./tmk_core/common/action.c ****                     /* tap key */
 610:./tmk_core/common/action.c ****                     if (tap_count > 0) {
 611:./tmk_core/common/action.c ****                         if (swap_held) {
 612:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 613:./tmk_core/common/action.c ****                             swap_held = false;
 614:./tmk_core/common/action.c ****                         }
 615:./tmk_core/common/action.c ****                         if (event.pressed) {
 616:./tmk_core/common/action.c ****                             register_code(action.swap.code);
 617:./tmk_core/common/action.c ****                         } else {
 618:./tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 619:./tmk_core/common/action.c ****                             *record = (keyrecord_t){}; // hack: reset tap mode
 620:./tmk_core/common/action.c ****                         }
 621:./tmk_core/common/action.c ****                     } else {
 622:./tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 623:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 624:./tmk_core/common/action.c ****                             swap_held = false;
 625:./tmk_core/common/action.c ****                         }
 626:./tmk_core/common/action.c ****                     }
 627:./tmk_core/common/action.c ****     #endif
 628:./tmk_core/common/action.c ****             }
 629:./tmk_core/common/action.c **** #endif
 630:./tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 631:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 632:./tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 633:./tmk_core/common/action.c ****             break;
 634:./tmk_core/common/action.c **** #endif
 635:./tmk_core/common/action.c ****         default:
 636:./tmk_core/common/action.c ****             break;
 637:./tmk_core/common/action.c ****     }
 638:./tmk_core/common/action.c **** 
 639:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 640:./tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 641:./tmk_core/common/action.c ****     switch (action.kind.id) {
 642:./tmk_core/common/action.c ****         case ACT_LAYER:
 643:./tmk_core/common/action.c ****         #ifndef NO_ACTION_TAPPING
 644:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 645:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 646:./tmk_core/common/action.c ****         #endif
 647:./tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 648:./tmk_core/common/action.c ****             break;
 649:./tmk_core/common/action.c ****         default:
 650:./tmk_core/common/action.c ****             break;
 651:./tmk_core/common/action.c ****     }
 652:./tmk_core/common/action.c **** #endif
 653:./tmk_core/common/action.c **** 
 654:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 655:./tmk_core/common/action.c ****   #ifdef RETRO_TAPPING
 656:./tmk_core/common/action.c ****   if (!is_tap_key(record->event.key)) {
 657:./tmk_core/common/action.c ****     retro_tapping_counter = 0;
 658:./tmk_core/common/action.c ****   } else {
 659:./tmk_core/common/action.c ****     if (event.pressed) {
 660:./tmk_core/common/action.c ****         if (tap_count > 0) {
 661:./tmk_core/common/action.c ****           retro_tapping_counter = 0;
 662:./tmk_core/common/action.c ****         } else {
 663:./tmk_core/common/action.c **** 
 664:./tmk_core/common/action.c ****         }
 665:./tmk_core/common/action.c ****     } else {
 666:./tmk_core/common/action.c ****       if (tap_count > 0) {
 667:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 668:./tmk_core/common/action.c ****       } else {
 669:./tmk_core/common/action.c ****         if (retro_tapping_counter == 2) {
 670:./tmk_core/common/action.c ****           register_code(action.layer_tap.code);
 671:./tmk_core/common/action.c ****           unregister_code(action.layer_tap.code);
 672:./tmk_core/common/action.c ****         }
 673:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 674:./tmk_core/common/action.c ****       }
 675:./tmk_core/common/action.c ****     }
 676:./tmk_core/common/action.c ****   }
 677:./tmk_core/common/action.c ****   #endif
 678:./tmk_core/common/action.c **** #endif
 679:./tmk_core/common/action.c **** 
 680:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 681:./tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 682:./tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 683:./tmk_core/common/action.c ****      */
 684:./tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 685:./tmk_core/common/action.c ****         record->event.pressed = false;
 686:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 687:./tmk_core/common/action.c ****         process_record(record);
 688:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 689:./tmk_core/common/action.c ****     }
 690:./tmk_core/common/action.c **** #endif
 691:./tmk_core/common/action.c **** }
 692:./tmk_core/common/action.c **** 
 693:./tmk_core/common/action.c **** 
 694:./tmk_core/common/action.c **** 
 695:./tmk_core/common/action.c **** 
 696:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 697:./tmk_core/common/action.c ****  *
 698:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 699:./tmk_core/common/action.c ****  */
 700:./tmk_core/common/action.c **** void register_code(uint8_t code)
 701:./tmk_core/common/action.c **** {
 137               		.loc 1 701 0
 138               		.cfi_startproc
 139               	.LVL9:
 140 0000 CF93      		push r28
 141               	.LCFI4:
 142               		.cfi_def_cfa_offset 3
 143               		.cfi_offset 28, -2
 144               	/* prologue: function */
 145               	/* frame size = 0 */
 146               	/* stack size = 1 */
 147               	.L__stack_usage = 1
 702:./tmk_core/common/action.c ****     if (code == KC_NO) {
 148               		.loc 1 702 0
 149 0002 8823      		tst r24
 150 0004 01F4      		brne .+2
 151 0006 00C0      		rjmp .L4
 152 0008 C82F      		mov r28,r24
 703:./tmk_core/common/action.c ****         return;
 704:./tmk_core/common/action.c ****     }
 705:./tmk_core/common/action.c **** 
 706:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 707:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 153               		.loc 1 707 0
 154 000a 8238      		cpi r24,lo8(-126)
 155 000c 01F4      		brne .L7
 708:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 709:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 710:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 156               		.loc 1 710 0
 157 000e 0E94 0000 		call host_keyboard_leds
 158               	.LVL10:
 159 0012 81FD      		sbrc r24,1
 160 0014 00C0      		rjmp .L4
 161               	.LVL11:
 162               	.LBB44:
 163               	.LBB45:
 164               		.file 2 "./tmk_core/common/action_util.h"
   1:./tmk_core/common/action_util.h **** /*
   2:./tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action_util.h **** 
   4:./tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action_util.h **** (at your option) any later version.
   8:./tmk_core/common/action_util.h **** 
   9:./tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:./tmk_core/common/action_util.h **** 
  14:./tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action_util.h **** */
  17:./tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:./tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:./tmk_core/common/action_util.h **** 
  20:./tmk_core/common/action_util.h **** #include <stdint.h>
  21:./tmk_core/common/action_util.h **** #include "report.h"
  22:./tmk_core/common/action_util.h **** 
  23:./tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:./tmk_core/common/action_util.h **** extern "C" {
  25:./tmk_core/common/action_util.h **** #endif
  26:./tmk_core/common/action_util.h **** 
  27:./tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:./tmk_core/common/action_util.h **** 
  29:./tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:./tmk_core/common/action_util.h **** 
  31:./tmk_core/common/action_util.h **** /* key */
  32:./tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 165               		.loc 2 33 0
 166 0016 69E3      		ldi r22,lo8(57)
 167 0018 8091 0000 		lds r24,keyboard_report
 168 001c 9091 0000 		lds r25,keyboard_report+1
 169 0020 0E94 0000 		call add_key_to_report
 170               	.LVL12:
 171               	.LBE45:
 172               	.LBE44:
 711:./tmk_core/common/action.c **** #endif
 712:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 713:./tmk_core/common/action.c ****         send_keyboard_report();
 173               		.loc 1 713 0
 174 0024 0E94 0000 		call send_keyboard_report
 175               	.LVL13:
 176               	.LBB46:
 177               	.LBB47:
 178               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 179               		.loc 3 187 0
 180 0028 2FEF      		ldi r18,lo8(319999)
 181 002a 81EE      		ldi r24,hi8(319999)
 182 002c 94E0      		ldi r25,hlo8(319999)
 183 002e 2150      	1:	subi r18,1
 184 0030 8040      		sbci r24,0
 185 0032 9040      		sbci r25,0
 186 0034 01F4      		brne 1b
 187 0036 00C0      		rjmp .
 188 0038 0000      		nop
 189               	.LVL14:
 190               	.LBE47:
 191               	.LBE46:
 192               	.LBB48:
 193               	.LBB49:
  34:./tmk_core/common/action_util.h **** }
  35:./tmk_core/common/action_util.h **** 
  36:./tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:./tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 194               		.loc 2 37 0
 195 003a 69E3      		ldi r22,lo8(57)
 196 003c 00C0      		rjmp .L39
 197               	.LVL15:
 198               	.L7:
 199               	.LBE49:
 200               	.LBE48:
 714:./tmk_core/common/action.c ****         wait_ms(100);
 715:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 716:./tmk_core/common/action.c ****         send_keyboard_report();
 717:./tmk_core/common/action.c ****     }
 718:./tmk_core/common/action.c **** 
 719:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 201               		.loc 1 719 0
 202 003e 8338      		cpi r24,lo8(-125)
 203 0040 01F4      		brne .L9
 720:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 721:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 204               		.loc 1 721 0
 205 0042 0E94 0000 		call host_keyboard_leds
 206               	.LVL16:
 207 0046 80FD      		sbrc r24,0
 208 0048 00C0      		rjmp .L4
 209               	.LVL17:
 210               	.LBB50:
 211               	.LBB51:
  33:./tmk_core/common/action_util.h **** }
 212               		.loc 2 33 0
 213 004a 63E5      		ldi r22,lo8(83)
 214 004c 8091 0000 		lds r24,keyboard_report
 215 0050 9091 0000 		lds r25,keyboard_report+1
 216 0054 0E94 0000 		call add_key_to_report
 217               	.LVL18:
 218               	.LBE51:
 219               	.LBE50:
 722:./tmk_core/common/action.c **** #endif
 723:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 724:./tmk_core/common/action.c ****         send_keyboard_report();
 220               		.loc 1 724 0
 221 0058 0E94 0000 		call send_keyboard_report
 222               	.LVL19:
 223               	.LBB52:
 224               	.LBB53:
 225               		.loc 3 187 0
 226 005c 2FEF      		ldi r18,lo8(319999)
 227 005e 81EE      		ldi r24,hi8(319999)
 228 0060 94E0      		ldi r25,hlo8(319999)
 229 0062 2150      	1:	subi r18,1
 230 0064 8040      		sbci r24,0
 231 0066 9040      		sbci r25,0
 232 0068 01F4      		brne 1b
 233 006a 00C0      		rjmp .
 234 006c 0000      		nop
 235               	.LVL20:
 236               	.LBE53:
 237               	.LBE52:
 238               	.LBB54:
 239               	.LBB55:
 240               		.loc 2 37 0
 241 006e 63E5      		ldi r22,lo8(83)
 242               	.LVL21:
 243               	.L39:
 244 0070 8091 0000 		lds r24,keyboard_report
 245 0074 9091 0000 		lds r25,keyboard_report+1
 246 0078 0E94 0000 		call del_key_from_report
 247               	.LVL22:
 248               	.L40:
 249               	/* epilogue start */
 250               	.LBE55:
 251               	.LBE54:
 725:./tmk_core/common/action.c ****         wait_ms(100);
 726:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 727:./tmk_core/common/action.c ****         send_keyboard_report();
 728:./tmk_core/common/action.c ****     }
 729:./tmk_core/common/action.c **** 
 730:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 731:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 732:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 733:./tmk_core/common/action.c **** #endif
 734:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 735:./tmk_core/common/action.c ****         send_keyboard_report();
 736:./tmk_core/common/action.c ****         wait_ms(100);
 737:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 738:./tmk_core/common/action.c ****         send_keyboard_report();
 739:./tmk_core/common/action.c ****     }
 740:./tmk_core/common/action.c **** #endif
 741:./tmk_core/common/action.c **** 
 742:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 743:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 744:./tmk_core/common/action.c ****         if (command_proc(code)) return;
 745:./tmk_core/common/action.c **** 
 746:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 747:./tmk_core/common/action.c **** /* TODO: remove
 748:./tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 749:./tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 750:./tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 751:./tmk_core/common/action.c **** 
 752:./tmk_core/common/action.c ****             add_key(code);
 753:./tmk_core/common/action.c ****             send_keyboard_report();
 754:./tmk_core/common/action.c **** 
 755:./tmk_core/common/action.c ****             set_mods(tmp_mods);
 756:./tmk_core/common/action.c ****             send_keyboard_report();
 757:./tmk_core/common/action.c ****             oneshot_cancel();
 758:./tmk_core/common/action.c ****         } else
 759:./tmk_core/common/action.c **** */
 760:./tmk_core/common/action.c **** #endif
 761:./tmk_core/common/action.c ****         {
 762:./tmk_core/common/action.c ****             add_key(code);
 763:./tmk_core/common/action.c ****             send_keyboard_report();
 764:./tmk_core/common/action.c ****         }
 765:./tmk_core/common/action.c ****     }
 766:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 767:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 768:./tmk_core/common/action.c ****         send_keyboard_report();
 769:./tmk_core/common/action.c ****     }
 770:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 771:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 772:./tmk_core/common/action.c ****     }
 773:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 775:./tmk_core/common/action.c ****     }
 776:./tmk_core/common/action.c **** }
 252               		.loc 1 776 0
 253 007c CF91      		pop r28
 727:./tmk_core/common/action.c ****     }
 254               		.loc 1 727 0
 255 007e 0C94 0000 		jmp send_keyboard_report
 256               	.LVL23:
 257               	.L9:
 730:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 258               		.loc 1 730 0
 259 0082 8438      		cpi r24,lo8(-124)
 260 0084 01F4      		brne .L10
 732:./tmk_core/common/action.c **** #endif
 261               		.loc 1 732 0
 262 0086 0E94 0000 		call host_keyboard_leds
 263               	.LVL24:
 264 008a 82FD      		sbrc r24,2
 265 008c 00C0      		rjmp .L4
 266               	.LVL25:
 267               	.LBB56:
 268               	.LBB57:
  33:./tmk_core/common/action_util.h **** }
 269               		.loc 2 33 0
 270 008e 67E4      		ldi r22,lo8(71)
 271 0090 8091 0000 		lds r24,keyboard_report
 272 0094 9091 0000 		lds r25,keyboard_report+1
 273 0098 0E94 0000 		call add_key_to_report
 274               	.LVL26:
 275               	.LBE57:
 276               	.LBE56:
 735:./tmk_core/common/action.c ****         wait_ms(100);
 277               		.loc 1 735 0
 278 009c 0E94 0000 		call send_keyboard_report
 279               	.LVL27:
 280               	.LBB58:
 281               	.LBB59:
 282               		.loc 3 187 0
 283 00a0 2FEF      		ldi r18,lo8(319999)
 284 00a2 81EE      		ldi r24,hi8(319999)
 285 00a4 94E0      		ldi r25,hlo8(319999)
 286 00a6 2150      	1:	subi r18,1
 287 00a8 8040      		sbci r24,0
 288 00aa 9040      		sbci r25,0
 289 00ac 01F4      		brne 1b
 290 00ae 00C0      		rjmp .
 291 00b0 0000      		nop
 292               	.LVL28:
 293               	.LBE59:
 294               	.LBE58:
 295               	.LBB60:
 296               	.LBB61:
 297               		.loc 2 37 0
 298 00b2 67E4      		ldi r22,lo8(71)
 299 00b4 00C0      		rjmp .L39
 300               	.LVL29:
 301               	.L10:
 302               	.LBE61:
 303               	.LBE60:
 742:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 304               		.loc 1 742 0
 305 00b6 8CEF      		ldi r24,lo8(-4)
 306               	.LVL30:
 307 00b8 8C0F      		add r24,r28
 308 00ba 813A      		cpi r24,lo8(-95)
 309 00bc 00F4      		brsh .L11
 744:./tmk_core/common/action.c **** 
 310               		.loc 1 744 0
 311 00be 8C2F      		mov r24,r28
 312 00c0 0E94 0000 		call command_proc
 313               	.LVL31:
 314 00c4 8111      		cpse r24,__zero_reg__
 315 00c6 00C0      		rjmp .L4
 316               	.LVL32:
 317               	.LBB62:
 318               	.LBB63:
  33:./tmk_core/common/action_util.h **** }
 319               		.loc 2 33 0
 320 00c8 6C2F      		mov r22,r28
 321 00ca 8091 0000 		lds r24,keyboard_report
 322 00ce 9091 0000 		lds r25,keyboard_report+1
 323 00d2 0E94 0000 		call add_key_to_report
 324               	.LVL33:
 325 00d6 00C0      		rjmp .L40
 326               	.L11:
 327               	.LBE63:
 328               	.LBE62:
 766:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 329               		.loc 1 766 0
 330 00d8 80E2      		ldi r24,lo8(32)
 331 00da 8C0F      		add r24,r28
 332 00dc 8830      		cpi r24,lo8(8)
 333 00de 00F4      		brsh .L12
 767:./tmk_core/common/action.c ****         send_keyboard_report();
 334               		.loc 1 767 0
 335 00e0 C770      		andi r28,lo8(7)
 336               	.LVL34:
 337 00e2 81E0      		ldi r24,lo8(1)
 338 00e4 00C0      		rjmp 2f
 339               		1:
 340 00e6 880F      		lsl r24
 341               		2:
 342 00e8 CA95      		dec r28
 343 00ea 02F4      		brpl 1b
 344 00ec 0E94 0000 		call add_mods
 345               	.LVL35:
 346 00f0 00C0      		rjmp .L40
 347               	.LVL36:
 348               	.L12:
 770:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 349               		.loc 1 770 0
 350 00f2 8BE5      		ldi r24,lo8(91)
 351 00f4 8C0F      		add r24,r28
 352 00f6 8330      		cpi r24,lo8(3)
 353 00f8 00F4      		brsh .L13
 771:./tmk_core/common/action.c ****     }
 354               		.loc 1 771 0
 355 00fa C53A      		cpi r28,lo8(-91)
 356 00fc 01F0      		breq .L16
 771:./tmk_core/common/action.c ****     }
 357               		.loc 1 771 0 is_stmt 0 discriminator 1
 358 00fe C63A      		cpi r28,lo8(-90)
 359 0100 01F0      		breq .L17
 771:./tmk_core/common/action.c ****     }
 360               		.loc 1 771 0
 361 0102 83E8      		ldi r24,lo8(-125)
 362 0104 90E0      		ldi r25,0
 363 0106 00C0      		rjmp .L14
 364               	.L16:
 365 0108 81E8      		ldi r24,lo8(-127)
 366 010a 90E0      		ldi r25,0
 367 010c 00C0      		rjmp .L14
 368               	.L17:
 369 010e 82E8      		ldi r24,lo8(-126)
 370 0110 90E0      		ldi r25,0
 371               	.L14:
 372               	/* epilogue start */
 373               		.loc 1 776 0 is_stmt 1 discriminator 12
 374 0112 CF91      		pop r28
 375               	.LVL37:
 771:./tmk_core/common/action.c ****     }
 376               		.loc 1 771 0 discriminator 12
 377 0114 0C94 0000 		jmp host_system_send
 378               	.LVL38:
 379               	.L13:
 773:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 380               		.loc 1 773 0
 381 0118 88E5      		ldi r24,lo8(88)
 382 011a 8C0F      		add r24,r28
 383 011c 8531      		cpi r24,lo8(21)
 384 011e 00F0      		brlo .+2
 385 0120 00C0      		rjmp .L4
 774:./tmk_core/common/action.c ****     }
 386               		.loc 1 774 0
 387 0122 C83A      		cpi r28,lo8(-88)
 388 0124 01F0      		breq .L18
 774:./tmk_core/common/action.c ****     }
 389               		.loc 1 774 0 is_stmt 0 discriminator 1
 390 0126 C93A      		cpi r28,lo8(-87)
 391 0128 01F0      		breq .L19
 774:./tmk_core/common/action.c ****     }
 392               		.loc 1 774 0 discriminator 3
 393 012a CA3A      		cpi r28,lo8(-86)
 394 012c 01F0      		breq .L20
 774:./tmk_core/common/action.c ****     }
 395               		.loc 1 774 0 discriminator 5
 396 012e CB3A      		cpi r28,lo8(-85)
 397 0130 01F0      		breq .L21
 774:./tmk_core/common/action.c ****     }
 398               		.loc 1 774 0 discriminator 7
 399 0132 CC3A      		cpi r28,lo8(-84)
 400 0134 01F0      		breq .L22
 774:./tmk_core/common/action.c ****     }
 401               		.loc 1 774 0 discriminator 9
 402 0136 CB3B      		cpi r28,lo8(-69)
 403 0138 01F0      		breq .L23
 774:./tmk_core/common/action.c ****     }
 404               		.loc 1 774 0 discriminator 11
 405 013a CC3B      		cpi r28,lo8(-68)
 406 013c 01F0      		breq .L24
 774:./tmk_core/common/action.c ****     }
 407               		.loc 1 774 0 discriminator 13
 408 013e CD3A      		cpi r28,lo8(-83)
 409 0140 01F0      		breq .L25
 774:./tmk_core/common/action.c ****     }
 410               		.loc 1 774 0 discriminator 15
 411 0142 C03B      		cpi r28,lo8(-80)
 412 0144 01F0      		breq .L26
 774:./tmk_core/common/action.c ****     }
 413               		.loc 1 774 0 discriminator 17
 414 0146 CE3A      		cpi r28,lo8(-82)
 415 0148 01F0      		breq .L27
 774:./tmk_core/common/action.c ****     }
 416               		.loc 1 774 0 discriminator 19
 417 014a CF3A      		cpi r28,lo8(-81)
 418 014c 01F0      		breq .L28
 774:./tmk_core/common/action.c ****     }
 419               		.loc 1 774 0 discriminator 21
 420 014e C13B      		cpi r28,lo8(-79)
 421 0150 01F0      		breq .L29
 774:./tmk_core/common/action.c ****     }
 422               		.loc 1 774 0 discriminator 23
 423 0152 C23B      		cpi r28,lo8(-78)
 424 0154 01F0      		breq .L30
 774:./tmk_core/common/action.c ****     }
 425               		.loc 1 774 0 discriminator 25
 426 0156 C33B      		cpi r28,lo8(-77)
 427 0158 01F0      		breq .L31
 774:./tmk_core/common/action.c ****     }
 428               		.loc 1 774 0 discriminator 27
 429 015a C43B      		cpi r28,lo8(-76)
 430 015c 01F0      		breq .L32
 774:./tmk_core/common/action.c ****     }
 431               		.loc 1 774 0 discriminator 29
 432 015e C53B      		cpi r28,lo8(-75)
 433 0160 01F0      		breq .L33
 774:./tmk_core/common/action.c ****     }
 434               		.loc 1 774 0 discriminator 31
 435 0162 C63B      		cpi r28,lo8(-74)
 436 0164 01F0      		breq .L34
 774:./tmk_core/common/action.c ****     }
 437               		.loc 1 774 0 discriminator 33
 438 0166 C73B      		cpi r28,lo8(-73)
 439 0168 01F0      		breq .L35
 774:./tmk_core/common/action.c ****     }
 440               		.loc 1 774 0 discriminator 35
 441 016a C83B      		cpi r28,lo8(-72)
 442 016c 01F0      		breq .L36
 774:./tmk_core/common/action.c ****     }
 443               		.loc 1 774 0 discriminator 37
 444 016e C93B      		cpi r28,lo8(-71)
 445 0170 01F0      		breq .L37
 774:./tmk_core/common/action.c ****     }
 446               		.loc 1 774 0 discriminator 39
 447 0172 CA3B      		cpi r28,lo8(-70)
 448 0174 01F4      		brne .+2
 449 0176 00C0      		rjmp .L38
 774:./tmk_core/common/action.c ****     }
 450               		.loc 1 774 0
 451 0178 80E0      		ldi r24,0
 452 017a 90E0      		ldi r25,0
 453 017c 00C0      		rjmp .L15
 454               	.L18:
 455 017e 82EE      		ldi r24,lo8(-30)
 456 0180 90E0      		ldi r25,0
 457 0182 00C0      		rjmp .L15
 458               	.L19:
 459 0184 89EE      		ldi r24,lo8(-23)
 460 0186 90E0      		ldi r25,0
 461 0188 00C0      		rjmp .L15
 462               	.L20:
 463 018a 8AEE      		ldi r24,lo8(-22)
 464 018c 90E0      		ldi r25,0
 465 018e 00C0      		rjmp .L15
 466               	.L21:
 467 0190 85EB      		ldi r24,lo8(-75)
 468 0192 90E0      		ldi r25,0
 469 0194 00C0      		rjmp .L15
 470               	.L22:
 471 0196 86EB      		ldi r24,lo8(-74)
 472 0198 90E0      		ldi r25,0
 473 019a 00C0      		rjmp .L15
 474               	.L23:
 475 019c 83EB      		ldi r24,lo8(-77)
 476 019e 90E0      		ldi r25,0
 477 01a0 00C0      		rjmp .L15
 478               	.L24:
 479 01a2 84EB      		ldi r24,lo8(-76)
 480 01a4 90E0      		ldi r25,0
 481 01a6 00C0      		rjmp .L15
 482               	.L25:
 483 01a8 87EB      		ldi r24,lo8(-73)
 484 01aa 90E0      		ldi r25,0
 485 01ac 00C0      		rjmp .L15
 486               	.L26:
 487 01ae 8CEC      		ldi r24,lo8(-52)
 488 01b0 90E0      		ldi r25,0
 489 01b2 00C0      		rjmp .L15
 490               	.L27:
 491 01b4 8DEC      		ldi r24,lo8(-51)
 492 01b6 90E0      		ldi r25,0
 493 01b8 00C0      		rjmp .L15
 494               	.L28:
 495 01ba 83E8      		ldi r24,lo8(-125)
 496 01bc 91E0      		ldi r25,lo8(1)
 497 01be 00C0      		rjmp .L15
 498               	.L29:
 499 01c0 8AE8      		ldi r24,lo8(-118)
 500 01c2 91E0      		ldi r25,lo8(1)
 501 01c4 00C0      		rjmp .L15
 502               	.L30:
 503 01c6 82E9      		ldi r24,lo8(-110)
 504 01c8 91E0      		ldi r25,lo8(1)
 505 01ca 00C0      		rjmp .L15
 506               	.L31:
 507 01cc 84E9      		ldi r24,lo8(-108)
 508 01ce 91E0      		ldi r25,lo8(1)
 509 01d0 00C0      		rjmp .L15
 510               	.L32:
 511 01d2 81E2      		ldi r24,lo8(33)
 512 01d4 92E0      		ldi r25,lo8(2)
 513 01d6 00C0      		rjmp .L15
 514               	.L33:
 515 01d8 83E2      		ldi r24,lo8(35)
 516 01da 92E0      		ldi r25,lo8(2)
 517 01dc 00C0      		rjmp .L15
 518               	.L34:
 519 01de 84E2      		ldi r24,lo8(36)
 520 01e0 92E0      		ldi r25,lo8(2)
 521 01e2 00C0      		rjmp .L15
 522               	.L35:
 523 01e4 85E2      		ldi r24,lo8(37)
 524 01e6 92E0      		ldi r25,lo8(2)
 525 01e8 00C0      		rjmp .L15
 526               	.L36:
 527 01ea 86E2      		ldi r24,lo8(38)
 528 01ec 92E0      		ldi r25,lo8(2)
 529 01ee 00C0      		rjmp .L15
 530               	.L37:
 531 01f0 87E2      		ldi r24,lo8(39)
 532 01f2 92E0      		ldi r25,lo8(2)
 533 01f4 00C0      		rjmp .L15
 534               	.L38:
 535 01f6 8AE2      		ldi r24,lo8(42)
 536 01f8 92E0      		ldi r25,lo8(2)
 537               	.L15:
 538               	/* epilogue start */
 539               		.loc 1 776 0 is_stmt 1 discriminator 84
 540 01fa CF91      		pop r28
 541               	.LVL39:
 774:./tmk_core/common/action.c ****     }
 542               		.loc 1 774 0 discriminator 84
 543 01fc 0C94 0000 		jmp host_consumer_send
 544               	.LVL40:
 545               	.L4:
 546               	/* epilogue start */
 547               		.loc 1 776 0
 548 0200 CF91      		pop r28
 549 0202 0895      		ret
 550               		.cfi_endproc
 551               	.LFE19:
 553               		.section	.text.unregister_code,"ax",@progbits
 554               	.global	unregister_code
 556               	unregister_code:
 557               	.LFB20:
 777:./tmk_core/common/action.c **** 
 778:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 779:./tmk_core/common/action.c ****  *
 780:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 781:./tmk_core/common/action.c ****  */
 782:./tmk_core/common/action.c **** void unregister_code(uint8_t code)
 783:./tmk_core/common/action.c **** {
 558               		.loc 1 783 0
 559               		.cfi_startproc
 560               	.LVL41:
 561               	/* prologue: function */
 562               	/* frame size = 0 */
 563               	/* stack size = 0 */
 564               	.L__stack_usage = 0
 784:./tmk_core/common/action.c ****     if (code == KC_NO) {
 565               		.loc 1 784 0
 566 0000 8823      		tst r24
 567 0002 01F4      		brne .+2
 568 0004 00C0      		rjmp .L42
 569 0006 682F      		mov r22,r24
 785:./tmk_core/common/action.c ****         return;
 786:./tmk_core/common/action.c ****     }
 787:./tmk_core/common/action.c **** 
 788:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 789:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 570               		.loc 1 789 0
 571 0008 8238      		cpi r24,lo8(-126)
 572 000a 01F4      		brne .L45
 790:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 791:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 792:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 573               		.loc 1 792 0
 574 000c 0E94 0000 		call host_keyboard_leds
 575               	.LVL42:
 576 0010 81FF      		sbrs r24,1
 577 0012 00C0      		rjmp .L42
 578               	.LVL43:
 579               	.LBB64:
 580               	.LBB65:
  33:./tmk_core/common/action_util.h **** }
 581               		.loc 2 33 0
 582 0014 69E3      		ldi r22,lo8(57)
 583 0016 8091 0000 		lds r24,keyboard_report
 584 001a 9091 0000 		lds r25,keyboard_report+1
 585 001e 0E94 0000 		call add_key_to_report
 586               	.LVL44:
 587               	.LBE65:
 588               	.LBE64:
 793:./tmk_core/common/action.c **** #endif
 794:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 795:./tmk_core/common/action.c ****         send_keyboard_report();
 589               		.loc 1 795 0
 590 0022 0E94 0000 		call send_keyboard_report
 591               	.LVL45:
 592               	.LBB66:
 593               	.LBB67:
 594               		.loc 2 37 0
 595 0026 69E3      		ldi r22,lo8(57)
 596 0028 00C0      		rjmp .L61
 597               	.LVL46:
 598               	.L45:
 599               	.LBE67:
 600               	.LBE66:
 796:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 797:./tmk_core/common/action.c ****         send_keyboard_report();
 798:./tmk_core/common/action.c ****     }
 799:./tmk_core/common/action.c **** 
 800:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 601               		.loc 1 800 0
 602 002a 8338      		cpi r24,lo8(-125)
 603 002c 01F4      		brne .L47
 801:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 802:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 604               		.loc 1 802 0
 605 002e 0E94 0000 		call host_keyboard_leds
 606               	.LVL47:
 607 0032 80FF      		sbrs r24,0
 608 0034 00C0      		rjmp .L42
 609               	.LVL48:
 610               	.LBB68:
 611               	.LBB69:
  33:./tmk_core/common/action_util.h **** }
 612               		.loc 2 33 0
 613 0036 63E5      		ldi r22,lo8(83)
 614 0038 8091 0000 		lds r24,keyboard_report
 615 003c 9091 0000 		lds r25,keyboard_report+1
 616 0040 0E94 0000 		call add_key_to_report
 617               	.LVL49:
 618               	.LBE69:
 619               	.LBE68:
 803:./tmk_core/common/action.c **** #endif
 804:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 805:./tmk_core/common/action.c ****         send_keyboard_report();
 620               		.loc 1 805 0
 621 0044 0E94 0000 		call send_keyboard_report
 622               	.LVL50:
 623               	.LBB70:
 624               	.LBB71:
 625               		.loc 2 37 0
 626 0048 63E5      		ldi r22,lo8(83)
 627               	.LVL51:
 628               	.L61:
 629 004a 8091 0000 		lds r24,keyboard_report
 630 004e 9091 0000 		lds r25,keyboard_report+1
 631 0052 0E94 0000 		call del_key_from_report
 632               	.LVL52:
 633               	.L62:
 634               	.LBE71:
 635               	.LBE70:
 806:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 807:./tmk_core/common/action.c ****         send_keyboard_report();
 636               		.loc 1 807 0
 637 0056 0C94 0000 		jmp send_keyboard_report
 638               	.LVL53:
 639               	.L47:
 808:./tmk_core/common/action.c ****     }
 809:./tmk_core/common/action.c **** 
 810:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 640               		.loc 1 810 0
 641 005a 8438      		cpi r24,lo8(-124)
 642 005c 01F4      		brne .L48
 811:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 812:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 643               		.loc 1 812 0
 644 005e 0E94 0000 		call host_keyboard_leds
 645               	.LVL54:
 646 0062 82FF      		sbrs r24,2
 647 0064 00C0      		rjmp .L42
 648               	.LVL55:
 649               	.LBB72:
 650               	.LBB73:
  33:./tmk_core/common/action_util.h **** }
 651               		.loc 2 33 0
 652 0066 67E4      		ldi r22,lo8(71)
 653 0068 8091 0000 		lds r24,keyboard_report
 654 006c 9091 0000 		lds r25,keyboard_report+1
 655 0070 0E94 0000 		call add_key_to_report
 656               	.LVL56:
 657               	.LBE73:
 658               	.LBE72:
 813:./tmk_core/common/action.c **** #endif
 814:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 815:./tmk_core/common/action.c ****         send_keyboard_report();
 659               		.loc 1 815 0
 660 0074 0E94 0000 		call send_keyboard_report
 661               	.LVL57:
 662               	.LBB74:
 663               	.LBB75:
 664               		.loc 2 37 0
 665 0078 67E4      		ldi r22,lo8(71)
 666 007a 00C0      		rjmp .L61
 667               	.LVL58:
 668               	.L48:
 669               	.LBE75:
 670               	.LBE74:
 816:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 817:./tmk_core/common/action.c ****         send_keyboard_report();
 818:./tmk_core/common/action.c ****     }
 819:./tmk_core/common/action.c **** #endif
 820:./tmk_core/common/action.c **** 
 821:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 671               		.loc 1 821 0
 672 007c 8CEF      		ldi r24,lo8(-4)
 673 007e 860F      		add r24,r22
 674 0080 813A      		cpi r24,lo8(-95)
 675 0082 00F0      		brlo .L61
 822:./tmk_core/common/action.c ****         del_key(code);
 823:./tmk_core/common/action.c ****         send_keyboard_report();
 824:./tmk_core/common/action.c ****     }
 825:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 676               		.loc 1 825 0
 677 0084 80E2      		ldi r24,lo8(32)
 678 0086 860F      		add r24,r22
 679 0088 8830      		cpi r24,lo8(8)
 680 008a 00F4      		brsh .L50
 826:./tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 681               		.loc 1 826 0
 682 008c 6770      		andi r22,lo8(7)
 683               	.LVL59:
 684 008e 81E0      		ldi r24,lo8(1)
 685 0090 00C0      		rjmp 2f
 686               		1:
 687 0092 880F      		lsl r24
 688               		2:
 689 0094 6A95      		dec r22
 690 0096 02F4      		brpl 1b
 691 0098 0E94 0000 		call del_mods
 692               	.LVL60:
 693 009c 00C0      		rjmp .L62
 694               	.LVL61:
 695               	.L50:
 827:./tmk_core/common/action.c ****         send_keyboard_report();
 828:./tmk_core/common/action.c ****     }
 829:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 696               		.loc 1 829 0
 697 009e 8BE5      		ldi r24,lo8(91)
 698 00a0 860F      		add r24,r22
 699 00a2 8330      		cpi r24,lo8(3)
 700 00a4 00F4      		brsh .L51
 830:./tmk_core/common/action.c ****         host_system_send(0);
 701               		.loc 1 830 0
 702 00a6 80E0      		ldi r24,0
 703 00a8 90E0      		ldi r25,0
 704 00aa 0C94 0000 		jmp host_system_send
 705               	.LVL62:
 706               	.L51:
 831:./tmk_core/common/action.c ****     }
 832:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 707               		.loc 1 832 0
 708 00ae 685A      		subi r22,lo8(-(88))
 709               	.LVL63:
 710 00b0 6531      		cpi r22,lo8(21)
 711 00b2 00F4      		brsh .L42
 833:./tmk_core/common/action.c ****         host_consumer_send(0);
 712               		.loc 1 833 0
 713 00b4 80E0      		ldi r24,0
 714 00b6 90E0      		ldi r25,0
 715 00b8 0C94 0000 		jmp host_consumer_send
 716               	.LVL64:
 717               	.L42:
 718 00bc 0895      		ret
 719               		.cfi_endproc
 720               	.LFE20:
 722               		.section	.text.register_mods,"ax",@progbits
 723               	.global	register_mods
 725               	register_mods:
 726               	.LFB21:
 834:./tmk_core/common/action.c ****     }
 835:./tmk_core/common/action.c **** }
 836:./tmk_core/common/action.c **** 
 837:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 838:./tmk_core/common/action.c ****  *
 839:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 840:./tmk_core/common/action.c ****  */
 841:./tmk_core/common/action.c **** void register_mods(uint8_t mods)
 842:./tmk_core/common/action.c **** {
 727               		.loc 1 842 0
 728               		.cfi_startproc
 729               	.LVL65:
 730               	/* prologue: function */
 731               	/* frame size = 0 */
 732               	/* stack size = 0 */
 733               	.L__stack_usage = 0
 843:./tmk_core/common/action.c ****     if (mods) {
 734               		.loc 1 843 0
 735 0000 8823      		tst r24
 736 0002 01F0      		breq .L63
 844:./tmk_core/common/action.c ****         add_mods(mods);
 737               		.loc 1 844 0
 738 0004 0E94 0000 		call add_mods
 739               	.LVL66:
 845:./tmk_core/common/action.c ****         send_keyboard_report();
 740               		.loc 1 845 0
 741 0008 0C94 0000 		jmp send_keyboard_report
 742               	.LVL67:
 743               	.L63:
 744 000c 0895      		ret
 745               		.cfi_endproc
 746               	.LFE21:
 748               		.section	.text.unregister_mods,"ax",@progbits
 749               	.global	unregister_mods
 751               	unregister_mods:
 752               	.LFB22:
 846:./tmk_core/common/action.c ****     }
 847:./tmk_core/common/action.c **** }
 848:./tmk_core/common/action.c **** 
 849:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 850:./tmk_core/common/action.c ****  *
 851:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 852:./tmk_core/common/action.c ****  */
 853:./tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 854:./tmk_core/common/action.c **** {
 753               		.loc 1 854 0
 754               		.cfi_startproc
 755               	.LVL68:
 756               	/* prologue: function */
 757               	/* frame size = 0 */
 758               	/* stack size = 0 */
 759               	.L__stack_usage = 0
 855:./tmk_core/common/action.c ****     if (mods) {
 760               		.loc 1 855 0
 761 0000 8823      		tst r24
 762 0002 01F0      		breq .L65
 856:./tmk_core/common/action.c ****         del_mods(mods);
 763               		.loc 1 856 0
 764 0004 0E94 0000 		call del_mods
 765               	.LVL69:
 857:./tmk_core/common/action.c ****         send_keyboard_report();
 766               		.loc 1 857 0
 767 0008 0C94 0000 		jmp send_keyboard_report
 768               	.LVL70:
 769               	.L65:
 770 000c 0895      		ret
 771               		.cfi_endproc
 772               	.LFE22:
 774               		.section	.text.process_action,"ax",@progbits
 775               	.global	process_action
 777               	process_action:
 778               	.LFB18:
 195:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 779               		.loc 1 195 0
 780               		.cfi_startproc
 781               	.LVL71:
 782 0000 8F92      		push r8
 783               	.LCFI5:
 784               		.cfi_def_cfa_offset 3
 785               		.cfi_offset 8, -2
 786 0002 9F92      		push r9
 787               	.LCFI6:
 788               		.cfi_def_cfa_offset 4
 789               		.cfi_offset 9, -3
 790 0004 AF92      		push r10
 791               	.LCFI7:
 792               		.cfi_def_cfa_offset 5
 793               		.cfi_offset 10, -4
 794 0006 BF92      		push r11
 795               	.LCFI8:
 796               		.cfi_def_cfa_offset 6
 797               		.cfi_offset 11, -5
 798 0008 DF92      		push r13
 799               	.LCFI9:
 800               		.cfi_def_cfa_offset 7
 801               		.cfi_offset 13, -6
 802 000a EF92      		push r14
 803               	.LCFI10:
 804               		.cfi_def_cfa_offset 8
 805               		.cfi_offset 14, -7
 806 000c FF92      		push r15
 807               	.LCFI11:
 808               		.cfi_def_cfa_offset 9
 809               		.cfi_offset 15, -8
 810 000e 0F93      		push r16
 811               	.LCFI12:
 812               		.cfi_def_cfa_offset 10
 813               		.cfi_offset 16, -9
 814 0010 1F93      		push r17
 815               	.LCFI13:
 816               		.cfi_def_cfa_offset 11
 817               		.cfi_offset 17, -10
 818 0012 CF93      		push r28
 819               	.LCFI14:
 820               		.cfi_def_cfa_offset 12
 821               		.cfi_offset 28, -11
 822 0014 DF93      		push r29
 823               	.LCFI15:
 824               		.cfi_def_cfa_offset 13
 825               		.cfi_offset 29, -12
 826               	/* prologue: function */
 827               	/* frame size = 0 */
 828               	/* stack size = 11 */
 829               	.L__stack_usage = 11
 830 0016 7C01      		movw r14,r24
 831 0018 D62F      		mov r29,r22
 832 001a C72F      		mov r28,r23
 833               	.LVL72:
 198:./tmk_core/common/action.c **** #endif
 834               		.loc 1 198 0
 835 001c FC01      		movw r30,r24
 836 001e 0581      		ldd r16,Z+5
 837 0020 0295      		swap r16
 838 0022 0F70      		andi r16,lo8(15)
 839               	.LVL73:
 201:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 840               		.loc 1 201 0
 841 0024 1281      		ldd r17,Z+2
 842 0026 1111      		cpse r17,__zero_reg__
 203:./tmk_core/common/action.c ****     }
 843               		.loc 1 203 0
 844 0028 0E94 0000 		call clear_weak_mods
 845               	.LVL74:
 846               	.L68:
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 847               		.loc 1 209 0
 848 002c 0E94 0000 		call is_oneshot_layer_active
 849               	.LVL75:
 850 0030 8823      		tst r24
 851 0032 01F0      		breq .L158
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 852               		.loc 1 209 0 is_stmt 0 discriminator 1
 853 0034 1123      		tst r17
 854 0036 01F0      		breq .L158
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 855               		.loc 1 209 0 discriminator 2
 856 0038 80E2      		ldi r24,lo8(32)
 857 003a 8D0F      		add r24,r29
 858 003c 8830      		cpi r24,lo8(8)
 859 003e 00F0      		brlo .L158
 210:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 860               		.loc 1 210 0 is_stmt 1
 861 0040 82E0      		ldi r24,lo8(2)
 862 0042 0E94 0000 		call clear_oneshot_layer_state
 863               	.LVL76:
 211:./tmk_core/common/action.c ****     }
 864               		.loc 1 211 0
 865 0046 0E94 0000 		call is_oneshot_layer_active
 866               	.LVL77:
 867 004a 91E0      		ldi r25,lo8(1)
 868 004c D82E      		mov r13,r24
 869 004e D926      		eor r13,r25
 870               	.LVL78:
 871 0050 00C0      		rjmp .L69
 872               	.LVL79:
 873               	.L158:
 207:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 874               		.loc 1 207 0
 875 0052 D12C      		mov r13,__zero_reg__
 876               	.LVL80:
 877               	.L69:
 215:./tmk_core/common/action.c ****         /* Key and Mods */
 878               		.loc 1 215 0
 879 0054 BC2E      		mov r11,r28
 880 0056 B294      		swap r11
 881 0058 8FE0      		ldi r24,lo8(15)
 882 005a B822      		and r11,r24
 883 005c 8B2D      		mov r24,r11
 884 005e 90E0      		ldi r25,0
 885 0060 FC01      		movw r30,r24
 886 0062 E050      		subi r30,lo8(-(gs(.L72)))
 887 0064 F040      		sbci r31,hi8(-(gs(.L72)))
 888 0066 0C94 0000 		jmp __tablejump2__
 889               		.section	.progmem.gcc_sw_table.process_action,"a",@progbits
 890               		.p2align	1
 891               	.L72:
 892 0000 0000      		.word gs(.L71)
 893 0002 0000      		.word gs(.L71)
 894 0004 0000      		.word gs(.L73)
 895 0006 0000      		.word gs(.L73)
 896 0008 0000      		.word gs(.L74)
 897 000a 0000      		.word gs(.L75)
 898 000c 0000      		.word gs(.L70)
 899 000e 0000      		.word gs(.L70)
 900 0010 0000      		.word gs(.L76)
 901 0012 0000      		.word gs(.L70)
 902 0014 0000      		.word gs(.L77)
 903 0016 0000      		.word gs(.L77)
 904 0018 0000      		.word gs(.L78)
 905 001a 0000      		.word gs(.L70)
 906 001c 0000      		.word gs(.L70)
 907 001e 0000      		.word gs(.L79)
 908               		.section	.text.process_action
 909               	.L71:
 910               	.LBB76:
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 911               		.loc 1 220 0
 912 006a 8C2F      		mov r24,r28
 913 006c 807F      		andi r24,lo8(-16)
 914 006e CF70      		andi r28,lo8(15)
 915               	.LVL81:
 916 0070 8823      		tst r24
 917 0072 01F0      		breq .L81
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 918               		.loc 1 220 0 is_stmt 0 discriminator 2
 919 0074 C295      		swap r28
 920 0076 C07F      		andi r28,lo8(-16)
 921               	.L81:
 922               	.LVL82:
 222:./tmk_core/common/action.c ****                     if (mods) {
 923               		.loc 1 222 0 is_stmt 1 discriminator 4
 924 0078 1123      		tst r17
 925 007a 01F0      		breq .L82
 223:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 926               		.loc 1 223 0
 927 007c CC23      		tst r28
 928 007e 01F4      		brne .+2
 929 0080 00C0      		rjmp .L188
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 930               		.loc 1 224 0
 931 0082 80E2      		ldi r24,lo8(32)
 932 0084 8D0F      		add r24,r29
 933 0086 8830      		cpi r24,lo8(8)
 934 0088 00F0      		brlo .L84
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 935               		.loc 1 224 0 is_stmt 0 discriminator 1
 936 008a D111      		cpse r29,__zero_reg__
 937 008c 00C0      		rjmp .L85
 938               	.L84:
 228:./tmk_core/common/action.c ****                         } else {
 939               		.loc 1 228 0 is_stmt 1
 940 008e 8C2F      		mov r24,r28
 941 0090 0E94 0000 		call add_mods
 942               	.LVL83:
 943 0094 00C0      		rjmp .L86
 944               	.L85:
 230:./tmk_core/common/action.c ****                         }
 945               		.loc 1 230 0
 946 0096 8C2F      		mov r24,r28
 947 0098 0E94 0000 		call add_weak_mods
 948               	.LVL84:
 949               	.L86:
 232:./tmk_core/common/action.c ****                     }
 950               		.loc 1 232 0
 951 009c 0E94 0000 		call send_keyboard_report
 952               	.LVL85:
 953 00a0 00C0      		rjmp .L188
 954               	.L82:
 236:./tmk_core/common/action.c ****                     if (mods) {
 955               		.loc 1 236 0
 956 00a2 8D2F      		mov r24,r29
 957 00a4 0E94 0000 		call unregister_code
 958               	.LVL86:
 237:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 959               		.loc 1 237 0
 960 00a8 CC23      		tst r28
 961 00aa 01F4      		brne .+2
 962 00ac 00C0      		rjmp .L70
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 963               		.loc 1 238 0
 964 00ae 80E2      		ldi r24,lo8(32)
 965 00b0 8D0F      		add r24,r29
 966 00b2 8830      		cpi r24,lo8(8)
 967 00b4 00F0      		brlo .L88
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 968               		.loc 1 238 0 is_stmt 0 discriminator 1
 969 00b6 D111      		cpse r29,__zero_reg__
 970 00b8 00C0      		rjmp .L89
 971               	.L88:
 239:./tmk_core/common/action.c ****                         } else {
 972               		.loc 1 239 0 is_stmt 1
 973 00ba 8C2F      		mov r24,r28
 974 00bc 0E94 0000 		call del_mods
 975               	.LVL87:
 976 00c0 00C0      		rjmp .L90
 977               	.L89:
 241:./tmk_core/common/action.c ****                         }
 978               		.loc 1 241 0
 979 00c2 8C2F      		mov r24,r28
 980 00c4 0E94 0000 		call del_weak_mods
 981               	.LVL88:
 982               	.L90:
 243:./tmk_core/common/action.c ****                     }
 983               		.loc 1 243 0
 984 00c8 0E94 0000 		call send_keyboard_report
 985               	.LVL89:
 986 00cc 00C0      		rjmp .L70
 987               	.LVL90:
 988               	.L73:
 989               	.LBE76:
 990               	.LBB77:
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 991               		.loc 1 252 0
 992 00ce 8C2F      		mov r24,r28
 993 00d0 807F      		andi r24,lo8(-16)
 994 00d2 CF70      		andi r28,lo8(15)
 995               	.LVL91:
 996 00d4 8032      		cpi r24,lo8(32)
 997 00d6 01F0      		breq .L92
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 998               		.loc 1 252 0 is_stmt 0 discriminator 2
 999 00d8 C295      		swap r28
 1000 00da C07F      		andi r28,lo8(-16)
 1001               	.L92:
 1002               	.LVL92:
 254:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 1003               		.loc 1 254 0 is_stmt 1 discriminator 4
 1004 00dc DD23      		tst r29
 1005 00de 01F0      		breq .L94
 1006 00e0 D130      		cpi r29,lo8(1)
 1007 00e2 01F0      		breq .L95
 1008 00e4 00C0      		rjmp .L197
 1009               	.L94:
 258:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 1010               		.loc 1 258 0
 1011 00e6 1123      		tst r17
 1012 00e8 01F0      		breq .L96
 259:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 1013               		.loc 1 259 0
 1014 00ea 0023      		tst r16
 1015 00ec 01F0      		breq .L98
 262:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1016               		.loc 1 262 0
 1017 00ee 0130      		cpi r16,lo8(1)
 1018 00f0 01F4      		brne .L98
 264:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1019               		.loc 1 264 0
 1020 00f2 0E94 0000 		call get_oneshot_mods
 1021               	.LVL93:
 1022 00f6 8C2B      		or r24,r28
 1023 00f8 0E94 0000 		call set_oneshot_mods
 1024               	.LVL94:
 1025 00fc 00C0      		rjmp .L70
 1026               	.L98:
 273:./tmk_core/common/action.c ****                             }
 1027               		.loc 1 273 0
 1028 00fe 0E94 0000 		call get_oneshot_mods
 1029               	.LVL95:
 1030 0102 8C2B      		or r24,r28
 1031 0104 00C0      		rjmp .L189
 1032               	.L96:
 276:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1033               		.loc 1 276 0
 1034 0106 0023      		tst r16
 1035 0108 01F0      		breq .L196
 279:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1036               		.loc 1 279 0
 1037 010a 0130      		cpi r16,lo8(1)
 1038 010c 01F4      		brne .+2
 1039 010e 00C0      		rjmp .L70
 1040               	.L196:
 291:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1041               		.loc 1 291 0
 1042 0110 0E94 0000 		call clear_oneshot_mods
 1043               	.LVL96:
 1044 0114 00C0      		rjmp .L105
 1045               	.L95:
 298:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1046               		.loc 1 298 0
 1047 0116 1123      		tst r17
 1048 0118 01F0      		breq .L101
 299:./tmk_core/common/action.c ****                                 register_mods(mods);
 1049               		.loc 1 299 0
 1050 011a 0630      		cpi r16,lo8(6)
 1051 011c 00F0      		brlo .+2
 1052 011e 00C0      		rjmp .L70
 1053 0120 00C0      		rjmp .L103
 1054               	.L101:
 303:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1055               		.loc 1 303 0
 1056 0122 0530      		cpi r16,lo8(5)
 1057 0124 00F0      		brlo .+2
 1058 0126 00C0      		rjmp .L70
 1059 0128 00C0      		rjmp .L105
 1060               	.L197:
 309:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 1061               		.loc 1 309 0
 1062 012a 1123      		tst r17
 1063 012c 01F0      		breq .L102
 310:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1064               		.loc 1 310 0
 1065 012e 0023      		tst r16
 1066 0130 01F0      		breq .L103
 312:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1067               		.loc 1 312 0
 1068 0132 F701      		movw r30,r14
 1069 0134 8581      		ldd r24,Z+5
 1070 0136 80FF      		sbrs r24,0
 1071 0138 00C0      		rjmp .L188
 315:./tmk_core/common/action.c ****                                     register_mods(mods);
 1072               		.loc 1 315 0
 1073 013a 8F70      		andi r24,lo8(15)
 1074 013c 8583      		std Z+5,r24
 1075               	.L103:
 325:./tmk_core/common/action.c ****                             }
 1076               		.loc 1 325 0
 1077 013e 8C2F      		mov r24,r28
 1078 0140 00C0      		rjmp .L189
 1079               	.L102:
 328:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1080               		.loc 1 328 0
 1081 0142 0111      		cpse r16,__zero_reg__
 1082 0144 00C0      		rjmp .L150
 1083               	.L105:
 333:./tmk_core/common/action.c ****                             }
 1084               		.loc 1 333 0
 1085 0146 8C2F      		mov r24,r28
 1086 0148 00C0      		rjmp .L190
 1087               	.LVL97:
 1088               	.L74:
 1089               	.LBE77:
 344:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1090               		.loc 1 344 0
 1091 014a 8C2F      		mov r24,r28
 1092 014c 8695      		lsr r24
 1093 014e 8695      		lsr r24
 1094 0150 8370      		andi r24,lo8(3)
 1095 0152 01F0      		breq .L106
 1096 0154 8130      		cpi r24,lo8(1)
 1097 0156 01F0      		breq .L107
 1098 0158 00C0      		rjmp .L70
 1099               	.L106:
 346:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1100               		.loc 1 346 0
 1101 015a 1123      		tst r17
 1102 015c 01F0      		breq .L108
 347:./tmk_core/common/action.c ****                     } else {
 1103               		.loc 1 347 0
 1104 015e 8D2F      		mov r24,r29
 1105 0160 9C2F      		mov r25,r28
 1106 0162 9370      		andi r25,lo8(3)
 1107 0164 00C0      		rjmp .L193
 1108               	.L108:
 349:./tmk_core/common/action.c ****                     }
 1109               		.loc 1 349 0
 1110 0166 80E0      		ldi r24,0
 1111 0168 90E0      		ldi r25,0
 1112               	.L193:
 1113 016a 0E94 0000 		call host_system_send
 1114               	.LVL98:
 1115 016e 00C0      		rjmp .L151
 1116               	.L107:
 353:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1117               		.loc 1 353 0
 1118 0170 1123      		tst r17
 1119 0172 01F0      		breq .L110
 354:./tmk_core/common/action.c ****                     } else {
 1120               		.loc 1 354 0
 1121 0174 8D2F      		mov r24,r29
 1122 0176 9C2F      		mov r25,r28
 1123 0178 9370      		andi r25,lo8(3)
 1124 017a 00C0      		rjmp .L194
 1125               	.L110:
 356:./tmk_core/common/action.c ****                     }
 1126               		.loc 1 356 0
 1127 017c 80E0      		ldi r24,0
 1128 017e 90E0      		ldi r25,0
 1129               	.L194:
 1130 0180 0E94 0000 		call host_consumer_send
 1131               	.LVL99:
 1132 0184 00C0      		rjmp .L151
 1133               	.L75:
 365:./tmk_core/common/action.c ****                 switch (action.key.code) {
 1134               		.loc 1 365 0
 1135 0186 1123      		tst r17
 1136 0188 01F0      		breq .L111
 366:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1137               		.loc 1 366 0
 1138 018a D53F      		cpi r29,lo8(-11)
 1139 018c 01F0      		breq .L113
 1140 018e D63F      		cpi r29,lo8(-10)
 1141 0190 01F0      		breq .L114
 1142 0192 D43F      		cpi r29,lo8(-12)
 1143 0194 01F4      		brne .L112
 368:./tmk_core/common/action.c ****                         break;
 1144               		.loc 1 368 0
 1145 0196 8091 0000 		lds r24,tp_buttons
 1146 019a 9091 0000 		lds r25,tp_buttons+1
 1147 019e 8160      		ori r24,1
 1148 01a0 00C0      		rjmp .L186
 1149               	.L113:
 371:./tmk_core/common/action.c ****                         break;
 1150               		.loc 1 371 0
 1151 01a2 8091 0000 		lds r24,tp_buttons
 1152 01a6 9091 0000 		lds r25,tp_buttons+1
 1153 01aa 8260      		ori r24,2
 1154 01ac 00C0      		rjmp .L186
 1155               	.L114:
 374:./tmk_core/common/action.c ****                         break;
 1156               		.loc 1 374 0
 1157 01ae 8091 0000 		lds r24,tp_buttons
 1158 01b2 9091 0000 		lds r25,tp_buttons+1
 1159 01b6 8460      		ori r24,4
 1160               	.L186:
 1161 01b8 9093 0000 		sts tp_buttons+1,r25
 1162 01bc 8093 0000 		sts tp_buttons,r24
 1163               	.L112:
 379:./tmk_core/common/action.c ****                 mousekey_send();
 1164               		.loc 1 379 0
 1165 01c0 8D2F      		mov r24,r29
 1166 01c2 0E94 0000 		call mousekey_on
 1167               	.LVL100:
 1168 01c6 00C0      		rjmp .L195
 1169               	.L111:
 382:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1170               		.loc 1 382 0
 1171 01c8 D53F      		cpi r29,lo8(-11)
 1172 01ca 01F0      		breq .L117
 1173 01cc D63F      		cpi r29,lo8(-10)
 1174 01ce 01F0      		breq .L118
 1175 01d0 D43F      		cpi r29,lo8(-12)
 1176 01d2 01F4      		brne .L116
 384:./tmk_core/common/action.c ****                         break;
 1177               		.loc 1 384 0
 1178 01d4 8091 0000 		lds r24,tp_buttons
 1179 01d8 9091 0000 		lds r25,tp_buttons+1
 1180 01dc 8E7F      		andi r24,254
 1181 01de 00C0      		rjmp .L187
 1182               	.L117:
 387:./tmk_core/common/action.c ****                         break;
 1183               		.loc 1 387 0
 1184 01e0 8091 0000 		lds r24,tp_buttons
 1185 01e4 9091 0000 		lds r25,tp_buttons+1
 1186 01e8 8D7F      		andi r24,253
 1187 01ea 00C0      		rjmp .L187
 1188               	.L118:
 390:./tmk_core/common/action.c ****                         break;
 1189               		.loc 1 390 0
 1190 01ec 8091 0000 		lds r24,tp_buttons
 1191 01f0 9091 0000 		lds r25,tp_buttons+1
 1192 01f4 8B7F      		andi r24,251
 1193               	.L187:
 1194 01f6 9093 0000 		sts tp_buttons+1,r25
 1195 01fa 8093 0000 		sts tp_buttons,r24
 1196               	.L116:
 395:./tmk_core/common/action.c ****                 mousekey_send();
 1197               		.loc 1 395 0
 1198 01fe 8D2F      		mov r24,r29
 1199 0200 0E94 0000 		call mousekey_off
 1200               	.LVL101:
 1201               	.L195:
 396:./tmk_core/common/action.c ****             }
 1202               		.loc 1 396 0
 1203 0204 0E94 0000 		call mousekey_send
 1204               	.LVL102:
 1205 0208 00C0      		rjmp .L151
 1206               	.L76:
 402:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1207               		.loc 1 402 0
 1208 020a 8C2F      		mov r24,r28
 1209 020c 8370      		andi r24,lo8(3)
 1210 020e 01F0      		breq .+2
 1211 0210 00C0      		rjmp .L120
 404:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1212               		.loc 1 404 0
 1213 0212 1111      		cpse r17,__zero_reg__
 1214 0214 00C0      		rjmp .L152
 1215               	.LVL103:
 1216               	.LBB78:
 405:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1217               		.loc 1 405 0
 1218 0216 2D2F      		mov r18,r29
 1219 0218 2295      		swap r18
 1220 021a 2695      		lsr r18
 1221 021c 2770      		andi r18,lo8(7)
 406:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1222               		.loc 1 406 0
 1223 021e 220F      		lsl r18
 1224 0220 220F      		lsl r18
 1225 0222 6D2F      		mov r22,r29
 1226 0224 6F70      		andi r22,lo8(15)
 1227 0226 862F      		mov r24,r22
 1228 0228 90E0      		ldi r25,0
 1229 022a A0E0      		ldi r26,0
 1230 022c B0E0      		ldi r27,0
 1231 022e 4C01      		movw r8,r24
 1232 0230 5D01      		movw r10,r26
 1233 0232 022E      		mov r0,r18
 1234 0234 00C0      		rjmp 2f
 1235               		1:
 1236 0236 880C      		lsl r8
 1237 0238 991C      		rol r9
 1238 023a AA1C      		rol r10
 1239 023c BB1C      		rol r11
 1240               		2:
 1241 023e 0A94      		dec r0
 1242 0240 02F4      		brpl 1b
 1243               	.LVL104:
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1244               		.loc 1 407 0
 1245 0242 D4FF      		sbrs r29,4
 1246 0244 00C0      		rjmp .L159
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1247               		.loc 1 407 0 is_stmt 0 discriminator 1
 1248 0246 8FE0      		ldi r24,lo8(15)
 1249 0248 90E0      		ldi r25,0
 1250 024a A0E0      		ldi r26,0
 1251 024c B0E0      		ldi r27,0
 1252 024e 00C0      		rjmp 2f
 1253               		1:
 1254 0250 880F      		lsl r24
 1255 0252 991F      		rol r25
 1256 0254 AA1F      		rol r26
 1257 0256 BB1F      		rol r27
 1258               		2:
 1259 0258 2A95      		dec r18
 1260 025a 02F4      		brpl 1b
 1261 025c BC01      		movw r22,r24
 1262 025e CD01      		movw r24,r26
 1263 0260 6095      		com r22
 1264 0262 7095      		com r23
 1265 0264 8095      		com r24
 1266 0266 9095      		com r25
 1267 0268 00C0      		rjmp .L122
 1268               	.L159:
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1269               		.loc 1 407 0
 1270 026a 60E0      		ldi r22,0
 1271 026c 70E0      		ldi r23,0
 1272 026e CB01      		movw r24,r22
 1273               	.L122:
 1274               	.LVL105:
 408:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1275               		.loc 1 408 0 is_stmt 1 discriminator 4
 1276 0270 C695      		lsr r28
 1277 0272 C695      		lsr r28
 1278               	.LVL106:
 1279 0274 C370      		andi r28,lo8(3)
 1280 0276 C230      		cpi r28,lo8(2)
 1281 0278 01F0      		breq .L124
 1282 027a 00F4      		brsh .L125
 1283 027c 6829      		or r22,r8
 1284 027e 7929      		or r23,r9
 1285 0280 8A29      		or r24,r10
 1286 0282 9B29      		or r25,r11
 1287               	.LVL107:
 1288 0284 C130      		cpi r28,lo8(1)
 1289 0286 01F0      		breq .L192
 409:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1290               		.loc 1 409 0 discriminator 4
 1291 0288 0E94 0000 		call default_layer_and
 1292               	.LVL108:
 1293 028c 00C0      		rjmp .L152
 1294               	.LVL109:
 1295               	.L124:
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1296               		.loc 1 411 0
 1297 028e 6829      		or r22,r8
 1298 0290 7929      		or r23,r9
 1299 0292 8A29      		or r24,r10
 1300 0294 9B29      		or r25,r11
 1301               	.LVL110:
 1302 0296 0E94 0000 		call default_layer_xor
 1303               	.LVL111:
 1304 029a 00C0      		rjmp .L152
 1305               	.LVL112:
 1306               	.L125:
 412:./tmk_core/common/action.c ****                     }
 1307               		.loc 1 412 0
 1308 029c 0E94 0000 		call default_layer_and
 1309               	.LVL113:
 1310 02a0 C501      		movw r24,r10
 1311 02a2 B401      		movw r22,r8
 1312               	.L192:
 1313 02a4 0E94 0000 		call default_layer_or
 1314               	.LVL114:
 1315 02a8 00C0      		rjmp .L152
 1316               	.LVL115:
 1317               	.L120:
 1318               	.LBE78:
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1319               		.loc 1 417 0
 1320 02aa 1123      		tst r17
 1321 02ac 01F0      		breq .L127
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1322               		.loc 1 417 0 is_stmt 0 discriminator 1
 1323 02ae 8C2F      		mov r24,r28
 1324 02b0 8170      		andi r24,lo8(1)
 1325 02b2 00C0      		rjmp .L128
 1326               	.L127:
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1327               		.loc 1 417 0 discriminator 2
 1328 02b4 8695      		lsr r24
 1329               	.L128:
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1330               		.loc 1 417 0 discriminator 4
 1331 02b6 8823      		tst r24
 1332 02b8 01F4      		brne .+2
 1333 02ba 00C0      		rjmp .L152
 1334               	.LVL116:
 1335               	.LBB79:
 419:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1336               		.loc 1 419 0 is_stmt 1
 1337 02bc 2D2F      		mov r18,r29
 1338 02be 2295      		swap r18
 1339 02c0 2695      		lsr r18
 1340 02c2 2770      		andi r18,lo8(7)
 420:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1341               		.loc 1 420 0
 1342 02c4 220F      		lsl r18
 1343 02c6 220F      		lsl r18
 1344 02c8 6D2F      		mov r22,r29
 1345 02ca 6F70      		andi r22,lo8(15)
 1346 02cc 862F      		mov r24,r22
 1347 02ce 90E0      		ldi r25,0
 1348 02d0 A0E0      		ldi r26,0
 1349 02d2 B0E0      		ldi r27,0
 1350 02d4 4C01      		movw r8,r24
 1351 02d6 5D01      		movw r10,r26
 1352 02d8 022E      		mov r0,r18
 1353 02da 00C0      		rjmp 2f
 1354               		1:
 1355 02dc 880C      		lsl r8
 1356 02de 991C      		rol r9
 1357 02e0 AA1C      		rol r10
 1358 02e2 BB1C      		rol r11
 1359               		2:
 1360 02e4 0A94      		dec r0
 1361 02e6 02F4      		brpl 1b
 1362               	.LVL117:
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1363               		.loc 1 421 0
 1364 02e8 D4FF      		sbrs r29,4
 1365 02ea 00C0      		rjmp .L160
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1366               		.loc 1 421 0 is_stmt 0 discriminator 1
 1367 02ec 8FE0      		ldi r24,lo8(15)
 1368 02ee 90E0      		ldi r25,0
 1369 02f0 A0E0      		ldi r26,0
 1370 02f2 B0E0      		ldi r27,0
 1371 02f4 00C0      		rjmp 2f
 1372               		1:
 1373 02f6 880F      		lsl r24
 1374 02f8 991F      		rol r25
 1375 02fa AA1F      		rol r26
 1376 02fc BB1F      		rol r27
 1377               		2:
 1378 02fe 2A95      		dec r18
 1379 0300 02F4      		brpl 1b
 1380 0302 BC01      		movw r22,r24
 1381 0304 CD01      		movw r24,r26
 1382 0306 6095      		com r22
 1383 0308 7095      		com r23
 1384 030a 8095      		com r24
 1385 030c 9095      		com r25
 1386 030e 00C0      		rjmp .L129
 1387               	.L160:
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1388               		.loc 1 421 0
 1389 0310 60E0      		ldi r22,0
 1390 0312 70E0      		ldi r23,0
 1391 0314 CB01      		movw r24,r22
 1392               	.L129:
 1393               	.LVL118:
 422:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1394               		.loc 1 422 0 is_stmt 1 discriminator 4
 1395 0316 C695      		lsr r28
 1396 0318 C695      		lsr r28
 1397               	.LVL119:
 1398 031a C370      		andi r28,lo8(3)
 1399 031c C230      		cpi r28,lo8(2)
 1400 031e 01F0      		breq .L131
 1401 0320 00F4      		brsh .L132
 1402 0322 6829      		or r22,r8
 1403 0324 7929      		or r23,r9
 1404 0326 8A29      		or r24,r10
 1405 0328 9B29      		or r25,r11
 1406               	.LVL120:
 1407 032a C130      		cpi r28,lo8(1)
 1408 032c 01F0      		breq .L191
 423:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1409               		.loc 1 423 0 discriminator 4
 1410 032e 0E94 0000 		call layer_and
 1411               	.LVL121:
 1412 0332 00C0      		rjmp .L152
 1413               	.LVL122:
 1414               	.L131:
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1415               		.loc 1 425 0
 1416 0334 6829      		or r22,r8
 1417 0336 7929      		or r23,r9
 1418 0338 8A29      		or r24,r10
 1419 033a 9B29      		or r25,r11
 1420               	.LVL123:
 1421 033c 0E94 0000 		call layer_xor
 1422               	.LVL124:
 1423 0340 00C0      		rjmp .L152
 1424               	.LVL125:
 1425               	.L132:
 426:./tmk_core/common/action.c ****                     }
 1426               		.loc 1 426 0
 1427 0342 0E94 0000 		call layer_and
 1428               	.LVL126:
 1429 0346 C501      		movw r24,r10
 1430 0348 B401      		movw r22,r8
 1431               	.L191:
 1432 034a 0E94 0000 		call layer_or
 1433               	.LVL127:
 1434 034e 00C0      		rjmp .L152
 1435               	.LVL128:
 1436               	.L77:
 1437               	.LBE79:
 434:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 1438               		.loc 1 434 0
 1439 0350 8D2F      		mov r24,r29
 1440 0352 90E0      		ldi r25,0
 1441 0354 FC01      		movw r30,r24
 1442 0356 E05E      		subi r30,-32
 1443 0358 F109      		sbc r31,__zero_reg__
 1444 035a E531      		cpi r30,21
 1445 035c F105      		cpc r31,__zero_reg__
 1446 035e 00F0      		brlo .+2
 1447 0360 00C0      		rjmp .L134
 1448 0362 E050      		subi r30,lo8(-(gs(.L136)))
 1449 0364 F040      		sbci r31,hi8(-(gs(.L136)))
 1450 0366 0C94 0000 		jmp __tablejump2__
 1451               		.section	.progmem.gcc_sw_table.process_action
 1452               		.p2align	1
 1453               	.L136:
 1454 0020 0000      		.word gs(.L135)
 1455 0022 0000      		.word gs(.L135)
 1456 0024 0000      		.word gs(.L135)
 1457 0026 0000      		.word gs(.L135)
 1458 0028 0000      		.word gs(.L135)
 1459 002a 0000      		.word gs(.L135)
 1460 002c 0000      		.word gs(.L135)
 1461 002e 0000      		.word gs(.L135)
 1462 0030 0000      		.word gs(.L135)
 1463 0032 0000      		.word gs(.L135)
 1464 0034 0000      		.word gs(.L135)
 1465 0036 0000      		.word gs(.L135)
 1466 0038 0000      		.word gs(.L135)
 1467 003a 0000      		.word gs(.L135)
 1468 003c 0000      		.word gs(.L135)
 1469 003e 0000      		.word gs(.L135)
 1470 0040 0000      		.word gs(.L137)
 1471 0042 0000      		.word gs(.L138)
 1472 0044 0000      		.word gs(.L139)
 1473 0046 0000      		.word gs(.L140)
 1474 0048 0000      		.word gs(.L141)
 1475               		.section	.text.process_action
 1476               	.L135:
 1477 036a DF70      		andi r29,lo8(15)
 1478               	.LVL129:
 1479 036c 8C2F      		mov r24,r28
 1480 036e 8F71      		andi r24,lo8(31)
 437:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1481               		.loc 1 437 0
 1482 0370 1123      		tst r17
 1483 0372 01F0      		breq .L142
 438:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 1484               		.loc 1 438 0
 1485 0374 0E94 0000 		call layer_on
 1486               	.LVL130:
 439:./tmk_core/common/action.c ****                     } else {
 1487               		.loc 1 439 0
 1488 0378 8D2F      		mov r24,r29
 1489               	.LVL131:
 1490               	.L189:
 1491 037a 0E94 0000 		call register_mods
 1492               	.LVL132:
 1493 037e 00C0      		rjmp .L70
 1494               	.LVL133:
 1495               	.L142:
 441:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 1496               		.loc 1 441 0
 1497 0380 0E94 0000 		call layer_off
 1498               	.LVL134:
 442:./tmk_core/common/action.c ****                     }
 1499               		.loc 1 442 0
 1500 0384 8D2F      		mov r24,r29
 1501               	.LVL135:
 1502               	.L190:
 1503 0386 0E94 0000 		call unregister_mods
 1504               	.LVL136:
 1505 038a 00C0      		rjmp .L70
 1506               	.L137:
 447:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1507               		.loc 1 447 0
 1508 038c 1123      		tst r17
 1509 038e 01F0      		breq .L143
 448:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1510               		.loc 1 448 0
 1511 0390 0530      		cpi r16,lo8(5)
 1512 0392 00F0      		brlo .+2
 1513 0394 00C0      		rjmp .L70
 1514               	.L144:
 449:./tmk_core/common/action.c ****                         }
 1515               		.loc 1 449 0
 1516 0396 8C2F      		mov r24,r28
 1517 0398 8F71      		andi r24,lo8(31)
 1518 039a 0E94 0000 		call layer_invert
 1519               	.LVL137:
 1520 039e 00C0      		rjmp .L70
 1521               	.L143:
 452:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1522               		.loc 1 452 0
 1523 03a0 0630      		cpi r16,lo8(6)
 1524 03a2 00F0      		brlo .+2
 1525 03a4 00C0      		rjmp .L70
 1526 03a6 00C0      		rjmp .L144
 1527               	.L138:
 458:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1528               		.loc 1 458 0
 1529 03a8 1123      		tst r17
 1530 03aa 01F0      		breq .L145
 1531               	.L146:
 458:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1532               		.loc 1 458 0 is_stmt 0 discriminator 1
 1533 03ac 8C2F      		mov r24,r28
 1534 03ae 8F71      		andi r24,lo8(31)
 1535 03b0 0E94 0000 		call layer_on
 1536               	.LVL138:
 1537 03b4 00C0      		rjmp .L70
 1538               	.L139:
 462:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1539               		.loc 1 462 0 is_stmt 1
 1540 03b6 1123      		tst r17
 1541 03b8 01F0      		breq .L146
 1542               	.L145:
 459:./tmk_core/common/action.c ****                     break;
 1543               		.loc 1 459 0
 1544 03ba 8C2F      		mov r24,r28
 1545 03bc 8F71      		andi r24,lo8(31)
 1546 03be 0E94 0000 		call layer_off
 1547               	.LVL139:
 1548 03c2 00C0      		rjmp .L70
 1549               	.L140:
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1550               		.loc 1 466 0
 1551 03c4 1123      		tst r17
 1552 03c6 01F0      		breq .L147
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1553               		.loc 1 466 0 is_stmt 0 discriminator 1
 1554 03c8 8C2F      		mov r24,r28
 1555 03ca 8F71      		andi r24,lo8(31)
 1556 03cc 0E94 0000 		call layer_move
 1557               	.LVL140:
 1558 03d0 00C0      		rjmp .L70
 1559               	.L147:
 467:./tmk_core/common/action.c ****                     break;
 1560               		.loc 1 467 0 is_stmt 1
 1561 03d2 0E94 0000 		call layer_clear
 1562               	.LVL141:
 1563 03d6 00C0      		rjmp .L70
 1564               	.L141:
 495:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1565               		.loc 1 495 0
 1566 03d8 1123      		tst r17
 1567 03da 01F0      		breq .L148
 496:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1568               		.loc 1 496 0
 1569 03dc CF71      		andi r28,lo8(31)
 1570               	.LVL142:
 1571 03de 8C2F      		mov r24,r28
 1572 03e0 0E94 0000 		call layer_on
 1573               	.LVL143:
 497:./tmk_core/common/action.c ****                     } else {
 1574               		.loc 1 497 0
 1575 03e4 63E0      		ldi r22,lo8(3)
 1576 03e6 8C2F      		mov r24,r28
 1577 03e8 0E94 0000 		call set_oneshot_layer
 1578               	.LVL144:
 1579 03ec 00C0      		rjmp .L70
 1580               	.LVL145:
 1581               	.L148:
 499:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 1582               		.loc 1 499 0
 1583 03ee 81E0      		ldi r24,lo8(1)
 1584 03f0 0E94 0000 		call clear_oneshot_layer_state
 1585               	.LVL146:
 500:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1586               		.loc 1 500 0
 1587 03f4 0230      		cpi r16,lo8(2)
 1588 03f6 00F0      		brlo .L70
 501:./tmk_core/common/action.c ****                         }
 1589               		.loc 1 501 0
 1590 03f8 82E0      		ldi r24,lo8(2)
 1591 03fa 0E94 0000 		call clear_oneshot_layer_state
 1592               	.LVL147:
 1593 03fe 00C0      		rjmp .L70
 1594               	.L134:
 509:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 1595               		.loc 1 509 0
 1596 0400 1123      		tst r17
 1597 0402 01F0      		breq .L149
 510:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1598               		.loc 1 510 0
 1599 0404 0023      		tst r16
 1600 0406 01F0      		breq .L146
 1601               	.L188:
 512:./tmk_core/common/action.c ****                         } else {
 1602               		.loc 1 512 0
 1603 0408 8D2F      		mov r24,r29
 1604 040a 0E94 0000 		call register_code
 1605               	.LVL148:
 1606 040e 00C0      		rjmp .L70
 1607               	.L149:
 518:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1608               		.loc 1 518 0
 1609 0410 0023      		tst r16
 1610 0412 01F0      		breq .L145
 520:./tmk_core/common/action.c ****                                 wait_ms(80);
 1611               		.loc 1 520 0
 1612 0414 D933      		cpi r29,lo8(57)
 1613 0416 01F4      		brne .L150
 1614               	.LVL149:
 1615               	.LBB80:
 1616               	.LBB81:
 1617               		.loc 3 187 0
 1618 0418 FFEF      		ldi r31,lo8(255999)
 1619 041a 27EE      		ldi r18,hi8(255999)
 1620 041c 83E0      		ldi r24,hlo8(255999)
 1621 041e F150      	1:	subi r31,1
 1622 0420 2040      		sbci r18,0
 1623 0422 8040      		sbci r24,0
 1624 0424 01F4      		brne 1b
 1625 0426 00C0      		rjmp .
 1626 0428 0000      		nop
 1627               	.LVL150:
 1628               	.L150:
 1629               	.LBE81:
 1630               	.LBE80:
 523:./tmk_core/common/action.c ****                         } else {
 1631               		.loc 1 523 0
 1632 042a 8D2F      		mov r24,r29
 1633 042c 0E94 0000 		call unregister_code
 1634               	.LVL151:
 1635 0430 00C0      		rjmp .L70
 1636               	.L78:
 537:./tmk_core/common/action.c ****             break;
 1637               		.loc 1 537 0
 1638 0432 4C2F      		mov r20,r28
 1639 0434 4F70      		andi r20,lo8(15)
 1640 0436 6D2F      		mov r22,r29
 1641 0438 C701      		movw r24,r14
 1642 043a 0E94 0000 		call action_get_macro
 1643               	.LVL152:
 1644 043e 0E94 0000 		call action_macro_play
 1645               	.LVL153:
 538:./tmk_core/common/action.c **** #endif
 1646               		.loc 1 538 0
 1647 0442 00C0      		rjmp .L151
 1648               	.L79:
 632:./tmk_core/common/action.c ****             break;
 1649               		.loc 1 632 0
 1650 0444 4C2F      		mov r20,r28
 1651 0446 4F70      		andi r20,lo8(15)
 1652 0448 6D2F      		mov r22,r29
 1653 044a C701      		movw r24,r14
 1654 044c 0E94 0000 		call action_function
 1655               	.LVL154:
 633:./tmk_core/common/action.c **** #endif
 1656               		.loc 1 633 0
 1657 0450 00C0      		rjmp .L151
 1658               	.L70:
 641:./tmk_core/common/action.c ****         case ACT_LAYER:
 1659               		.loc 1 641 0
 1660 0452 98E0      		ldi r25,lo8(8)
 1661 0454 B916      		cp r11,r25
 1662 0456 01F0      		breq .L152
 1663 0458 B916      		cp r11,r25
 1664 045a 00F0      		brlo .L151
 1665 045c 86EF      		ldi r24,lo8(-10)
 1666 045e 8B0D      		add r24,r11
 1667 0460 8230      		cpi r24,lo8(2)
 1668 0462 00F4      		brsh .L151
 1669               	.L152:
 647:./tmk_core/common/action.c ****             break;
 1670               		.loc 1 647 0
 1671 0464 0E94 0000 		call host_keyboard_leds
 1672               	.LVL155:
 1673 0468 0E94 0000 		call led_set
 1674               	.LVL156:
 1675               	.L151:
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 1676               		.loc 1 684 0
 1677 046c DD20      		tst r13
 1678 046e 01F0      		breq .L67
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 1679               		.loc 1 684 0 is_stmt 0 discriminator 1
 1680 0470 0E94 0000 		call get_oneshot_layer_state
 1681               	.LVL157:
 1682 0474 80FD      		sbrc r24,0
 1683 0476 00C0      		rjmp .L67
 685:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1684               		.loc 1 685 0 is_stmt 1
 1685 0478 F701      		movw r30,r14
 1686 047a 1282      		std Z+2,__zero_reg__
 686:./tmk_core/common/action.c ****         process_record(record);
 1687               		.loc 1 686 0
 1688 047c 0E94 0000 		call get_oneshot_layer
 1689               	.LVL158:
 1690 0480 0E94 0000 		call layer_on
 1691               	.LVL159:
 687:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1692               		.loc 1 687 0
 1693 0484 C701      		movw r24,r14
 1694 0486 0E94 0000 		call process_record
 1695               	.LVL160:
 688:./tmk_core/common/action.c ****     }
 1696               		.loc 1 688 0
 1697 048a 0E94 0000 		call get_oneshot_layer
 1698               	.LVL161:
 1699               	/* epilogue start */
 691:./tmk_core/common/action.c **** 
 1700               		.loc 1 691 0
 1701 048e DF91      		pop r29
 1702               	.LVL162:
 1703 0490 CF91      		pop r28
 1704 0492 1F91      		pop r17
 1705               	.LVL163:
 1706 0494 0F91      		pop r16
 1707               	.LVL164:
 1708 0496 FF90      		pop r15
 1709 0498 EF90      		pop r14
 1710               	.LVL165:
 1711 049a DF90      		pop r13
 1712               	.LVL166:
 1713 049c BF90      		pop r11
 1714 049e AF90      		pop r10
 1715 04a0 9F90      		pop r9
 1716 04a2 8F90      		pop r8
 688:./tmk_core/common/action.c ****     }
 1717               		.loc 1 688 0
 1718 04a4 0C94 0000 		jmp layer_off
 1719               	.LVL167:
 1720               	.L67:
 1721               	/* epilogue start */
 691:./tmk_core/common/action.c **** 
 1722               		.loc 1 691 0
 1723 04a8 DF91      		pop r29
 1724               	.LVL168:
 1725 04aa CF91      		pop r28
 1726 04ac 1F91      		pop r17
 1727               	.LVL169:
 1728 04ae 0F91      		pop r16
 1729               	.LVL170:
 1730 04b0 FF90      		pop r15
 1731 04b2 EF90      		pop r14
 1732               	.LVL171:
 1733 04b4 DF90      		pop r13
 1734               	.LVL172:
 1735 04b6 BF90      		pop r11
 1736 04b8 AF90      		pop r10
 1737 04ba 9F90      		pop r9
 1738 04bc 8F90      		pop r8
 1739 04be 0895      		ret
 1740               		.cfi_endproc
 1741               	.LFE18:
 1743               		.section	.text.process_record,"ax",@progbits
 1744               	.global	process_record
 1746               	process_record:
 1747               	.LFB17:
 173:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1748               		.loc 1 173 0
 1749               		.cfi_startproc
 1750               	.LVL173:
 1751 0000 0F93      		push r16
 1752               	.LCFI16:
 1753               		.cfi_def_cfa_offset 3
 1754               		.cfi_offset 16, -2
 1755 0002 1F93      		push r17
 1756               	.LCFI17:
 1757               		.cfi_def_cfa_offset 4
 1758               		.cfi_offset 17, -3
 1759 0004 CF93      		push r28
 1760               	.LCFI18:
 1761               		.cfi_def_cfa_offset 5
 1762               		.cfi_offset 28, -4
 1763 0006 DF93      		push r29
 1764               	.LCFI19:
 1765               		.cfi_def_cfa_offset 6
 1766               		.cfi_offset 29, -5
 1767               	/* prologue: function */
 1768               	/* frame size = 0 */
 1769               	/* stack size = 4 */
 1770               	.L__stack_usage = 4
 1771 0008 EC01      		movw r28,r24
 1772 000a 9881      		ld r25,Y
 1773 000c 8981      		ldd r24,Y+1
 1774               	.LVL174:
 1775               	.LBB84:
 1776               	.LBB85:
 1777               		.file 4 "./tmk_core/common/keyboard.h"
   1:./tmk_core/common/keyboard.h **** /*
   2:./tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/keyboard.h **** 
   4:./tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/keyboard.h **** (at your option) any later version.
   8:./tmk_core/common/keyboard.h **** 
   9:./tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:./tmk_core/common/keyboard.h **** 
  14:./tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/keyboard.h **** */
  17:./tmk_core/common/keyboard.h **** 
  18:./tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:./tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:./tmk_core/common/keyboard.h **** 
  21:./tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:./tmk_core/common/keyboard.h **** #include <stdint.h>
  23:./tmk_core/common/keyboard.h **** 
  24:./tmk_core/common/keyboard.h **** 
  25:./tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:./tmk_core/common/keyboard.h **** extern "C" {
  27:./tmk_core/common/keyboard.h **** #endif
  28:./tmk_core/common/keyboard.h **** 
  29:./tmk_core/common/keyboard.h **** /* key matrix position */
  30:./tmk_core/common/keyboard.h **** typedef struct {
  31:./tmk_core/common/keyboard.h ****     uint8_t col;
  32:./tmk_core/common/keyboard.h ****     uint8_t row;
  33:./tmk_core/common/keyboard.h **** } keypos_t;
  34:./tmk_core/common/keyboard.h **** 
  35:./tmk_core/common/keyboard.h **** /* key event */
  36:./tmk_core/common/keyboard.h **** typedef struct {
  37:./tmk_core/common/keyboard.h ****     keypos_t key;
  38:./tmk_core/common/keyboard.h ****     bool     pressed;
  39:./tmk_core/common/keyboard.h ****     uint16_t time;
  40:./tmk_core/common/keyboard.h **** } keyevent_t;
  41:./tmk_core/common/keyboard.h **** 
  42:./tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:./tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:./tmk_core/common/keyboard.h **** 
  45:./tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:./tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:./tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:./tmk_core/common/keyboard.h ****  */
  49:./tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1778               		.loc 4 49 0
 1779 000e 2B81      		ldd r18,Y+3
 1780 0010 3C81      		ldd r19,Y+4
 1781 0012 232B      		or r18,r19
 1782 0014 01F0      		breq .L203
 1783 0016 8F3F      		cpi r24,lo8(-1)
 1784 0018 01F4      		brne .L204
 1785 001a 81E0      		ldi r24,lo8(1)
 1786 001c 9F3F      		cpi r25,lo8(-1)
 1787 001e 01F4      		brne .L204
 1788 0020 00C0      		rjmp .L199
 1789               	.L203:
 1790 0022 81E0      		ldi r24,lo8(1)
 1791 0024 00C0      		rjmp .L199
 1792               	.L204:
 1793 0026 80E0      		ldi r24,0
 1794               	.L199:
 1795               	.LBE85:
 1796               	.LBE84:
 174:./tmk_core/common/action.c **** 
 1797               		.loc 1 174 0
 1798 0028 80FD      		sbrc r24,0
 1799 002a 00C0      		rjmp .L198
 176:./tmk_core/common/action.c ****         return;
 1800               		.loc 1 176 0
 1801 002c CE01      		movw r24,r28
 1802 002e 0E94 0000 		call process_record_quantum
 1803               	.LVL175:
 1804 0032 8823      		tst r24
 1805 0034 01F0      		breq .L198
 179:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 1806               		.loc 1 179 0
 1807 0036 6881      		ld r22,Y
 1808 0038 7981      		ldd r23,Y+1
 1809 003a 8A81      		ldd r24,Y+2
 1810 003c 0E94 0000 		call store_or_get_action
 1811               	.LVL176:
 1812 0040 8C01      		movw r16,r24
 1813               	.LVL177:
 182:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 1814               		.loc 1 182 0
 1815 0042 0E94 0000 		call layer_debug
 1816               	.LVL178:
 183:./tmk_core/common/action.c **** #endif
 1817               		.loc 1 183 0
 1818 0046 0E94 0000 		call default_layer_debug
 1819               	.LVL179:
 187:./tmk_core/common/action.c **** }
 1820               		.loc 1 187 0
 1821 004a B801      		movw r22,r16
 1822 004c CE01      		movw r24,r28
 1823 004e 0E94 0000 		call process_action
 1824               	.LVL180:
 1825               	.L198:
 1826               	/* epilogue start */
 188:./tmk_core/common/action.c **** 
 1827               		.loc 1 188 0
 1828 0052 DF91      		pop r29
 1829 0054 CF91      		pop r28
 1830               	.LVL181:
 1831 0056 1F91      		pop r17
 1832 0058 0F91      		pop r16
 1833               	.LVL182:
 1834 005a 0895      		ret
 1835               		.cfi_endproc
 1836               	.LFE17:
 1838               		.section	.text.process_record_nocache,"ax",@progbits
 1839               	.global	process_record_nocache
 1841               	process_record_nocache:
 1842               	.LFB14:
 127:./tmk_core/common/action.c ****     disable_action_cache = true;
 1843               		.loc 1 127 0
 1844               		.cfi_startproc
 1845               	.LVL183:
 1846               	/* prologue: function */
 1847               	/* frame size = 0 */
 1848               	/* stack size = 0 */
 1849               	.L__stack_usage = 0
 128:./tmk_core/common/action.c ****     process_record(record);
 1850               		.loc 1 128 0
 1851 0000 21E0      		ldi r18,lo8(1)
 1852 0002 2093 0000 		sts disable_action_cache,r18
 129:./tmk_core/common/action.c ****     disable_action_cache = false;
 1853               		.loc 1 129 0
 1854 0006 0E94 0000 		call process_record
 1855               	.LVL184:
 130:./tmk_core/common/action.c **** }
 1856               		.loc 1 130 0
 1857 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 1858 000e 0895      		ret
 1859               		.cfi_endproc
 1860               	.LFE14:
 1862               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1863               	.global	clear_keyboard_but_mods
 1865               	clear_keyboard_but_mods:
 1866               	.LFB24:
 858:./tmk_core/common/action.c ****     }
 859:./tmk_core/common/action.c **** }
 860:./tmk_core/common/action.c **** 
 861:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 862:./tmk_core/common/action.c ****  *
 863:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 864:./tmk_core/common/action.c ****  */
 865:./tmk_core/common/action.c **** void clear_keyboard(void)
 866:./tmk_core/common/action.c **** {
 867:./tmk_core/common/action.c ****     clear_mods();
 868:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 869:./tmk_core/common/action.c **** }
 870:./tmk_core/common/action.c **** 
 871:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 872:./tmk_core/common/action.c ****  *
 873:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 874:./tmk_core/common/action.c ****  */
 875:./tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 876:./tmk_core/common/action.c **** {
 1867               		.loc 1 876 0
 1868               		.cfi_startproc
 1869               	/* prologue: function */
 1870               	/* frame size = 0 */
 1871               	/* stack size = 0 */
 1872               	.L__stack_usage = 0
 877:./tmk_core/common/action.c ****     clear_weak_mods();
 1873               		.loc 1 877 0
 1874 0000 0E94 0000 		call clear_weak_mods
 1875               	.LVL185:
 878:./tmk_core/common/action.c ****     clear_macro_mods();
 1876               		.loc 1 878 0
 1877 0004 0E94 0000 		call clear_macro_mods
 1878               	.LVL186:
 1879               	.LBB86:
 1880               	.LBB87:
  38:./tmk_core/common/action_util.h **** }
  39:./tmk_core/common/action_util.h **** 
  40:./tmk_core/common/action_util.h **** inline void clear_keys(void) {
  41:./tmk_core/common/action_util.h ****   clear_keys_from_report(keyboard_report);
 1881               		.loc 2 41 0
 1882 0008 8091 0000 		lds r24,keyboard_report
 1883 000c 9091 0000 		lds r25,keyboard_report+1
 1884 0010 0E94 0000 		call clear_keys_from_report
 1885               	.LVL187:
 1886               	.LBE87:
 1887               	.LBE86:
 879:./tmk_core/common/action.c ****     clear_keys();
 880:./tmk_core/common/action.c ****     send_keyboard_report();
 1888               		.loc 1 880 0
 1889 0014 0E94 0000 		call send_keyboard_report
 1890               	.LVL188:
 881:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 882:./tmk_core/common/action.c ****     mousekey_clear();
 1891               		.loc 1 882 0
 1892 0018 0E94 0000 		call mousekey_clear
 1893               	.LVL189:
 883:./tmk_core/common/action.c ****     mousekey_send();
 1894               		.loc 1 883 0
 1895 001c 0E94 0000 		call mousekey_send
 1896               	.LVL190:
 884:./tmk_core/common/action.c **** #endif
 885:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 886:./tmk_core/common/action.c ****     host_system_send(0);
 1897               		.loc 1 886 0
 1898 0020 80E0      		ldi r24,0
 1899 0022 90E0      		ldi r25,0
 1900 0024 0E94 0000 		call host_system_send
 1901               	.LVL191:
 887:./tmk_core/common/action.c ****     host_consumer_send(0);
 1902               		.loc 1 887 0
 1903 0028 80E0      		ldi r24,0
 1904 002a 90E0      		ldi r25,0
 1905 002c 0C94 0000 		jmp host_consumer_send
 1906               	.LVL192:
 1907               		.cfi_endproc
 1908               	.LFE24:
 1910               		.section	.text.clear_keyboard,"ax",@progbits
 1911               	.global	clear_keyboard
 1913               	clear_keyboard:
 1914               	.LFB23:
 866:./tmk_core/common/action.c ****     clear_mods();
 1915               		.loc 1 866 0
 1916               		.cfi_startproc
 1917               	/* prologue: function */
 1918               	/* frame size = 0 */
 1919               	/* stack size = 0 */
 1920               	.L__stack_usage = 0
 867:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1921               		.loc 1 867 0
 1922 0000 0E94 0000 		call clear_mods
 1923               	.LVL193:
 868:./tmk_core/common/action.c **** }
 1924               		.loc 1 868 0
 1925 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1926               	.LVL194:
 1927               		.cfi_endproc
 1928               	.LFE23:
 1930               		.section	.text.is_tap_key,"ax",@progbits
 1931               	.global	is_tap_key
 1933               	is_tap_key:
 1934               	.LFB25:
 888:./tmk_core/common/action.c **** #endif
 889:./tmk_core/common/action.c **** }
 890:./tmk_core/common/action.c **** 
 891:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 892:./tmk_core/common/action.c ****  *
 893:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 894:./tmk_core/common/action.c ****  */
 895:./tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 896:./tmk_core/common/action.c **** {
 1935               		.loc 1 896 0
 1936               		.cfi_startproc
 1937               	.LVL195:
 1938               	/* prologue: function */
 1939               	/* frame size = 0 */
 1940               	/* stack size = 0 */
 1941               	.L__stack_usage = 0
 897:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1942               		.loc 1 897 0
 1943 0000 0E94 0000 		call layer_switch_get_action
 1944               	.LVL196:
 898:./tmk_core/common/action.c **** 
 899:./tmk_core/common/action.c ****     switch (action.kind.id) {
 1945               		.loc 1 899 0
 1946 0004 E92F      		mov r30,r25
 1947 0006 E295      		swap r30
 1948 0008 EF70      		andi r30,lo8(15)
 1949 000a 4E2F      		mov r20,r30
 1950 000c 50E0      		ldi r21,0
 1951 000e FA01      		movw r30,r20
 1952 0010 3297      		sbiw r30,2
 1953 0012 EE30      		cpi r30,14
 1954 0014 F105      		cpc r31,__zero_reg__
 1955 0016 00F4      		brsh .L223
 1956 0018 E050      		subi r30,lo8(-(gs(.L217)))
 1957 001a F040      		sbci r31,hi8(-(gs(.L217)))
 1958 001c 0C94 0000 		jmp __tablejump2__
 1959               		.section	.progmem.gcc_sw_table.is_tap_key,"a",@progbits
 1960               		.p2align	1
 1961               	.L217:
 1962 0000 0000      		.word gs(.L216)
 1963 0002 0000      		.word gs(.L216)
 1964 0004 0000      		.word gs(.L223)
 1965 0006 0000      		.word gs(.L223)
 1966 0008 0000      		.word gs(.L218)
 1967 000a 0000      		.word gs(.L223)
 1968 000c 0000      		.word gs(.L223)
 1969 000e 0000      		.word gs(.L223)
 1970 0010 0000      		.word gs(.L216)
 1971 0012 0000      		.word gs(.L216)
 1972 0014 0000      		.word gs(.L219)
 1973 0016 0000      		.word gs(.L223)
 1974 0018 0000      		.word gs(.L223)
 1975 001a 0000      		.word gs(.L219)
 1976               		.section	.text.is_tap_key
 1977               	.L216:
 900:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 901:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 902:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 903:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 904:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1978               		.loc 1 904 0
 1979 0020 803F      		cpi r24,lo8(-16)
 1980 0022 01F0      		breq .L225
 1981 0024 00F4      		brsh .L221
 1982 0026 803E      		cpi r24,lo8(-32)
 1983 0028 00F4      		brsh .L223
 1984 002a 00C0      		rjmp .L225
 1985               	.L221:
 1986 002c 843F      		cpi r24,lo8(-12)
 1987 002e 01F4      		brne .L223
 1988 0030 00C0      		rjmp .L225
 1989               	.L218:
 905:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 906:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 907:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 908:./tmk_core/common/action.c ****                     return true;
 909:./tmk_core/common/action.c ****             }
 910:./tmk_core/common/action.c ****             return false;
 911:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 912:./tmk_core/common/action.c ****             switch (action.swap.code) {
 1990               		.loc 1 912 0
 1991 0032 803E      		cpi r24,lo8(-32)
 1992 0034 00F0      		brlo .L225
 1993 0036 813F      		cpi r24,lo8(-15)
 1994 0038 01F4      		brne .L223
 1995 003a 00C0      		rjmp .L225
 1996               	.L219:
 913:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 914:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 915:./tmk_core/common/action.c ****                     return true;
 916:./tmk_core/common/action.c ****             }
 917:./tmk_core/common/action.c ****             return false;
 918:./tmk_core/common/action.c ****         case ACT_MACRO:
 919:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 920:./tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 1997               		.loc 1 920 0
 1998 003c 93FB      		bst r25,3
 1999 003e 8827      		clr r24
 2000 0040 80F9      		bld r24,0
 2001               	.LVL197:
 2002 0042 0895      		ret
 2003               	.LVL198:
 2004               	.L223:
 921:./tmk_core/common/action.c ****             return false;
 922:./tmk_core/common/action.c ****     }
 923:./tmk_core/common/action.c ****     return false;
 2005               		.loc 1 923 0
 2006 0044 80E0      		ldi r24,0
 2007               	.LVL199:
 2008 0046 0895      		ret
 2009               	.LVL200:
 2010               	.L225:
 915:./tmk_core/common/action.c ****             }
 2011               		.loc 1 915 0
 2012 0048 81E0      		ldi r24,lo8(1)
 2013               	.LVL201:
 924:./tmk_core/common/action.c **** }
 2014               		.loc 1 924 0
 2015 004a 0895      		ret
 2016               		.cfi_endproc
 2017               	.LFE25:
 2019               		.section	.text.debug_event,"ax",@progbits
 2020               	.global	debug_event
 2022               	debug_event:
 2023               	.LFB26:
 925:./tmk_core/common/action.c **** 
 926:./tmk_core/common/action.c **** 
 927:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 928:./tmk_core/common/action.c ****  *
 929:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 930:./tmk_core/common/action.c ****  */
 931:./tmk_core/common/action.c **** void debug_event(keyevent_t event)
 932:./tmk_core/common/action.c **** {
 2024               		.loc 1 932 0
 2025               		.cfi_startproc
 2026 0000 CF93      		push r28
 2027               	.LCFI20:
 2028               		.cfi_def_cfa_offset 3
 2029               		.cfi_offset 28, -2
 2030 0002 DF93      		push r29
 2031               	.LCFI21:
 2032               		.cfi_def_cfa_offset 4
 2033               		.cfi_offset 29, -3
 2034 0004 00D0      		rcall .
 2035 0006 00D0      		rcall .
 2036 0008 1F92      		push __zero_reg__
 2037               	.LCFI22:
 2038               		.cfi_def_cfa_offset 9
 2039 000a CDB7      		in r28,__SP_L__
 2040 000c DEB7      		in r29,__SP_H__
 2041               	.LCFI23:
 2042               		.cfi_def_cfa_register 28
 2043               	/* prologue: function */
 2044               	/* frame size = 5 */
 2045               	/* stack size = 7 */
 2046               	.L__stack_usage = 7
 2047               	/* epilogue start */
 933:./tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 934:./tmk_core/common/action.c **** }
 2048               		.loc 1 934 0
 2049 000e 0F90      		pop __tmp_reg__
 2050 0010 0F90      		pop __tmp_reg__
 2051 0012 0F90      		pop __tmp_reg__
 2052 0014 0F90      		pop __tmp_reg__
 2053 0016 0F90      		pop __tmp_reg__
 2054 0018 DF91      		pop r29
 2055 001a CF91      		pop r28
 2056 001c 0895      		ret
 2057               		.cfi_endproc
 2058               	.LFE26:
 2060               		.section	.text.debug_record,"ax",@progbits
 2061               	.global	debug_record
 2063               	debug_record:
 2064               	.LFB27:
 935:./tmk_core/common/action.c **** 
 936:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 937:./tmk_core/common/action.c ****  *
 938:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 939:./tmk_core/common/action.c ****  */
 940:./tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 941:./tmk_core/common/action.c **** {
 2065               		.loc 1 941 0
 2066               		.cfi_startproc
 2067 0000 CF93      		push r28
 2068               	.LCFI24:
 2069               		.cfi_def_cfa_offset 3
 2070               		.cfi_offset 28, -2
 2071 0002 DF93      		push r29
 2072               	.LCFI25:
 2073               		.cfi_def_cfa_offset 4
 2074               		.cfi_offset 29, -3
 2075 0004 00D0      		rcall .
 2076 0006 00D0      		rcall .
 2077 0008 00D0      		rcall .
 2078               	.LCFI26:
 2079               		.cfi_def_cfa_offset 10
 2080 000a CDB7      		in r28,__SP_L__
 2081 000c DEB7      		in r29,__SP_H__
 2082               	.LCFI27:
 2083               		.cfi_def_cfa_register 28
 2084               	/* prologue: function */
 2085               	/* frame size = 6 */
 2086               	/* stack size = 8 */
 2087               	.L__stack_usage = 8
 2088               	/* epilogue start */
 942:./tmk_core/common/action.c ****     debug_event(record.event);
 943:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 944:./tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 945:./tmk_core/common/action.c **** #endif
 946:./tmk_core/common/action.c **** }
 2089               		.loc 1 946 0
 2090 000e 2696      		adiw r28,6
 2091 0010 0FB6      		in __tmp_reg__,__SREG__
 2092 0012 F894      		cli
 2093 0014 DEBF      		out __SP_H__,r29
 2094 0016 0FBE      		out __SREG__,__tmp_reg__
 2095 0018 CDBF      		out __SP_L__,r28
 2096 001a DF91      		pop r29
 2097 001c CF91      		pop r28
 2098 001e 0895      		ret
 2099               		.cfi_endproc
 2100               	.LFE27:
 2102               		.section	.text.debug_action,"ax",@progbits
 2103               	.global	debug_action
 2105               	debug_action:
 2106               	.LFB28:
 947:./tmk_core/common/action.c **** 
 948:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 949:./tmk_core/common/action.c ****  *
 950:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 951:./tmk_core/common/action.c ****  */
 952:./tmk_core/common/action.c **** void debug_action(action_t action)
 953:./tmk_core/common/action.c **** {
 2107               		.loc 1 953 0
 2108               		.cfi_startproc
 2109               	.LVL202:
 2110               	/* prologue: function */
 2111               	/* frame size = 0 */
 2112               	/* stack size = 0 */
 2113               	.L__stack_usage = 0
 2114 0000 0895      		ret
 2115               		.cfi_endproc
 2116               	.LFE28:
 2118               	.global	disable_action_cache
 2119               		.section	.bss.disable_action_cache,"aw",@nobits
 2122               	disable_action_cache:
 2123 0000 00        		.zero	1
 2124               		.comm	tp_buttons,2,1
 2125               		.text
 2126               	.Letext0:
 2127               		.file 5 "/usr/lib/avr/include/stdint.h"
 2128               		.file 6 "./tmk_core/common/keycode.h"
 2129               		.file 7 "./tmk_core/common/report.h"
 2130               		.file 8 "./tmk_core/common/action_code.h"
 2131               		.file 9 "./tmk_core/common/action.h"
 2132               		.file 10 "./tmk_core/common/action_tapping.h"
 2133               		.file 11 "./tmk_core/common/action_layer.h"
 2134               		.file 12 "./tmk_core/common/host.h"
 2135               		.file 13 "./tmk_core/common/command.h"
 2136               		.file 14 "./tmk_core/common/mousekey.h"
 2137               		.file 15 "./tmk_core/common/action_macro.h"
 2138               		.file 16 "./tmk_core/common/led.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/ccBdRmFv.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccBdRmFv.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccBdRmFv.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccBdRmFv.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccBdRmFv.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccBdRmFv.s:13     .text.action_exec:0000000000000000 action_exec
     /tmp/ccBdRmFv.s:93     .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccBdRmFv.s:112    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/ccBdRmFv.s:135    .text.register_code:0000000000000000 register_code
     /tmp/ccBdRmFv.s:556    .text.unregister_code:0000000000000000 unregister_code
     /tmp/ccBdRmFv.s:725    .text.register_mods:0000000000000000 register_mods
     /tmp/ccBdRmFv.s:751    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/ccBdRmFv.s:777    .text.process_action:0000000000000000 process_action
                            *COM*:0000000000000002 tp_buttons
     /tmp/ccBdRmFv.s:1746   .text.process_record:0000000000000000 process_record
     /tmp/ccBdRmFv.s:1841   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/ccBdRmFv.s:2122   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/ccBdRmFv.s:1865   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/ccBdRmFv.s:1913   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/ccBdRmFv.s:1933   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/ccBdRmFv.s:2022   .text.debug_event:0000000000000000 debug_event
     /tmp/ccBdRmFv.s:2063   .text.debug_record:0000000000000000 debug_record
     /tmp/ccBdRmFv.s:2105   .text.debug_action:0000000000000000 debug_action

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
keyboard_report
add_key_to_report
send_keyboard_report
del_key_from_report
command_proc
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
mousekey_on
mousekey_off
mousekey_send
default_layer_and
default_layer_xor
default_layer_or
layer_and
layer_xor
layer_or
layer_on
layer_off
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
led_set
get_oneshot_layer_state
get_oneshot_layer
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys_from_report
mousekey_clear
clear_mods
__do_clear_bss
