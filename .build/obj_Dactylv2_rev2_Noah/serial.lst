   1               		.file	"serial.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.serial_output,"ax",@progbits
  12               	serial_output:
  13               	.LFB7:
  14               		.file 1 "keyboards/Dactylv2/serial.c"
   1:keyboards/Dactylv2/serial.c **** /*
   2:keyboards/Dactylv2/serial.c ****  * WARNING: be careful changing this code, it is very timing dependent
   3:keyboards/Dactylv2/serial.c ****  */
   4:keyboards/Dactylv2/serial.c **** 
   5:keyboards/Dactylv2/serial.c **** #ifndef F_CPU
   6:keyboards/Dactylv2/serial.c **** #define F_CPU 16000000
   7:keyboards/Dactylv2/serial.c **** #endif
   8:keyboards/Dactylv2/serial.c **** 
   9:keyboards/Dactylv2/serial.c **** #include <avr/io.h>
  10:keyboards/Dactylv2/serial.c **** #include <avr/interrupt.h>
  11:keyboards/Dactylv2/serial.c **** #include <util/delay.h>
  12:keyboards/Dactylv2/serial.c **** #include <stdbool.h>
  13:keyboards/Dactylv2/serial.c **** #include "serial.h"
  14:keyboards/Dactylv2/serial.c **** 
  15:keyboards/Dactylv2/serial.c **** #ifndef USE_I2C
  16:keyboards/Dactylv2/serial.c **** 
  17:keyboards/Dactylv2/serial.c **** // Serial pulse period in microseconds. Its probably a bad idea to lower this
  18:keyboards/Dactylv2/serial.c **** // value.
  19:keyboards/Dactylv2/serial.c **** #define SERIAL_DELAY 24
  20:keyboards/Dactylv2/serial.c **** 
  21:keyboards/Dactylv2/serial.c **** uint8_t volatile serial_slave_buffer[SERIAL_SLAVE_BUFFER_LENGTH] = {0};
  22:keyboards/Dactylv2/serial.c **** uint8_t volatile serial_master_buffer[SERIAL_MASTER_BUFFER_LENGTH] = {0};
  23:keyboards/Dactylv2/serial.c **** 
  24:keyboards/Dactylv2/serial.c **** #define SLAVE_DATA_CORRUPT (1<<0)
  25:keyboards/Dactylv2/serial.c **** volatile uint8_t status = 0;
  26:keyboards/Dactylv2/serial.c **** 
  27:keyboards/Dactylv2/serial.c **** inline static
  28:keyboards/Dactylv2/serial.c **** void serial_delay(void) {
  29:keyboards/Dactylv2/serial.c ****   _delay_us(SERIAL_DELAY);
  30:keyboards/Dactylv2/serial.c **** }
  31:keyboards/Dactylv2/serial.c **** 
  32:keyboards/Dactylv2/serial.c **** inline static
  33:keyboards/Dactylv2/serial.c **** void serial_output(void) {
  15               		.loc 1 33 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  34:keyboards/Dactylv2/serial.c ****   SERIAL_PIN_DDR |= SERIAL_PIN_MASK;
  21               		.loc 1 34 0
  22 0000 509A      		sbi 0xa,0
  23 0002 0895      		ret
  24               		.cfi_endproc
  25               	.LFE7:
  27               		.section	.text.serial_input,"ax",@progbits
  29               	serial_input:
  30               	.LFB8:
  35:keyboards/Dactylv2/serial.c **** }
  36:keyboards/Dactylv2/serial.c **** 
  37:keyboards/Dactylv2/serial.c **** // make the serial pin an input with pull-up resistor
  38:keyboards/Dactylv2/serial.c **** inline static
  39:keyboards/Dactylv2/serial.c **** void serial_input(void) {
  31               		.loc 1 39 0
  32               		.cfi_startproc
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
  40:keyboards/Dactylv2/serial.c ****   SERIAL_PIN_DDR  &= ~SERIAL_PIN_MASK;
  37               		.loc 1 40 0
  38 0000 5098      		cbi 0xa,0
  41:keyboards/Dactylv2/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
  39               		.loc 1 41 0
  40 0002 589A      		sbi 0xb,0
  41 0004 0895      		ret
  42               		.cfi_endproc
  43               	.LFE8:
  45               		.section	.text.serial_high,"ax",@progbits
  47               	serial_high:
  48               	.LFB11:
  42:keyboards/Dactylv2/serial.c **** }
  43:keyboards/Dactylv2/serial.c **** 
  44:keyboards/Dactylv2/serial.c **** inline static
  45:keyboards/Dactylv2/serial.c **** uint8_t serial_read_pin(void) {
  46:keyboards/Dactylv2/serial.c ****   return !!(SERIAL_PIN_INPUT & SERIAL_PIN_MASK);
  47:keyboards/Dactylv2/serial.c **** }
  48:keyboards/Dactylv2/serial.c **** 
  49:keyboards/Dactylv2/serial.c **** inline static
  50:keyboards/Dactylv2/serial.c **** void serial_low(void) {
  51:keyboards/Dactylv2/serial.c ****   SERIAL_PIN_PORT &= ~SERIAL_PIN_MASK;
  52:keyboards/Dactylv2/serial.c **** }
  53:keyboards/Dactylv2/serial.c **** 
  54:keyboards/Dactylv2/serial.c **** inline static
  55:keyboards/Dactylv2/serial.c **** void serial_high(void) {
  49               		.loc 1 55 0
  50               		.cfi_startproc
  51               	/* prologue: function */
  52               	/* frame size = 0 */
  53               	/* stack size = 0 */
  54               	.L__stack_usage = 0
  56:keyboards/Dactylv2/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
  55               		.loc 1 56 0
  56 0000 589A      		sbi 0xb,0
  57 0002 0895      		ret
  58               		.cfi_endproc
  59               	.LFE11:
  61               		.section	.text.sync_recv,"ax",@progbits
  63               	sync_recv:
  64               	.LFB14:
  57:keyboards/Dactylv2/serial.c **** }
  58:keyboards/Dactylv2/serial.c **** 
  59:keyboards/Dactylv2/serial.c **** void serial_master_init(void) {
  60:keyboards/Dactylv2/serial.c ****   serial_output();
  61:keyboards/Dactylv2/serial.c ****   serial_high();
  62:keyboards/Dactylv2/serial.c **** }
  63:keyboards/Dactylv2/serial.c **** 
  64:keyboards/Dactylv2/serial.c **** void serial_slave_init(void) {
  65:keyboards/Dactylv2/serial.c ****   serial_input();
  66:keyboards/Dactylv2/serial.c **** 
  67:keyboards/Dactylv2/serial.c ****   // Enable INT0
  68:keyboards/Dactylv2/serial.c ****   EIMSK |= _BV(INT0);
  69:keyboards/Dactylv2/serial.c ****   // Trigger on falling edge of INT0
  70:keyboards/Dactylv2/serial.c ****   EICRA &= ~(_BV(ISC00) | _BV(ISC01));
  71:keyboards/Dactylv2/serial.c **** }
  72:keyboards/Dactylv2/serial.c **** 
  73:keyboards/Dactylv2/serial.c **** // Used by the master to synchronize timing with the slave.
  74:keyboards/Dactylv2/serial.c **** static
  75:keyboards/Dactylv2/serial.c **** void sync_recv(void) {
  65               		.loc 1 75 0
  66               		.cfi_startproc
  67               	/* prologue: function */
  68               	/* frame size = 0 */
  69               	/* stack size = 0 */
  70               	.L__stack_usage = 0
  76:keyboards/Dactylv2/serial.c ****   serial_input();
  71               		.loc 1 76 0
  72 0000 0E94 0000 		call serial_input
  73               	.LVL0:
  74               	.L5:
  77:keyboards/Dactylv2/serial.c ****   // This shouldn't hang if the slave disconnects because the
  78:keyboards/Dactylv2/serial.c ****   // serial line will float to high if the slave does disconnect.
  79:keyboards/Dactylv2/serial.c ****   while (!serial_read_pin());
  75               		.loc 1 79 0 discriminator 1
  76 0004 489B      		sbis 0x9,0
  77 0006 00C0      		rjmp .L5
  78               	.LVL1:
  79               	.LBB49:
  80               	.LBB50:
  81               	.LBB51:
  82               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  83               		.loc 2 276 0
  84 0008 80E8      		ldi r24,lo8(-128)
  85 000a 8A95      	1:	dec r24
  86 000c 01F4      		brne 1b
  87               	.LVL2:
  88 000e 0895      		ret
  89               	.LBE51:
  90               	.LBE50:
  91               	.LBE49:
  92               		.cfi_endproc
  93               	.LFE14:
  95               		.section	.text.serial_read_byte,"ax",@progbits
  97               	serial_read_byte:
  98               	.LFB16:
  80:keyboards/Dactylv2/serial.c ****   serial_delay();
  81:keyboards/Dactylv2/serial.c **** }
  82:keyboards/Dactylv2/serial.c **** 
  83:keyboards/Dactylv2/serial.c **** // Used by the slave to send a synchronization signal to the master.
  84:keyboards/Dactylv2/serial.c **** static
  85:keyboards/Dactylv2/serial.c **** void sync_send(void) {
  86:keyboards/Dactylv2/serial.c ****   serial_output();
  87:keyboards/Dactylv2/serial.c **** 
  88:keyboards/Dactylv2/serial.c ****   serial_low();
  89:keyboards/Dactylv2/serial.c ****   serial_delay();
  90:keyboards/Dactylv2/serial.c **** 
  91:keyboards/Dactylv2/serial.c ****   serial_high();
  92:keyboards/Dactylv2/serial.c **** }
  93:keyboards/Dactylv2/serial.c **** 
  94:keyboards/Dactylv2/serial.c **** // Reads a byte from the serial line
  95:keyboards/Dactylv2/serial.c **** static
  96:keyboards/Dactylv2/serial.c **** uint8_t serial_read_byte(void) {
  99               		.loc 1 96 0
 100               		.cfi_startproc
 101               	/* prologue: function */
 102               	/* frame size = 0 */
 103               	/* stack size = 0 */
 104               	.L__stack_usage = 0
 105               	.LVL3:
  97:keyboards/Dactylv2/serial.c ****   uint8_t byte = 0;
  98:keyboards/Dactylv2/serial.c ****   serial_input();
 106               		.loc 1 98 0
 107 0000 0E94 0000 		call serial_input
 108               	.LVL4:
 109 0004 98E0      		ldi r25,lo8(8)
  97:keyboards/Dactylv2/serial.c ****   uint8_t byte = 0;
 110               		.loc 1 97 0
 111 0006 80E0      		ldi r24,0
 112               	.LVL5:
 113               	.L10:
 114               	.LBB60:
 115               	.LBB61:
 116               	.LBB62:
  46:keyboards/Dactylv2/serial.c **** }
 117               		.loc 1 46 0 discriminator 3
 118 0008 29B1      		in r18,0x9
 119               	.LBE62:
 120               	.LBE61:
  99:keyboards/Dactylv2/serial.c ****   for ( uint8_t i = 0; i < 8; ++i) {
 100:keyboards/Dactylv2/serial.c ****     byte = (byte << 1) | serial_read_pin();
 121               		.loc 1 100 0 discriminator 3
 122 000a 880F      		lsl r24
 123               	.LVL6:
 124 000c 2170      		andi r18,lo8(1)
 125 000e 822B      		or r24,r18
 126               	.LVL7:
 127               	.LBB63:
 128               	.LBB64:
 129               	.LBB65:
 130               		.loc 2 276 0 discriminator 3
 131 0010 20E8      		ldi r18,lo8(-128)
 132 0012 2A95      	1:	dec r18
 133 0014 01F4      		brne 1b
 134               	.LVL8:
 135               	.LBE65:
 136               	.LBE64:
 137               	.LBE63:
 138               	.LBB66:
 139               	.LBB67:
 140 0016 25E0      		ldi r18,lo8(5)
 141 0018 2A95      	1:	dec r18
 142 001a 01F4      		brne 1b
 143 001c 0000      		nop
 144               	.LVL9:
 145 001e 9150      		subi r25,lo8(-(-1))
 146               	.LVL10:
 147               	.LBE67:
 148               	.LBE66:
  99:keyboards/Dactylv2/serial.c ****   for ( uint8_t i = 0; i < 8; ++i) {
 149               		.loc 1 99 0 discriminator 3
 150 0020 01F4      		brne .L10
 151               	/* epilogue start */
 152               	.LBE60:
 101:keyboards/Dactylv2/serial.c ****     serial_delay();
 102:keyboards/Dactylv2/serial.c ****     _delay_us(1);
 103:keyboards/Dactylv2/serial.c ****   }
 104:keyboards/Dactylv2/serial.c **** 
 105:keyboards/Dactylv2/serial.c ****   return byte;
 106:keyboards/Dactylv2/serial.c **** }
 153               		.loc 1 106 0
 154 0022 0895      		ret
 155               		.cfi_endproc
 156               	.LFE16:
 158               		.section	.text.serial_write_byte,"ax",@progbits
 160               	serial_write_byte:
 161               	.LFB17:
 107:keyboards/Dactylv2/serial.c **** 
 108:keyboards/Dactylv2/serial.c **** // Sends a byte with MSB ordering
 109:keyboards/Dactylv2/serial.c **** static
 110:keyboards/Dactylv2/serial.c **** void serial_write_byte(uint8_t data) {
 162               		.loc 1 110 0
 163               		.cfi_startproc
 164               	.LVL11:
 165 0000 0F93      		push r16
 166               	.LCFI0:
 167               		.cfi_def_cfa_offset 3
 168               		.cfi_offset 16, -2
 169 0002 1F93      		push r17
 170               	.LCFI1:
 171               		.cfi_def_cfa_offset 4
 172               		.cfi_offset 17, -3
 173 0004 CF93      		push r28
 174               	.LCFI2:
 175               		.cfi_def_cfa_offset 5
 176               		.cfi_offset 28, -4
 177               	/* prologue: function */
 178               	/* frame size = 0 */
 179               	/* stack size = 3 */
 180               	.L__stack_usage = 3
 181 0006 082F      		mov r16,r24
 182               	.LVL12:
 111:keyboards/Dactylv2/serial.c ****   uint8_t b = 8;
 112:keyboards/Dactylv2/serial.c ****   serial_output();
 183               		.loc 1 112 0
 184 0008 0E94 0000 		call serial_output
 185               	.LVL13:
 111:keyboards/Dactylv2/serial.c ****   uint8_t b = 8;
 186               		.loc 1 111 0
 187 000c C8E0      		ldi r28,lo8(8)
 113:keyboards/Dactylv2/serial.c ****   while( b-- ) {
 114:keyboards/Dactylv2/serial.c ****     if(data & (1 << b)) {
 188               		.loc 1 114 0
 189 000e 10E0      		ldi r17,0
 190               	.LVL14:
 191               	.L13:
 113:keyboards/Dactylv2/serial.c ****   while( b-- ) {
 192               		.loc 1 113 0
 193               	.LVL15:
 194 0010 C150      		subi r28,1
 195 0012 00F0      		brcs .L17
 196               		.loc 1 114 0
 197 0014 C801      		movw r24,r16
 198 0016 0C2E      		mov r0,r28
 199 0018 00C0      		rjmp 2f
 200               		1:
 201 001a 9595      		asr r25
 202 001c 8795      		ror r24
 203               		2:
 204 001e 0A94      		dec r0
 205 0020 02F4      		brpl 1b
 206 0022 80FF      		sbrs r24,0
 207 0024 00C0      		rjmp .L14
 115:keyboards/Dactylv2/serial.c ****       serial_high();
 208               		.loc 1 115 0
 209 0026 0E94 0000 		call serial_high
 210               	.LVL16:
 211 002a 00C0      		rjmp .L15
 212               	.L14:
 213               	.LBB73:
 214               	.LBB74:
  51:keyboards/Dactylv2/serial.c **** }
 215               		.loc 1 51 0
 216 002c 5898      		cbi 0xb,0
 217               	.L15:
 218               	.LVL17:
 219               	.LBE74:
 220               	.LBE73:
 221               	.LBB75:
 222               	.LBB76:
 223               	.LBB77:
 224               		.loc 2 276 0
 225 002e 80E8      		ldi r24,lo8(-128)
 226 0030 8A95      	1:	dec r24
 227 0032 01F4      		brne 1b
 228               	.LVL18:
 229 0034 00C0      		rjmp .L13
 230               	.L17:
 231               	/* epilogue start */
 232               	.LBE77:
 233               	.LBE76:
 234               	.LBE75:
 116:keyboards/Dactylv2/serial.c ****     } else {
 117:keyboards/Dactylv2/serial.c ****       serial_low();
 118:keyboards/Dactylv2/serial.c ****     }
 119:keyboards/Dactylv2/serial.c ****     serial_delay();
 120:keyboards/Dactylv2/serial.c ****   }
 121:keyboards/Dactylv2/serial.c **** }
 235               		.loc 1 121 0
 236 0036 CF91      		pop r28
 237               	.LVL19:
 238 0038 1F91      		pop r17
 239 003a 0F91      		pop r16
 240               	.LVL20:
 241 003c 0895      		ret
 242               		.cfi_endproc
 243               	.LFE17:
 245               		.section	.text.sync_send,"ax",@progbits
 247               	sync_send:
 248               	.LFB15:
  85:keyboards/Dactylv2/serial.c ****   serial_output();
 249               		.loc 1 85 0
 250               		.cfi_startproc
 251               	/* prologue: function */
 252               	/* frame size = 0 */
 253               	/* stack size = 0 */
 254               	.L__stack_usage = 0
  86:keyboards/Dactylv2/serial.c **** 
 255               		.loc 1 86 0
 256 0000 0E94 0000 		call serial_output
 257               	.LVL21:
 258               	.LBB83:
 259               	.LBB84:
  51:keyboards/Dactylv2/serial.c **** }
 260               		.loc 1 51 0
 261 0004 5898      		cbi 0xb,0
 262               	.LVL22:
 263               	.LBE84:
 264               	.LBE83:
 265               	.LBB85:
 266               	.LBB86:
 267               	.LBB87:
 268               		.loc 2 276 0
 269 0006 80E8      		ldi r24,lo8(-128)
 270 0008 8A95      	1:	dec r24
 271 000a 01F4      		brne 1b
 272               	.LVL23:
 273               	.LBE87:
 274               	.LBE86:
 275               	.LBE85:
  91:keyboards/Dactylv2/serial.c **** }
 276               		.loc 1 91 0
 277 000c 0C94 0000 		jmp serial_high
 278               	.LVL24:
 279               		.cfi_endproc
 280               	.LFE15:
 282               		.section	.text.serial_master_init,"ax",@progbits
 283               	.global	serial_master_init
 285               	serial_master_init:
 286               	.LFB12:
  59:keyboards/Dactylv2/serial.c ****   serial_output();
 287               		.loc 1 59 0
 288               		.cfi_startproc
 289               	/* prologue: function */
 290               	/* frame size = 0 */
 291               	/* stack size = 0 */
 292               	.L__stack_usage = 0
  60:keyboards/Dactylv2/serial.c ****   serial_high();
 293               		.loc 1 60 0
 294 0000 0E94 0000 		call serial_output
 295               	.LVL25:
  61:keyboards/Dactylv2/serial.c **** }
 296               		.loc 1 61 0
 297 0004 0C94 0000 		jmp serial_high
 298               	.LVL26:
 299               		.cfi_endproc
 300               	.LFE12:
 302               		.section	.text.serial_slave_init,"ax",@progbits
 303               	.global	serial_slave_init
 305               	serial_slave_init:
 306               	.LFB13:
  64:keyboards/Dactylv2/serial.c ****   serial_input();
 307               		.loc 1 64 0
 308               		.cfi_startproc
 309               	/* prologue: function */
 310               	/* frame size = 0 */
 311               	/* stack size = 0 */
 312               	.L__stack_usage = 0
  65:keyboards/Dactylv2/serial.c **** 
 313               		.loc 1 65 0
 314 0000 0E94 0000 		call serial_input
 315               	.LVL27:
  68:keyboards/Dactylv2/serial.c ****   // Trigger on falling edge of INT0
 316               		.loc 1 68 0
 317 0004 E89A      		sbi 0x1d,0
  70:keyboards/Dactylv2/serial.c **** }
 318               		.loc 1 70 0
 319 0006 E9E6      		ldi r30,lo8(105)
 320 0008 F0E0      		ldi r31,0
 321 000a 8081      		ld r24,Z
 322 000c 8C7F      		andi r24,lo8(-4)
 323 000e 8083      		st Z,r24
 324 0010 0895      		ret
 325               		.cfi_endproc
 326               	.LFE13:
 328               		.section	.text.__vector_1,"ax",@progbits
 329               	.global	__vector_1
 331               	__vector_1:
 332               	.LFB18:
 122:keyboards/Dactylv2/serial.c **** 
 123:keyboards/Dactylv2/serial.c **** // interrupt handle to be used by the slave device
 124:keyboards/Dactylv2/serial.c **** ISR(SERIAL_PIN_INTERRUPT) {
 333               		.loc 1 124 0
 334               		.cfi_startproc
 335 0000 1F92      		push r1
 336               	.LCFI3:
 337               		.cfi_def_cfa_offset 3
 338               		.cfi_offset 1, -2
 339 0002 0F92      		push r0
 340               	.LCFI4:
 341               		.cfi_def_cfa_offset 4
 342               		.cfi_offset 0, -3
 343 0004 0FB6      		in r0,__SREG__
 344 0006 0F92      		push r0
 345 0008 1124      		clr __zero_reg__
 346 000a EF92      		push r14
 347               	.LCFI5:
 348               		.cfi_def_cfa_offset 5
 349               		.cfi_offset 14, -4
 350 000c FF92      		push r15
 351               	.LCFI6:
 352               		.cfi_def_cfa_offset 6
 353               		.cfi_offset 15, -5
 354 000e 1F93      		push r17
 355               	.LCFI7:
 356               		.cfi_def_cfa_offset 7
 357               		.cfi_offset 17, -6
 358 0010 2F93      		push r18
 359               	.LCFI8:
 360               		.cfi_def_cfa_offset 8
 361               		.cfi_offset 18, -7
 362 0012 3F93      		push r19
 363               	.LCFI9:
 364               		.cfi_def_cfa_offset 9
 365               		.cfi_offset 19, -8
 366 0014 4F93      		push r20
 367               	.LCFI10:
 368               		.cfi_def_cfa_offset 10
 369               		.cfi_offset 20, -9
 370 0016 5F93      		push r21
 371               	.LCFI11:
 372               		.cfi_def_cfa_offset 11
 373               		.cfi_offset 21, -10
 374 0018 6F93      		push r22
 375               	.LCFI12:
 376               		.cfi_def_cfa_offset 12
 377               		.cfi_offset 22, -11
 378 001a 7F93      		push r23
 379               	.LCFI13:
 380               		.cfi_def_cfa_offset 13
 381               		.cfi_offset 23, -12
 382 001c 8F93      		push r24
 383               	.LCFI14:
 384               		.cfi_def_cfa_offset 14
 385               		.cfi_offset 24, -13
 386 001e 9F93      		push r25
 387               	.LCFI15:
 388               		.cfi_def_cfa_offset 15
 389               		.cfi_offset 25, -14
 390 0020 AF93      		push r26
 391               	.LCFI16:
 392               		.cfi_def_cfa_offset 16
 393               		.cfi_offset 26, -15
 394 0022 BF93      		push r27
 395               	.LCFI17:
 396               		.cfi_def_cfa_offset 17
 397               		.cfi_offset 27, -16
 398 0024 CF93      		push r28
 399               	.LCFI18:
 400               		.cfi_def_cfa_offset 18
 401               		.cfi_offset 28, -17
 402 0026 DF93      		push r29
 403               	.LCFI19:
 404               		.cfi_def_cfa_offset 19
 405               		.cfi_offset 29, -18
 406 0028 EF93      		push r30
 407               	.LCFI20:
 408               		.cfi_def_cfa_offset 20
 409               		.cfi_offset 30, -19
 410 002a FF93      		push r31
 411               	.LCFI21:
 412               		.cfi_def_cfa_offset 21
 413               		.cfi_offset 31, -20
 414               	/* prologue: Signal */
 415               	/* frame size = 0 */
 416               	/* stack size = 20 */
 417               	.L__stack_usage = 20
 125:keyboards/Dactylv2/serial.c ****   sync_send();
 418               		.loc 1 125 0
 419 002c 0E94 0000 		call sync_send
 420               	.LVL28:
 421               	.LBB88:
 126:keyboards/Dactylv2/serial.c **** 
 127:keyboards/Dactylv2/serial.c ****   uint8_t checksum = 0;
 128:keyboards/Dactylv2/serial.c ****   for (int i = 0; i < SERIAL_SLAVE_BUFFER_LENGTH; ++i) {
 422               		.loc 1 128 0
 423 0030 C0E0      		ldi r28,0
 424 0032 D0E0      		ldi r29,0
 425               	.LBE88:
 127:keyboards/Dactylv2/serial.c ****   for (int i = 0; i < SERIAL_SLAVE_BUFFER_LENGTH; ++i) {
 426               		.loc 1 127 0
 427 0034 10E0      		ldi r17,0
 428               	.LVL29:
 429               	.L22:
 430               	.LBB89:
 129:keyboards/Dactylv2/serial.c ****     serial_write_byte(serial_slave_buffer[i]);
 431               		.loc 1 129 0 discriminator 3
 432 0036 CE01      		movw r24,r28
 433 0038 8050      		subi r24,lo8(-(serial_slave_buffer))
 434 003a 9040      		sbci r25,hi8(-(serial_slave_buffer))
 435 003c 7C01      		movw r14,r24
 436 003e FC01      		movw r30,r24
 437 0040 8081      		ld r24,Z
 438 0042 0E94 0000 		call serial_write_byte
 439               	.LVL30:
 130:keyboards/Dactylv2/serial.c ****     sync_send();
 440               		.loc 1 130 0 discriminator 3
 441 0046 0E94 0000 		call sync_send
 442               	.LVL31:
 131:keyboards/Dactylv2/serial.c ****     checksum += serial_slave_buffer[i];
 443               		.loc 1 131 0 discriminator 3
 444 004a F701      		movw r30,r14
 445 004c 8081      		ld r24,Z
 446 004e 180F      		add r17,r24
 447               	.LVL32:
 128:keyboards/Dactylv2/serial.c ****     serial_write_byte(serial_slave_buffer[i]);
 448               		.loc 1 128 0 discriminator 3
 449 0050 2196      		adiw r28,1
 450               	.LVL33:
 451 0052 C730      		cpi r28,7
 452 0054 D105      		cpc r29,__zero_reg__
 453 0056 01F4      		brne .L22
 454               	.LBE89:
 132:keyboards/Dactylv2/serial.c ****   }
 133:keyboards/Dactylv2/serial.c ****   serial_write_byte(checksum);
 455               		.loc 1 133 0
 456 0058 812F      		mov r24,r17
 457 005a 0E94 0000 		call serial_write_byte
 458               	.LVL34:
 134:keyboards/Dactylv2/serial.c ****   sync_send();
 459               		.loc 1 134 0
 460 005e 0E94 0000 		call sync_send
 461               	.LVL35:
 462               	.LBB90:
 463               	.LBB91:
 464               	.LBB92:
 465               		.loc 2 276 0
 466 0062 F0E8      		ldi r31,lo8(-128)
 467 0064 FA95      	1:	dec r31
 468 0066 01F4      		brne 1b
 469               	.LVL36:
 470               	.LBE92:
 471               	.LBE91:
 472               	.LBE90:
 473               	.LBB93:
 474               	.LBB94:
 475 0068 80E4      		ldi r24,lo8(64)
 476 006a 8A95      	1:	dec r24
 477 006c 01F4      		brne 1b
 478               	.LVL37:
 479               	.LBE94:
 480               	.LBE93:
 481               	.LBB95:
 135:keyboards/Dactylv2/serial.c **** 
 136:keyboards/Dactylv2/serial.c ****   // wait for the sync to finish sending
 137:keyboards/Dactylv2/serial.c ****   serial_delay();
 138:keyboards/Dactylv2/serial.c **** 
 139:keyboards/Dactylv2/serial.c ****   // read the middle of pulses
 140:keyboards/Dactylv2/serial.c ****   _delay_us(SERIAL_DELAY/2);
 141:keyboards/Dactylv2/serial.c **** 
 142:keyboards/Dactylv2/serial.c ****   uint8_t checksum_computed = 0;
 143:keyboards/Dactylv2/serial.c ****   for (int i = 0; i < SERIAL_MASTER_BUFFER_LENGTH; ++i) {
 144:keyboards/Dactylv2/serial.c ****     serial_master_buffer[i] = serial_read_byte();
 482               		.loc 1 144 0
 483 006e 0E94 0000 		call serial_read_byte
 484               	.LVL38:
 485 0072 8093 0000 		sts serial_master_buffer,r24
 145:keyboards/Dactylv2/serial.c ****     sync_send();
 486               		.loc 1 145 0
 487 0076 0E94 0000 		call sync_send
 488               	.LVL39:
 146:keyboards/Dactylv2/serial.c ****     checksum_computed += serial_master_buffer[i];
 489               		.loc 1 146 0
 490 007a C091 0000 		lds r28,serial_master_buffer
 491               	.LVL40:
 492               	.LBE95:
 147:keyboards/Dactylv2/serial.c ****   }
 148:keyboards/Dactylv2/serial.c ****   uint8_t checksum_received = serial_read_byte();
 493               		.loc 1 148 0
 494 007e 0E94 0000 		call serial_read_byte
 495               	.LVL41:
 496 0082 D82F      		mov r29,r24
 497               	.LVL42:
 149:keyboards/Dactylv2/serial.c ****   sync_send();
 498               		.loc 1 149 0
 499 0084 0E94 0000 		call sync_send
 500               	.LVL43:
 150:keyboards/Dactylv2/serial.c **** 
 151:keyboards/Dactylv2/serial.c ****   serial_input(); // end transaction
 501               		.loc 1 151 0
 502 0088 0E94 0000 		call serial_input
 503               	.LVL44:
 152:keyboards/Dactylv2/serial.c **** 
 153:keyboards/Dactylv2/serial.c ****   if ( checksum_computed != checksum_received ) {
 154:keyboards/Dactylv2/serial.c ****     status |= SLAVE_DATA_CORRUPT;
 504               		.loc 1 154 0
 505 008c 8091 0000 		lds r24,status
 153:keyboards/Dactylv2/serial.c ****     status |= SLAVE_DATA_CORRUPT;
 506               		.loc 1 153 0
 507 0090 DC17      		cp r29,r28
 508 0092 01F0      		breq .L23
 509               		.loc 1 154 0
 510 0094 8160      		ori r24,lo8(1)
 511 0096 00C0      		rjmp .L26
 512               	.L23:
 155:keyboards/Dactylv2/serial.c ****   } else {
 156:keyboards/Dactylv2/serial.c ****     status &= ~SLAVE_DATA_CORRUPT;
 513               		.loc 1 156 0
 514 0098 8E7F      		andi r24,lo8(-2)
 515               	.L26:
 516 009a 8093 0000 		sts status,r24
 517               	/* epilogue start */
 157:keyboards/Dactylv2/serial.c ****   }
 158:keyboards/Dactylv2/serial.c **** }
 518               		.loc 1 158 0
 519 009e FF91      		pop r31
 520 00a0 EF91      		pop r30
 521 00a2 DF91      		pop r29
 522               	.LVL45:
 523 00a4 CF91      		pop r28
 524               	.LVL46:
 525 00a6 BF91      		pop r27
 526 00a8 AF91      		pop r26
 527 00aa 9F91      		pop r25
 528 00ac 8F91      		pop r24
 529 00ae 7F91      		pop r23
 530 00b0 6F91      		pop r22
 531 00b2 5F91      		pop r21
 532 00b4 4F91      		pop r20
 533 00b6 3F91      		pop r19
 534 00b8 2F91      		pop r18
 535 00ba 1F91      		pop r17
 536               	.LVL47:
 537 00bc FF90      		pop r15
 538 00be EF90      		pop r14
 539               	.LVL48:
 540 00c0 0F90      		pop r0
 541 00c2 0FBE      		out __SREG__,r0
 542 00c4 0F90      		pop r0
 543 00c6 1F90      		pop r1
 544 00c8 1895      		reti
 545               		.cfi_endproc
 546               	.LFE18:
 548               		.section	.text.serial_update_buffers,"ax",@progbits
 549               	.global	serial_update_buffers
 551               	serial_update_buffers:
 552               	.LFB20:
 159:keyboards/Dactylv2/serial.c **** 
 160:keyboards/Dactylv2/serial.c **** inline
 161:keyboards/Dactylv2/serial.c **** bool serial_slave_DATA_CORRUPT(void) {
 162:keyboards/Dactylv2/serial.c ****   return status & SLAVE_DATA_CORRUPT;
 163:keyboards/Dactylv2/serial.c **** }
 164:keyboards/Dactylv2/serial.c **** 
 165:keyboards/Dactylv2/serial.c **** // Copies the serial_slave_buffer to the master and sends the
 166:keyboards/Dactylv2/serial.c **** // serial_master_buffer to the slave.
 167:keyboards/Dactylv2/serial.c **** //
 168:keyboards/Dactylv2/serial.c **** // Returns:
 169:keyboards/Dactylv2/serial.c **** // 0 => no error
 170:keyboards/Dactylv2/serial.c **** // 1 => slave did not respond
 171:keyboards/Dactylv2/serial.c **** int serial_update_buffers(void) {
 553               		.loc 1 171 0
 554               		.cfi_startproc
 555 0000 EF92      		push r14
 556               	.LCFI22:
 557               		.cfi_def_cfa_offset 3
 558               		.cfi_offset 14, -2
 559 0002 FF92      		push r15
 560               	.LCFI23:
 561               		.cfi_def_cfa_offset 4
 562               		.cfi_offset 15, -3
 563 0004 1F93      		push r17
 564               	.LCFI24:
 565               		.cfi_def_cfa_offset 5
 566               		.cfi_offset 17, -4
 567 0006 CF93      		push r28
 568               	.LCFI25:
 569               		.cfi_def_cfa_offset 6
 570               		.cfi_offset 28, -5
 571 0008 DF93      		push r29
 572               	.LCFI26:
 573               		.cfi_def_cfa_offset 7
 574               		.cfi_offset 29, -6
 575               	/* prologue: function */
 576               	/* frame size = 0 */
 577               	/* stack size = 5 */
 578               	.L__stack_usage = 5
 172:keyboards/Dactylv2/serial.c ****   // this code is very time dependent, so we need to disable interrupts
 173:keyboards/Dactylv2/serial.c ****   cli();
 579               		.loc 1 173 0
 580               	/* #APP */
 581               	 ;  173 "keyboards/Dactylv2/serial.c" 1
 582 000a F894      		cli
 583               	 ;  0 "" 2
 174:keyboards/Dactylv2/serial.c **** 
 175:keyboards/Dactylv2/serial.c ****   // signal to the slave that we want to start a transaction
 176:keyboards/Dactylv2/serial.c ****   serial_output();
 584               		.loc 1 176 0
 585               	/* #NOAPP */
 586 000c 0E94 0000 		call serial_output
 587               	.LVL49:
 588               	.LBB106:
 589               	.LBB107:
  51:keyboards/Dactylv2/serial.c **** }
 590               		.loc 1 51 0
 591 0010 5898      		cbi 0xb,0
 592               	.LVL50:
 593               	.LBE107:
 594               	.LBE106:
 595               	.LBB108:
 596               	.LBB109:
 597               		.loc 2 276 0
 598 0012 25E0      		ldi r18,lo8(5)
 599 0014 2A95      	1:	dec r18
 600 0016 01F4      		brne 1b
 601 0018 0000      		nop
 602               	.LVL51:
 603               	.LBE109:
 604               	.LBE108:
 177:keyboards/Dactylv2/serial.c ****   serial_low();
 178:keyboards/Dactylv2/serial.c ****   _delay_us(1);
 179:keyboards/Dactylv2/serial.c **** 
 180:keyboards/Dactylv2/serial.c ****   // wait for the slaves response
 181:keyboards/Dactylv2/serial.c ****   serial_input();
 605               		.loc 1 181 0
 606 001a 0E94 0000 		call serial_input
 607               	.LVL52:
 182:keyboards/Dactylv2/serial.c ****   serial_high();
 608               		.loc 1 182 0
 609 001e 0E94 0000 		call serial_high
 610               	.LVL53:
 611               	.LBB110:
 612               	.LBB111:
 613               		.loc 2 276 0
 614 0022 30E8      		ldi r19,lo8(-128)
 615 0024 3A95      	1:	dec r19
 616 0026 01F4      		brne 1b
 617               	.LVL54:
 618               	.LBE111:
 619               	.LBE110:
 183:keyboards/Dactylv2/serial.c ****   _delay_us(SERIAL_DELAY);
 184:keyboards/Dactylv2/serial.c **** 
 185:keyboards/Dactylv2/serial.c ****   // check if the slave is present
 186:keyboards/Dactylv2/serial.c ****   if (serial_read_pin()) {
 620               		.loc 1 186 0
 621 0028 4899      		sbic 0x9,0
 622 002a 00C0      		rjmp .L31
 187:keyboards/Dactylv2/serial.c ****     // slave failed to pull the line low, assume not present
 188:keyboards/Dactylv2/serial.c ****     sei();
 189:keyboards/Dactylv2/serial.c ****     return 1;
 190:keyboards/Dactylv2/serial.c ****   }
 191:keyboards/Dactylv2/serial.c **** 
 192:keyboards/Dactylv2/serial.c ****   // if the slave is present syncronize with it
 193:keyboards/Dactylv2/serial.c ****   sync_recv();
 623               		.loc 1 193 0
 624 002c 0E94 0000 		call sync_recv
 625               	.LVL55:
 626               	.LBB112:
 194:keyboards/Dactylv2/serial.c **** 
 195:keyboards/Dactylv2/serial.c ****   uint8_t checksum_computed = 0;
 196:keyboards/Dactylv2/serial.c ****   // receive data from the slave
 197:keyboards/Dactylv2/serial.c ****   for (int i = 0; i < SERIAL_SLAVE_BUFFER_LENGTH; ++i) {
 627               		.loc 1 197 0
 628 0030 C0E0      		ldi r28,0
 629 0032 D0E0      		ldi r29,0
 630               	.LBE112:
 195:keyboards/Dactylv2/serial.c ****   // receive data from the slave
 631               		.loc 1 195 0
 632 0034 10E0      		ldi r17,0
 633               	.LVL56:
 634               	.L30:
 635               	.LBB113:
 198:keyboards/Dactylv2/serial.c ****     serial_slave_buffer[i] = serial_read_byte();
 636               		.loc 1 198 0 discriminator 3
 637 0036 0E94 0000 		call serial_read_byte
 638               	.LVL57:
 639 003a FE01      		movw r30,r28
 640 003c E050      		subi r30,lo8(-(serial_slave_buffer))
 641 003e F040      		sbci r31,hi8(-(serial_slave_buffer))
 642 0040 7F01      		movw r14,r30
 643 0042 8083      		st Z,r24
 199:keyboards/Dactylv2/serial.c ****     sync_recv();
 644               		.loc 1 199 0 discriminator 3
 645 0044 0E94 0000 		call sync_recv
 646               	.LVL58:
 200:keyboards/Dactylv2/serial.c ****     checksum_computed += serial_slave_buffer[i];
 647               		.loc 1 200 0 discriminator 3
 648 0048 F701      		movw r30,r14
 649 004a 8081      		ld r24,Z
 650 004c 180F      		add r17,r24
 651               	.LVL59:
 197:keyboards/Dactylv2/serial.c ****     serial_slave_buffer[i] = serial_read_byte();
 652               		.loc 1 197 0 discriminator 3
 653 004e 2196      		adiw r28,1
 654               	.LVL60:
 655 0050 C730      		cpi r28,7
 656 0052 D105      		cpc r29,__zero_reg__
 657 0054 01F4      		brne .L30
 658               	.LBE113:
 201:keyboards/Dactylv2/serial.c ****   }
 202:keyboards/Dactylv2/serial.c ****   uint8_t checksum_received = serial_read_byte();
 659               		.loc 1 202 0
 660 0056 0E94 0000 		call serial_read_byte
 661               	.LVL61:
 662 005a C82F      		mov r28,r24
 663               	.LVL62:
 203:keyboards/Dactylv2/serial.c ****   sync_recv();
 664               		.loc 1 203 0
 665 005c 0E94 0000 		call sync_recv
 666               	.LVL63:
 204:keyboards/Dactylv2/serial.c **** 
 205:keyboards/Dactylv2/serial.c ****   if (checksum_computed != checksum_received) {
 667               		.loc 1 205 0
 668 0060 1C13      		cpse r17,r28
 669 0062 00C0      		rjmp .L31
 670               	.LVL64:
 671               	.LBB114:
 206:keyboards/Dactylv2/serial.c ****     sei();
 207:keyboards/Dactylv2/serial.c ****     return 1;
 208:keyboards/Dactylv2/serial.c ****   }
 209:keyboards/Dactylv2/serial.c **** 
 210:keyboards/Dactylv2/serial.c ****   uint8_t checksum = 0;
 211:keyboards/Dactylv2/serial.c ****   // send data to the slave
 212:keyboards/Dactylv2/serial.c ****   for (int i = 0; i < SERIAL_MASTER_BUFFER_LENGTH; ++i) {
 213:keyboards/Dactylv2/serial.c ****     serial_write_byte(serial_master_buffer[i]);
 672               		.loc 1 213 0 discriminator 1
 673 0064 8091 0000 		lds r24,serial_master_buffer
 674 0068 0E94 0000 		call serial_write_byte
 675               	.LVL65:
 214:keyboards/Dactylv2/serial.c ****     sync_recv();
 676               		.loc 1 214 0 discriminator 1
 677 006c 0E94 0000 		call sync_recv
 678               	.LVL66:
 215:keyboards/Dactylv2/serial.c ****     checksum += serial_master_buffer[i];
 679               		.loc 1 215 0 discriminator 1
 680 0070 8091 0000 		lds r24,serial_master_buffer
 681               	.LVL67:
 682               	.LBE114:
 216:keyboards/Dactylv2/serial.c ****   }
 217:keyboards/Dactylv2/serial.c ****   serial_write_byte(checksum);
 683               		.loc 1 217 0 discriminator 1
 684 0074 0E94 0000 		call serial_write_byte
 685               	.LVL68:
 218:keyboards/Dactylv2/serial.c ****   sync_recv();
 686               		.loc 1 218 0 discriminator 1
 687 0078 0E94 0000 		call sync_recv
 688               	.LVL69:
 219:keyboards/Dactylv2/serial.c **** 
 220:keyboards/Dactylv2/serial.c ****   // always, release the line when not in use
 221:keyboards/Dactylv2/serial.c ****   serial_output();
 689               		.loc 1 221 0 discriminator 1
 690 007c 0E94 0000 		call serial_output
 691               	.LVL70:
 222:keyboards/Dactylv2/serial.c ****   serial_high();
 692               		.loc 1 222 0 discriminator 1
 693 0080 0E94 0000 		call serial_high
 694               	.LVL71:
 223:keyboards/Dactylv2/serial.c **** 
 224:keyboards/Dactylv2/serial.c ****   sei();
 695               		.loc 1 224 0 discriminator 1
 696               	/* #APP */
 697               	 ;  224 "keyboards/Dactylv2/serial.c" 1
 698 0084 7894      		sei
 699               	 ;  0 "" 2
 225:keyboards/Dactylv2/serial.c ****   return 0;
 700               		.loc 1 225 0 discriminator 1
 701               	/* #NOAPP */
 702 0086 80E0      		ldi r24,0
 703 0088 90E0      		ldi r25,0
 704 008a 00C0      		rjmp .L29
 705               	.LVL72:
 706               	.L31:
 206:keyboards/Dactylv2/serial.c ****     return 1;
 707               		.loc 1 206 0
 708               	/* #APP */
 709               	 ;  206 "keyboards/Dactylv2/serial.c" 1
 710 008c 7894      		sei
 711               	 ;  0 "" 2
 207:keyboards/Dactylv2/serial.c ****   }
 712               		.loc 1 207 0
 713               	/* #NOAPP */
 714 008e 81E0      		ldi r24,lo8(1)
 715 0090 90E0      		ldi r25,0
 716               	.L29:
 717               	/* epilogue start */
 226:keyboards/Dactylv2/serial.c **** }
 718               		.loc 1 226 0
 719 0092 DF91      		pop r29
 720 0094 CF91      		pop r28
 721 0096 1F91      		pop r17
 722 0098 FF90      		pop r15
 723 009a EF90      		pop r14
 724 009c 0895      		ret
 725               		.cfi_endproc
 726               	.LFE20:
 728               	.global	status
 729               		.section	.bss.status,"aw",@nobits
 732               	status:
 733 0000 00        		.zero	1
 734               	.global	serial_master_buffer
 735               		.section	.bss.serial_master_buffer,"aw",@nobits
 738               	serial_master_buffer:
 739 0000 00        		.zero	1
 740               	.global	serial_slave_buffer
 741               		.section	.bss.serial_slave_buffer,"aw",@nobits
 744               	serial_slave_buffer:
 745 0000 0000 0000 		.zero	7
 745      0000 00
 746               		.text
 747               	.Letext0:
 748               		.file 3 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 serial.c
     /tmp/cckeejru.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cckeejru.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cckeejru.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cckeejru.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cckeejru.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cckeejru.s:12     .text.serial_output:0000000000000000 serial_output
     /tmp/cckeejru.s:29     .text.serial_input:0000000000000000 serial_input
     /tmp/cckeejru.s:47     .text.serial_high:0000000000000000 serial_high
     /tmp/cckeejru.s:63     .text.sync_recv:0000000000000000 sync_recv
     /tmp/cckeejru.s:97     .text.serial_read_byte:0000000000000000 serial_read_byte
     /tmp/cckeejru.s:160    .text.serial_write_byte:0000000000000000 serial_write_byte
     /tmp/cckeejru.s:247    .text.sync_send:0000000000000000 sync_send
     /tmp/cckeejru.s:285    .text.serial_master_init:0000000000000000 serial_master_init
     /tmp/cckeejru.s:305    .text.serial_slave_init:0000000000000000 serial_slave_init
     /tmp/cckeejru.s:331    .text.__vector_1:0000000000000000 __vector_1
     /tmp/cckeejru.s:744    .bss.serial_slave_buffer:0000000000000000 serial_slave_buffer
     /tmp/cckeejru.s:738    .bss.serial_master_buffer:0000000000000000 serial_master_buffer
     /tmp/cckeejru.s:732    .bss.status:0000000000000000 status
     /tmp/cckeejru.s:551    .text.serial_update_buffers:0000000000000000 serial_update_buffers

UNDEFINED SYMBOLS
__do_clear_bss
