   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.matrix_init_user,"ax",@progbits
  11               		.weak	matrix_init_user
  13               	matrix_init_user:
  14               	.LFB10:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012-2017 Jun Wako, Jack Humbert
   3:quantum/matrix.c **** 
   4:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   6:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/matrix.c **** (at your option) any later version.
   8:quantum/matrix.c **** 
   9:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  10:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/matrix.c **** GNU General Public License for more details.
  13:quantum/matrix.c **** 
  14:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  15:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/matrix.c **** */
  17:quantum/matrix.c **** #include <stdint.h>
  18:quantum/matrix.c **** #include <stdbool.h>
  19:quantum/matrix.c **** #if defined(__AVR__)
  20:quantum/matrix.c **** #include <avr/io.h>
  21:quantum/matrix.c **** #endif
  22:quantum/matrix.c **** #include "wait.h"
  23:quantum/matrix.c **** #include "print.h"
  24:quantum/matrix.c **** #include "debug.h"
  25:quantum/matrix.c **** #include "util.h"
  26:quantum/matrix.c **** #include "matrix.h"
  27:quantum/matrix.c **** #include "timer.h"
  28:quantum/matrix.c **** 
  29:quantum/matrix.c **** 
  30:quantum/matrix.c **** /* Set 0 if debouncing isn't needed */
  31:quantum/matrix.c **** 
  32:quantum/matrix.c **** #ifndef DEBOUNCING_DELAY
  33:quantum/matrix.c **** #   define DEBOUNCING_DELAY 5
  34:quantum/matrix.c **** #endif
  35:quantum/matrix.c **** 
  36:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
  37:quantum/matrix.c ****     static uint16_t debouncing_time;
  38:quantum/matrix.c ****     static bool debouncing = false;
  39:quantum/matrix.c **** #endif
  40:quantum/matrix.c **** 
  41:quantum/matrix.c **** #if (MATRIX_COLS <= 8)
  42:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 01234567\n")
  43:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse8(matrix_get_row(row))
  44:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop(matrix[i])
  45:quantum/matrix.c **** #    define ROW_SHIFTER ((uint8_t)1)
  46:quantum/matrix.c **** #elif (MATRIX_COLS <= 16)
  47:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF\n")
  48:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse16(matrix_get_row(row))
  49:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop16(matrix[i])
  50:quantum/matrix.c **** #    define ROW_SHIFTER ((uint16_t)1)
  51:quantum/matrix.c **** #elif (MATRIX_COLS <= 32)
  52:quantum/matrix.c **** #    define print_matrix_header()  print("\nr/c 0123456789ABCDEF0123456789ABCDEF\n")
  53:quantum/matrix.c **** #    define print_matrix_row(row)  print_bin_reverse32(matrix_get_row(row))
  54:quantum/matrix.c **** #    define matrix_bitpop(i)       bitpop32(matrix[i])
  55:quantum/matrix.c **** #    define ROW_SHIFTER  ((uint32_t)1)
  56:quantum/matrix.c **** #endif
  57:quantum/matrix.c **** 
  58:quantum/matrix.c **** #ifdef MATRIX_MASKED
  59:quantum/matrix.c ****     extern const matrix_row_t matrix_mask[];
  60:quantum/matrix.c **** #endif
  61:quantum/matrix.c **** 
  62:quantum/matrix.c **** #if (DIODE_DIRECTION == ROW2COL) || (DIODE_DIRECTION == COL2ROW)
  63:quantum/matrix.c **** static const uint8_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  64:quantum/matrix.c **** static const uint8_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  65:quantum/matrix.c **** #endif
  66:quantum/matrix.c **** 
  67:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  68:quantum/matrix.c **** static matrix_row_t matrix[MATRIX_ROWS];
  69:quantum/matrix.c **** 
  70:quantum/matrix.c **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  71:quantum/matrix.c **** 
  72:quantum/matrix.c **** 
  73:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
  74:quantum/matrix.c ****     static void init_cols(void);
  75:quantum/matrix.c ****     static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row);
  76:quantum/matrix.c ****     static void unselect_rows(void);
  77:quantum/matrix.c ****     static void select_row(uint8_t row);
  78:quantum/matrix.c ****     static void unselect_row(uint8_t row);
  79:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
  80:quantum/matrix.c ****     static void init_rows(void);
  81:quantum/matrix.c ****     static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col);
  82:quantum/matrix.c ****     static void unselect_cols(void);
  83:quantum/matrix.c ****     static void unselect_col(uint8_t col);
  84:quantum/matrix.c ****     static void select_col(uint8_t col);
  85:quantum/matrix.c **** #endif
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** __attribute__ ((weak))
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  89:quantum/matrix.c ****     matrix_init_kb();
  90:quantum/matrix.c **** }
  91:quantum/matrix.c **** 
  92:quantum/matrix.c **** __attribute__ ((weak))
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  94:quantum/matrix.c ****     matrix_scan_kb();
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** __attribute__ ((weak))
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  99:quantum/matrix.c ****     matrix_init_user();
 100:quantum/matrix.c **** }
 101:quantum/matrix.c **** 
 102:quantum/matrix.c **** __attribute__ ((weak))
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
 104:quantum/matrix.c ****     matrix_scan_user();
 105:quantum/matrix.c **** }
 106:quantum/matrix.c **** 
 107:quantum/matrix.c **** __attribute__ ((weak))
 108:quantum/matrix.c **** void matrix_init_user(void) {
  16               		.loc 1 108 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 0895      		ret
  23               		.cfi_endproc
  24               	.LFE10:
  26               		.section	.text.matrix_init_kb,"ax",@progbits
  27               		.weak	matrix_init_kb
  29               	matrix_init_kb:
  30               	.LFB8:
  98:quantum/matrix.c **** void matrix_init_kb(void) {
  31               		.loc 1 98 0
  32               		.cfi_startproc
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
  99:quantum/matrix.c ****     matrix_init_user();
  37               		.loc 1 99 0
  38 0000 0C94 0000 		jmp matrix_init_user
  39               	.LVL0:
  40               		.cfi_endproc
  41               	.LFE8:
  43               		.section	.text.matrix_init_quantum,"ax",@progbits
  44               		.weak	matrix_init_quantum
  46               	matrix_init_quantum:
  47               	.LFB6:
  88:quantum/matrix.c **** void matrix_init_quantum(void) {
  48               		.loc 1 88 0
  49               		.cfi_startproc
  50               	/* prologue: function */
  51               	/* frame size = 0 */
  52               	/* stack size = 0 */
  53               	.L__stack_usage = 0
  89:quantum/matrix.c ****     matrix_init_kb();
  54               		.loc 1 89 0
  55 0000 0C94 0000 		jmp matrix_init_kb
  56               	.LVL1:
  57               		.cfi_endproc
  58               	.LFE6:
  60               		.section	.text.matrix_scan_user,"ax",@progbits
  61               		.weak	matrix_scan_user
  63               	matrix_scan_user:
  64               	.LFB11:
 109:quantum/matrix.c **** }
 110:quantum/matrix.c **** 
 111:quantum/matrix.c **** __attribute__ ((weak))
 112:quantum/matrix.c **** void matrix_scan_user(void) {
  65               		.loc 1 112 0
  66               		.cfi_startproc
  67               	/* prologue: function */
  68               	/* frame size = 0 */
  69               	/* stack size = 0 */
  70               	.L__stack_usage = 0
  71 0000 0895      		ret
  72               		.cfi_endproc
  73               	.LFE11:
  75               		.section	.text.matrix_scan_kb,"ax",@progbits
  76               		.weak	matrix_scan_kb
  78               	matrix_scan_kb:
  79               	.LFB9:
 103:quantum/matrix.c **** void matrix_scan_kb(void) {
  80               		.loc 1 103 0
  81               		.cfi_startproc
  82               	/* prologue: function */
  83               	/* frame size = 0 */
  84               	/* stack size = 0 */
  85               	.L__stack_usage = 0
 104:quantum/matrix.c ****     matrix_scan_user();
  86               		.loc 1 104 0
  87 0000 0C94 0000 		jmp matrix_scan_user
  88               	.LVL2:
  89               		.cfi_endproc
  90               	.LFE9:
  92               		.section	.text.matrix_scan_quantum,"ax",@progbits
  93               		.weak	matrix_scan_quantum
  95               	matrix_scan_quantum:
  96               	.LFB7:
  93:quantum/matrix.c **** void matrix_scan_quantum(void) {
  97               		.loc 1 93 0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
  94:quantum/matrix.c ****     matrix_scan_kb();
 103               		.loc 1 94 0
 104 0000 0C94 0000 		jmp matrix_scan_kb
 105               	.LVL3:
 106               		.cfi_endproc
 107               	.LFE7:
 109               		.section	.text.matrix_rows,"ax",@progbits
 110               	.global	matrix_rows
 112               	matrix_rows:
 113               	.LFB12:
 113:quantum/matrix.c **** }
 114:quantum/matrix.c **** 
 115:quantum/matrix.c **** inline
 116:quantum/matrix.c **** uint8_t matrix_rows(void) {
 114               		.loc 1 116 0
 115               		.cfi_startproc
 116               	/* prologue: function */
 117               	/* frame size = 0 */
 118               	/* stack size = 0 */
 119               	.L__stack_usage = 0
 117:quantum/matrix.c ****     return MATRIX_ROWS;
 118:quantum/matrix.c **** }
 120               		.loc 1 118 0
 121 0000 85E0      		ldi r24,lo8(5)
 122 0002 0895      		ret
 123               		.cfi_endproc
 124               	.LFE12:
 126               		.section	.text.matrix_cols,"ax",@progbits
 127               	.global	matrix_cols
 129               	matrix_cols:
 130               	.LFB13:
 119:quantum/matrix.c **** 
 120:quantum/matrix.c **** inline
 121:quantum/matrix.c **** uint8_t matrix_cols(void) {
 131               		.loc 1 121 0
 132               		.cfi_startproc
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 135               	/* stack size = 0 */
 136               	.L__stack_usage = 0
 122:quantum/matrix.c ****     return MATRIX_COLS;
 123:quantum/matrix.c **** }
 137               		.loc 1 123 0
 138 0000 8FE0      		ldi r24,lo8(15)
 139 0002 0895      		ret
 140               		.cfi_endproc
 141               	.LFE13:
 143               		.section	.text.matrix_init,"ax",@progbits
 144               	.global	matrix_init
 146               	matrix_init:
 147               	.LFB14:
 124:quantum/matrix.c **** 
 125:quantum/matrix.c **** // void matrix_power_up(void) {
 126:quantum/matrix.c **** // #if (DIODE_DIRECTION == COL2ROW)
 127:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 128:quantum/matrix.c **** //         /* DDRxn */
 129:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 1) |= _BV(row_pins[r] & 0xF);
 130:quantum/matrix.c **** //         toggle_row(r);
 131:quantum/matrix.c **** //     }
 132:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 133:quantum/matrix.c **** //         /* PORTxn */
 134:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 2) |= _BV(col_pins[c] & 0xF);
 135:quantum/matrix.c **** //     }
 136:quantum/matrix.c **** // #elif (DIODE_DIRECTION == ROW2COL)
 137:quantum/matrix.c **** //     for (int8_t c = MATRIX_COLS - 1; c >= 0; --c) {
 138:quantum/matrix.c **** //         /* DDRxn */
 139:quantum/matrix.c **** //         _SFR_IO8((col_pins[c] >> 4) + 1) |= _BV(col_pins[c] & 0xF);
 140:quantum/matrix.c **** //         toggle_col(c);
 141:quantum/matrix.c **** //     }
 142:quantum/matrix.c **** //     for (int8_t r = MATRIX_ROWS - 1; r >= 0; --r) {
 143:quantum/matrix.c **** //         /* PORTxn */
 144:quantum/matrix.c **** //         _SFR_IO8((row_pins[r] >> 4) + 2) |= _BV(row_pins[r] & 0xF);
 145:quantum/matrix.c **** //     }
 146:quantum/matrix.c **** // #endif
 147:quantum/matrix.c **** // }
 148:quantum/matrix.c **** 
 149:quantum/matrix.c **** void matrix_init(void) {
 148               		.loc 1 149 0
 149               		.cfi_startproc
 150               	/* prologue: function */
 151               	/* frame size = 0 */
 152               	/* stack size = 0 */
 153               	.L__stack_usage = 0
 150:quantum/matrix.c **** 
 151:quantum/matrix.c ****     // To use PORTF disable JTAG with writing JTD bit twice within four cycles.
 152:quantum/matrix.c ****     #if  (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__) || defined(__AVR_ATmega32U4_
 153:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 154               		.loc 1 153 0
 155 0000 85B7      		in r24,0x35
 156 0002 8068      		ori r24,lo8(-128)
 157 0004 85BF      		out 0x35,r24
 154:quantum/matrix.c ****         MCUCR |= _BV(JTD);
 158               		.loc 1 154 0
 159 0006 85B7      		in r24,0x35
 160 0008 8068      		ori r24,lo8(-128)
 161 000a 85BF      		out 0x35,r24
 162               	.LVL4:
 163 000c A0E0      		ldi r26,lo8(row_pins)
 164 000e B0E0      		ldi r27,hi8(row_pins)
 165               	.LBB19:
 166               	.LBB20:
 167               	.LBB21:
 155:quantum/matrix.c ****     #endif
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // initialize row and col
 158:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 159:quantum/matrix.c ****     unselect_rows();
 160:quantum/matrix.c ****     init_cols();
 161:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 162:quantum/matrix.c ****     unselect_cols();
 163:quantum/matrix.c ****     init_rows();
 164:quantum/matrix.c **** #endif
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     // initialize matrix state: all keys off
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 168:quantum/matrix.c ****         matrix[i] = 0;
 169:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 170:quantum/matrix.c ****     }
 171:quantum/matrix.c **** 
 172:quantum/matrix.c ****     matrix_init_quantum();
 173:quantum/matrix.c **** }
 174:quantum/matrix.c **** 
 175:quantum/matrix.c **** uint8_t matrix_scan(void)
 176:quantum/matrix.c **** {
 177:quantum/matrix.c **** 
 178:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 179:quantum/matrix.c **** 
 180:quantum/matrix.c ****     // Set row, read cols
 181:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 182:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 183:quantum/matrix.c ****             bool matrix_changed = read_cols_on_row(matrix_debouncing, current_row);
 184:quantum/matrix.c **** 
 185:quantum/matrix.c ****             if (matrix_changed) {
 186:quantum/matrix.c ****                 debouncing = true;
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 188:quantum/matrix.c ****             }
 189:quantum/matrix.c **** 
 190:quantum/matrix.c **** #       else
 191:quantum/matrix.c ****             read_cols_on_row(matrix, current_row);
 192:quantum/matrix.c **** #       endif
 193:quantum/matrix.c **** 
 194:quantum/matrix.c ****     }
 195:quantum/matrix.c **** 
 196:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 197:quantum/matrix.c **** 
 198:quantum/matrix.c ****     // Set col, read rows
 199:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 200:quantum/matrix.c **** #       if (DEBOUNCING_DELAY > 0)
 201:quantum/matrix.c ****             bool matrix_changed = read_rows_on_col(matrix_debouncing, current_col);
 202:quantum/matrix.c ****             if (matrix_changed) {
 203:quantum/matrix.c ****                 debouncing = true;
 204:quantum/matrix.c ****                 debouncing_time = timer_read();
 205:quantum/matrix.c ****             }
 206:quantum/matrix.c **** #       else
 207:quantum/matrix.c ****              read_rows_on_col(matrix, current_col);
 208:quantum/matrix.c **** #       endif
 209:quantum/matrix.c **** 
 210:quantum/matrix.c ****     }
 211:quantum/matrix.c **** 
 212:quantum/matrix.c **** #endif
 213:quantum/matrix.c **** 
 214:quantum/matrix.c **** #   if (DEBOUNCING_DELAY > 0)
 215:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 218:quantum/matrix.c ****             }
 219:quantum/matrix.c ****             debouncing = false;
 220:quantum/matrix.c ****         }
 221:quantum/matrix.c **** #   endif
 222:quantum/matrix.c **** 
 223:quantum/matrix.c ****     matrix_scan_quantum();
 224:quantum/matrix.c ****     return 1;
 225:quantum/matrix.c **** }
 226:quantum/matrix.c **** 
 227:quantum/matrix.c **** bool matrix_is_modified(void)
 228:quantum/matrix.c **** {
 229:quantum/matrix.c **** #if (DEBOUNCING_DELAY > 0)
 230:quantum/matrix.c ****     if (debouncing) return false;
 231:quantum/matrix.c **** #endif
 232:quantum/matrix.c ****     return true;
 233:quantum/matrix.c **** }
 234:quantum/matrix.c **** 
 235:quantum/matrix.c **** inline
 236:quantum/matrix.c **** bool matrix_is_on(uint8_t row, uint8_t col)
 237:quantum/matrix.c **** {
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 239:quantum/matrix.c **** }
 240:quantum/matrix.c **** 
 241:quantum/matrix.c **** inline
 242:quantum/matrix.c **** matrix_row_t matrix_get_row(uint8_t row)
 243:quantum/matrix.c **** {
 244:quantum/matrix.c ****     // Matrix mask lets you disable switches in the returned matrix data. For example, if you have 
 245:quantum/matrix.c ****     // switch blocker installed and the switch is always pressed.
 246:quantum/matrix.c **** #ifdef MATRIX_MASKED
 247:quantum/matrix.c ****     return matrix[row] & matrix_mask[row];
 248:quantum/matrix.c **** #else
 249:quantum/matrix.c ****     return matrix[row];
 250:quantum/matrix.c **** #endif
 251:quantum/matrix.c **** }
 252:quantum/matrix.c **** 
 253:quantum/matrix.c **** void matrix_print(void)
 254:quantum/matrix.c **** {
 255:quantum/matrix.c ****     print_matrix_header();
 256:quantum/matrix.c **** 
 257:quantum/matrix.c ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 258:quantum/matrix.c ****         phex(row); print(": ");
 259:quantum/matrix.c ****         print_matrix_row(row);
 260:quantum/matrix.c ****         print("\n");
 261:quantum/matrix.c ****     }
 262:quantum/matrix.c **** }
 263:quantum/matrix.c **** 
 264:quantum/matrix.c **** uint8_t matrix_key_count(void)
 265:quantum/matrix.c **** {
 266:quantum/matrix.c ****     uint8_t count = 0;
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 269:quantum/matrix.c ****     }
 270:quantum/matrix.c ****     return count;
 271:quantum/matrix.c **** }
 272:quantum/matrix.c **** 
 273:quantum/matrix.c **** 
 274:quantum/matrix.c **** 
 275:quantum/matrix.c **** #if (DIODE_DIRECTION == COL2ROW)
 276:quantum/matrix.c **** 
 277:quantum/matrix.c **** static void init_cols(void)
 278:quantum/matrix.c **** {
 279:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 283:quantum/matrix.c ****     }
 284:quantum/matrix.c **** }
 285:quantum/matrix.c **** 
 286:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)
 287:quantum/matrix.c **** {
 288:quantum/matrix.c ****     // Store last value of row prior to reading
 289:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 290:quantum/matrix.c **** 
 291:quantum/matrix.c ****     // Clear data in matrix row
 292:quantum/matrix.c ****     current_matrix[current_row] = 0;
 293:quantum/matrix.c **** 
 294:quantum/matrix.c ****     // Select row and wait for row selecton to stabilize
 295:quantum/matrix.c ****     select_row(current_row);
 296:quantum/matrix.c ****     wait_us(30);
 297:quantum/matrix.c **** 
 298:quantum/matrix.c ****     // For each col...
 299:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 300:quantum/matrix.c **** 
 301:quantum/matrix.c ****         // Select the col pin to read (active low)
 302:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 304:quantum/matrix.c **** 
 305:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 306:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 307:quantum/matrix.c ****     }
 308:quantum/matrix.c **** 
 309:quantum/matrix.c ****     // Unselect row
 310:quantum/matrix.c ****     unselect_row(current_row);
 311:quantum/matrix.c **** 
 312:quantum/matrix.c ****     return (last_row_value != current_matrix[current_row]);
 313:quantum/matrix.c **** }
 314:quantum/matrix.c **** 
 315:quantum/matrix.c **** static void select_row(uint8_t row)
 316:quantum/matrix.c **** {
 317:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 320:quantum/matrix.c **** }
 321:quantum/matrix.c **** 
 322:quantum/matrix.c **** static void unselect_row(uint8_t row)
 323:quantum/matrix.c **** {
 324:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 325:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 327:quantum/matrix.c **** }
 328:quantum/matrix.c **** 
 329:quantum/matrix.c **** static void unselect_rows(void)
 330:quantum/matrix.c **** {
 331:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 333:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 168               		.loc 1 333 0
 169 0010 21E0      		ldi r18,lo8(1)
 170 0012 30E0      		ldi r19,0
 171               	.LVL5:
 172               	.L11:
 332:quantum/matrix.c ****         uint8_t pin = row_pins[x];
 173               		.loc 1 332 0
 174 0014 8D91      		ld r24,X+
 175               	.LVL6:
 176               		.loc 1 333 0
 177 0016 E82F      		mov r30,r24
 178 0018 E295      		swap r30
 179 001a EF70      		andi r30,lo8(15)
 180 001c F0E0      		ldi r31,0
 181 001e 41A1      		ldd r20,Z+33
 182 0020 8F70      		andi r24,lo8(15)
 183               	.LVL7:
 184 0022 B901      		movw r22,r18
 185 0024 00C0      		rjmp 2f
 186               		1:
 187 0026 660F      		lsl r22
 188 0028 771F      		rol r23
 189               		2:
 190 002a 8A95      		dec r24
 191 002c 02F4      		brpl 1b
 192 002e CB01      		movw r24,r22
 193 0030 962F      		mov r25,r22
 194 0032 9095      		com r25
 195 0034 4923      		and r20,r25
 196 0036 41A3      		std Z+33,r20
 197               	.LVL8:
 334:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 198               		.loc 1 334 0
 199 0038 92A1      		ldd r25,Z+34
 200 003a 982B      		or r25,r24
 201 003c 92A3      		std Z+34,r25
 202               	.LVL9:
 203               	.LBE21:
 331:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_ROWS; x++) {
 204               		.loc 1 331 0
 205 003e 70E0      		ldi r23,hi8(row_pins+5)
 206 0040 A030      		cpi r26,lo8(row_pins+5)
 207 0042 B707      		cpc r27,r23
 208 0044 01F4      		brne .L11
 209 0046 A0E0      		ldi r26,lo8(col_pins)
 210 0048 B0E0      		ldi r27,hi8(col_pins)
 211               	.LVL10:
 212               	.LBE20:
 213               	.LBE19:
 214               	.LBB22:
 215               	.LBB23:
 216               	.LBB24:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 217               		.loc 1 281 0
 218 004a 21E0      		ldi r18,lo8(1)
 219 004c 30E0      		ldi r19,0
 220               	.L13:
 221               	.LVL11:
 280:quantum/matrix.c ****         uint8_t pin = col_pins[x];
 222               		.loc 1 280 0
 223 004e 8D91      		ld r24,X+
 224               	.LVL12:
 281:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 225               		.loc 1 281 0
 226 0050 E82F      		mov r30,r24
 227 0052 E295      		swap r30
 228 0054 EF70      		andi r30,lo8(15)
 229 0056 F0E0      		ldi r31,0
 230 0058 41A1      		ldd r20,Z+33
 231 005a 8F70      		andi r24,lo8(15)
 232               	.LVL13:
 233 005c B901      		movw r22,r18
 234 005e 00C0      		rjmp 2f
 235               		1:
 236 0060 660F      		lsl r22
 237 0062 771F      		rol r23
 238               		2:
 239 0064 8A95      		dec r24
 240 0066 02F4      		brpl 1b
 241 0068 CB01      		movw r24,r22
 242 006a 962F      		mov r25,r22
 243 006c 9095      		com r25
 244 006e 4923      		and r20,r25
 245 0070 41A3      		std Z+33,r20
 246               	.LVL14:
 282:quantum/matrix.c ****         _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 247               		.loc 1 282 0
 248 0072 92A1      		ldd r25,Z+34
 249 0074 982B      		or r25,r24
 250 0076 92A3      		std Z+34,r25
 251               	.LVL15:
 252               	.LBE24:
 279:quantum/matrix.c ****     for(uint8_t x = 0; x < MATRIX_COLS; x++) {
 253               		.loc 1 279 0
 254 0078 70E0      		ldi r23,hi8(col_pins+15)
 255 007a A030      		cpi r26,lo8(col_pins+15)
 256 007c B707      		cpc r27,r23
 257 007e 01F4      		brne .L13
 258 0080 E0E0      		ldi r30,lo8(matrix)
 259 0082 F0E0      		ldi r31,hi8(matrix)
 260 0084 A0E0      		ldi r26,lo8(matrix_debouncing)
 261 0086 B0E0      		ldi r27,hi8(matrix_debouncing)
 262               	.LVL16:
 263               	.L15:
 264               	.LBE23:
 265               	.LBE22:
 266               	.LBB25:
 168:quantum/matrix.c ****         matrix[i] = 0;
 267               		.loc 1 168 0 discriminator 2
 268 0088 1192      		st Z+,__zero_reg__
 269 008a 1192      		st Z+,__zero_reg__
 169:quantum/matrix.c ****         matrix_debouncing[i] = 0;
 270               		.loc 1 169 0 discriminator 2
 271 008c 1D92      		st X+,__zero_reg__
 272 008e 1D92      		st X+,__zero_reg__
 273               	.LVL17:
 167:quantum/matrix.c ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 274               		.loc 1 167 0 discriminator 2
 275 0090 80E0      		ldi r24,hi8(matrix+10)
 276 0092 E030      		cpi r30,lo8(matrix+10)
 277 0094 F807      		cpc r31,r24
 278 0096 01F4      		brne .L15
 279               	.LBE25:
 172:quantum/matrix.c ****     matrix_init_quantum();
 280               		.loc 1 172 0
 281 0098 0C94 0000 		jmp matrix_init_quantum
 282               	.LVL18:
 283               		.cfi_endproc
 284               	.LFE14:
 286               		.section	.text.matrix_scan,"ax",@progbits
 287               	.global	matrix_scan
 289               	matrix_scan:
 290               	.LFB15:
 176:quantum/matrix.c **** {
 291               		.loc 1 176 0
 292               		.cfi_startproc
 293 0000 4F92      		push r4
 294               	.LCFI0:
 295               		.cfi_def_cfa_offset 3
 296               		.cfi_offset 4, -2
 297 0002 5F92      		push r5
 298               	.LCFI1:
 299               		.cfi_def_cfa_offset 4
 300               		.cfi_offset 5, -3
 301 0004 7F92      		push r7
 302               	.LCFI2:
 303               		.cfi_def_cfa_offset 5
 304               		.cfi_offset 7, -4
 305 0006 8F92      		push r8
 306               	.LCFI3:
 307               		.cfi_def_cfa_offset 6
 308               		.cfi_offset 8, -5
 309 0008 9F92      		push r9
 310               	.LCFI4:
 311               		.cfi_def_cfa_offset 7
 312               		.cfi_offset 9, -6
 313 000a AF92      		push r10
 314               	.LCFI5:
 315               		.cfi_def_cfa_offset 8
 316               		.cfi_offset 10, -7
 317 000c BF92      		push r11
 318               	.LCFI6:
 319               		.cfi_def_cfa_offset 9
 320               		.cfi_offset 11, -8
 321 000e CF92      		push r12
 322               	.LCFI7:
 323               		.cfi_def_cfa_offset 10
 324               		.cfi_offset 12, -9
 325 0010 DF92      		push r13
 326               	.LCFI8:
 327               		.cfi_def_cfa_offset 11
 328               		.cfi_offset 13, -10
 329 0012 EF92      		push r14
 330               	.LCFI9:
 331               		.cfi_def_cfa_offset 12
 332               		.cfi_offset 14, -11
 333 0014 FF92      		push r15
 334               	.LCFI10:
 335               		.cfi_def_cfa_offset 13
 336               		.cfi_offset 15, -12
 337 0016 0F93      		push r16
 338               	.LCFI11:
 339               		.cfi_def_cfa_offset 14
 340               		.cfi_offset 16, -13
 341 0018 1F93      		push r17
 342               	.LCFI12:
 343               		.cfi_def_cfa_offset 15
 344               		.cfi_offset 17, -14
 345 001a CF93      		push r28
 346               	.LCFI13:
 347               		.cfi_def_cfa_offset 16
 348               		.cfi_offset 28, -15
 349 001c DF93      		push r29
 350               	.LCFI14:
 351               		.cfi_def_cfa_offset 17
 352               		.cfi_offset 29, -16
 353               	/* prologue: function */
 354               	/* frame size = 0 */
 355               	/* stack size = 15 */
 356               	.L__stack_usage = 15
 357               	.LVL19:
 358 001e 00E0      		ldi r16,lo8(row_pins)
 359 0020 10E0      		ldi r17,hi8(row_pins)
 176:quantum/matrix.c **** {
 360               		.loc 1 176 0
 361 0022 C0E0      		ldi r28,lo8(matrix_debouncing)
 362 0024 D0E0      		ldi r29,hi8(matrix_debouncing)
 363               	.LBB39:
 364               	.LBB40:
 365               	.LBB41:
 366               	.LBB42:
 367               	.LBB43:
 368               	.LBB44:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 369               		.loc 1 318 0
 370 0026 EE24      		clr r14
 371 0028 E394      		inc r14
 372 002a F12C      		mov r15,__zero_reg__
 373               	.LBE44:
 374               	.LBE43:
 375               	.LBE42:
 376               	.LBE41:
 186:quantum/matrix.c ****                 debouncing = true;
 377               		.loc 1 186 0
 378 002c 9924      		clr r9
 379 002e 9394      		inc r9
 380               	.LVL20:
 381               	.L23:
 382 0030 BE01      		movw r22,r28
 383               	.LBB54:
 384               	.LBB53:
 289:quantum/matrix.c ****     matrix_row_t last_row_value = current_matrix[current_row];
 385               		.loc 1 289 0
 386 0032 A880      		ld r10,Y
 387 0034 B980      		ldd r11,Y+1
 388               	.LVL21:
 292:quantum/matrix.c ****     current_matrix[current_row] = 0;
 389               		.loc 1 292 0
 390 0036 1982      		std Y+1,__zero_reg__
 391 0038 1882      		st Y,__zero_reg__
 392               	.LVL22:
 393               	.LBB46:
 394               	.LBB45:
 317:quantum/matrix.c ****     uint8_t pin = row_pins[row];
 395               		.loc 1 317 0
 396 003a D801      		movw r26,r16
 397 003c 2D91      		ld r18,X+
 398 003e 8D01      		movw r16,r26
 399               	.LVL23:
 318:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) |=  _BV(pin & 0xF); // OUT
 400               		.loc 1 318 0
 401 0040 E22F      		mov r30,r18
 402 0042 E295      		swap r30
 403 0044 EF70      		andi r30,lo8(15)
 404 0046 F0E0      		ldi r31,0
 405 0048 81A1      		ldd r24,Z+33
 406 004a 2F70      		andi r18,lo8(15)
 407               	.LVL24:
 408 004c A701      		movw r20,r14
 409 004e 00C0      		rjmp 2f
 410               		1:
 411 0050 440F      		lsl r20
 412 0052 551F      		rol r21
 413               		2:
 414 0054 2A95      		dec r18
 415 0056 02F4      		brpl 1b
 416 0058 9A01      		movw r18,r20
 417 005a 842B      		or r24,r20
 418 005c 81A3      		std Z+33,r24
 419               	.LVL25:
 319:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) &= ~_BV(pin & 0xF); // LOW
 420               		.loc 1 319 0
 421 005e 82A1      		ldd r24,Z+34
 422 0060 842E      		mov r8,r20
 423 0062 8094      		com r8
 424 0064 8821      		and r24,r8
 425 0066 82A3      		std Z+34,r24
 426               	.LVL26:
 427               	.LBE45:
 428               	.LBE46:
 429               	.LBB47:
 430               	.LBB48:
 431               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/avr/include/util/delay.h **** 
 166:/usr/lib/avr/include/util/delay.h **** #else
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/avr/include/util/delay.h **** 
 235:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/avr/include/util/delay.h **** 
 238:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h **** 	#else
 242:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/avr/include/util/delay.h **** 	#endif
 245:/usr/lib/avr/include/util/delay.h **** 
 246:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 432               		.loc 2 246 0
 433 0068 50EA      		ldi r21,lo8(-96)
 434 006a 5A95      		1: dec r21
 435 006c 01F4      		brne 1b
 436               	.LVL27:
 437 006e 40E0      		ldi r20,lo8(col_pins)
 438 0070 442E      		mov r4,r20
 439 0072 40E0      		ldi r20,hi8(col_pins)
 440 0074 542E      		mov r5,r20
 441 0076 80E0      		ldi r24,0
 442 0078 90E0      		ldi r25,0
 443               	.LVL28:
 444               	.L20:
 445               	.LBE48:
 446               	.LBE47:
 447               	.LBB49:
 448               	.LBB50:
 302:quantum/matrix.c ****         uint8_t pin = col_pins[col_index];
 449               		.loc 1 302 0
 450 007a D201      		movw r26,r4
 451 007c 4D91      		ld r20,X+
 452 007e 2D01      		movw r4,r26
 453               	.LVL29:
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 454               		.loc 1 303 0
 455 0080 C42E      		mov r12,r20
 456 0082 C294      		swap r12
 457 0084 3FE0      		ldi r19,lo8(15)
 458 0086 C322      		and r12,r19
 459 0088 D12C      		mov r13,__zero_reg__
 460 008a D601      		movw r26,r12
 461 008c 9096      		adiw r26,32
 462 008e 7C90      		ld r7,X
 463               	.LVL30:
 306:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 464               		.loc 1 306 0
 465 0090 C880      		ld r12,Y
 466 0092 D980      		ldd r13,Y+1
 303:quantum/matrix.c ****         uint8_t pin_state = (_SFR_IO8(pin >> 4) & _BV(pin & 0xF));
 467               		.loc 1 303 0
 468 0094 4F70      		andi r20,lo8(15)
 469               	.LVL31:
 470 0096 D701      		movw r26,r14
 471 0098 00C0      		rjmp 2f
 472               		1:
 473 009a AA0F      		lsl r26
 474 009c BB1F      		rol r27
 475               		2:
 476 009e 4A95      		dec r20
 477 00a0 02F4      		brpl 1b
 478 00a2 7A22      		and r7,r26
 479               	.LVL32:
 306:quantum/matrix.c ****         current_matrix[current_row] |=  pin_state ? 0 : (ROW_SHIFTER << col_index);
 480               		.loc 1 306 0
 481 00a4 01F4      		brne .L29
 482 00a6 A701      		movw r20,r14
 483 00a8 082E      		mov r0,r24
 484 00aa 00C0      		rjmp 2f
 485               		1:
 486 00ac 440F      		lsl r20
 487 00ae 551F      		rol r21
 488               		2:
 489 00b0 0A94      		dec r0
 490 00b2 02F4      		brpl 1b
 491 00b4 00C0      		rjmp .L18
 492               	.L29:
 493 00b6 40E0      		ldi r20,0
 494 00b8 50E0      		ldi r21,0
 495               	.L18:
 496 00ba 4C29      		or r20,r12
 497 00bc 5D29      		or r21,r13
 498 00be 5983      		std Y+1,r21
 499 00c0 4883      		st Y,r20
 500               	.LVL33:
 501 00c2 0196      		adiw r24,1
 502               	.LVL34:
 503               	.LBE50:
 299:quantum/matrix.c ****     for(uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 504               		.loc 1 299 0
 505 00c4 8F30      		cpi r24,15
 506 00c6 9105      		cpc r25,__zero_reg__
 507 00c8 01F4      		brne .L20
 508               	.LVL35:
 509               	.LBE49:
 510               	.LBB51:
 511               	.LBB52:
 325:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 1) &= ~_BV(pin & 0xF); // IN
 512               		.loc 1 325 0
 513 00ca 81A1      		ldd r24,Z+33
 514               	.LVL36:
 515 00cc 8821      		and r24,r8
 516 00ce 81A3      		std Z+33,r24
 517               	.LVL37:
 326:quantum/matrix.c ****     _SFR_IO8((pin >> 4) + 2) |=  _BV(pin & 0xF); // HI
 518               		.loc 1 326 0
 519 00d0 82A1      		ldd r24,Z+34
 520 00d2 822B      		or r24,r18
 521 00d4 82A3      		std Z+34,r24
 522 00d6 2296      		adiw r28,2
 523               	.LBE52:
 524               	.LBE51:
 525               	.LBE53:
 526               	.LBE54:
 185:quantum/matrix.c ****             if (matrix_changed) {
 527               		.loc 1 185 0
 528 00d8 FB01      		movw r30,r22
 529 00da 8081      		ld r24,Z
 530 00dc 9181      		ldd r25,Z+1
 531 00de A816      		cp r10,r24
 532 00e0 B906      		cpc r11,r25
 533 00e2 01F0      		breq .L21
 186:quantum/matrix.c ****                 debouncing = true;
 534               		.loc 1 186 0
 535 00e4 9092 0000 		sts debouncing,r9
 187:quantum/matrix.c ****                 debouncing_time = timer_read();
 536               		.loc 1 187 0
 537 00e8 0E94 0000 		call timer_read
 538               	.LVL38:
 539 00ec 9093 0000 		sts debouncing_time+1,r25
 540 00f0 8093 0000 		sts debouncing_time,r24
 541               	.L21:
 542               	.LVL39:
 543               	.LBE40:
 181:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 544               		.loc 1 181 0
 545 00f4 F0E0      		ldi r31,hi8(row_pins+5)
 546 00f6 0030      		cpi r16,lo8(row_pins+5)
 547 00f8 1F07      		cpc r17,r31
 548 00fa 01F0      		breq .+2
 549 00fc 00C0      		rjmp .L23
 550               	.LBE39:
 215:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 551               		.loc 1 215 0
 552 00fe 8091 0000 		lds r24,debouncing
 553 0102 8823      		tst r24
 554 0104 01F0      		breq .L25
 215:quantum/matrix.c ****         if (debouncing && (timer_elapsed(debouncing_time) > DEBOUNCING_DELAY)) {
 555               		.loc 1 215 0 is_stmt 0 discriminator 1
 556 0106 8091 0000 		lds r24,debouncing_time
 557 010a 9091 0000 		lds r25,debouncing_time+1
 558 010e 0E94 0000 		call timer_elapsed
 559               	.LVL40:
 560 0112 0697      		sbiw r24,6
 561 0114 00F0      		brlo .L25
 562 0116 E0E0      		ldi r30,lo8(matrix_debouncing)
 563 0118 F0E0      		ldi r31,hi8(matrix_debouncing)
 564 011a A0E0      		ldi r26,lo8(matrix)
 565 011c B0E0      		ldi r27,hi8(matrix)
 566               	.L28:
 567               	.LBB55:
 217:quantum/matrix.c ****                 matrix[i] = matrix_debouncing[i];
 568               		.loc 1 217 0 is_stmt 1 discriminator 2
 569 011e 8191      		ld r24,Z+
 570 0120 9191      		ld r25,Z+
 571 0122 8D93      		st X+,r24
 572 0124 9D93      		st X+,r25
 573               	.LVL41:
 216:quantum/matrix.c ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 574               		.loc 1 216 0 discriminator 2
 575 0126 40E0      		ldi r20,hi8(matrix_debouncing+10)
 576 0128 E030      		cpi r30,lo8(matrix_debouncing+10)
 577 012a F407      		cpc r31,r20
 578 012c 01F4      		brne .L28
 579               	.LBE55:
 219:quantum/matrix.c ****             debouncing = false;
 580               		.loc 1 219 0
 581 012e 1092 0000 		sts debouncing,__zero_reg__
 582               	.L25:
 223:quantum/matrix.c ****     matrix_scan_quantum();
 583               		.loc 1 223 0
 584 0132 0E94 0000 		call matrix_scan_quantum
 585               	.LVL42:
 225:quantum/matrix.c **** }
 586               		.loc 1 225 0
 587 0136 81E0      		ldi r24,lo8(1)
 588               	/* epilogue start */
 589 0138 DF91      		pop r29
 590 013a CF91      		pop r28
 591 013c 1F91      		pop r17
 592 013e 0F91      		pop r16
 593               	.LVL43:
 594 0140 FF90      		pop r15
 595 0142 EF90      		pop r14
 596 0144 DF90      		pop r13
 597 0146 CF90      		pop r12
 598 0148 BF90      		pop r11
 599 014a AF90      		pop r10
 600               	.LVL44:
 601 014c 9F90      		pop r9
 602 014e 8F90      		pop r8
 603 0150 7F90      		pop r7
 604 0152 5F90      		pop r5
 605 0154 4F90      		pop r4
 606 0156 0895      		ret
 607               		.cfi_endproc
 608               	.LFE15:
 610               		.section	.text.matrix_is_modified,"ax",@progbits
 611               	.global	matrix_is_modified
 613               	matrix_is_modified:
 614               	.LFB16:
 228:quantum/matrix.c **** {
 615               		.loc 1 228 0
 616               		.cfi_startproc
 617               	/* prologue: function */
 618               	/* frame size = 0 */
 619               	/* stack size = 0 */
 620               	.L__stack_usage = 0
 230:quantum/matrix.c ****     if (debouncing) return false;
 621               		.loc 1 230 0
 622 0000 9091 0000 		lds r25,debouncing
 233:quantum/matrix.c **** }
 623               		.loc 1 233 0
 624 0004 81E0      		ldi r24,lo8(1)
 625 0006 8927      		eor r24,r25
 626 0008 0895      		ret
 627               		.cfi_endproc
 628               	.LFE16:
 630               		.section	.text.matrix_is_on,"ax",@progbits
 631               	.global	matrix_is_on
 633               	matrix_is_on:
 634               	.LFB17:
 237:quantum/matrix.c **** {
 635               		.loc 1 237 0
 636               		.cfi_startproc
 637               	.LVL45:
 638               	/* prologue: function */
 639               	/* frame size = 0 */
 640               	/* stack size = 0 */
 641               	.L__stack_usage = 0
 238:quantum/matrix.c ****     return (matrix[row] & ((matrix_row_t)1<col));
 642               		.loc 1 238 0
 643 0000 E82F      		mov r30,r24
 644 0002 F0E0      		ldi r31,0
 645 0004 EE0F      		lsl r30
 646 0006 FF1F      		rol r31
 647 0008 E050      		subi r30,lo8(-(matrix))
 648 000a F040      		sbci r31,hi8(-(matrix))
 649 000c 21E0      		ldi r18,lo8(1)
 650 000e 30E0      		ldi r19,0
 651 0010 6230      		cpi r22,lo8(2)
 652 0012 00F4      		brsh .L32
 653 0014 20E0      		ldi r18,0
 654 0016 30E0      		ldi r19,0
 655               	.L32:
 656 0018 8081      		ld r24,Z
 657 001a 9181      		ldd r25,Z+1
 658               	.LVL46:
 659 001c 8223      		and r24,r18
 660 001e 9323      		and r25,r19
 239:quantum/matrix.c **** }
 661               		.loc 1 239 0
 662 0020 8170      		andi r24,lo8(1)
 663 0022 0895      		ret
 664               		.cfi_endproc
 665               	.LFE17:
 667               		.section	.text.matrix_get_row,"ax",@progbits
 668               	.global	matrix_get_row
 670               	matrix_get_row:
 671               	.LFB18:
 243:quantum/matrix.c **** {
 672               		.loc 1 243 0
 673               		.cfi_startproc
 674               	.LVL47:
 675               	/* prologue: function */
 676               	/* frame size = 0 */
 677               	/* stack size = 0 */
 678               	.L__stack_usage = 0
 249:quantum/matrix.c ****     return matrix[row];
 679               		.loc 1 249 0
 680 0000 E82F      		mov r30,r24
 681 0002 F0E0      		ldi r31,0
 682 0004 EE0F      		lsl r30
 683 0006 FF1F      		rol r31
 684 0008 E050      		subi r30,lo8(-(matrix))
 685 000a F040      		sbci r31,hi8(-(matrix))
 251:quantum/matrix.c **** }
 686               		.loc 1 251 0
 687 000c 8081      		ld r24,Z
 688 000e 9181      		ldd r25,Z+1
 689               	.LVL48:
 690 0010 0895      		ret
 691               		.cfi_endproc
 692               	.LFE18:
 694               		.section	.text.matrix_print,"ax",@progbits
 695               	.global	matrix_print
 697               	matrix_print:
 698               	.LFB19:
 254:quantum/matrix.c **** {
 699               		.loc 1 254 0
 700               		.cfi_startproc
 701               	/* prologue: function */
 702               	/* frame size = 0 */
 703               	/* stack size = 0 */
 704               	.L__stack_usage = 0
 705               	.LVL49:
 706 0000 0895      		ret
 707               		.cfi_endproc
 708               	.LFE19:
 710               		.section	.text.matrix_key_count,"ax",@progbits
 711               	.global	matrix_key_count
 713               	matrix_key_count:
 714               	.LFB20:
 265:quantum/matrix.c **** {
 715               		.loc 1 265 0
 716               		.cfi_startproc
 265:quantum/matrix.c **** {
 717               		.loc 1 265 0
 718 0000 1F93      		push r17
 719               	.LCFI15:
 720               		.cfi_def_cfa_offset 3
 721               		.cfi_offset 17, -2
 722 0002 CF93      		push r28
 723               	.LCFI16:
 724               		.cfi_def_cfa_offset 4
 725               		.cfi_offset 28, -3
 726 0004 DF93      		push r29
 727               	.LCFI17:
 728               		.cfi_def_cfa_offset 5
 729               		.cfi_offset 29, -4
 730               	/* prologue: function */
 731               	/* frame size = 0 */
 732               	/* stack size = 3 */
 733               	.L__stack_usage = 3
 734               	.LVL50:
 735 0006 C0E0      		ldi r28,lo8(matrix)
 736 0008 D0E0      		ldi r29,hi8(matrix)
 266:quantum/matrix.c ****     uint8_t count = 0;
 737               		.loc 1 266 0
 738 000a 10E0      		ldi r17,0
 739               	.LVL51:
 740               	.L37:
 741               	.LBB56:
 268:quantum/matrix.c ****         count += matrix_bitpop(i);
 742               		.loc 1 268 0 discriminator 2
 743 000c 8991      		ld r24,Y+
 744 000e 9991      		ld r25,Y+
 745 0010 0E94 0000 		call bitpop16
 746               	.LVL52:
 747 0014 180F      		add r17,r24
 748               	.LVL53:
 267:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 749               		.loc 1 267 0 discriminator 2
 750 0016 80E0      		ldi r24,hi8(matrix+10)
 751 0018 C030      		cpi r28,lo8(matrix+10)
 752 001a D807      		cpc r29,r24
 753 001c 01F4      		brne .L37
 754               	.LBE56:
 271:quantum/matrix.c **** }
 755               		.loc 1 271 0
 756 001e 812F      		mov r24,r17
 757               	/* epilogue start */
 758 0020 DF91      		pop r29
 759 0022 CF91      		pop r28
 760 0024 1F91      		pop r17
 761               	.LVL54:
 762 0026 0895      		ret
 763               		.cfi_endproc
 764               	.LFE20:
 766               		.section	.bss.matrix_debouncing,"aw",@nobits
 769               	matrix_debouncing:
 770 0000 0000 0000 		.zero	10
 770      0000 0000 
 770      0000 
 771               		.section	.bss.matrix,"aw",@nobits
 774               	matrix:
 775 0000 0000 0000 		.zero	10
 775      0000 0000 
 775      0000 
 776               		.section	.rodata.col_pins,"a",@progbits
 779               	col_pins:
 780 0000 F0        		.byte	-16
 781 0001 F1        		.byte	-15
 782 0002 C6        		.byte	-58
 783 0003 67        		.byte	103
 784 0004 66        		.byte	102
 785 0005 36        		.byte	54
 786 0006 94        		.byte	-108
 787 0007 31        		.byte	49
 788 0008 37        		.byte	55
 789 0009 35        		.byte	53
 790 000a 34        		.byte	52
 791 000b 97        		.byte	-105
 792 000c 96        		.byte	-106
 793 000d 33        		.byte	51
 794 000e 30        		.byte	48
 795               		.section	.rodata.row_pins,"a",@progbits
 798               	row_pins:
 799 0000 90        		.byte	-112
 800 0001 91        		.byte	-111
 801 0002 92        		.byte	-110
 802 0003 93        		.byte	-109
 803 0004 95        		.byte	-107
 804               		.section	.bss.debouncing,"aw",@nobits
 807               	debouncing:
 808 0000 00        		.zero	1
 809               		.section	.bss.debouncing_time,"aw",@nobits
 812               	debouncing_time:
 813 0000 0000      		.zero	2
 814               		.text
 815               	.Letext0:
 816               		.file 3 "/usr/lib/avr/include/stdint.h"
 817               		.file 4 "./tmk_core/common/matrix.h"
 818               		.file 5 "./tmk_core/common/timer.h"
 819               		.file 6 "./tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccpRJnRO.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccpRJnRO.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccpRJnRO.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccpRJnRO.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccpRJnRO.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccpRJnRO.s:13     .text.matrix_init_user:0000000000000000 matrix_init_user
     /tmp/ccpRJnRO.s:29     .text.matrix_init_kb:0000000000000000 matrix_init_kb
     /tmp/ccpRJnRO.s:46     .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccpRJnRO.s:63     .text.matrix_scan_user:0000000000000000 matrix_scan_user
     /tmp/ccpRJnRO.s:78     .text.matrix_scan_kb:0000000000000000 matrix_scan_kb
     /tmp/ccpRJnRO.s:95     .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccpRJnRO.s:112    .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccpRJnRO.s:129    .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccpRJnRO.s:146    .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccpRJnRO.s:798    .rodata.row_pins:0000000000000000 row_pins
     /tmp/ccpRJnRO.s:779    .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccpRJnRO.s:774    .bss.matrix:0000000000000000 matrix
     /tmp/ccpRJnRO.s:769    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccpRJnRO.s:289    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccpRJnRO.s:807    .bss.debouncing:0000000000000000 debouncing
     /tmp/ccpRJnRO.s:812    .bss.debouncing_time:0000000000000000 debouncing_time
     /tmp/ccpRJnRO.s:613    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccpRJnRO.s:633    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccpRJnRO.s:670    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccpRJnRO.s:697    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccpRJnRO.s:713    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
timer_read
timer_elapsed
bitpop16
__do_copy_data
__do_clear_bss
