   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB106:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  19:quantum/quantum.c **** #include "outputselect.h"
  20:quantum/quantum.c **** #endif
  21:quantum/quantum.c **** 
  22:quantum/quantum.c **** #ifndef TAPPING_TERM
  23:quantum/quantum.c **** #define TAPPING_TERM 200
  24:quantum/quantum.c **** #endif
  25:quantum/quantum.c **** 
  26:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  27:quantum/quantum.c **** #define BREATHING_PERIOD 6
  28:quantum/quantum.c **** #endif
  29:quantum/quantum.c **** 
  30:quantum/quantum.c **** #include "backlight.h"
  31:quantum/quantum.c **** extern backlight_config_t backlight_config;
  32:quantum/quantum.c **** 
  33:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  34:quantum/quantum.c **** #include "fauxclicky.h"
  35:quantum/quantum.c **** #endif
  36:quantum/quantum.c **** 
  37:quantum/quantum.c **** #ifdef API_ENABLE
  38:quantum/quantum.c **** #include "api.h"
  39:quantum/quantum.c **** #endif
  40:quantum/quantum.c **** 
  41:quantum/quantum.c **** #ifdef MIDI_ENABLE
  42:quantum/quantum.c **** #include "process_midi.h"
  43:quantum/quantum.c **** #endif
  44:quantum/quantum.c **** 
  45:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  46:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  47:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  48:quantum/quantum.c ****   #endif
  49:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  50:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  51:quantum/quantum.c ****   #endif
  52:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  53:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  54:quantum/quantum.c ****   #endif
  55:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  56:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  57:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  58:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  59:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  60:quantum/quantum.c ****   #endif
  61:quantum/quantum.c **** #endif
  62:quantum/quantum.c **** 
  63:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 63 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  38 0008 8C01      		movw r16,r24
  39 000a EB01      		movw r28,r22
  64:quantum/quantum.c ****   switch (code) {
  40               		.loc 1 64 0
  41 000c 9A95      		dec r25
  42               	.LVL1:
  43 000e 8115      		cp r24,__zero_reg__
  44 0010 9F41      		sbci r25,31
  45 0012 00F4      		brsh .L1
  65:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  66:quantum/quantum.c ****     break;
  67:quantum/quantum.c ****   default:
  68:quantum/quantum.c ****     return;
  69:quantum/quantum.c ****   }
  70:quantum/quantum.c **** 
  71:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 71 0
  47 0014 10FF      		sbrs r17,0
  48 0016 00C0      		rjmp .L4
  72:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 72 0
  50 0018 80EE      		ldi r24,lo8(-32)
  51 001a FB01      		movw r30,r22
  52 001c 0995      		icall
  53               	.LVL2:
  54               	.L4:
  73:quantum/quantum.c ****   if (code & QK_LSFT)
  55               		.loc 1 73 0
  56 001e 11FF      		sbrs r17,1
  57 0020 00C0      		rjmp .L5
  74:quantum/quantum.c ****     f(KC_LSFT);
  58               		.loc 1 74 0
  59 0022 81EE      		ldi r24,lo8(-31)
  60 0024 FE01      		movw r30,r28
  61 0026 0995      		icall
  62               	.LVL3:
  63               	.L5:
  75:quantum/quantum.c ****   if (code & QK_LALT)
  64               		.loc 1 75 0
  65 0028 12FF      		sbrs r17,2
  66 002a 00C0      		rjmp .L6
  76:quantum/quantum.c ****     f(KC_LALT);
  67               		.loc 1 76 0
  68 002c 82EE      		ldi r24,lo8(-30)
  69 002e FE01      		movw r30,r28
  70 0030 0995      		icall
  71               	.LVL4:
  72               	.L6:
  77:quantum/quantum.c ****   if (code & QK_LGUI)
  73               		.loc 1 77 0
  74 0032 13FF      		sbrs r17,3
  75 0034 00C0      		rjmp .L7
  78:quantum/quantum.c ****     f(KC_LGUI);
  76               		.loc 1 78 0
  77 0036 83EE      		ldi r24,lo8(-29)
  78 0038 FE01      		movw r30,r28
  79 003a 0995      		icall
  80               	.LVL5:
  81               	.L7:
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  82               		.loc 1 80 0
  83 003c 0115      		cp r16,__zero_reg__
  84 003e 1041      		sbci r17,16
  85 0040 00F0      		brlo .L1
  81:quantum/quantum.c **** 
  82:quantum/quantum.c ****   if (code & QK_RCTL)
  83:quantum/quantum.c ****     f(KC_RCTL);
  86               		.loc 1 83 0
  87 0042 84EE      		ldi r24,lo8(-28)
  88 0044 FE01      		movw r30,r28
  89 0046 0995      		icall
  90               	.LVL6:
  84:quantum/quantum.c ****   if (code & QK_RSFT)
  85:quantum/quantum.c ****     f(KC_RSFT);
  91               		.loc 1 85 0
  92 0048 85EE      		ldi r24,lo8(-27)
  93 004a FE01      		movw r30,r28
  94 004c 0995      		icall
  95               	.LVL7:
  86:quantum/quantum.c ****   if (code & QK_RALT)
  87:quantum/quantum.c ****     f(KC_RALT);
  96               		.loc 1 87 0
  97 004e 86EE      		ldi r24,lo8(-26)
  98 0050 FE01      		movw r30,r28
  99 0052 0995      		icall
 100               	.LVL8:
  88:quantum/quantum.c ****   if (code & QK_RGUI)
  89:quantum/quantum.c ****     f(KC_RGUI);
 101               		.loc 1 89 0
 102 0054 87EE      		ldi r24,lo8(-25)
 103 0056 FE01      		movw r30,r28
 104               	/* epilogue start */
  90:quantum/quantum.c **** }
 105               		.loc 1 90 0
 106 0058 DF91      		pop r29
 107 005a CF91      		pop r28
 108               	.LVL9:
 109 005c 1F91      		pop r17
 110 005e 0F91      		pop r16
 111               	.LVL10:
  89:quantum/quantum.c ****     f(KC_RGUI);
 112               		.loc 1 89 0
 113 0060 0994      		ijmp
 114               	.LVL11:
 115               	.L1:
 116               	/* epilogue start */
 117               		.loc 1 90 0
 118 0062 DF91      		pop r29
 119 0064 CF91      		pop r28
 120               	.LVL12:
 121 0066 1F91      		pop r17
 122 0068 0F91      		pop r16
 123               	.LVL13:
 124 006a 0895      		ret
 125               		.cfi_endproc
 126               	.LFE106:
 128               		.section	.text.qk_register_weak_mods,"ax",@progbits
 130               	qk_register_weak_mods:
 131               	.LFB107:
  91:quantum/quantum.c **** 
  92:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 132               		.loc 1 92 0
 133               		.cfi_startproc
 134               	.LVL14:
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  93:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 139               		.loc 1 93 0
 140 0000 8770      		andi r24,lo8(7)
 141               	.LVL15:
 142 0002 91E0      		ldi r25,lo8(1)
 143 0004 00C0      		rjmp 2f
 144               		1:
 145 0006 990F      		lsl r25
 146               		2:
 147 0008 8A95      		dec r24
 148 000a 02F4      		brpl 1b
 149 000c 892F      		mov r24,r25
 150 000e 0E94 0000 		call add_weak_mods
 151               	.LVL16:
  94:quantum/quantum.c ****     send_keyboard_report();
 152               		.loc 1 94 0
 153 0012 0C94 0000 		jmp send_keyboard_report
 154               	.LVL17:
 155               		.cfi_endproc
 156               	.LFE107:
 158               		.section	.text.qk_register_mods,"ax",@progbits
 160               	qk_register_mods:
 161               	.LFB109:
  95:quantum/quantum.c **** }
  96:quantum/quantum.c **** 
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
  99:quantum/quantum.c ****     send_keyboard_report();
 100:quantum/quantum.c **** }
 101:quantum/quantum.c **** 
 102:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 162               		.loc 1 102 0
 163               		.cfi_startproc
 164               	.LVL18:
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 103:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 169               		.loc 1 103 0
 170 0000 8770      		andi r24,lo8(7)
 171               	.LVL19:
 172 0002 91E0      		ldi r25,lo8(1)
 173 0004 00C0      		rjmp 2f
 174               		1:
 175 0006 990F      		lsl r25
 176               		2:
 177 0008 8A95      		dec r24
 178 000a 02F4      		brpl 1b
 179 000c 892F      		mov r24,r25
 180 000e 0E94 0000 		call add_weak_mods
 181               	.LVL20:
 104:quantum/quantum.c ****     send_keyboard_report();
 182               		.loc 1 104 0
 183 0012 0C94 0000 		jmp send_keyboard_report
 184               	.LVL21:
 185               		.cfi_endproc
 186               	.LFE109:
 188               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 190               	qk_unregister_weak_mods:
 191               	.LFB108:
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
 192               		.loc 1 97 0
 193               		.cfi_startproc
 194               	.LVL22:
 195               	/* prologue: function */
 196               	/* frame size = 0 */
 197               	/* stack size = 0 */
 198               	.L__stack_usage = 0
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 199               		.loc 1 98 0
 200 0000 8770      		andi r24,lo8(7)
 201               	.LVL23:
 202 0002 91E0      		ldi r25,lo8(1)
 203 0004 00C0      		rjmp 2f
 204               		1:
 205 0006 990F      		lsl r25
 206               		2:
 207 0008 8A95      		dec r24
 208 000a 02F4      		brpl 1b
 209 000c 892F      		mov r24,r25
 210 000e 0E94 0000 		call del_weak_mods
 211               	.LVL24:
  99:quantum/quantum.c ****     send_keyboard_report();
 212               		.loc 1 99 0
 213 0012 0C94 0000 		jmp send_keyboard_report
 214               	.LVL25:
 215               		.cfi_endproc
 216               	.LFE108:
 218               		.section	.text.qk_unregister_mods,"ax",@progbits
 220               	qk_unregister_mods:
 221               	.LFB110:
 105:quantum/quantum.c **** }
 106:quantum/quantum.c **** 
 107:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 222               		.loc 1 107 0
 223               		.cfi_startproc
 224               	.LVL26:
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 227               	/* stack size = 0 */
 228               	.L__stack_usage = 0
 108:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 229               		.loc 1 108 0
 230 0000 8770      		andi r24,lo8(7)
 231               	.LVL27:
 232 0002 91E0      		ldi r25,lo8(1)
 233 0004 00C0      		rjmp 2f
 234               		1:
 235 0006 990F      		lsl r25
 236               		2:
 237 0008 8A95      		dec r24
 238 000a 02F4      		brpl 1b
 239 000c 892F      		mov r24,r25
 240 000e 0E94 0000 		call del_weak_mods
 241               	.LVL28:
 109:quantum/quantum.c ****     send_keyboard_report();
 242               		.loc 1 109 0
 243 0012 0C94 0000 		jmp send_keyboard_report
 244               	.LVL29:
 245               		.cfi_endproc
 246               	.LFE110:
 248               		.section	.text.register_code16,"ax",@progbits
 249               	.global	register_code16
 251               	register_code16:
 252               	.LFB111:
 110:quantum/quantum.c **** }
 111:quantum/quantum.c **** 
 112:quantum/quantum.c **** void register_code16 (uint16_t code) {
 253               		.loc 1 112 0
 254               		.cfi_startproc
 255               	.LVL30:
 256 0000 CF93      		push r28
 257               	.LCFI4:
 258               		.cfi_def_cfa_offset 3
 259               		.cfi_offset 28, -2
 260 0002 DF93      		push r29
 261               	.LCFI5:
 262               		.cfi_def_cfa_offset 4
 263               		.cfi_offset 29, -3
 264               	/* prologue: function */
 265               	/* frame size = 0 */
 266               	/* stack size = 2 */
 267               	.L__stack_usage = 2
 268 0004 EC01      		movw r28,r24
 113:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 269               		.loc 1 113 0
 270 0006 805E      		subi r24,-32
 271 0008 9109      		sbc r25,__zero_reg__
 272               	.LVL31:
 273 000a 0897      		sbiw r24,8
 274 000c 00F0      		brlo .L26
 275               		.loc 1 113 0 is_stmt 0 discriminator 1
 276 000e 2097      		sbiw r28,0
 277 0010 01F4      		brne .L27
 278               	.L26:
 114:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 279               		.loc 1 114 0 is_stmt 1
 280 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 281 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 282 0016 00C0      		rjmp .L29
 283               	.L27:
 115:quantum/quantum.c ****   } else {
 116:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 284               		.loc 1 116 0
 285 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 286 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 287               	.L29:
 288 001c CE01      		movw r24,r28
 289 001e 0E94 0000 		call do_code16
 290               	.LVL32:
 117:quantum/quantum.c ****   }
 118:quantum/quantum.c ****   register_code (code);
 291               		.loc 1 118 0
 292 0022 8C2F      		mov r24,r28
 293               	/* epilogue start */
 119:quantum/quantum.c **** }
 294               		.loc 1 119 0
 295 0024 DF91      		pop r29
 296 0026 CF91      		pop r28
 297               	.LVL33:
 118:quantum/quantum.c ****   register_code (code);
 298               		.loc 1 118 0
 299 0028 0C94 0000 		jmp register_code
 300               	.LVL34:
 301               		.cfi_endproc
 302               	.LFE111:
 304               		.section	.text.unregister_code16,"ax",@progbits
 305               	.global	unregister_code16
 307               	unregister_code16:
 308               	.LFB112:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 309               		.loc 1 121 0
 310               		.cfi_startproc
 311               	.LVL35:
 312 0000 CF93      		push r28
 313               	.LCFI6:
 314               		.cfi_def_cfa_offset 3
 315               		.cfi_offset 28, -2
 316 0002 DF93      		push r29
 317               	.LCFI7:
 318               		.cfi_def_cfa_offset 4
 319               		.cfi_offset 29, -3
 320               	/* prologue: function */
 321               	/* frame size = 0 */
 322               	/* stack size = 2 */
 323               	.L__stack_usage = 2
 324 0004 EC01      		movw r28,r24
 122:quantum/quantum.c ****   unregister_code (code);
 325               		.loc 1 122 0
 326 0006 0E94 0000 		call unregister_code
 327               	.LVL36:
 123:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 328               		.loc 1 123 0
 329 000a CE01      		movw r24,r28
 330 000c 805E      		subi r24,-32
 331 000e 9109      		sbc r25,__zero_reg__
 332 0010 0897      		sbiw r24,8
 333 0012 00F0      		brlo .L31
 334               		.loc 1 123 0 is_stmt 0 discriminator 1
 335 0014 2097      		sbiw r28,0
 336 0016 01F4      		brne .L32
 337               	.L31:
 124:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 338               		.loc 1 124 0 is_stmt 1
 339 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 340 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 341 001c 00C0      		rjmp .L33
 342               	.L32:
 125:quantum/quantum.c ****   } else {
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 343               		.loc 1 126 0
 344 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 345 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 346               	.L33:
 347 0022 CE01      		movw r24,r28
 348               	/* epilogue start */
 127:quantum/quantum.c ****   }
 128:quantum/quantum.c **** }
 349               		.loc 1 128 0
 350 0024 DF91      		pop r29
 351 0026 CF91      		pop r28
 352               	.LVL37:
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 353               		.loc 1 126 0
 354 0028 0C94 0000 		jmp do_code16
 355               	.LVL38:
 356               		.cfi_endproc
 357               	.LFE112:
 359               		.section	.text.process_action_kb,"ax",@progbits
 360               		.weak	process_action_kb
 362               	process_action_kb:
 363               	.LFB113:
 129:quantum/quantum.c **** 
 130:quantum/quantum.c **** __attribute__ ((weak))
 131:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 364               		.loc 1 131 0
 365               		.cfi_startproc
 366               	.LVL39:
 367               	/* prologue: function */
 368               	/* frame size = 0 */
 369               	/* stack size = 0 */
 370               	.L__stack_usage = 0
 132:quantum/quantum.c ****   return true;
 133:quantum/quantum.c **** }
 371               		.loc 1 133 0
 372 0000 81E0      		ldi r24,lo8(1)
 373               	.LVL40:
 374 0002 0895      		ret
 375               		.cfi_endproc
 376               	.LFE113:
 378               		.section	.text.process_record_user,"ax",@progbits
 379               		.weak	process_record_user
 381               	process_record_user:
 382               	.LFB115:
 134:quantum/quantum.c **** 
 135:quantum/quantum.c **** __attribute__ ((weak))
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 138:quantum/quantum.c **** }
 139:quantum/quantum.c **** 
 140:quantum/quantum.c **** __attribute__ ((weak))
 141:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 383               		.loc 1 141 0
 384               		.cfi_startproc
 385               	.LVL41:
 386               	/* prologue: function */
 387               	/* frame size = 0 */
 388               	/* stack size = 0 */
 389               	.L__stack_usage = 0
 142:quantum/quantum.c ****   return true;
 143:quantum/quantum.c **** }
 390               		.loc 1 143 0
 391 0000 81E0      		ldi r24,lo8(1)
 392               	.LVL42:
 393 0002 0895      		ret
 394               		.cfi_endproc
 395               	.LFE115:
 397               		.section	.text.process_record_kb,"ax",@progbits
 398               		.weak	process_record_kb
 400               	process_record_kb:
 401               	.LFB114:
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 402               		.loc 1 136 0
 403               		.cfi_startproc
 404               	.LVL43:
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407               	/* stack size = 0 */
 408               	.L__stack_usage = 0
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 409               		.loc 1 137 0
 410 0000 0C94 0000 		jmp process_record_user
 411               	.LVL44:
 412               		.cfi_endproc
 413               	.LFE114:
 415               		.section	.text.reset_keyboard,"ax",@progbits
 416               	.global	reset_keyboard
 418               	reset_keyboard:
 419               	.LFB116:
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** void reset_keyboard(void) {
 420               		.loc 1 145 0
 421               		.cfi_startproc
 422               	/* prologue: function */
 423               	/* frame size = 0 */
 424               	/* stack size = 0 */
 425               	.L__stack_usage = 0
 146:quantum/quantum.c ****   clear_keyboard();
 426               		.loc 1 146 0
 427 0000 0E94 0000 		call clear_keyboard
 428               	.LVL45:
 429               	.LBB29:
 430               	.LBB30:
 431               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 432               		.loc 2 164 0
 433 0004 2FEF      		ldi r18,lo8(799999)
 434 0006 84E3      		ldi r24,hi8(799999)
 435 0008 9CE0      		ldi r25,hlo8(799999)
 436 000a 2150      		1: subi r18,1
 437 000c 8040      		sbci r24,0
 438 000e 9040      		sbci r25,0
 439 0010 01F4      		brne 1b
 440 0012 00C0      		rjmp .
 441 0014 0000      		nop
 442               	.LBE30:
 443               	.LBE29:
 147:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 148:quantum/quantum.c ****   process_midi_all_notes_off();
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 151:quantum/quantum.c ****   music_all_notes_off();
 152:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 153:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 154:quantum/quantum.c ****   shutdown_user();
 155:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 156:quantum/quantum.c ****     wait_ms(1);
 157:quantum/quantum.c ****   stop_all_notes();
 158:quantum/quantum.c **** #else
 159:quantum/quantum.c ****   wait_ms(250);
 160:quantum/quantum.c **** #endif
 161:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 162:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 163:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 164:quantum/quantum.c **** #endif
 165:quantum/quantum.c ****   bootloader_jump();
 444               		.loc 1 165 0
 445 0016 0C94 0000 		jmp bootloader_jump
 446               	.LVL46:
 447               		.cfi_endproc
 448               	.LFE116:
 450               		.section	.text.process_record_quantum,"ax",@progbits
 451               	.global	process_record_quantum
 453               	process_record_quantum:
 454               	.LFB117:
 166:quantum/quantum.c **** }
 167:quantum/quantum.c **** 
 168:quantum/quantum.c **** // Shift / paren setup
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** #ifndef LSPO_KEY
 171:quantum/quantum.c ****   #define LSPO_KEY KC_9
 172:quantum/quantum.c **** #endif
 173:quantum/quantum.c **** #ifndef RSPC_KEY
 174:quantum/quantum.c ****   #define RSPC_KEY KC_0
 175:quantum/quantum.c **** #endif
 176:quantum/quantum.c **** 
 177:quantum/quantum.c **** // Shift / Enter setup
 178:quantum/quantum.c **** #ifndef SFTENT_KEY
 179:quantum/quantum.c ****   #define SFTENT_KEY KC_ENT
 180:quantum/quantum.c **** #endif
 181:quantum/quantum.c **** 
 182:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 183:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 184:quantum/quantum.c **** 
 185:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 186:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 187:quantum/quantum.c ****  */
 188:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 455               		.loc 1 190 0
 456               		.cfi_startproc
 457               	.LVL47:
 458 0000 0F93      		push r16
 459               	.LCFI8:
 460               		.cfi_def_cfa_offset 3
 461               		.cfi_offset 16, -2
 462 0002 1F93      		push r17
 463               	.LCFI9:
 464               		.cfi_def_cfa_offset 4
 465               		.cfi_offset 17, -3
 466 0004 CF93      		push r28
 467               	.LCFI10:
 468               		.cfi_def_cfa_offset 5
 469               		.cfi_offset 28, -4
 470 0006 DF93      		push r29
 471               	.LCFI11:
 472               		.cfi_def_cfa_offset 6
 473               		.cfi_offset 29, -5
 474               	/* prologue: function */
 475               	/* frame size = 0 */
 476               	/* stack size = 4 */
 477               	.L__stack_usage = 4
 478 0008 8C01      		movw r16,r24
 191:quantum/quantum.c **** 
 192:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 193:quantum/quantum.c ****   keypos_t key = record->event.key;
 479               		.loc 1 193 0
 480 000a FC01      		movw r30,r24
 481 000c C081      		ld r28,Z
 482 000e D181      		ldd r29,Z+1
 483               	.LVL48:
 194:quantum/quantum.c ****   uint16_t keycode;
 195:quantum/quantum.c **** 
 196:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 197:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 198:quantum/quantum.c ****     if (!disable_action_cache) {
 199:quantum/quantum.c ****       uint8_t layer;
 200:quantum/quantum.c **** 
 201:quantum/quantum.c ****       if (record->event.pressed) {
 202:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 203:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 204:quantum/quantum.c ****       } else {
 205:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 206:quantum/quantum.c ****       }
 207:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 208:quantum/quantum.c ****     } else
 209:quantum/quantum.c ****   #endif
 210:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 484               		.loc 1 210 0
 485 0010 CE01      		movw r24,r28
 486               	.LVL49:
 487 0012 0E94 0000 		call layer_switch_get_layer
 488               	.LVL50:
 489 0016 BE01      		movw r22,r28
 490 0018 0E94 0000 		call keymap_key_to_keycode
 491               	.LVL51:
 492 001c EC01      		movw r28,r24
 493               	.LVL52:
 211:quantum/quantum.c **** 
 212:quantum/quantum.c ****     // This is how you use actions here
 213:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 214:quantum/quantum.c ****     //   action_t action;
 215:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 216:quantum/quantum.c ****     //   process_action(record, action);
 217:quantum/quantum.c ****     //   return false;
 218:quantum/quantum.c ****     // }
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 221:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 222:quantum/quantum.c ****   #endif
 223:quantum/quantum.c **** 
 224:quantum/quantum.c ****   if (!(
 225:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 226:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 227:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 228:quantum/quantum.c ****   #endif
 229:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 230:quantum/quantum.c ****       process_clicky(keycode, record) &&
 231:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 494               		.loc 1 232 0
 495 001e B801      		movw r22,r16
 496 0020 0E94 0000 		call process_record_kb
 497               	.LVL53:
 498 0024 8823      		tst r24
 499 0026 01F4      		brne .+2
 500 0028 00C0      		rjmp .L151
 233:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 234:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 235:quantum/quantum.c ****   #endif
 236:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 237:quantum/quantum.c ****     process_midi(keycode, record) &&
 238:quantum/quantum.c ****   #endif
 239:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 240:quantum/quantum.c ****     process_audio(keycode, record) &&
 241:quantum/quantum.c ****   #endif
 242:quantum/quantum.c ****   #ifdef STENO_ENABLE
 243:quantum/quantum.c ****     process_steno(keycode, record) &&
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c ****   #if ( defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSI
 246:quantum/quantum.c ****     process_music(keycode, record) &&
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 250:quantum/quantum.c ****   #endif
 251:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 252:quantum/quantum.c ****     process_leader(keycode, record) &&
 501               		.loc 1 252 0 discriminator 2
 502 002a B801      		movw r22,r16
 503 002c CE01      		movw r24,r28
 504 002e 0E94 0000 		call process_leader
 505               	.LVL54:
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 506               		.loc 1 232 0 discriminator 2
 507 0032 8823      		tst r24
 508 0034 01F4      		brne .+2
 509 0036 00C0      		rjmp .L151
 253:quantum/quantum.c ****   #endif
 254:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 255:quantum/quantum.c ****     process_chording(keycode, record) &&
 256:quantum/quantum.c ****   #endif
 257:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 258:quantum/quantum.c ****     process_combo(keycode, record) &&
 259:quantum/quantum.c ****   #endif
 260:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 261:quantum/quantum.c ****     process_unicode(keycode, record) &&
 262:quantum/quantum.c ****   #endif
 263:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 264:quantum/quantum.c ****     process_ucis(keycode, record) &&
 265:quantum/quantum.c ****   #endif
 266:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 267:quantum/quantum.c ****     process_printer(keycode, record) &&
 268:quantum/quantum.c ****   #endif
 269:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 270:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 271:quantum/quantum.c ****   #endif
 272:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 273:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 274:quantum/quantum.c ****   #endif
 275:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 276:quantum/quantum.c ****     process_terminal(keycode, record) &&
 277:quantum/quantum.c ****   #endif
 278:quantum/quantum.c ****       true)) {
 279:quantum/quantum.c ****     return false;
 280:quantum/quantum.c ****   }
 281:quantum/quantum.c **** 
 282:quantum/quantum.c ****   // Shift / paren setup
 283:quantum/quantum.c **** 
 284:quantum/quantum.c ****   switch(keycode) {
 510               		.loc 1 284 0
 511 0038 C93C      		cpi r28,-55
 512 003a FCE5      		ldi r31,92
 513 003c DF07      		cpc r29,r31
 514 003e 01F4      		brne .L215
 285:quantum/quantum.c ****     case RESET:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 287:quantum/quantum.c ****         reset_keyboard();
 288:quantum/quantum.c ****       }
 289:quantum/quantum.c ****     return false;
 290:quantum/quantum.c ****     case DEBUG:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 292:quantum/quantum.c ****           debug_enable = true;
 293:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 294:quantum/quantum.c ****       }
 295:quantum/quantum.c ****     return false;
 296:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 297:quantum/quantum.c ****   case FC_TOG:
 298:quantum/quantum.c ****     if (record->event.pressed) {
 299:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 300:quantum/quantum.c ****     }
 301:quantum/quantum.c ****     return false;
 302:quantum/quantum.c ****   case FC_ON:
 303:quantum/quantum.c ****     if (record->event.pressed) {
 304:quantum/quantum.c ****       FAUXCLICKY_ON;
 305:quantum/quantum.c ****     }
 306:quantum/quantum.c ****     return false;
 307:quantum/quantum.c ****   case FC_OFF:
 308:quantum/quantum.c ****     if (record->event.pressed) {
 309:quantum/quantum.c ****       FAUXCLICKY_OFF;
 310:quantum/quantum.c ****     }
 311:quantum/quantum.c ****     return false;
 312:quantum/quantum.c ****   #endif
 313:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 314:quantum/quantum.c ****   case RGB_TOG:
 315:quantum/quantum.c ****     if (record->event.pressed) {
 316:quantum/quantum.c ****       rgblight_toggle();
 317:quantum/quantum.c ****     }
 318:quantum/quantum.c ****     return false;
 319:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 320:quantum/quantum.c ****     if (record->event.pressed) {
 321:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 322:quantum/quantum.c ****       if(shifted) {
 323:quantum/quantum.c ****         rgblight_step_reverse();
 324:quantum/quantum.c ****       }
 325:quantum/quantum.c ****       else {
 326:quantum/quantum.c ****         rgblight_step();
 327:quantum/quantum.c ****       }
 328:quantum/quantum.c ****     }
 329:quantum/quantum.c ****     return false;
 330:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 331:quantum/quantum.c ****     if (record->event.pressed) {
 332:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 333:quantum/quantum.c ****       if(shifted) {
 334:quantum/quantum.c ****         rgblight_step();
 335:quantum/quantum.c ****       }
 336:quantum/quantum.c ****       else {
 337:quantum/quantum.c ****         rgblight_step_reverse();
 338:quantum/quantum.c ****       }
 339:quantum/quantum.c ****     }
 340:quantum/quantum.c ****     return false;
 341:quantum/quantum.c ****   case RGB_HUI:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 343:quantum/quantum.c ****       rgblight_increase_hue();
 344:quantum/quantum.c ****     }
 345:quantum/quantum.c ****     return false;
 346:quantum/quantum.c ****   case RGB_HUD:
 347:quantum/quantum.c ****     if (record->event.pressed) {
 348:quantum/quantum.c ****       rgblight_decrease_hue();
 349:quantum/quantum.c ****     }
 350:quantum/quantum.c ****     return false;
 351:quantum/quantum.c ****   case RGB_SAI:
 352:quantum/quantum.c ****     if (record->event.pressed) {
 353:quantum/quantum.c ****       rgblight_increase_sat();
 354:quantum/quantum.c ****     }
 355:quantum/quantum.c ****     return false;
 356:quantum/quantum.c ****   case RGB_SAD:
 357:quantum/quantum.c ****     if (record->event.pressed) {
 358:quantum/quantum.c ****       rgblight_decrease_sat();
 359:quantum/quantum.c ****     }
 360:quantum/quantum.c ****     return false;
 361:quantum/quantum.c ****   case RGB_VAI:
 362:quantum/quantum.c ****     if (record->event.pressed) {
 363:quantum/quantum.c ****       rgblight_increase_val();
 364:quantum/quantum.c ****     }
 365:quantum/quantum.c ****     return false;
 366:quantum/quantum.c ****   case RGB_VAD:
 367:quantum/quantum.c ****     if (record->event.pressed) {
 368:quantum/quantum.c ****       rgblight_decrease_val();
 369:quantum/quantum.c ****     }
 370:quantum/quantum.c ****     return false;
 371:quantum/quantum.c ****   case RGB_SPI:
 372:quantum/quantum.c ****     if (record->event.pressed) {
 515               		.loc 1 372 0
 516 0040 F801      		movw r30,r16
 517 0042 8281      		ldd r24,Z+2
 518 0044 8823      		tst r24
 519 0046 01F4      		brne .+2
 520 0048 00C0      		rjmp .L151
 373:quantum/quantum.c ****       rgblight_increase_speed();
 521               		.loc 1 373 0
 522 004a 0E94 0000 		call rgblight_increase_speed
 523               	.LVL55:
 524 004e 00C0      		rjmp .L151
 525               	.L215:
 284:quantum/quantum.c ****   switch(keycode) {
 526               		.loc 1 284 0
 527 0050 CA3C      		cpi r28,-54
 528 0052 8CE5      		ldi r24,92
 529 0054 D807      		cpc r29,r24
 530 0056 00F0      		brlo .+2
 531 0058 00C0      		rjmp .L116
 532 005a C13C      		cpi r28,-63
 533 005c 9CE5      		ldi r25,92
 534 005e D907      		cpc r29,r25
 535 0060 01F4      		brne .L216
 320:quantum/quantum.c ****     if (record->event.pressed) {
 536               		.loc 1 320 0
 537 0062 F801      		movw r30,r16
 538 0064 8281      		ldd r24,Z+2
 539 0066 8823      		tst r24
 540 0068 01F4      		brne .+2
 541 006a 00C0      		rjmp .L151
 542               	.LBB31:
 321:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 543               		.loc 1 321 0
 544 006c 0E94 0000 		call get_mods
 545               	.LVL56:
 546 0070 8272      		andi r24,lo8(34)
 547               	.LVL57:
 322:quantum/quantum.c ****       if(shifted) {
 548               		.loc 1 322 0
 549 0072 01F0      		breq .L46
 550               	.LVL58:
 551               	.L48:
 323:quantum/quantum.c ****         rgblight_step_reverse();
 552               		.loc 1 323 0
 553 0074 0E94 0000 		call rgblight_step_reverse
 554               	.LVL59:
 555 0078 00C0      		rjmp .L151
 556               	.L216:
 557               	.LBE31:
 284:quantum/quantum.c ****   switch(keycode) {
 558               		.loc 1 284 0
 559 007a C23C      		cpi r28,-62
 560 007c ECE5      		ldi r30,92
 561 007e DE07      		cpc r29,r30
 562 0080 00F0      		brlo .L217
 563 0082 F801      		movw r30,r16
 564 0084 8281      		ldd r24,Z+2
 565 0086 C53C      		cpi r28,-59
 566 0088 FCE5      		ldi r31,92
 567 008a DF07      		cpc r29,r31
 568 008c 01F4      		brne .+2
 569 008e 00C0      		rjmp .L51
 570 0090 00F0      		brlo .+2
 571 0092 00C0      		rjmp .L119
 572 0094 C33C      		cpi r28,-61
 573 0096 ECE5      		ldi r30,92
 574 0098 DE07      		cpc r29,r30
 575 009a 01F4      		brne .+2
 576 009c 00C0      		rjmp .L49
 577 009e 00F0      		brlo .+2
 578 00a0 00C0      		rjmp .L218
 331:quantum/quantum.c ****     if (record->event.pressed) {
 579               		.loc 1 331 0
 580 00a2 8823      		tst r24
 581 00a4 01F4      		brne .+2
 582 00a6 00C0      		rjmp .L151
 583               	.LBB32:
 332:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 584               		.loc 1 332 0
 585 00a8 0E94 0000 		call get_mods
 586               	.LVL60:
 587 00ac 8272      		andi r24,lo8(34)
 588               	.LVL61:
 333:quantum/quantum.c ****       if(shifted) {
 589               		.loc 1 333 0
 590 00ae 01F0      		breq .L48
 591               	.LVL62:
 592               	.L46:
 593               	.LBE32:
 594               	.LBB33:
 326:quantum/quantum.c ****         rgblight_step();
 595               		.loc 1 326 0
 596 00b0 0E94 0000 		call rgblight_step
 597               	.LVL63:
 598 00b4 00C0      		rjmp .L151
 599               	.L217:
 600               	.LBE33:
 284:quantum/quantum.c ****   switch(keycode) {
 601               		.loc 1 284 0
 602 00b6 C531      		cpi r28,21
 603 00b8 FCE5      		ldi r31,92
 604 00ba DF07      		cpc r29,r31
 605 00bc 00F0      		brlo .+2
 606 00be 00C0      		rjmp .L118
 607 00c0 C230      		cpi r28,2
 608 00c2 8CE5      		ldi r24,92
 609 00c4 D807      		cpc r29,r24
 610 00c6 00F4      		brsh .+2
 611 00c8 00C0      		rjmp .L219
 374:quantum/quantum.c ****     }
 375:quantum/quantum.c ****     return false;
 376:quantum/quantum.c ****   case RGB_SPD:
 377:quantum/quantum.c ****     if (record->event.pressed) {
 378:quantum/quantum.c ****       rgblight_decrease_speed();
 379:quantum/quantum.c ****     }
 380:quantum/quantum.c ****     return false;
 381:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 382:quantum/quantum.c ****     if (record->event.pressed) {
 383:quantum/quantum.c ****       rgblight_mode(1);
 384:quantum/quantum.c ****     }
 385:quantum/quantum.c ****     return false;
 386:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 387:quantum/quantum.c ****     if (record->event.pressed) {
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 389:quantum/quantum.c ****         rgblight_step();
 390:quantum/quantum.c ****       } else {
 391:quantum/quantum.c ****         rgblight_mode(2);
 392:quantum/quantum.c ****       }
 393:quantum/quantum.c ****     }
 394:quantum/quantum.c ****     return false;
 395:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 396:quantum/quantum.c ****     if (record->event.pressed) {
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 398:quantum/quantum.c ****         rgblight_step();
 399:quantum/quantum.c ****       } else {
 400:quantum/quantum.c ****         rgblight_mode(6);
 401:quantum/quantum.c ****       }
 402:quantum/quantum.c ****     }
 403:quantum/quantum.c ****     return false;
 404:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 405:quantum/quantum.c ****     if (record->event.pressed) {
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 407:quantum/quantum.c ****         rgblight_step();
 408:quantum/quantum.c ****       } else {
 409:quantum/quantum.c ****         rgblight_mode(9);
 410:quantum/quantum.c ****       }
 411:quantum/quantum.c ****     }
 412:quantum/quantum.c ****     return false;
 413:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 414:quantum/quantum.c ****     if (record->event.pressed) {
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 416:quantum/quantum.c ****         rgblight_step();
 417:quantum/quantum.c ****       } else {
 418:quantum/quantum.c ****         rgblight_mode(15);
 419:quantum/quantum.c ****       }
 420:quantum/quantum.c ****     }
 421:quantum/quantum.c ****     return false;
 422:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 423:quantum/quantum.c ****     if (record->event.pressed) {
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 425:quantum/quantum.c ****         rgblight_step();
 426:quantum/quantum.c ****       } else {
 427:quantum/quantum.c ****         rgblight_mode(21);
 428:quantum/quantum.c ****       }
 429:quantum/quantum.c ****     }
 430:quantum/quantum.c ****     return false;
 431:quantum/quantum.c ****   case RGB_MODE_XMAS:
 432:quantum/quantum.c ****     if (record->event.pressed) {
 433:quantum/quantum.c ****       rgblight_mode(24);
 434:quantum/quantum.c ****     }
 435:quantum/quantum.c ****     return false;
 436:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 437:quantum/quantum.c ****     if (record->event.pressed) {
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 439:quantum/quantum.c ****         rgblight_step();
 440:quantum/quantum.c ****       } else {
 441:quantum/quantum.c ****         rgblight_mode(25);
 442:quantum/quantum.c ****       }
 443:quantum/quantum.c ****     }
 444:quantum/quantum.c ****     return false;
 445:quantum/quantum.c ****   #endif
 446:quantum/quantum.c ****     #ifdef PROTOCOL_LUFA
 447:quantum/quantum.c ****     case OUT_AUTO:
 448:quantum/quantum.c ****       if (record->event.pressed) {
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 450:quantum/quantum.c ****       }
 451:quantum/quantum.c ****       return false;
 452:quantum/quantum.c ****     case OUT_USB:
 453:quantum/quantum.c ****       if (record->event.pressed) {
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 455:quantum/quantum.c ****       }
 456:quantum/quantum.c ****       return false;
 457:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 458:quantum/quantum.c ****     case OUT_BT:
 459:quantum/quantum.c ****       if (record->event.pressed) {
 460:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 461:quantum/quantum.c ****       }
 462:quantum/quantum.c ****       return false;
 463:quantum/quantum.c ****     #endif
 464:quantum/quantum.c ****     #endif
 465:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 466:quantum/quantum.c ****       if (record->event.pressed) {
 612               		.loc 1 466 0
 613 00ca F801      		movw r30,r16
 614 00cc 8281      		ldd r24,Z+2
 615 00ce 8823      		tst r24
 616 00d0 01F4      		brne .+2
 617 00d2 00C0      		rjmp .L74
 467:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 468:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 618               		.loc 1 468 0
 619 00d4 0E94 0000 		call eeconfig_is_enabled
 620               	.LVL64:
 621 00d8 8111      		cpse r24,__zero_reg__
 622 00da 00C0      		rjmp .L75
 469:quantum/quantum.c ****             eeconfig_init();
 623               		.loc 1 469 0
 624 00dc 0E94 0000 		call eeconfig_init
 625               	.LVL65:
 626               	.L75:
 470:quantum/quantum.c ****         }
 471:quantum/quantum.c ****         /* keymap config */
 472:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 627               		.loc 1 472 0
 628 00e0 0E94 0000 		call eeconfig_read_keymap
 629               	.LVL66:
 630 00e4 90E0      		ldi r25,0
 631 00e6 9093 0000 		sts keymap_config+1,r25
 632 00ea 8093 0000 		sts keymap_config,r24
 473:quantum/quantum.c ****         switch (keycode)
 633               		.loc 1 473 0
 634 00ee FE01      		movw r30,r28
 635 00f0 E350      		subi r30,3
 636 00f2 FC45      		sbci r31,92
 637 00f4 E231      		cpi r30,18
 638 00f6 F105      		cpc r31,__zero_reg__
 639 00f8 00F4      		brsh .L76
 640 00fa E050      		subi r30,lo8(-(gs(.L78)))
 641 00fc F040      		sbci r31,hi8(-(gs(.L78)))
 642 00fe 0C94 0000 		jmp __tablejump2__
 643               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 644               		.p2align	1
 645               	.L78:
 646 0000 0000      		.word gs(.L77)
 647 0002 0000      		.word gs(.L79)
 648 0004 0000      		.word gs(.L80)
 649 0006 0000      		.word gs(.L81)
 650 0008 0000      		.word gs(.L82)
 651 000a 0000      		.word gs(.L83)
 652 000c 0000      		.word gs(.L84)
 653 000e 0000      		.word gs(.L85)
 654 0010 0000      		.word gs(.L86)
 655 0012 0000      		.word gs(.L87)
 656 0014 0000      		.word gs(.L88)
 657 0016 0000      		.word gs(.L89)
 658 0018 0000      		.word gs(.L90)
 659 001a 0000      		.word gs(.L91)
 660 001c 0000      		.word gs(.L92)
 661 001e 0000      		.word gs(.L93)
 662 0020 0000      		.word gs(.L94)
 663 0022 0000      		.word gs(.L95)
 664               		.section	.text.process_record_quantum
 665               	.L76:
 474:quantum/quantum.c ****         {
 475:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 476:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 666               		.loc 1 476 0
 667 0102 8091 0000 		lds r24,keymap_config
 668 0106 8160      		ori r24,lo8(1<<0)
 669 0108 00C0      		rjmp .L208
 670               	.L77:
 477:quantum/quantum.c ****             break;
 478:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 479:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 671               		.loc 1 479 0
 672 010a 8091 0000 		lds r24,keymap_config
 673 010e 8260      		ori r24,lo8(1<<1)
 674               	.L208:
 675 0110 8093 0000 		sts keymap_config,r24
 480:quantum/quantum.c ****             break;
 676               		.loc 1 480 0
 677 0114 00C0      		rjmp .L96
 678               	.L79:
 481:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 482:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 679               		.loc 1 482 0
 680 0116 8091 0000 		lds r24,keymap_config
 681 011a 8460      		ori r24,lo8(1<<2)
 682 011c 00C0      		rjmp .L208
 683               	.L80:
 483:quantum/quantum.c ****             break;
 484:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 485:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 684               		.loc 1 485 0
 685 011e 8091 0000 		lds r24,keymap_config
 686 0122 00C0      		rjmp .L214
 687               	.L81:
 486:quantum/quantum.c ****             break;
 487:quantum/quantum.c ****           case MAGIC_NO_GUI:
 488:quantum/quantum.c ****             keymap_config.no_gui = true;
 688               		.loc 1 488 0
 689 0124 8091 0000 		lds r24,keymap_config
 690 0128 8061      		ori r24,lo8(1<<4)
 691 012a 00C0      		rjmp .L208
 692               	.L82:
 489:quantum/quantum.c ****             break;
 490:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 491:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 693               		.loc 1 491 0
 694 012c 8091 0000 		lds r24,keymap_config
 695 0130 8062      		ori r24,lo8(1<<5)
 696 0132 00C0      		rjmp .L208
 697               	.L83:
 492:quantum/quantum.c ****             break;
 493:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 494:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 698               		.loc 1 494 0
 699 0134 8091 0000 		lds r24,keymap_config
 700 0138 8064      		ori r24,lo8(1<<6)
 701 013a 00C0      		rjmp .L208
 702               	.L84:
 495:quantum/quantum.c ****             break;
 496:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 497:quantum/quantum.c ****             keymap_config.nkro = true;
 703               		.loc 1 497 0
 704 013c 8091 0000 		lds r24,keymap_config
 705 0140 8068      		ori r24,lo8(1<<7)
 706 0142 00C0      		rjmp .L208
 707               	.L85:
 498:quantum/quantum.c ****             break;
 499:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 500:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 708               		.loc 1 500 0
 709 0144 8091 0000 		lds r24,keymap_config
 501:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 710               		.loc 1 501 0
 711 0148 8460      		ori r24,lo8(4)
 712               	.L214:
 713 014a 8860      		ori r24,lo8(1<<3)
 714 014c 00C0      		rjmp .L208
 715               	.L86:
 502:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 503:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 504:quantum/quantum.c ****             #endif
 505:quantum/quantum.c ****             break;
 506:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 507:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 716               		.loc 1 507 0
 717 014e 8091 0000 		lds r24,keymap_config
 718 0152 8E7F      		andi r24,lo8(~(1<<0))
 719 0154 00C0      		rjmp .L208
 720               	.L87:
 508:quantum/quantum.c ****             break;
 509:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 510:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 721               		.loc 1 510 0
 722 0156 8091 0000 		lds r24,keymap_config
 723 015a 8D7F      		andi r24,lo8(~(1<<1))
 724 015c 00C0      		rjmp .L208
 725               	.L88:
 511:quantum/quantum.c ****             break;
 512:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 513:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 726               		.loc 1 513 0
 727 015e 8091 0000 		lds r24,keymap_config
 728 0162 8B7F      		andi r24,lo8(~(1<<2))
 729 0164 00C0      		rjmp .L208
 730               	.L89:
 514:quantum/quantum.c ****             break;
 515:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 516:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 731               		.loc 1 516 0
 732 0166 8091 0000 		lds r24,keymap_config
 733 016a 00C0      		rjmp .L213
 734               	.L90:
 517:quantum/quantum.c ****             break;
 518:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 519:quantum/quantum.c ****             keymap_config.no_gui = false;
 735               		.loc 1 519 0
 736 016c 8091 0000 		lds r24,keymap_config
 737 0170 8F7E      		andi r24,lo8(~(1<<4))
 738 0172 00C0      		rjmp .L208
 739               	.L91:
 520:quantum/quantum.c ****             break;
 521:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 522:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 740               		.loc 1 522 0
 741 0174 8091 0000 		lds r24,keymap_config
 742 0178 8F7D      		andi r24,lo8(~(1<<5))
 743 017a 00C0      		rjmp .L208
 744               	.L92:
 523:quantum/quantum.c ****             break;
 524:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 525:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 745               		.loc 1 525 0
 746 017c 8091 0000 		lds r24,keymap_config
 747 0180 8F7B      		andi r24,lo8(~(1<<6))
 748 0182 00C0      		rjmp .L208
 749               	.L93:
 526:quantum/quantum.c ****             break;
 527:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 528:quantum/quantum.c ****             keymap_config.nkro = false;
 750               		.loc 1 528 0
 751 0184 8091 0000 		lds r24,keymap_config
 752 0188 8F77      		andi r24,lo8(~(1<<7))
 753 018a 00C0      		rjmp .L208
 754               	.L94:
 529:quantum/quantum.c ****             break;
 530:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 531:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 755               		.loc 1 531 0
 756 018c 8091 0000 		lds r24,keymap_config
 532:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 757               		.loc 1 532 0
 758 0190 8B7F      		andi r24,lo8(-5)
 759               	.L213:
 760 0192 877F      		andi r24,lo8(~(1<<3))
 761 0194 00C0      		rjmp .L208
 762               	.L95:
 533:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 534:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 535:quantum/quantum.c ****             #endif
 536:quantum/quantum.c ****             break;
 537:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 538:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 763               		.loc 1 538 0
 764 0196 9091 0000 		lds r25,keymap_config
 765 019a 97FB      		bst r25,7
 766 019c 8827      		clr r24
 767 019e 80F9      		bld r24,0
 768 01a0 21E0      		ldi r18,lo8(1)
 769 01a2 8227      		eor r24,r18
 770 01a4 80FB      		bst r24,0
 771 01a6 97F9      		bld r25,7
 772 01a8 9093 0000 		sts keymap_config,r25
 773               	.L96:
 539:quantum/quantum.c ****             break;
 540:quantum/quantum.c ****           default:
 541:quantum/quantum.c ****             break;
 542:quantum/quantum.c ****         }
 543:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 774               		.loc 1 543 0
 775 01ac 8091 0000 		lds r24,keymap_config
 776 01b0 0E94 0000 		call eeconfig_update_keymap
 777               	.LVL67:
 544:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 778               		.loc 1 544 0
 779 01b4 0E94 0000 		call clear_keyboard
 780               	.LVL68:
 545:quantum/quantum.c **** 
 546:quantum/quantum.c ****         return false;
 781               		.loc 1 546 0
 782 01b8 00C0      		rjmp .L151
 783               	.L219:
 284:quantum/quantum.c ****   switch(keycode) {
 784               		.loc 1 284 0
 785 01ba C115      		cp r28,__zero_reg__
 786 01bc 9CE5      		ldi r25,92
 787 01be D907      		cpc r29,r25
 788 01c0 01F0      		breq .L41
 789 01c2 C130      		cpi r28,1
 790 01c4 DC45      		sbci r29,92
 791 01c6 01F0      		breq .L43
 792               	.L115:
 547:quantum/quantum.c ****       }
 548:quantum/quantum.c ****       break;
 549:quantum/quantum.c ****     case KC_LSPO: {
 550:quantum/quantum.c ****       if (record->event.pressed) {
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 554:quantum/quantum.c ****       }
 555:quantum/quantum.c ****       else {
 556:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 557:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 558:quantum/quantum.c ****             shift_interrupted[0] = true;
 559:quantum/quantum.c ****             shift_interrupted[1] = true;
 560:quantum/quantum.c ****           }
 561:quantum/quantum.c ****         #endif
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 565:quantum/quantum.c ****         }
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 567:quantum/quantum.c ****       }
 568:quantum/quantum.c ****       return false;
 569:quantum/quantum.c ****     }
 570:quantum/quantum.c **** 
 571:quantum/quantum.c ****     case KC_RSPC: {
 572:quantum/quantum.c ****       if (record->event.pressed) {
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 576:quantum/quantum.c ****       }
 577:quantum/quantum.c ****       else {
 578:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 579:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 580:quantum/quantum.c ****             shift_interrupted[0] = true;
 581:quantum/quantum.c ****             shift_interrupted[1] = true;
 582:quantum/quantum.c ****           }
 583:quantum/quantum.c ****         #endif
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 587:quantum/quantum.c ****         }
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 589:quantum/quantum.c ****       }
 590:quantum/quantum.c ****       return false;
 591:quantum/quantum.c ****     }
 592:quantum/quantum.c **** 
 593:quantum/quantum.c ****     case KC_SFTENT: {
 594:quantum/quantum.c ****       if (record->event.pressed) {
 595:quantum/quantum.c ****         shift_interrupted[1] = false;
 596:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 597:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 598:quantum/quantum.c ****       }
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 603:quantum/quantum.c ****       }
 604:quantum/quantum.c ****       else {
 605:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 606:quantum/quantum.c ****       }
 607:quantum/quantum.c ****       return false;
 608:quantum/quantum.c ****     }
 609:quantum/quantum.c **** 
 610:quantum/quantum.c ****     case GRAVE_ESC: {
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 612:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 613:quantum/quantum.c **** 
 614:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 615:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 616:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 617:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 618:quantum/quantum.c ****         shifted = 0;
 619:quantum/quantum.c ****       }
 620:quantum/quantum.c **** #endif
 621:quantum/quantum.c **** 
 622:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 623:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 624:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 625:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 626:quantum/quantum.c ****         shifted = 0;
 627:quantum/quantum.c ****       }
 628:quantum/quantum.c **** #endif
 629:quantum/quantum.c **** 
 630:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 631:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 632:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 633:quantum/quantum.c ****         shifted = 0;
 634:quantum/quantum.c ****       }
 635:quantum/quantum.c **** #endif
 636:quantum/quantum.c **** 
 637:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 638:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 639:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 640:quantum/quantum.c ****         shifted = 0;
 641:quantum/quantum.c ****       }
 642:quantum/quantum.c **** #endif
 643:quantum/quantum.c **** 
 644:quantum/quantum.c ****       if (record->event.pressed) {
 645:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 646:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 647:quantum/quantum.c ****       }
 648:quantum/quantum.c ****       else {
 649:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 650:quantum/quantum.c ****       }
 651:quantum/quantum.c **** 
 652:quantum/quantum.c ****       send_keyboard_report();
 653:quantum/quantum.c ****       return false;
 654:quantum/quantum.c ****     }
 655:quantum/quantum.c **** 
 656:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 657:quantum/quantum.c ****     case BL_BRTG: {
 658:quantum/quantum.c ****       if (record->event.pressed)
 659:quantum/quantum.c ****         breathing_toggle();
 660:quantum/quantum.c ****       return false;
 661:quantum/quantum.c ****     }
 662:quantum/quantum.c **** #endif
 663:quantum/quantum.c **** 
 664:quantum/quantum.c ****     default: {
 665:quantum/quantum.c ****       shift_interrupted[0] = true;
 793               		.loc 1 665 0
 794 01c8 81E0      		ldi r24,lo8(1)
 795 01ca 8093 0000 		sts shift_interrupted,r24
 666:quantum/quantum.c ****       shift_interrupted[1] = true;
 796               		.loc 1 666 0
 797 01ce 8093 0000 		sts shift_interrupted+1,r24
 798               	.L74:
 667:quantum/quantum.c ****       break;
 668:quantum/quantum.c ****     }
 669:quantum/quantum.c ****   }
 670:quantum/quantum.c **** 
 671:quantum/quantum.c ****   return process_action_kb(record);
 799               		.loc 1 671 0
 800 01d2 C801      		movw r24,r16
 801               	/* epilogue start */
 672:quantum/quantum.c **** }
 802               		.loc 1 672 0
 803 01d4 DF91      		pop r29
 804 01d6 CF91      		pop r28
 805               	.LVL69:
 806 01d8 1F91      		pop r17
 807 01da 0F91      		pop r16
 808               	.LVL70:
 671:quantum/quantum.c ****   return process_action_kb(record);
 809               		.loc 1 671 0
 810 01dc 0C94 0000 		jmp process_action_kb
 811               	.LVL71:
 812               	.L41:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 813               		.loc 1 286 0
 814 01e0 F801      		movw r30,r16
 815 01e2 8281      		ldd r24,Z+2
 816 01e4 8823      		tst r24
 817 01e6 01F4      		brne .+2
 818 01e8 00C0      		rjmp .L151
 287:quantum/quantum.c ****         reset_keyboard();
 819               		.loc 1 287 0
 820 01ea 0E94 0000 		call reset_keyboard
 821               	.LVL72:
 822 01ee 00C0      		rjmp .L151
 823               	.L43:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 824               		.loc 1 291 0
 825 01f0 F801      		movw r30,r16
 826 01f2 8281      		ldd r24,Z+2
 827 01f4 8823      		tst r24
 828 01f6 01F4      		brne .+2
 829 01f8 00C0      		rjmp .L151
 292:quantum/quantum.c ****           debug_enable = true;
 830               		.loc 1 292 0
 831 01fa 8091 0000 		lds r24,debug_config
 832 01fe 8160      		ori r24,lo8(1<<0)
 833 0200 8093 0000 		sts debug_config,r24
 834 0204 00C0      		rjmp .L151
 835               	.L118:
 284:quantum/quantum.c ****   switch(keycode) {
 836               		.loc 1 284 0
 837 0206 C531      		cpi r28,21
 838 0208 FCE5      		ldi r31,92
 839 020a DF07      		cpc r29,r31
 840 020c 01F4      		brne .L220
 841               	.LBB34:
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 842               		.loc 1 611 0
 843 020e 0E94 0000 		call get_mods
 844               	.LVL73:
 845 0212 382F      		mov r19,r24
 846               	.LVL74:
 644:quantum/quantum.c ****       if (record->event.pressed) {
 847               		.loc 1 644 0
 848 0214 F801      		movw r30,r16
 849 0216 2281      		ldd r18,Z+2
 850 0218 8091 0000 		lds r24,keyboard_report
 851 021c 9091 0000 		lds r25,keyboard_report+1
 852 0220 2223      		tst r18
 853 0222 01F0      		breq .L110
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 854               		.loc 1 611 0
 855 0224 3A7A      		andi r19,lo8(-86)
 856               	.LVL75:
 645:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 857               		.loc 1 645 0
 858 0226 21E0      		ldi r18,lo8(1)
 859 0228 01F4      		brne .L111
 860 022a 20E0      		ldi r18,0
 861               	.L111:
 862 022c 2093 0000 		sts grave_esc_was_shifted,r18
 646:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 863               		.loc 1 646 0
 864 0230 2223      		tst r18
 865 0232 01F0      		breq .L123
 866 0234 65E3      		ldi r22,lo8(53)
 867 0236 00C0      		rjmp .L112
 868               	.L123:
 869 0238 69E2      		ldi r22,lo8(41)
 870               	.L112:
 871               	.LVL76:
 872               	.LBB35:
 873               	.LBB36:
 874               		.file 3 "./tmk_core/common/action_util.h"
   1:./tmk_core/common/action_util.h **** /*
   2:./tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action_util.h **** 
   4:./tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action_util.h **** (at your option) any later version.
   8:./tmk_core/common/action_util.h **** 
   9:./tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:./tmk_core/common/action_util.h **** 
  14:./tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action_util.h **** */
  17:./tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:./tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:./tmk_core/common/action_util.h **** 
  20:./tmk_core/common/action_util.h **** #include <stdint.h>
  21:./tmk_core/common/action_util.h **** #include "report.h"
  22:./tmk_core/common/action_util.h **** 
  23:./tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:./tmk_core/common/action_util.h **** extern "C" {
  25:./tmk_core/common/action_util.h **** #endif
  26:./tmk_core/common/action_util.h **** 
  27:./tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:./tmk_core/common/action_util.h **** 
  29:./tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:./tmk_core/common/action_util.h **** 
  31:./tmk_core/common/action_util.h **** /* key */
  32:./tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 875               		.loc 3 33 0 discriminator 1
 876 023a 0E94 0000 		call add_key_to_report
 877               	.LVL77:
 878 023e 00C0      		rjmp .L113
 879               	.LVL78:
 880               	.L110:
 881               	.LBE36:
 882               	.LBE35:
 649:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 883               		.loc 1 649 0
 884 0240 2091 0000 		lds r18,grave_esc_was_shifted
 885 0244 2223      		tst r18
 886 0246 01F0      		breq .L124
 887 0248 65E3      		ldi r22,lo8(53)
 888 024a 00C0      		rjmp .L114
 889               	.L124:
 890 024c 69E2      		ldi r22,lo8(41)
 891               	.L114:
 892               	.LVL79:
 893               	.LBB37:
 894               	.LBB38:
  34:./tmk_core/common/action_util.h **** }
  35:./tmk_core/common/action_util.h **** 
  36:./tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:./tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 895               		.loc 3 37 0 discriminator 3
 896 024e 0E94 0000 		call del_key_from_report
 897               	.LVL80:
 898               	.L113:
 899               	.LBE38:
 900               	.LBE37:
 652:quantum/quantum.c ****       send_keyboard_report();
 901               		.loc 1 652 0
 902 0252 0E94 0000 		call send_keyboard_report
 903               	.LVL81:
 653:quantum/quantum.c ****       return false;
 904               		.loc 1 653 0
 905 0256 00C0      		rjmp .L151
 906               	.L220:
 907               	.LBE34:
 284:quantum/quantum.c ****   switch(keycode) {
 908               		.loc 1 284 0
 909 0258 C03C      		cpi r28,-64
 910 025a DC45      		sbci r29,92
 911 025c 01F0      		breq .+2
 912 025e 00C0      		rjmp .L115
 315:quantum/quantum.c ****     if (record->event.pressed) {
 913               		.loc 1 315 0
 914 0260 F801      		movw r30,r16
 915 0262 8281      		ldd r24,Z+2
 916 0264 8823      		tst r24
 917 0266 01F4      		brne .+2
 918 0268 00C0      		rjmp .L151
 316:quantum/quantum.c ****       rgblight_toggle();
 919               		.loc 1 316 0
 920 026a 0E94 0000 		call rgblight_toggle
 921               	.LVL82:
 922 026e 00C0      		rjmp .L151
 923               	.L51:
 352:quantum/quantum.c ****     if (record->event.pressed) {
 924               		.loc 1 352 0
 925 0270 8823      		tst r24
 926 0272 01F4      		brne .+2
 927 0274 00C0      		rjmp .L151
 353:quantum/quantum.c ****       rgblight_increase_sat();
 928               		.loc 1 353 0
 929 0276 0E94 0000 		call rgblight_increase_sat
 930               	.LVL83:
 931 027a 00C0      		rjmp .L151
 932               	.L49:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 933               		.loc 1 342 0
 934 027c 8823      		tst r24
 935 027e 01F4      		brne .+2
 936 0280 00C0      		rjmp .L151
 343:quantum/quantum.c ****       rgblight_increase_hue();
 937               		.loc 1 343 0
 938 0282 0E94 0000 		call rgblight_increase_hue
 939               	.LVL84:
 940 0286 00C0      		rjmp .L151
 941               	.L218:
 347:quantum/quantum.c ****     if (record->event.pressed) {
 942               		.loc 1 347 0
 943 0288 8823      		tst r24
 944 028a 01F4      		brne .+2
 945 028c 00C0      		rjmp .L151
 348:quantum/quantum.c ****       rgblight_decrease_hue();
 946               		.loc 1 348 0
 947 028e 0E94 0000 		call rgblight_decrease_hue
 948               	.LVL85:
 949 0292 00C0      		rjmp .L151
 950               	.L119:
 284:quantum/quantum.c ****   switch(keycode) {
 951               		.loc 1 284 0
 952 0294 C73C      		cpi r28,-57
 953 0296 9CE5      		ldi r25,92
 954 0298 D907      		cpc r29,r25
 955 029a 01F4      		brne .L221
 362:quantum/quantum.c ****     if (record->event.pressed) {
 956               		.loc 1 362 0
 957 029c 8823      		tst r24
 958 029e 01F4      		brne .+2
 959 02a0 00C0      		rjmp .L151
 363:quantum/quantum.c ****       rgblight_increase_val();
 960               		.loc 1 363 0
 961 02a2 0E94 0000 		call rgblight_increase_val
 962               	.LVL86:
 963 02a6 00C0      		rjmp .L151
 964               	.L221:
 284:quantum/quantum.c ****   switch(keycode) {
 965               		.loc 1 284 0
 966 02a8 C83C      		cpi r28,-56
 967 02aa DC45      		sbci r29,92
 968 02ac 00F4      		brsh .L222
 357:quantum/quantum.c ****     if (record->event.pressed) {
 969               		.loc 1 357 0
 970 02ae 8823      		tst r24
 971 02b0 01F4      		brne .+2
 972 02b2 00C0      		rjmp .L151
 358:quantum/quantum.c ****       rgblight_decrease_sat();
 973               		.loc 1 358 0
 974 02b4 0E94 0000 		call rgblight_decrease_sat
 975               	.LVL87:
 976 02b8 00C0      		rjmp .L151
 977               	.L222:
 367:quantum/quantum.c ****     if (record->event.pressed) {
 978               		.loc 1 367 0
 979 02ba 8823      		tst r24
 980 02bc 01F4      		brne .+2
 981 02be 00C0      		rjmp .L151
 368:quantum/quantum.c ****       rgblight_decrease_val();
 982               		.loc 1 368 0
 983 02c0 0E94 0000 		call rgblight_decrease_val
 984               	.LVL88:
 985 02c4 00C0      		rjmp .L151
 986               	.L116:
 284:quantum/quantum.c ****   switch(keycode) {
 987               		.loc 1 284 0
 988 02c6 C03D      		cpi r28,-48
 989 02c8 FCE5      		ldi r31,92
 990 02ca DF07      		cpc r29,r31
 991 02cc 01F4      		brne .L223
 423:quantum/quantum.c ****     if (record->event.pressed) {
 992               		.loc 1 423 0
 993 02ce F801      		movw r30,r16
 994 02d0 8281      		ldd r24,Z+2
 995 02d2 8823      		tst r24
 996 02d4 01F4      		brne .+2
 997 02d6 00C0      		rjmp .L151
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 998               		.loc 1 424 0
 999 02d8 0E94 0000 		call rgblight_get_mode
 1000               	.LVL89:
 1001 02dc 6531      		cpi r22,21
 1002 02de 7105      		cpc r23,__zero_reg__
 1003 02e0 8105      		cpc r24,__zero_reg__
 1004 02e2 9105      		cpc r25,__zero_reg__
 1005 02e4 00F0      		brlo .L67
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 1006               		.loc 1 424 0 is_stmt 0 discriminator 1
 1007 02e6 0E94 0000 		call rgblight_get_mode
 1008               	.LVL90:
 1009 02ea 6731      		cpi r22,23
 1010 02ec 7105      		cpc r23,__zero_reg__
 1011 02ee 8105      		cpc r24,__zero_reg__
 1012 02f0 9105      		cpc r25,__zero_reg__
 1013 02f2 00F4      		brsh .+2
 1014 02f4 00C0      		rjmp .L46
 1015               	.L67:
 427:quantum/quantum.c ****         rgblight_mode(21);
 1016               		.loc 1 427 0 is_stmt 1
 1017 02f6 85E1      		ldi r24,lo8(21)
 1018               	.L209:
 391:quantum/quantum.c ****         rgblight_mode(2);
 1019               		.loc 1 391 0
 1020 02f8 0E94 0000 		call rgblight_mode
 1021               	.LVL91:
 1022 02fc 00C0      		rjmp .L151
 1023               	.L223:
 284:quantum/quantum.c ****   switch(keycode) {
 1024               		.loc 1 284 0
 1025 02fe C13D      		cpi r28,-47
 1026 0300 8CE5      		ldi r24,92
 1027 0302 D807      		cpc r29,r24
 1028 0304 00F0      		brlo .+2
 1029 0306 00C0      		rjmp .L120
 1030 0308 CC3C      		cpi r28,-52
 1031 030a 9CE5      		ldi r25,92
 1032 030c D907      		cpc r29,r25
 1033 030e 01F4      		brne .L224
 387:quantum/quantum.c ****     if (record->event.pressed) {
 1034               		.loc 1 387 0
 1035 0310 F801      		movw r30,r16
 1036 0312 8281      		ldd r24,Z+2
 1037 0314 8823      		tst r24
 1038 0316 01F4      		brne .+2
 1039 0318 00C0      		rjmp .L151
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 1040               		.loc 1 388 0
 1041 031a 0E94 0000 		call rgblight_get_mode
 1042               	.LVL92:
 1043 031e 6230      		cpi r22,2
 1044 0320 7105      		cpc r23,__zero_reg__
 1045 0322 8105      		cpc r24,__zero_reg__
 1046 0324 9105      		cpc r25,__zero_reg__
 1047 0326 00F0      		brlo .L59
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 1048               		.loc 1 388 0 is_stmt 0 discriminator 1
 1049 0328 0E94 0000 		call rgblight_get_mode
 1050               	.LVL93:
 1051 032c 6530      		cpi r22,5
 1052 032e 7105      		cpc r23,__zero_reg__
 1053 0330 8105      		cpc r24,__zero_reg__
 1054 0332 9105      		cpc r25,__zero_reg__
 1055 0334 00F4      		brsh .+2
 1056 0336 00C0      		rjmp .L46
 1057               	.L59:
 391:quantum/quantum.c ****         rgblight_mode(2);
 1058               		.loc 1 391 0 is_stmt 1
 1059 0338 82E0      		ldi r24,lo8(2)
 1060 033a 00C0      		rjmp .L209
 1061               	.L224:
 284:quantum/quantum.c ****   switch(keycode) {
 1062               		.loc 1 284 0
 1063 033c CD3C      		cpi r28,-51
 1064 033e ECE5      		ldi r30,92
 1065 0340 DE07      		cpc r29,r30
 1066 0342 00F4      		brsh .L121
 1067 0344 CA3C      		cpi r28,-54
 1068 0346 FCE5      		ldi r31,92
 1069 0348 DF07      		cpc r29,r31
 1070 034a 01F4      		brne .L225
 377:quantum/quantum.c ****     if (record->event.pressed) {
 1071               		.loc 1 377 0
 1072 034c F801      		movw r30,r16
 1073 034e 8281      		ldd r24,Z+2
 1074 0350 8823      		tst r24
 1075 0352 01F4      		brne .+2
 1076 0354 00C0      		rjmp .L151
 378:quantum/quantum.c ****       rgblight_decrease_speed();
 1077               		.loc 1 378 0
 1078 0356 0E94 0000 		call rgblight_decrease_speed
 1079               	.LVL94:
 1080 035a 00C0      		rjmp .L151
 1081               	.L225:
 284:quantum/quantum.c ****   switch(keycode) {
 1082               		.loc 1 284 0
 1083 035c CB3C      		cpi r28,-53
 1084 035e DC45      		sbci r29,92
 1085 0360 01F0      		breq .+2
 1086 0362 00C0      		rjmp .L115
 382:quantum/quantum.c ****     if (record->event.pressed) {
 1087               		.loc 1 382 0
 1088 0364 F801      		movw r30,r16
 1089 0366 8281      		ldd r24,Z+2
 1090 0368 8823      		tst r24
 1091 036a 01F4      		brne .+2
 1092 036c 00C0      		rjmp .L151
 383:quantum/quantum.c ****       rgblight_mode(1);
 1093               		.loc 1 383 0
 1094 036e 81E0      		ldi r24,lo8(1)
 1095 0370 00C0      		rjmp .L209
 1096               	.L121:
 1097 0372 F801      		movw r30,r16
 1098 0374 8281      		ldd r24,Z+2
 284:quantum/quantum.c ****   switch(keycode) {
 1099               		.loc 1 284 0
 1100 0376 CE3C      		cpi r28,-50
 1101 0378 FCE5      		ldi r31,92
 1102 037a DF07      		cpc r29,r31
 1103 037c 01F4      		brne .L226
 405:quantum/quantum.c ****     if (record->event.pressed) {
 1104               		.loc 1 405 0
 1105 037e 8823      		tst r24
 1106 0380 01F4      		brne .+2
 1107 0382 00C0      		rjmp .L151
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 1108               		.loc 1 406 0
 1109 0384 0E94 0000 		call rgblight_get_mode
 1110               	.LVL95:
 1111 0388 6930      		cpi r22,9
 1112 038a 7105      		cpc r23,__zero_reg__
 1113 038c 8105      		cpc r24,__zero_reg__
 1114 038e 9105      		cpc r25,__zero_reg__
 1115 0390 00F0      		brlo .L63
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 1116               		.loc 1 406 0 is_stmt 0 discriminator 1
 1117 0392 0E94 0000 		call rgblight_get_mode
 1118               	.LVL96:
 1119 0396 6E30      		cpi r22,14
 1120 0398 7105      		cpc r23,__zero_reg__
 1121 039a 8105      		cpc r24,__zero_reg__
 1122 039c 9105      		cpc r25,__zero_reg__
 1123 039e 00F4      		brsh .+2
 1124 03a0 00C0      		rjmp .L46
 1125               	.L63:
 409:quantum/quantum.c ****         rgblight_mode(9);
 1126               		.loc 1 409 0 is_stmt 1
 1127 03a2 89E0      		ldi r24,lo8(9)
 1128 03a4 00C0      		rjmp .L209
 1129               	.L226:
 284:quantum/quantum.c ****   switch(keycode) {
 1130               		.loc 1 284 0
 1131 03a6 CF3C      		cpi r28,-49
 1132 03a8 DC45      		sbci r29,92
 1133 03aa 00F4      		brsh .L227
 396:quantum/quantum.c ****     if (record->event.pressed) {
 1134               		.loc 1 396 0
 1135 03ac 8823      		tst r24
 1136 03ae 01F4      		brne .+2
 1137 03b0 00C0      		rjmp .L151
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 1138               		.loc 1 397 0
 1139 03b2 0E94 0000 		call rgblight_get_mode
 1140               	.LVL97:
 1141 03b6 6630      		cpi r22,6
 1142 03b8 7105      		cpc r23,__zero_reg__
 1143 03ba 8105      		cpc r24,__zero_reg__
 1144 03bc 9105      		cpc r25,__zero_reg__
 1145 03be 00F0      		brlo .L61
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 1146               		.loc 1 397 0 is_stmt 0 discriminator 1
 1147 03c0 0E94 0000 		call rgblight_get_mode
 1148               	.LVL98:
 1149 03c4 6830      		cpi r22,8
 1150 03c6 7105      		cpc r23,__zero_reg__
 1151 03c8 8105      		cpc r24,__zero_reg__
 1152 03ca 9105      		cpc r25,__zero_reg__
 1153 03cc 00F4      		brsh .+2
 1154 03ce 00C0      		rjmp .L46
 1155               	.L61:
 400:quantum/quantum.c ****         rgblight_mode(6);
 1156               		.loc 1 400 0 is_stmt 1
 1157 03d0 86E0      		ldi r24,lo8(6)
 1158 03d2 00C0      		rjmp .L209
 1159               	.L227:
 414:quantum/quantum.c ****     if (record->event.pressed) {
 1160               		.loc 1 414 0
 1161 03d4 8823      		tst r24
 1162 03d6 01F4      		brne .+2
 1163 03d8 00C0      		rjmp .L151
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 1164               		.loc 1 415 0
 1165 03da 0E94 0000 		call rgblight_get_mode
 1166               	.LVL99:
 1167 03de 6F30      		cpi r22,15
 1168 03e0 7105      		cpc r23,__zero_reg__
 1169 03e2 8105      		cpc r24,__zero_reg__
 1170 03e4 9105      		cpc r25,__zero_reg__
 1171 03e6 00F0      		brlo .L65
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 1172               		.loc 1 415 0 is_stmt 0 discriminator 1
 1173 03e8 0E94 0000 		call rgblight_get_mode
 1174               	.LVL100:
 1175 03ec 6431      		cpi r22,20
 1176 03ee 7105      		cpc r23,__zero_reg__
 1177 03f0 8105      		cpc r24,__zero_reg__
 1178 03f2 9105      		cpc r25,__zero_reg__
 1179 03f4 00F4      		brsh .+2
 1180 03f6 00C0      		rjmp .L46
 1181               	.L65:
 418:quantum/quantum.c ****         rgblight_mode(15);
 1182               		.loc 1 418 0 is_stmt 1
 1183 03f8 8FE0      		ldi r24,lo8(15)
 1184 03fa 00C0      		rjmp .L209
 1185               	.L120:
 284:quantum/quantum.c ****   switch(keycode) {
 1186               		.loc 1 284 0
 1187 03fc C43D      		cpi r28,-44
 1188 03fe ECE5      		ldi r30,92
 1189 0400 DE07      		cpc r29,r30
 1190 0402 01F4      		brne .L228
 572:quantum/quantum.c ****       if (record->event.pressed) {
 1191               		.loc 1 572 0
 1192 0404 F801      		movw r30,r16
 1193 0406 8281      		ldd r24,Z+2
 1194 0408 8823      		tst r24
 1195 040a 01F0      		breq .L103
 1196               	.L108:
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 1197               		.loc 1 573 0
 1198 040c 1092 0000 		sts shift_interrupted+1,__zero_reg__
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 1199               		.loc 1 574 0
 1200 0410 0E94 0000 		call timer_read
 1201               	.LVL101:
 1202 0414 9093 0000 		sts scs_timer+2+1,r25
 1203 0418 8093 0000 		sts scs_timer+2,r24
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 1204               		.loc 1 575 0
 1205 041c 80E2      		ldi r24,lo8(32)
 1206               	.L211:
 1207 041e 0E94 0000 		call register_mods
 1208               	.LVL102:
 1209 0422 00C0      		rjmp .L151
 1210               	.L103:
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1211               		.loc 1 584 0
 1212 0424 8091 0000 		lds r24,shift_interrupted+1
 1213 0428 8111      		cpse r24,__zero_reg__
 1214 042a 00C0      		rjmp .L105
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1215               		.loc 1 584 0 is_stmt 0 discriminator 1
 1216 042c 8091 0000 		lds r24,scs_timer+2
 1217 0430 9091 0000 		lds r25,scs_timer+2+1
 1218 0434 0E94 0000 		call timer_elapsed
 1219               	.LVL103:
 1220 0438 883C      		cpi r24,-56
 1221 043a 9105      		cpc r25,__zero_reg__
 1222 043c 00F4      		brsh .L105
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 1223               		.loc 1 585 0 is_stmt 1
 1224 043e 87E2      		ldi r24,lo8(39)
 1225 0440 0E94 0000 		call register_code
 1226               	.LVL104:
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 1227               		.loc 1 586 0
 1228 0444 87E2      		ldi r24,lo8(39)
 1229 0446 0E94 0000 		call unregister_code
 1230               	.LVL105:
 1231               	.L105:
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1232               		.loc 1 588 0
 1233 044a 80E2      		ldi r24,lo8(32)
 1234               	.L210:
 1235 044c 0E94 0000 		call unregister_mods
 1236               	.LVL106:
 1237 0450 00C0      		rjmp .L151
 1238               	.L228:
 284:quantum/quantum.c ****   switch(keycode) {
 1239               		.loc 1 284 0
 1240 0452 C53D      		cpi r28,-43
 1241 0454 FCE5      		ldi r31,92
 1242 0456 DF07      		cpc r29,r31
 1243 0458 00F0      		brlo .+2
 1244 045a 00C0      		rjmp .L122
 1245 045c F801      		movw r30,r16
 1246 045e 8281      		ldd r24,Z+2
 1247 0460 C23D      		cpi r28,-46
 1248 0462 FCE5      		ldi r31,92
 1249 0464 DF07      		cpc r29,r31
 1250 0466 01F4      		brne .L229
 437:quantum/quantum.c ****     if (record->event.pressed) {
 1251               		.loc 1 437 0
 1252 0468 8823      		tst r24
 1253 046a 01F4      		brne .+2
 1254 046c 00C0      		rjmp .L151
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 1255               		.loc 1 438 0
 1256 046e 0E94 0000 		call rgblight_get_mode
 1257               	.LVL107:
 1258 0472 6931      		cpi r22,25
 1259 0474 7105      		cpc r23,__zero_reg__
 1260 0476 8105      		cpc r24,__zero_reg__
 1261 0478 9105      		cpc r25,__zero_reg__
 1262 047a 00F0      		brlo .L70
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 1263               		.loc 1 438 0 is_stmt 0 discriminator 1
 1264 047c 0E94 0000 		call rgblight_get_mode
 1265               	.LVL108:
 1266 0480 6232      		cpi r22,34
 1267 0482 7105      		cpc r23,__zero_reg__
 1268 0484 8105      		cpc r24,__zero_reg__
 1269 0486 9105      		cpc r25,__zero_reg__
 1270 0488 00F4      		brsh .+2
 1271 048a 00C0      		rjmp .L46
 1272               	.L70:
 441:quantum/quantum.c ****         rgblight_mode(25);
 1273               		.loc 1 441 0 is_stmt 1
 1274 048c 89E1      		ldi r24,lo8(25)
 1275 048e 00C0      		rjmp .L209
 1276               	.L229:
 284:quantum/quantum.c ****   switch(keycode) {
 1277               		.loc 1 284 0
 1278 0490 C33D      		cpi r28,-45
 1279 0492 DC45      		sbci r29,92
 1280 0494 00F4      		brsh .L230
 432:quantum/quantum.c ****     if (record->event.pressed) {
 1281               		.loc 1 432 0
 1282 0496 8823      		tst r24
 1283 0498 01F4      		brne .+2
 1284 049a 00C0      		rjmp .L151
 433:quantum/quantum.c ****       rgblight_mode(24);
 1285               		.loc 1 433 0
 1286 049c 88E1      		ldi r24,lo8(24)
 1287 049e 00C0      		rjmp .L209
 1288               	.L230:
 550:quantum/quantum.c ****       if (record->event.pressed) {
 1289               		.loc 1 550 0
 1290 04a0 8823      		tst r24
 1291 04a2 01F0      		breq .L98
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 1292               		.loc 1 551 0
 1293 04a4 1092 0000 		sts shift_interrupted,__zero_reg__
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 1294               		.loc 1 552 0
 1295 04a8 0E94 0000 		call timer_read
 1296               	.LVL109:
 1297 04ac 9093 0000 		sts scs_timer+1,r25
 1298 04b0 8093 0000 		sts scs_timer,r24
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 1299               		.loc 1 553 0
 1300 04b4 82E0      		ldi r24,lo8(2)
 1301 04b6 00C0      		rjmp .L211
 1302               	.L98:
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 1303               		.loc 1 562 0
 1304 04b8 8091 0000 		lds r24,shift_interrupted
 1305 04bc 8111      		cpse r24,__zero_reg__
 1306 04be 00C0      		rjmp .L100
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 1307               		.loc 1 562 0 is_stmt 0 discriminator 1
 1308 04c0 8091 0000 		lds r24,scs_timer
 1309 04c4 9091 0000 		lds r25,scs_timer+1
 1310 04c8 0E94 0000 		call timer_elapsed
 1311               	.LVL110:
 1312 04cc 883C      		cpi r24,-56
 1313 04ce 9105      		cpc r25,__zero_reg__
 1314 04d0 00F4      		brsh .L100
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 1315               		.loc 1 563 0 is_stmt 1
 1316 04d2 86E2      		ldi r24,lo8(38)
 1317 04d4 0E94 0000 		call register_code
 1318               	.LVL111:
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 1319               		.loc 1 564 0
 1320 04d8 86E2      		ldi r24,lo8(38)
 1321 04da 0E94 0000 		call unregister_code
 1322               	.LVL112:
 1323               	.L100:
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 1324               		.loc 1 566 0
 1325 04de 82E0      		ldi r24,lo8(2)
 1326 04e0 00C0      		rjmp .L210
 1327               	.L122:
 284:quantum/quantum.c ****   switch(keycode) {
 1328               		.loc 1 284 0
 1329 04e2 C83D      		cpi r28,-40
 1330 04e4 ECE5      		ldi r30,92
 1331 04e6 DE07      		cpc r29,r30
 1332 04e8 01F4      		brne .L231
 448:quantum/quantum.c ****       if (record->event.pressed) {
 1333               		.loc 1 448 0
 1334 04ea F801      		movw r30,r16
 1335 04ec 8281      		ldd r24,Z+2
 1336 04ee 8823      		tst r24
 1337 04f0 01F0      		breq .L151
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 1338               		.loc 1 449 0
 1339 04f2 80E0      		ldi r24,0
 1340 04f4 00C0      		rjmp .L212
 1341               	.L231:
 284:quantum/quantum.c ****   switch(keycode) {
 1342               		.loc 1 284 0
 1343 04f6 C93D      		cpi r28,-39
 1344 04f8 FCE5      		ldi r31,92
 1345 04fa DF07      		cpc r29,r31
 1346 04fc 01F4      		brne .L232
 453:quantum/quantum.c ****       if (record->event.pressed) {
 1347               		.loc 1 453 0
 1348 04fe F801      		movw r30,r16
 1349 0500 8281      		ldd r24,Z+2
 1350 0502 8823      		tst r24
 1351 0504 01F0      		breq .L151
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 1352               		.loc 1 454 0
 1353 0506 82E0      		ldi r24,lo8(2)
 1354               	.L212:
 1355 0508 0E94 0000 		call set_output
 1356               	.LVL113:
 1357 050c 00C0      		rjmp .L151
 1358               	.L232:
 284:quantum/quantum.c ****   switch(keycode) {
 1359               		.loc 1 284 0
 1360 050e C53D      		cpi r28,-43
 1361 0510 DC45      		sbci r29,92
 1362 0512 01F0      		breq .+2
 1363 0514 00C0      		rjmp .L115
 594:quantum/quantum.c ****       if (record->event.pressed) {
 1364               		.loc 1 594 0
 1365 0516 F801      		movw r30,r16
 1366 0518 8281      		ldd r24,Z+2
 1367 051a 8111      		cpse r24,__zero_reg__
 1368 051c 00C0      		rjmp .L108
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1369               		.loc 1 599 0
 1370 051e 8091 0000 		lds r24,shift_interrupted+1
 1371 0522 8111      		cpse r24,__zero_reg__
 1372 0524 00C0      		rjmp .L105
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1373               		.loc 1 599 0 is_stmt 0 discriminator 1
 1374 0526 8091 0000 		lds r24,scs_timer+2
 1375 052a 9091 0000 		lds r25,scs_timer+2+1
 1376 052e 0E94 0000 		call timer_elapsed
 1377               	.LVL114:
 1378 0532 883C      		cpi r24,-56
 1379 0534 9105      		cpc r25,__zero_reg__
 1380 0536 00F0      		brlo .+2
 1381 0538 00C0      		rjmp .L105
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1382               		.loc 1 600 0 is_stmt 1
 1383 053a 80E2      		ldi r24,lo8(32)
 1384 053c 0E94 0000 		call unregister_mods
 1385               	.LVL115:
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 1386               		.loc 1 601 0
 1387 0540 88E2      		ldi r24,lo8(40)
 1388 0542 0E94 0000 		call register_code
 1389               	.LVL116:
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 1390               		.loc 1 602 0
 1391 0546 88E2      		ldi r24,lo8(40)
 1392 0548 0E94 0000 		call unregister_code
 1393               	.LVL117:
 1394               	.L151:
 1395               		.loc 1 672 0
 1396 054c 80E0      		ldi r24,0
 1397               	/* epilogue start */
 1398 054e DF91      		pop r29
 1399 0550 CF91      		pop r28
 1400               	.LVL118:
 1401 0552 1F91      		pop r17
 1402 0554 0F91      		pop r16
 1403               	.LVL119:
 1404 0556 0895      		ret
 1405               		.cfi_endproc
 1406               	.LFE117:
 1408               		.section	.text.send_char,"ax",@progbits
 1409               	.global	send_char
 1411               	send_char:
 1412               	.LFB122:
 673:quantum/quantum.c **** 
 674:quantum/quantum.c **** __attribute__ ((weak))
 675:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 676:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 677:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 678:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 679:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 680:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 681:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 682:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 683:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 684:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 685:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 686:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 687:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 688:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 689:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 690:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 691:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 692:quantum/quantum.c **** };
 693:quantum/quantum.c **** 
 694:quantum/quantum.c **** __attribute__ ((weak))
 695:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 696:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 697:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 698:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 699:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 700:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 701:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 702:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 703:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 704:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 705:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 706:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 707:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 708:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 709:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 710:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 711:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 712:quantum/quantum.c **** };
 713:quantum/quantum.c **** 
 714:quantum/quantum.c **** void send_string(const char *str) {
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 716:quantum/quantum.c **** }
 717:quantum/quantum.c **** 
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 720:quantum/quantum.c **** }
 721:quantum/quantum.c **** 
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 723:quantum/quantum.c ****     while (1) {
 724:quantum/quantum.c ****         char ascii_code = *str;
 725:quantum/quantum.c ****         if (!ascii_code) break;
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 727:quantum/quantum.c ****           // tap
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 729:quantum/quantum.c ****           register_code(keycode);
 730:quantum/quantum.c ****           unregister_code(keycode);
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 732:quantum/quantum.c ****           // down
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 734:quantum/quantum.c ****           register_code(keycode);
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 736:quantum/quantum.c ****           // up
 737:quantum/quantum.c ****           uint8_t keycode = *(++str);
 738:quantum/quantum.c ****           unregister_code(keycode);
 739:quantum/quantum.c ****         } else {
 740:quantum/quantum.c ****           send_char(ascii_code);
 741:quantum/quantum.c ****         }
 742:quantum/quantum.c ****         ++str;
 743:quantum/quantum.c ****         // interval
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 745:quantum/quantum.c ****     }
 746:quantum/quantum.c **** }
 747:quantum/quantum.c **** 
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 749:quantum/quantum.c ****     while (1) {
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 751:quantum/quantum.c ****         if (!ascii_code) break;
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 753:quantum/quantum.c ****           // tap
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 755:quantum/quantum.c ****           register_code(keycode);
 756:quantum/quantum.c ****           unregister_code(keycode);
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 758:quantum/quantum.c ****           // down
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 760:quantum/quantum.c ****           register_code(keycode);
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 762:quantum/quantum.c ****           // up
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 764:quantum/quantum.c ****           unregister_code(keycode);
 765:quantum/quantum.c ****         } else {
 766:quantum/quantum.c ****           send_char(ascii_code);
 767:quantum/quantum.c ****         }
 768:quantum/quantum.c ****         ++str;
 769:quantum/quantum.c ****         // interval
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 771:quantum/quantum.c ****     }
 772:quantum/quantum.c **** }
 773:quantum/quantum.c **** 
 774:quantum/quantum.c **** void send_char(char ascii_code) {
 1413               		.loc 1 774 0
 1414               		.cfi_startproc
 1415               	.LVL120:
 1416 0000 CF93      		push r28
 1417               	.LCFI12:
 1418               		.cfi_def_cfa_offset 3
 1419               		.cfi_offset 28, -2
 1420               	/* prologue: function */
 1421               	/* frame size = 0 */
 1422               	/* stack size = 1 */
 1423               	.L__stack_usage = 1
 1424               	.LBB39:
 775:quantum/quantum.c ****   uint8_t keycode;
 776:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 1425               		.loc 1 776 0
 1426 0002 282F      		mov r18,r24
 1427 0004 30E0      		ldi r19,0
 1428               	.LVL121:
 1429 0006 F901      		movw r30,r18
 1430 0008 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 1431 000a F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 1432               	.LVL122:
 1433               	/* #APP */
 1434               	 ;  776 "quantum/quantum.c" 1
 1435 000c C491      		lpm r28, Z
 1436               		
 1437               	 ;  0 "" 2
 1438               	.LVL123:
 1439               	/* #NOAPP */
 1440               	.LBE39:
 1441               	.LBB40:
 777:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 1442               		.loc 1 777 0
 1443 000e F901      		movw r30,r18
 1444               	.LVL124:
 1445 0010 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 1446 0012 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 1447               	.LVL125:
 1448               	/* #APP */
 1449               	 ;  777 "quantum/quantum.c" 1
 1450 0014 2491      		lpm r18, Z
 1451               		
 1452               	 ;  0 "" 2
 1453               	.LVL126:
 1454               	/* #NOAPP */
 1455               	.LBE40:
 1456 0016 2223      		tst r18
 1457 0018 01F0      		breq .L234
 778:quantum/quantum.c ****       register_code(KC_LSFT);
 1458               		.loc 1 778 0
 1459 001a 81EE      		ldi r24,lo8(-31)
 1460               	.LVL127:
 1461 001c 0E94 0000 		call register_code
 1462               	.LVL128:
 779:quantum/quantum.c ****       register_code(keycode);
 1463               		.loc 1 779 0
 1464 0020 8C2F      		mov r24,r28
 1465 0022 0E94 0000 		call register_code
 1466               	.LVL129:
 780:quantum/quantum.c ****       unregister_code(keycode);
 1467               		.loc 1 780 0
 1468 0026 8C2F      		mov r24,r28
 1469 0028 0E94 0000 		call unregister_code
 1470               	.LVL130:
 781:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1471               		.loc 1 781 0
 1472 002c 81EE      		ldi r24,lo8(-31)
 1473 002e 00C0      		rjmp .L235
 1474               	.LVL131:
 1475               	.L234:
 782:quantum/quantum.c ****   } else {
 783:quantum/quantum.c ****       register_code(keycode);
 1476               		.loc 1 783 0
 1477 0030 8C2F      		mov r24,r28
 1478               	.LVL132:
 1479 0032 0E94 0000 		call register_code
 1480               	.LVL133:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1481               		.loc 1 784 0
 1482 0036 8C2F      		mov r24,r28
 1483               	.L235:
 1484               	/* epilogue start */
 785:quantum/quantum.c ****   }
 786:quantum/quantum.c **** }
 1485               		.loc 1 786 0
 1486 0038 CF91      		pop r28
 1487               	.LVL134:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1488               		.loc 1 784 0
 1489 003a 0C94 0000 		jmp unregister_code
 1490               	.LVL135:
 1491               		.cfi_endproc
 1492               	.LFE122:
 1494               		.section	.text.send_string_with_delay,"ax",@progbits
 1495               	.global	send_string_with_delay
 1497               	send_string_with_delay:
 1498               	.LFB120:
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 1499               		.loc 1 722 0
 1500               		.cfi_startproc
 1501               	.LVL136:
 1502 0000 FF92      		push r15
 1503               	.LCFI13:
 1504               		.cfi_def_cfa_offset 3
 1505               		.cfi_offset 15, -2
 1506 0002 0F93      		push r16
 1507               	.LCFI14:
 1508               		.cfi_def_cfa_offset 4
 1509               		.cfi_offset 16, -3
 1510 0004 1F93      		push r17
 1511               	.LCFI15:
 1512               		.cfi_def_cfa_offset 5
 1513               		.cfi_offset 17, -4
 1514 0006 CF93      		push r28
 1515               	.LCFI16:
 1516               		.cfi_def_cfa_offset 6
 1517               		.cfi_offset 28, -5
 1518 0008 DF93      		push r29
 1519               	.LCFI17:
 1520               		.cfi_def_cfa_offset 7
 1521               		.cfi_offset 29, -6
 1522               	/* prologue: function */
 1523               	/* frame size = 0 */
 1524               	/* stack size = 5 */
 1525               	.L__stack_usage = 5
 1526 000a EC01      		movw r28,r24
 1527 000c F62E      		mov r15,r22
 1528               	.LVL137:
 1529               	.L244:
 1530               	.LBB41:
 724:quantum/quantum.c ****         char ascii_code = *str;
 1531               		.loc 1 724 0
 1532 000e 8881      		ld r24,Y
 1533               	.LVL138:
 725:quantum/quantum.c ****         if (!ascii_code) break;
 1534               		.loc 1 725 0
 1535 0010 8823      		tst r24
 1536 0012 01F0      		breq .L236
 1537 0014 8E01      		movw r16,r28
 1538 0016 0F5F      		subi r16,-1
 1539 0018 1F4F      		sbci r17,-1
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 1540               		.loc 1 726 0
 1541 001a 8130      		cpi r24,lo8(1)
 1542 001c 01F4      		brne .L238
 1543               	.LVL139:
 1544               	.LBB42:
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 1545               		.loc 1 728 0
 1546 001e C981      		ldd r28,Y+1
 1547               	.LVL140:
 729:quantum/quantum.c ****           register_code(keycode);
 1548               		.loc 1 729 0
 1549 0020 8C2F      		mov r24,r28
 1550               	.LVL141:
 1551 0022 0E94 0000 		call register_code
 1552               	.LVL142:
 730:quantum/quantum.c ****           unregister_code(keycode);
 1553               		.loc 1 730 0
 1554 0026 8C2F      		mov r24,r28
 1555 0028 00C0      		rjmp .L246
 1556               	.LVL143:
 1557               	.L238:
 1558               	.LBE42:
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1559               		.loc 1 731 0
 1560 002a 8230      		cpi r24,lo8(2)
 1561 002c 01F4      		brne .L240
 1562               	.LVL144:
 1563               	.LBB43:
 734:quantum/quantum.c ****           register_code(keycode);
 1564               		.loc 1 734 0
 1565 002e 8981      		ldd r24,Y+1
 1566               	.LVL145:
 1567 0030 0E94 0000 		call register_code
 1568               	.LVL146:
 1569               	.L245:
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 1570               		.loc 1 733 0
 1571 0034 E801      		movw r28,r16
 1572               	.LBE43:
 1573 0036 00C0      		rjmp .L239
 1574               	.LVL147:
 1575               	.L240:
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1576               		.loc 1 735 0
 1577 0038 8330      		cpi r24,lo8(3)
 1578 003a 01F4      		brne .L241
 1579               	.LVL148:
 1580               	.LBB44:
 738:quantum/quantum.c ****           unregister_code(keycode);
 1581               		.loc 1 738 0
 1582 003c 8981      		ldd r24,Y+1
 1583               	.LVL149:
 1584               	.L246:
 1585 003e 0E94 0000 		call unregister_code
 1586               	.LVL150:
 1587 0042 00C0      		rjmp .L245
 1588               	.LVL151:
 1589               	.L241:
 1590               	.LBE44:
 740:quantum/quantum.c ****           send_char(ascii_code);
 1591               		.loc 1 740 0
 1592 0044 0E94 0000 		call send_char
 1593               	.LVL152:
 1594               	.L239:
 742:quantum/quantum.c ****         ++str;
 1595               		.loc 1 742 0
 1596 0048 2196      		adiw r28,1
 1597               	.LVL153:
 1598               	.LBB45:
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1599               		.loc 1 744 0
 1600 004a 8F2D      		mov r24,r15
 1601               	.LVL154:
 1602               	.L242:
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1603               		.loc 1 744 0 is_stmt 0 discriminator 1
 1604 004c 8823      		tst r24
 1605 004e 01F0      		breq .L244
 1606               	.LVL155:
 1607               	.LBB46:
 1608               	.LBB47:
 1609               		.loc 2 164 0 is_stmt 1
 1610 0050 EFE9      		ldi r30,lo8(3999)
 1611 0052 FFE0      		ldi r31,hi8(3999)
 1612 0054 3197      		1: sbiw r30,1
 1613 0056 01F4      		brne 1b
 1614 0058 00C0      		rjmp .
 1615 005a 0000      		nop
 1616 005c 8150      		subi r24,lo8(-(-1))
 1617               	.LVL156:
 1618 005e 00C0      		rjmp .L242
 1619               	.LVL157:
 1620               	.L236:
 1621               	/* epilogue start */
 1622               	.LBE47:
 1623               	.LBE46:
 1624               	.LBE45:
 1625               	.LBE41:
 746:quantum/quantum.c **** }
 1626               		.loc 1 746 0
 1627 0060 DF91      		pop r29
 1628 0062 CF91      		pop r28
 1629               	.LVL158:
 1630 0064 1F91      		pop r17
 1631 0066 0F91      		pop r16
 1632 0068 FF90      		pop r15
 1633               	.LVL159:
 1634 006a 0895      		ret
 1635               		.cfi_endproc
 1636               	.LFE120:
 1638               		.section	.text.send_string,"ax",@progbits
 1639               	.global	send_string
 1641               	send_string:
 1642               	.LFB118:
 714:quantum/quantum.c **** void send_string(const char *str) {
 1643               		.loc 1 714 0
 1644               		.cfi_startproc
 1645               	.LVL160:
 1646               	/* prologue: function */
 1647               	/* frame size = 0 */
 1648               	/* stack size = 0 */
 1649               	.L__stack_usage = 0
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 1650               		.loc 1 715 0
 1651 0000 60E0      		ldi r22,0
 1652 0002 0C94 0000 		jmp send_string_with_delay
 1653               	.LVL161:
 1654               		.cfi_endproc
 1655               	.LFE118:
 1657               		.section	.text.send_string_with_delay_P,"ax",@progbits
 1658               	.global	send_string_with_delay_P
 1660               	send_string_with_delay_P:
 1661               	.LFB121:
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 1662               		.loc 1 748 0
 1663               		.cfi_startproc
 1664               	.LVL162:
 1665 0000 0F93      		push r16
 1666               	.LCFI18:
 1667               		.cfi_def_cfa_offset 3
 1668               		.cfi_offset 16, -2
 1669 0002 1F93      		push r17
 1670               	.LCFI19:
 1671               		.cfi_def_cfa_offset 4
 1672               		.cfi_offset 17, -3
 1673 0004 CF93      		push r28
 1674               	.LCFI20:
 1675               		.cfi_def_cfa_offset 5
 1676               		.cfi_offset 28, -4
 1677 0006 DF93      		push r29
 1678               	.LCFI21:
 1679               		.cfi_def_cfa_offset 6
 1680               		.cfi_offset 29, -5
 1681               	/* prologue: function */
 1682               	/* frame size = 0 */
 1683               	/* stack size = 4 */
 1684               	.L__stack_usage = 4
 1685 0008 EC01      		movw r28,r24
 1686 000a 062F      		mov r16,r22
 1687               	.LVL163:
 1688               	.L256:
 1689               	.LBB48:
 1690               	.LBB49:
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 1691               		.loc 1 750 0
 1692 000c FE01      		movw r30,r28
 1693               	/* #APP */
 1694               	 ;  750 "quantum/quantum.c" 1
 1695 000e 8491      		lpm r24, Z
 1696               		
 1697               	 ;  0 "" 2
 1698               	.LVL164:
 1699               	/* #NOAPP */
 1700               	.LBE49:
 751:quantum/quantum.c ****         if (!ascii_code) break;
 1701               		.loc 1 751 0
 1702 0010 8823      		tst r24
 1703 0012 01F0      		breq .L248
 1704 0014 9E01      		movw r18,r28
 1705 0016 2F5F      		subi r18,-1
 1706 0018 3F4F      		sbci r19,-1
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 1707               		.loc 1 752 0
 1708 001a 8130      		cpi r24,lo8(1)
 1709 001c 01F4      		brne .L250
 1710               	.LBB50:
 1711               	.LBB51:
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1712               		.loc 1 754 0
 1713 001e E901      		movw r28,r18
 1714               	.LVL165:
 1715 0020 F901      		movw r30,r18
 1716               	.LVL166:
 1717               	/* #APP */
 1718               	 ;  754 "quantum/quantum.c" 1
 1719 0022 1491      		lpm r17, Z
 1720               		
 1721               	 ;  0 "" 2
 1722               	.LVL167:
 1723               	/* #NOAPP */
 1724               	.LBE51:
 755:quantum/quantum.c ****           register_code(keycode);
 1725               		.loc 1 755 0
 1726 0024 812F      		mov r24,r17
 1727               	.LVL168:
 1728 0026 0E94 0000 		call register_code
 1729               	.LVL169:
 756:quantum/quantum.c ****           unregister_code(keycode);
 1730               		.loc 1 756 0
 1731 002a 812F      		mov r24,r17
 1732 002c 00C0      		rjmp .L257
 1733               	.LVL170:
 1734               	.L250:
 1735               	.LBE50:
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1736               		.loc 1 757 0
 1737 002e 8230      		cpi r24,lo8(2)
 1738 0030 01F4      		brne .L252
 1739               	.LBB52:
 1740               	.LBB53:
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1741               		.loc 1 759 0
 1742 0032 E901      		movw r28,r18
 1743               	.LVL171:
 1744 0034 F901      		movw r30,r18
 1745               	.LVL172:
 1746               	/* #APP */
 1747               	 ;  759 "quantum/quantum.c" 1
 1748 0036 8491      		lpm r24, Z
 1749               		
 1750               	 ;  0 "" 2
 1751               	.LVL173:
 1752               	/* #NOAPP */
 1753               	.LBE53:
 760:quantum/quantum.c ****           register_code(keycode);
 1754               		.loc 1 760 0
 1755 0038 0E94 0000 		call register_code
 1756               	.LVL174:
 1757               	.LBE52:
 1758 003c 00C0      		rjmp .L251
 1759               	.LVL175:
 1760               	.L252:
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1761               		.loc 1 761 0
 1762 003e 8330      		cpi r24,lo8(3)
 1763 0040 01F4      		brne .L253
 1764               	.LBB54:
 1765               	.LBB55:
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1766               		.loc 1 763 0
 1767 0042 E901      		movw r28,r18
 1768               	.LVL176:
 1769 0044 F901      		movw r30,r18
 1770               	.LVL177:
 1771               	/* #APP */
 1772               	 ;  763 "quantum/quantum.c" 1
 1773 0046 8491      		lpm r24, Z
 1774               		
 1775               	 ;  0 "" 2
 1776               	.LVL178:
 1777               	/* #NOAPP */
 1778               	.L257:
 1779               	.LBE55:
 764:quantum/quantum.c ****           unregister_code(keycode);
 1780               		.loc 1 764 0
 1781 0048 0E94 0000 		call unregister_code
 1782               	.LVL179:
 1783               	.LBE54:
 1784 004c 00C0      		rjmp .L251
 1785               	.LVL180:
 1786               	.L253:
 766:quantum/quantum.c ****           send_char(ascii_code);
 1787               		.loc 1 766 0
 1788 004e 0E94 0000 		call send_char
 1789               	.LVL181:
 1790               	.L251:
 768:quantum/quantum.c ****         ++str;
 1791               		.loc 1 768 0
 1792 0052 2196      		adiw r28,1
 1793               	.LVL182:
 1794               	.LBB56:
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1795               		.loc 1 770 0
 1796 0054 802F      		mov r24,r16
 1797               	.LVL183:
 1798               	.L254:
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1799               		.loc 1 770 0 is_stmt 0 discriminator 1
 1800 0056 8823      		tst r24
 1801 0058 01F0      		breq .L256
 1802               	.LVL184:
 1803               	.LBB57:
 1804               	.LBB58:
 1805               		.loc 2 164 0 is_stmt 1
 1806 005a EFE9      		ldi r30,lo8(3999)
 1807 005c FFE0      		ldi r31,hi8(3999)
 1808 005e 3197      		1: sbiw r30,1
 1809 0060 01F4      		brne 1b
 1810 0062 00C0      		rjmp .
 1811 0064 0000      		nop
 1812 0066 8150      		subi r24,lo8(-(-1))
 1813               	.LVL185:
 1814 0068 00C0      		rjmp .L254
 1815               	.LVL186:
 1816               	.L248:
 1817               	/* epilogue start */
 1818               	.LBE58:
 1819               	.LBE57:
 1820               	.LBE56:
 1821               	.LBE48:
 772:quantum/quantum.c **** }
 1822               		.loc 1 772 0
 1823 006a DF91      		pop r29
 1824 006c CF91      		pop r28
 1825               	.LVL187:
 1826 006e 1F91      		pop r17
 1827 0070 0F91      		pop r16
 1828               	.LVL188:
 1829 0072 0895      		ret
 1830               		.cfi_endproc
 1831               	.LFE121:
 1833               		.section	.text.send_string_P,"ax",@progbits
 1834               	.global	send_string_P
 1836               	send_string_P:
 1837               	.LFB119:
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 1838               		.loc 1 718 0
 1839               		.cfi_startproc
 1840               	.LVL189:
 1841               	/* prologue: function */
 1842               	/* frame size = 0 */
 1843               	/* stack size = 0 */
 1844               	.L__stack_usage = 0
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1845               		.loc 1 719 0
 1846 0000 60E0      		ldi r22,0
 1847 0002 0C94 0000 		jmp send_string_with_delay_P
 1848               	.LVL190:
 1849               		.cfi_endproc
 1850               	.LFE119:
 1852               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1853               	.global	set_single_persistent_default_layer
 1855               	set_single_persistent_default_layer:
 1856               	.LFB123:
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1857               		.loc 1 788 0
 1858               		.cfi_startproc
 1859               	.LVL191:
 1860 0000 CF93      		push r28
 1861               	.LCFI22:
 1862               		.cfi_def_cfa_offset 3
 1863               		.cfi_offset 28, -2
 1864 0002 DF93      		push r29
 1865               	.LCFI23:
 1866               		.cfi_def_cfa_offset 4
 1867               		.cfi_offset 29, -3
 1868               	/* prologue: function */
 1869               	/* frame size = 0 */
 1870               	/* stack size = 2 */
 1871               	.L__stack_usage = 2
 789:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 790:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 791:quantum/quantum.c ****   #endif
 792:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1872               		.loc 1 792 0
 1873 0004 C1E0      		ldi r28,lo8(1)
 1874 0006 D0E0      		ldi r29,0
 1875 0008 00C0      		rjmp 2f
 1876               		1:
 1877 000a CC0F      		lsl r28
 1878 000c DD1F      		rol r29
 1879               		2:
 1880 000e 8A95      		dec r24
 1881 0010 02F4      		brpl 1b
 1882 0012 8C2F      		mov r24,r28
 1883               	.LVL192:
 1884 0014 0E94 0000 		call eeconfig_update_default_layer
 1885               	.LVL193:
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1886               		.loc 1 793 0
 1887 0018 BE01      		movw r22,r28
 1888 001a 80E0      		ldi r24,0
 1889 001c 90E0      		ldi r25,0
 1890               	/* epilogue start */
 794:quantum/quantum.c **** }
 1891               		.loc 1 794 0
 1892 001e DF91      		pop r29
 1893 0020 CF91      		pop r28
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1894               		.loc 1 793 0
 1895 0022 0C94 0000 		jmp default_layer_set
 1896               	.LVL194:
 1897               		.cfi_endproc
 1898               	.LFE123:
 1900               		.section	.text.update_tri_layer_state,"ax",@progbits
 1901               	.global	update_tri_layer_state
 1903               	update_tri_layer_state:
 1904               	.LFB124:
 795:quantum/quantum.c **** 
 796:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1905               		.loc 1 796 0
 1906               		.cfi_startproc
 1907               	.LVL195:
 1908 0000 4F92      		push r4
 1909               	.LCFI24:
 1910               		.cfi_def_cfa_offset 3
 1911               		.cfi_offset 4, -2
 1912 0002 5F92      		push r5
 1913               	.LCFI25:
 1914               		.cfi_def_cfa_offset 4
 1915               		.cfi_offset 5, -3
 1916 0004 6F92      		push r6
 1917               	.LCFI26:
 1918               		.cfi_def_cfa_offset 5
 1919               		.cfi_offset 6, -4
 1920 0006 7F92      		push r7
 1921               	.LCFI27:
 1922               		.cfi_def_cfa_offset 6
 1923               		.cfi_offset 7, -5
 1924 0008 8F92      		push r8
 1925               	.LCFI28:
 1926               		.cfi_def_cfa_offset 7
 1927               		.cfi_offset 8, -6
 1928 000a 9F92      		push r9
 1929               	.LCFI29:
 1930               		.cfi_def_cfa_offset 8
 1931               		.cfi_offset 9, -7
 1932 000c AF92      		push r10
 1933               	.LCFI30:
 1934               		.cfi_def_cfa_offset 9
 1935               		.cfi_offset 10, -8
 1936 000e BF92      		push r11
 1937               	.LCFI31:
 1938               		.cfi_def_cfa_offset 10
 1939               		.cfi_offset 11, -9
 1940 0010 CF92      		push r12
 1941               	.LCFI32:
 1942               		.cfi_def_cfa_offset 11
 1943               		.cfi_offset 12, -10
 1944 0012 DF92      		push r13
 1945               	.LCFI33:
 1946               		.cfi_def_cfa_offset 12
 1947               		.cfi_offset 13, -11
 1948 0014 EF92      		push r14
 1949               	.LCFI34:
 1950               		.cfi_def_cfa_offset 13
 1951               		.cfi_offset 14, -12
 1952 0016 FF92      		push r15
 1953               	.LCFI35:
 1954               		.cfi_def_cfa_offset 14
 1955               		.cfi_offset 15, -13
 1956 0018 0F93      		push r16
 1957               	.LCFI36:
 1958               		.cfi_def_cfa_offset 15
 1959               		.cfi_offset 16, -14
 1960 001a 1F93      		push r17
 1961               	.LCFI37:
 1962               		.cfi_def_cfa_offset 16
 1963               		.cfi_offset 17, -15
 1964               	/* prologue: function */
 1965               	/* frame size = 0 */
 1966               	/* stack size = 14 */
 1967               	.L__stack_usage = 14
 1968 001c 2B01      		movw r4,r22
 1969 001e 3C01      		movw r6,r24
 797:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 1970               		.loc 1 797 0
 1971 0020 C12C      		mov r12,__zero_reg__
 1972 0022 D12C      		mov r13,__zero_reg__
 1973 0024 7601      		movw r14,r12
 1974 0026 C394      		inc r12
 1975 0028 D701      		movw r26,r14
 1976 002a C601      		movw r24,r12
 1977 002c 00C0      		rjmp 2f
 1978               		1:
 1979 002e 880F      		lsl r24
 1980 0030 991F      		rol r25
 1981 0032 AA1F      		rol r26
 1982 0034 BB1F      		rol r27
 1983               		2:
 1984 0036 4A95      		dec r20
 1985 0038 02F4      		brpl 1b
 1986 003a AC01      		movw r20,r24
 1987 003c BD01      		movw r22,r26
 1988               	.LVL196:
 1989 003e 4601      		movw r8,r12
 1990 0040 5701      		movw r10,r14
 1991 0042 00C0      		rjmp 2f
 1992               		1:
 1993 0044 880C      		lsl r8
 1994 0046 991C      		rol r9
 1995 0048 AA1C      		rol r10
 1996 004a BB1C      		rol r11
 1997               		2:
 1998 004c 2A95      		dec r18
 1999 004e 02F4      		brpl 1b
 2000 0050 4829      		or r20,r8
 2001 0052 5929      		or r21,r9
 2002 0054 6A29      		or r22,r10
 2003 0056 7B29      		or r23,r11
 2004               	.LVL197:
 798:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 2005               		.loc 1 798 0
 2006 0058 D701      		movw r26,r14
 2007 005a C601      		movw r24,r12
 2008 005c 00C0      		rjmp 2f
 2009               		1:
 2010 005e 880F      		lsl r24
 2011 0060 991F      		rol r25
 2012 0062 AA1F      		rol r26
 2013 0064 BB1F      		rol r27
 2014               		2:
 2015 0066 0A95      		dec r16
 2016 0068 02F4      		brpl 1b
 2017               	.LVL198:
 799:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 2018               		.loc 1 799 0
 2019 006a 6A01      		movw r12,r20
 2020 006c 7B01      		movw r14,r22
 2021 006e C420      		and r12,r4
 2022 0070 D520      		and r13,r5
 2023 0072 E620      		and r14,r6
 2024 0074 F720      		and r15,r7
 2025 0076 C416      		cp r12,r20
 2026 0078 D506      		cpc r13,r21
 2027 007a E606      		cpc r14,r22
 2028 007c F706      		cpc r15,r23
 2029 007e 01F4      		brne .L261
 2030               		.loc 1 799 0 is_stmt 0 discriminator 1
 2031 0080 BC01      		movw r22,r24
 2032 0082 CD01      		movw r24,r26
 2033               	.LVL199:
 2034 0084 6429      		or r22,r4
 2035 0086 7529      		or r23,r5
 2036 0088 8629      		or r24,r6
 2037 008a 9729      		or r25,r7
 2038 008c 00C0      		rjmp .L262
 2039               	.L261:
 2040               		.loc 1 799 0 discriminator 2
 2041 008e BC01      		movw r22,r24
 2042 0090 CD01      		movw r24,r26
 2043 0092 6095      		com r22
 2044 0094 7095      		com r23
 2045 0096 8095      		com r24
 2046 0098 9095      		com r25
 2047 009a 6421      		and r22,r4
 2048 009c 7521      		and r23,r5
 2049 009e 8621      		and r24,r6
 2050 00a0 9721      		and r25,r7
 2051               	.L262:
 2052               	/* epilogue start */
 800:quantum/quantum.c **** }
 2053               		.loc 1 800 0 is_stmt 1 discriminator 3
 2054 00a2 1F91      		pop r17
 2055 00a4 0F91      		pop r16
 2056               	.LVL200:
 2057 00a6 FF90      		pop r15
 2058               	.LVL201:
 2059 00a8 EF90      		pop r14
 2060               	.LVL202:
 2061 00aa DF90      		pop r13
 2062               	.LVL203:
 2063 00ac CF90      		pop r12
 2064               	.LVL204:
 2065 00ae BF90      		pop r11
 2066               	.LVL205:
 2067 00b0 AF90      		pop r10
 2068               	.LVL206:
 2069 00b2 9F90      		pop r9
 2070               	.LVL207:
 2071 00b4 8F90      		pop r8
 2072               	.LVL208:
 2073 00b6 7F90      		pop r7
 2074               	.LVL209:
 2075 00b8 6F90      		pop r6
 2076               	.LVL210:
 2077 00ba 5F90      		pop r5
 2078               	.LVL211:
 2079 00bc 4F90      		pop r4
 2080               	.LVL212:
 2081 00be 0895      		ret
 2082               		.cfi_endproc
 2083               	.LFE124:
 2085               		.section	.text.update_tri_layer,"ax",@progbits
 2086               	.global	update_tri_layer
 2088               	update_tri_layer:
 2089               	.LFB125:
 801:quantum/quantum.c **** 
 802:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 2090               		.loc 1 802 0
 2091               		.cfi_startproc
 2092               	.LVL213:
 2093 0000 0F93      		push r16
 2094               	.LCFI38:
 2095               		.cfi_def_cfa_offset 3
 2096               		.cfi_offset 16, -2
 2097               	/* prologue: function */
 2098               	/* frame size = 0 */
 2099               	/* stack size = 1 */
 2100               	.L__stack_usage = 1
 2101 0002 382F      		mov r19,r24
 2102 0004 262F      		mov r18,r22
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 2103               		.loc 1 803 0
 2104 0006 6091 0000 		lds r22,layer_state
 2105 000a 7091 0000 		lds r23,layer_state+1
 2106 000e 8091 0000 		lds r24,layer_state+2
 2107 0012 9091 0000 		lds r25,layer_state+3
 2108               	.LVL214:
 2109 0016 042F      		mov r16,r20
 2110 0018 432F      		mov r20,r19
 2111               	.LVL215:
 2112 001a 0E94 0000 		call update_tri_layer_state
 2113               	.LVL216:
 2114               	/* epilogue start */
 804:quantum/quantum.c **** }
 2115               		.loc 1 804 0
 2116 001e 0F91      		pop r16
 2117               	.LVL217:
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 2118               		.loc 1 803 0
 2119 0020 0C94 0000 		jmp layer_state_set
 2120               	.LVL218:
 2121               		.cfi_endproc
 2122               	.LFE125:
 2124               		.section	.text.tap_random_base64,"ax",@progbits
 2125               	.global	tap_random_base64
 2127               	tap_random_base64:
 2128               	.LFB126:
 805:quantum/quantum.c **** 
 806:quantum/quantum.c **** void tap_random_base64(void) {
 2129               		.loc 1 806 0
 2130               		.cfi_startproc
 2131 0000 CF93      		push r28
 2132               	.LCFI39:
 2133               		.cfi_def_cfa_offset 3
 2134               		.cfi_offset 28, -2
 2135               	/* prologue: function */
 2136               	/* frame size = 0 */
 2137               	/* stack size = 1 */
 2138               	.L__stack_usage = 1
 807:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 808:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 2139               		.loc 1 808 0
 2140 0002 66B5      		in r22,0x26
 2141 0004 4091 8400 		lds r20,132
 2142 0008 5091 8500 		lds r21,132+1
 2143 000c 8091 9400 		lds r24,148
 2144 0010 9091 9500 		lds r25,148+1
 2145 0014 2091 BE00 		lds r18,190
 2146 0018 3091 BF00 		lds r19,190+1
 2147 001c C42F      		mov r28,r20
 2148 001e C80F      		add r28,r24
 2149 0020 C60F      		add r28,r22
 2150 0022 C20F      		add r28,r18
 2151 0024 CF73      		andi r28,lo8(63)
 2152               	.LVL219:
 809:quantum/quantum.c ****   #else
 810:quantum/quantum.c ****     uint8_t key = rand() % 64;
 811:quantum/quantum.c ****   #endif
 812:quantum/quantum.c ****   switch (key) {
 2153               		.loc 1 812 0
 2154 0026 CE33      		cpi r28,lo8(62)
 2155 0028 00F4      		brsh .L266
 2156 002a C533      		cpi r28,lo8(53)
 2157 002c 00F4      		brsh .L267
 2158 002e CA31      		cpi r28,lo8(26)
 2159 0030 00F0      		brlo .L265
 2160 0032 C433      		cpi r28,lo8(52)
 2161 0034 00F4      		brsh .L272
 813:quantum/quantum.c ****     case 0 ... 25:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 815:quantum/quantum.c ****       register_code(key + KC_A);
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 817:quantum/quantum.c ****       unregister_code(KC_LSFT);
 818:quantum/quantum.c ****       break;
 819:quantum/quantum.c ****     case 26 ... 51:
 820:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 2162               		.loc 1 820 0
 2163 0036 C651      		subi r28,lo8(-(-22))
 2164               	.LVL220:
 2165 0038 00C0      		rjmp .L275
 2166               	.LVL221:
 2167               	.L266:
 812:quantum/quantum.c ****   switch (key) {
 2168               		.loc 1 812 0
 2169 003a CE33      		cpi r28,lo8(62)
 2170 003c 01F0      		breq .L270
 2171 003e CF33      		cpi r28,lo8(63)
 2172 0040 01F0      		breq .L271
 2173               	.L265:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 2174               		.loc 1 814 0
 2175 0042 81EE      		ldi r24,lo8(-31)
 2176 0044 0E94 0000 		call register_code
 2177               	.LVL222:
 815:quantum/quantum.c ****       register_code(key + KC_A);
 2178               		.loc 1 815 0
 2179 0048 CC5F      		subi r28,lo8(-(4))
 2180               	.LVL223:
 2181 004a 8C2F      		mov r24,r28
 2182 004c 0E94 0000 		call register_code
 2183               	.LVL224:
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 2184               		.loc 1 816 0
 2185 0050 8C2F      		mov r24,r28
 2186 0052 00C0      		rjmp .L274
 2187               	.LVL225:
 2188               	.L272:
 821:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 822:quantum/quantum.c ****       break;
 823:quantum/quantum.c ****     case 52:
 824:quantum/quantum.c ****       register_code(KC_0);
 2189               		.loc 1 824 0
 2190 0054 87E2      		ldi r24,lo8(39)
 2191 0056 0E94 0000 		call register_code
 2192               	.LVL226:
 825:quantum/quantum.c ****       unregister_code(KC_0);
 2193               		.loc 1 825 0
 2194 005a 87E2      		ldi r24,lo8(39)
 2195 005c 00C0      		rjmp .L273
 2196               	.L267:
 826:quantum/quantum.c ****       break;
 827:quantum/quantum.c ****     case 53 ... 61:
 828:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 2197               		.loc 1 828 0
 2198 005e C751      		subi r28,lo8(-(-23))
 2199               	.LVL227:
 2200               	.L275:
 2201 0060 8C2F      		mov r24,r28
 2202               	.LVL228:
 2203 0062 0E94 0000 		call register_code
 2204               	.LVL229:
 829:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 2205               		.loc 1 829 0
 2206 0066 8C2F      		mov r24,r28
 2207 0068 00C0      		rjmp .L273
 2208               	.LVL230:
 2209               	.L270:
 830:quantum/quantum.c ****       break;
 831:quantum/quantum.c ****     case 62:
 832:quantum/quantum.c ****       register_code(KC_LSFT);
 2210               		.loc 1 832 0
 2211 006a 81EE      		ldi r24,lo8(-31)
 2212 006c 0E94 0000 		call register_code
 2213               	.LVL231:
 833:quantum/quantum.c ****       register_code(KC_EQL);
 2214               		.loc 1 833 0
 2215 0070 8EE2      		ldi r24,lo8(46)
 2216 0072 0E94 0000 		call register_code
 2217               	.LVL232:
 834:quantum/quantum.c ****       unregister_code(KC_EQL);
 2218               		.loc 1 834 0
 2219 0076 8EE2      		ldi r24,lo8(46)
 2220               	.LVL233:
 2221               	.L274:
 2222 0078 0E94 0000 		call unregister_code
 2223               	.LVL234:
 835:quantum/quantum.c ****       unregister_code(KC_LSFT);
 2224               		.loc 1 835 0
 2225 007c 81EE      		ldi r24,lo8(-31)
 2226 007e 00C0      		rjmp .L273
 2227               	.LVL235:
 2228               	.L271:
 836:quantum/quantum.c ****       break;
 837:quantum/quantum.c ****     case 63:
 838:quantum/quantum.c ****       register_code(KC_SLSH);
 2229               		.loc 1 838 0
 2230 0080 88E3      		ldi r24,lo8(56)
 2231 0082 0E94 0000 		call register_code
 2232               	.LVL236:
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2233               		.loc 1 839 0
 2234 0086 88E3      		ldi r24,lo8(56)
 2235               	.LVL237:
 2236               	.L273:
 2237               	/* epilogue start */
 840:quantum/quantum.c ****       break;
 841:quantum/quantum.c ****   }
 842:quantum/quantum.c **** }
 2238               		.loc 1 842 0
 2239 0088 CF91      		pop r28
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2240               		.loc 1 839 0
 2241 008a 0C94 0000 		jmp unregister_code
 2242               	.LVL238:
 2243               		.cfi_endproc
 2244               	.LFE126:
 2246               		.section	.text.matrix_init_quantum,"ax",@progbits
 2247               	.global	matrix_init_quantum
 2249               	matrix_init_quantum:
 2250               	.LFB127:
 843:quantum/quantum.c **** 
 844:quantum/quantum.c **** void matrix_init_quantum() {
 2251               		.loc 1 844 0
 2252               		.cfi_startproc
 2253               	/* prologue: function */
 2254               	/* frame size = 0 */
 2255               	/* stack size = 0 */
 2256               	.L__stack_usage = 0
 845:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 846:quantum/quantum.c ****     backlight_init_ports();
 847:quantum/quantum.c ****   #endif
 848:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 849:quantum/quantum.c ****     audio_init();
 850:quantum/quantum.c ****   #endif
 851:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 852:quantum/quantum.c ****     rgb_matrix_init_drivers();
 853:quantum/quantum.c ****   #endif
 854:quantum/quantum.c ****   matrix_init_kb();
 2257               		.loc 1 854 0
 2258 0000 0C94 0000 		jmp matrix_init_kb
 2259               	.LVL239:
 2260               		.cfi_endproc
 2261               	.LFE127:
 2263               		.section	.text.matrix_scan_quantum,"ax",@progbits
 2264               	.global	matrix_scan_quantum
 2266               	matrix_scan_quantum:
 2267               	.LFB128:
 855:quantum/quantum.c **** }
 856:quantum/quantum.c **** 
 857:quantum/quantum.c **** uint8_t rgb_matrix_task_counter = 0;
 858:quantum/quantum.c **** 
 859:quantum/quantum.c **** #ifndef RGB_MATRIX_SKIP_FRAMES
 860:quantum/quantum.c ****   #define RGB_MATRIX_SKIP_FRAMES 1
 861:quantum/quantum.c **** #endif
 862:quantum/quantum.c **** 
 863:quantum/quantum.c **** void matrix_scan_quantum() {
 2268               		.loc 1 863 0
 2269               		.cfi_startproc
 2270               	/* prologue: function */
 2271               	/* frame size = 0 */
 2272               	/* stack size = 0 */
 2273               	.L__stack_usage = 0
 864:quantum/quantum.c ****   #if defined(AUDIO_ENABLE)
 865:quantum/quantum.c ****     matrix_scan_music();
 866:quantum/quantum.c ****   #endif
 867:quantum/quantum.c **** 
 868:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 869:quantum/quantum.c ****     matrix_scan_tap_dance();
 870:quantum/quantum.c ****   #endif
 871:quantum/quantum.c **** 
 872:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 873:quantum/quantum.c ****     matrix_scan_combo();
 874:quantum/quantum.c ****   #endif
 875:quantum/quantum.c **** 
 876:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 877:quantum/quantum.c ****     backlight_task();
 878:quantum/quantum.c ****   #endif
 879:quantum/quantum.c **** 
 880:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 881:quantum/quantum.c ****     rgb_matrix_task();
 882:quantum/quantum.c ****     if (rgb_matrix_task_counter == 0) {
 883:quantum/quantum.c ****       rgb_matrix_update_pwm_buffers();
 884:quantum/quantum.c ****     }
 885:quantum/quantum.c ****     rgb_matrix_task_counter = ((rgb_matrix_task_counter + 1) % (RGB_MATRIX_SKIP_FRAMES + 1));
 886:quantum/quantum.c ****   #endif
 887:quantum/quantum.c **** 
 888:quantum/quantum.c ****   matrix_scan_kb();
 2274               		.loc 1 888 0
 2275 0000 0C94 0000 		jmp matrix_scan_kb
 2276               	.LVL240:
 2277               		.cfi_endproc
 2278               	.LFE128:
 2280               		.section	.text.backlight_init_ports,"ax",@progbits
 2281               		.weak	backlight_init_ports
 2283               	backlight_init_ports:
 2284               	.LFB129:
 889:quantum/quantum.c **** }
 890:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 891:quantum/quantum.c **** 
 892:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 893:quantum/quantum.c **** 
 894:quantum/quantum.c **** // depending on the pin, we use a different output compare unit
 895:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 896:quantum/quantum.c **** #  define COM1x1 COM1C1
 897:quantum/quantum.c **** #  define OCR1x  OCR1C
 898:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 899:quantum/quantum.c **** #  define COM1x1 COM1B1
 900:quantum/quantum.c **** #  define OCR1x  OCR1B
 901:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 902:quantum/quantum.c **** #  define COM1x1 COM1A1
 903:quantum/quantum.c **** #  define OCR1x  OCR1A
 904:quantum/quantum.c **** #else
 905:quantum/quantum.c **** #  define NO_HARDWARE_PWM
 906:quantum/quantum.c **** #endif
 907:quantum/quantum.c **** 
 908:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
 909:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
 910:quantum/quantum.c **** #endif
 911:quantum/quantum.c **** 
 912:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM // pwm through software
 913:quantum/quantum.c **** 
 914:quantum/quantum.c **** __attribute__ ((weak))
 915:quantum/quantum.c **** void backlight_init_ports(void)
 916:quantum/quantum.c **** {
 917:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
 918:quantum/quantum.c ****   // DDRx |= n
 919:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 920:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
 921:quantum/quantum.c ****     // PORTx &= ~n
 922:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 923:quantum/quantum.c ****   #else
 924:quantum/quantum.c ****     // PORTx |= n
 925:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 926:quantum/quantum.c ****   #endif
 927:quantum/quantum.c **** }
 928:quantum/quantum.c **** 
 929:quantum/quantum.c **** __attribute__ ((weak))
 930:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 931:quantum/quantum.c **** 
 932:quantum/quantum.c **** uint8_t backlight_tick = 0;
 933:quantum/quantum.c **** 
 934:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 935:quantum/quantum.c **** void backlight_task(void) {
 936:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
 937:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 938:quantum/quantum.c ****       // PORTx &= ~n
 939:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 940:quantum/quantum.c ****     #else
 941:quantum/quantum.c ****       // PORTx |= n
 942:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 943:quantum/quantum.c ****     #endif
 944:quantum/quantum.c ****   } else {
 945:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 946:quantum/quantum.c ****       // PORTx |= n
 947:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 948:quantum/quantum.c ****     #else
 949:quantum/quantum.c ****       // PORTx &= ~n
 950:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 951:quantum/quantum.c ****     #endif
 952:quantum/quantum.c ****   }
 953:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
 954:quantum/quantum.c **** }
 955:quantum/quantum.c **** #endif
 956:quantum/quantum.c **** 
 957:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 958:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
 959:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
 960:quantum/quantum.c ****   #endif
 961:quantum/quantum.c **** #endif
 962:quantum/quantum.c **** 
 963:quantum/quantum.c **** #else // pwm through timer
 964:quantum/quantum.c **** 
 965:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
 966:quantum/quantum.c **** 
 967:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
 968:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
 969:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
 970:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 971:quantum/quantum.c ****   else {
 972:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
 973:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
 974:quantum/quantum.c ****     // and revert what we've done again after squaring.
 975:quantum/quantum.c ****     y = y * y * y >> 8;
 976:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 977:quantum/quantum.c ****       return 0xFFFFU;
 978:quantum/quantum.c ****     else
 979:quantum/quantum.c ****       return (uint16_t) y;
 980:quantum/quantum.c ****   }
 981:quantum/quantum.c **** }
 982:quantum/quantum.c **** 
 983:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
 984:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
 985:quantum/quantum.c ****   OCR1x = val;
 986:quantum/quantum.c **** }
 987:quantum/quantum.c **** 
 988:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 989:quantum/quantum.c **** __attribute__ ((weak))
 990:quantum/quantum.c **** void backlight_set(uint8_t level) {
 991:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
 992:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 993:quantum/quantum.c **** 
 994:quantum/quantum.c ****   if (level == 0) {
 995:quantum/quantum.c ****     // Turn off PWM control on backlight pin
 996:quantum/quantum.c ****     TCCR1A &= ~(_BV(COM1x1));
 997:quantum/quantum.c ****   } else {
 998:quantum/quantum.c ****     // Turn on PWM control of backlight pin
 999:quantum/quantum.c ****     TCCR1A |= _BV(COM1x1);
1000:quantum/quantum.c ****   }
1001:quantum/quantum.c ****   // Set the brightness
1002:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
1003:quantum/quantum.c **** }
1004:quantum/quantum.c **** 
1005:quantum/quantum.c **** void backlight_task(void) {}
1006:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1007:quantum/quantum.c **** 
1008:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1009:quantum/quantum.c **** 
1010:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1011:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1012:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1013:quantum/quantum.c **** #define BREATHING_STEPS 128
1014:quantum/quantum.c **** 
1015:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1016:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1017:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1018:quantum/quantum.c **** 
1019:quantum/quantum.c **** bool is_breathing(void) {
1020:quantum/quantum.c ****     return !!(TIMSK1 & _BV(TOIE1));
1021:quantum/quantum.c **** }
1022:quantum/quantum.c **** 
1023:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSK1 |= _BV(TOIE1);} while (0)
1024:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSK1 &= ~_BV(TOIE1);} while (0)
1025:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1026:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1027:quantum/quantum.c **** 
1028:quantum/quantum.c **** void breathing_enable(void)
1029:quantum/quantum.c **** {
1030:quantum/quantum.c ****   breathing_counter = 0;
1031:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1032:quantum/quantum.c ****   breathing_interrupt_enable();
1033:quantum/quantum.c **** }
1034:quantum/quantum.c **** 
1035:quantum/quantum.c **** void breathing_pulse(void)
1036:quantum/quantum.c **** {
1037:quantum/quantum.c ****     if (get_backlight_level() == 0)
1038:quantum/quantum.c ****       breathing_min();
1039:quantum/quantum.c ****     else
1040:quantum/quantum.c ****       breathing_max();
1041:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1042:quantum/quantum.c ****     breathing_interrupt_enable();
1043:quantum/quantum.c **** }
1044:quantum/quantum.c **** 
1045:quantum/quantum.c **** void breathing_disable(void)
1046:quantum/quantum.c **** {
1047:quantum/quantum.c ****     breathing_interrupt_disable();
1048:quantum/quantum.c ****     // Restore backlight level
1049:quantum/quantum.c ****     backlight_set(get_backlight_level());
1050:quantum/quantum.c **** }
1051:quantum/quantum.c **** 
1052:quantum/quantum.c **** void breathing_self_disable(void)
1053:quantum/quantum.c **** {
1054:quantum/quantum.c ****   if (get_backlight_level() == 0)
1055:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1056:quantum/quantum.c ****   else
1057:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1058:quantum/quantum.c **** }
1059:quantum/quantum.c **** 
1060:quantum/quantum.c **** void breathing_toggle(void) {
1061:quantum/quantum.c ****   if (is_breathing())
1062:quantum/quantum.c ****     breathing_disable();
1063:quantum/quantum.c ****   else
1064:quantum/quantum.c ****     breathing_enable();
1065:quantum/quantum.c **** }
1066:quantum/quantum.c **** 
1067:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1068:quantum/quantum.c **** {
1069:quantum/quantum.c ****   if (!value)
1070:quantum/quantum.c ****     value = 1;
1071:quantum/quantum.c ****   breathing_period = value;
1072:quantum/quantum.c **** }
1073:quantum/quantum.c **** 
1074:quantum/quantum.c **** void breathing_period_default(void) {
1075:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1076:quantum/quantum.c **** }
1077:quantum/quantum.c **** 
1078:quantum/quantum.c **** void breathing_period_inc(void)
1079:quantum/quantum.c **** {
1080:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1081:quantum/quantum.c **** }
1082:quantum/quantum.c **** 
1083:quantum/quantum.c **** void breathing_period_dec(void)
1084:quantum/quantum.c **** {
1085:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1086:quantum/quantum.c **** }
1087:quantum/quantum.c **** 
1088:quantum/quantum.c **** /* To generate breathing curve in python:
1089:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1090:quantum/quantum.c ****  */
1091:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1092:quantum/quantum.c **** 
1093:quantum/quantum.c **** // Use this before the cie_lightness function.
1094:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1095:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1096:quantum/quantum.c **** }
1097:quantum/quantum.c **** 
1098:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1099:quantum/quantum.c ****  * about 244 times per second.
1100:quantum/quantum.c ****  */
1101:quantum/quantum.c **** ISR(TIMER1_OVF_vect)
1102:quantum/quantum.c **** {
1103:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1104:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1105:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1106:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1107:quantum/quantum.c **** 
1108:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1109:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1110:quantum/quantum.c ****   {
1111:quantum/quantum.c ****       breathing_interrupt_disable();
1112:quantum/quantum.c ****   }
1113:quantum/quantum.c **** 
1114:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1115:quantum/quantum.c **** }
1116:quantum/quantum.c **** 
1117:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1118:quantum/quantum.c **** 
1119:quantum/quantum.c **** __attribute__ ((weak))
1120:quantum/quantum.c **** void backlight_init_ports(void)
1121:quantum/quantum.c **** {
1122:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1123:quantum/quantum.c ****   // DDRx |= n
1124:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
1125:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1126:quantum/quantum.c ****     // PORTx &= ~n
1127:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1128:quantum/quantum.c ****   #else
1129:quantum/quantum.c ****     // PORTx |= n
1130:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1131:quantum/quantum.c ****   #endif
1132:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1133:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1134:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1135:quantum/quantum.c **** 
1136:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1137:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1138:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1139:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1140:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1141:quantum/quantum.c **** 
1142:quantum/quantum.c ****   /*
1143:quantum/quantum.c ****   14.8.3:
1144:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1145:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1146:quantum/quantum.c ****   */
1147:quantum/quantum.c **** 
1148:quantum/quantum.c ****   TCCR1A = _BV(COM1x1) | _BV(WGM11); // = 0b00001010;
1149:quantum/quantum.c ****   TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1150:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1151:quantum/quantum.c ****   ICR1 = TIMER_TOP;
1152:quantum/quantum.c **** 
1153:quantum/quantum.c ****   backlight_init();
1154:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1155:quantum/quantum.c ****     breathing_enable();
1156:quantum/quantum.c ****   #endif
1157:quantum/quantum.c **** }
1158:quantum/quantum.c **** 
1159:quantum/quantum.c **** #endif // NO_HARDWARE_PWM
1160:quantum/quantum.c **** 
1161:quantum/quantum.c **** #else // backlight
1162:quantum/quantum.c **** 
1163:quantum/quantum.c **** __attribute__ ((weak))
1164:quantum/quantum.c **** void backlight_init_ports(void) {}
 2285               		.loc 1 1164 0
 2286               		.cfi_startproc
 2287               	/* prologue: function */
 2288               	/* frame size = 0 */
 2289               	/* stack size = 0 */
 2290               	.L__stack_usage = 0
 2291 0000 0895      		ret
 2292               		.cfi_endproc
 2293               	.LFE129:
 2295               		.section	.text.backlight_set,"ax",@progbits
 2296               		.weak	backlight_set
 2298               	backlight_set:
 2299               	.LFB130:
1165:quantum/quantum.c **** 
1166:quantum/quantum.c **** __attribute__ ((weak))
1167:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 2300               		.loc 1 1167 0
 2301               		.cfi_startproc
 2302               	.LVL241:
 2303               	/* prologue: function */
 2304               	/* frame size = 0 */
 2305               	/* stack size = 0 */
 2306               	.L__stack_usage = 0
 2307 0000 0895      		ret
 2308               		.cfi_endproc
 2309               	.LFE130:
 2311               		.section	.text.send_nibble,"ax",@progbits
 2312               	.global	send_nibble
 2314               	send_nibble:
 2315               	.LFB134:
1168:quantum/quantum.c **** 
1169:quantum/quantum.c **** #endif // backlight
1170:quantum/quantum.c **** 
1171:quantum/quantum.c **** 
1172:quantum/quantum.c **** // Functions for spitting out values
1173:quantum/quantum.c **** //
1174:quantum/quantum.c **** 
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1176:quantum/quantum.c ****     uint16_t word = (number >> 16);
1177:quantum/quantum.c ****     send_word(word);
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1179:quantum/quantum.c **** }
1180:quantum/quantum.c **** 
1181:quantum/quantum.c **** void send_word(uint16_t number) {
1182:quantum/quantum.c ****     uint8_t byte = number >> 8;
1183:quantum/quantum.c ****     send_byte(byte);
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
1185:quantum/quantum.c **** }
1186:quantum/quantum.c **** 
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
1188:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1189:quantum/quantum.c ****     send_nibble(nibble);
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
1191:quantum/quantum.c **** }
1192:quantum/quantum.c **** 
1193:quantum/quantum.c **** void send_nibble(uint8_t number) {
 2316               		.loc 1 1193 0
 2317               		.cfi_startproc
 2318               	.LVL242:
 2319               		.loc 1 1193 0
 2320 0000 CF93      		push r28
 2321               	.LCFI40:
 2322               		.cfi_def_cfa_offset 3
 2323               		.cfi_offset 28, -2
 2324               	/* prologue: function */
 2325               	/* frame size = 0 */
 2326               	/* stack size = 1 */
 2327               	.L__stack_usage = 1
1194:quantum/quantum.c ****     switch (number) {
 2328               		.loc 1 1194 0
 2329 0002 8A30      		cpi r24,lo8(10)
 2330 0004 00F4      		brsh .L282
 2331 0006 8130      		cpi r24,lo8(1)
 2332 0008 00F4      		brsh .L290
1195:quantum/quantum.c ****         case 0:
1196:quantum/quantum.c ****             register_code(KC_0);
 2333               		.loc 1 1196 0
 2334 000a 87E2      		ldi r24,lo8(39)
 2335               	.LVL243:
 2336 000c 0E94 0000 		call register_code
 2337               	.LVL244:
1197:quantum/quantum.c ****             unregister_code(KC_0);
 2338               		.loc 1 1197 0
 2339 0010 87E2      		ldi r24,lo8(39)
 2340 0012 00C0      		rjmp .L288
 2341               	.LVL245:
 2342               	.L282:
1194:quantum/quantum.c ****     switch (number) {
 2343               		.loc 1 1194 0
 2344 0014 8031      		cpi r24,lo8(16)
 2345 0016 00F4      		brsh .L291
1198:quantum/quantum.c ****             break;
1199:quantum/quantum.c ****         case 1 ... 9:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1201:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1202:quantum/quantum.c ****             break;
1203:quantum/quantum.c ****         case 0xA ... 0xF:
1204:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 2346               		.loc 1 1204 0
 2347 0018 CAEF      		ldi r28,lo8(-6)
 2348 001a 00C0      		rjmp .L289
 2349               	.L290:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
 2350               		.loc 1 1200 0
 2351 001c CDE1      		ldi r28,lo8(29)
 2352               	.L289:
 2353               		.loc 1 1204 0
 2354 001e C80F      		add r28,r24
 2355 0020 8C2F      		mov r24,r28
 2356               	.LVL246:
 2357 0022 0E94 0000 		call register_code
 2358               	.LVL247:
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2359               		.loc 1 1205 0
 2360 0026 8C2F      		mov r24,r28
 2361               	.L288:
 2362               	/* epilogue start */
1206:quantum/quantum.c ****             break;
1207:quantum/quantum.c ****     }
1208:quantum/quantum.c **** }
 2363               		.loc 1 1208 0
 2364 0028 CF91      		pop r28
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2365               		.loc 1 1205 0
 2366 002a 0C94 0000 		jmp unregister_code
 2367               	.LVL248:
 2368               	.L291:
 2369               	/* epilogue start */
 2370               		.loc 1 1208 0
 2371 002e CF91      		pop r28
 2372 0030 0895      		ret
 2373               		.cfi_endproc
 2374               	.LFE134:
 2376               		.section	.text.send_byte,"ax",@progbits
 2377               	.global	send_byte
 2379               	send_byte:
 2380               	.LFB133:
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
 2381               		.loc 1 1187 0
 2382               		.cfi_startproc
 2383               	.LVL249:
 2384 0000 CF93      		push r28
 2385               	.LCFI41:
 2386               		.cfi_def_cfa_offset 3
 2387               		.cfi_offset 28, -2
 2388               	/* prologue: function */
 2389               	/* frame size = 0 */
 2390               	/* stack size = 1 */
 2391               	.L__stack_usage = 1
 2392 0002 C82F      		mov r28,r24
 2393               	.LVL250:
1189:quantum/quantum.c ****     send_nibble(nibble);
 2394               		.loc 1 1189 0
 2395 0004 8295      		swap r24
 2396               	.LVL251:
 2397 0006 8F70      		andi r24,lo8(15)
 2398 0008 0E94 0000 		call send_nibble
 2399               	.LVL252:
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
 2400               		.loc 1 1190 0
 2401 000c 8C2F      		mov r24,r28
 2402 000e 8F70      		andi r24,lo8(15)
 2403               	/* epilogue start */
1191:quantum/quantum.c **** }
 2404               		.loc 1 1191 0
 2405 0010 CF91      		pop r28
 2406               	.LVL253:
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
 2407               		.loc 1 1190 0
 2408 0012 0C94 0000 		jmp send_nibble
 2409               	.LVL254:
 2410               		.cfi_endproc
 2411               	.LFE133:
 2413               		.section	.text.send_word,"ax",@progbits
 2414               	.global	send_word
 2416               	send_word:
 2417               	.LFB132:
1181:quantum/quantum.c **** void send_word(uint16_t number) {
 2418               		.loc 1 1181 0
 2419               		.cfi_startproc
 2420               	.LVL255:
 2421 0000 CF93      		push r28
 2422               	.LCFI42:
 2423               		.cfi_def_cfa_offset 3
 2424               		.cfi_offset 28, -2
 2425               	/* prologue: function */
 2426               	/* frame size = 0 */
 2427               	/* stack size = 1 */
 2428               	.L__stack_usage = 1
 2429 0002 C82F      		mov r28,r24
 2430               	.LVL256:
1183:quantum/quantum.c ****     send_byte(byte);
 2431               		.loc 1 1183 0
 2432 0004 892F      		mov r24,r25
 2433               	.LVL257:
 2434 0006 0E94 0000 		call send_byte
 2435               	.LVL258:
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
 2436               		.loc 1 1184 0
 2437 000a 8C2F      		mov r24,r28
 2438               	/* epilogue start */
1185:quantum/quantum.c **** }
 2439               		.loc 1 1185 0
 2440 000c CF91      		pop r28
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
 2441               		.loc 1 1184 0
 2442 000e 0C94 0000 		jmp send_byte
 2443               	.LVL259:
 2444               		.cfi_endproc
 2445               	.LFE132:
 2447               		.section	.text.send_dword,"ax",@progbits
 2448               	.global	send_dword
 2450               	send_dword:
 2451               	.LFB131:
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
 2452               		.loc 1 1175 0
 2453               		.cfi_startproc
 2454               	.LVL260:
 2455 0000 CF92      		push r12
 2456               	.LCFI43:
 2457               		.cfi_def_cfa_offset 3
 2458               		.cfi_offset 12, -2
 2459 0002 DF92      		push r13
 2460               	.LCFI44:
 2461               		.cfi_def_cfa_offset 4
 2462               		.cfi_offset 13, -3
 2463 0004 EF92      		push r14
 2464               	.LCFI45:
 2465               		.cfi_def_cfa_offset 5
 2466               		.cfi_offset 14, -4
 2467 0006 FF92      		push r15
 2468               	.LCFI46:
 2469               		.cfi_def_cfa_offset 6
 2470               		.cfi_offset 15, -5
 2471               	/* prologue: function */
 2472               	/* frame size = 0 */
 2473               	/* stack size = 4 */
 2474               	.L__stack_usage = 4
 2475 0008 6B01      		movw r12,r22
 2476 000a 7C01      		movw r14,r24
 2477               	.LVL261:
1177:quantum/quantum.c ****     send_word(word);
 2478               		.loc 1 1177 0
 2479 000c C701      		movw r24,r14
 2480 000e 0E94 0000 		call send_word
 2481               	.LVL262:
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2482               		.loc 1 1178 0
 2483 0012 C601      		movw r24,r12
 2484               	/* epilogue start */
1179:quantum/quantum.c **** }
 2485               		.loc 1 1179 0
 2486 0014 FF90      		pop r15
 2487 0016 EF90      		pop r14
 2488 0018 DF90      		pop r13
 2489 001a CF90      		pop r12
 2490               	.LVL263:
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2491               		.loc 1 1178 0
 2492 001c 0C94 0000 		jmp send_word
 2493               	.LVL264:
 2494               		.cfi_endproc
 2495               	.LFE131:
 2497               		.section	.text.hex_to_keycode,"ax",@progbits
 2498               		.weak	hex_to_keycode
 2500               	hex_to_keycode:
 2501               	.LFB135:
1209:quantum/quantum.c **** 
1210:quantum/quantum.c **** 
1211:quantum/quantum.c **** __attribute__((weak))
1212:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1213:quantum/quantum.c **** {
 2502               		.loc 1 1213 0
 2503               		.cfi_startproc
 2504               	.LVL265:
 2505               	/* prologue: function */
 2506               	/* frame size = 0 */
 2507               	/* stack size = 0 */
 2508               	.L__stack_usage = 0
1214:quantum/quantum.c ****   hex = hex & 0xF;
 2509               		.loc 1 1214 0
 2510 0000 282F      		mov r18,r24
 2511 0002 2F70      		andi r18,lo8(15)
 2512               	.LVL266:
1215:quantum/quantum.c ****   if (hex == 0x0) {
 2513               		.loc 1 1215 0
 2514 0004 01F0      		breq .L298
 2515 0006 822F      		mov r24,r18
 2516 0008 90E0      		ldi r25,0
1216:quantum/quantum.c ****     return KC_0;
1217:quantum/quantum.c ****   } else if (hex < 0xA) {
 2517               		.loc 1 1217 0
 2518 000a 2A30      		cpi r18,lo8(10)
 2519 000c 00F4      		brsh .L297
1218:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 2520               		.loc 1 1218 0
 2521 000e 4D96      		adiw r24,29
 2522 0010 0895      		ret
 2523               	.L297:
1219:quantum/quantum.c ****   } else {
1220:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 2524               		.loc 1 1220 0
 2525 0012 0697      		sbiw r24,6
 2526 0014 0895      		ret
 2527               	.L298:
1216:quantum/quantum.c ****     return KC_0;
 2528               		.loc 1 1216 0
 2529 0016 87E2      		ldi r24,lo8(39)
 2530 0018 90E0      		ldi r25,0
1221:quantum/quantum.c ****   }
1222:quantum/quantum.c **** }
 2531               		.loc 1 1222 0
 2532 001a 0895      		ret
 2533               		.cfi_endproc
 2534               	.LFE135:
 2536               		.section	.text.api_send_unicode,"ax",@progbits
 2537               	.global	api_send_unicode
 2539               	api_send_unicode:
 2540               	.LFB136:
1223:quantum/quantum.c **** 
1224:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 2541               		.loc 1 1224 0
 2542               		.cfi_startproc
 2543               	.LVL267:
 2544               	/* prologue: function */
 2545               	/* frame size = 0 */
 2546               	/* stack size = 0 */
 2547               	.L__stack_usage = 0
 2548 0000 0895      		ret
 2549               		.cfi_endproc
 2550               	.LFE136:
 2552               		.section	.text.led_set_user,"ax",@progbits
 2553               		.weak	led_set_user
 2555               	led_set_user:
 2556               	.LFB137:
1225:quantum/quantum.c **** #ifdef API_ENABLE
1226:quantum/quantum.c ****     uint8_t chunk[4];
1227:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1228:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1229:quantum/quantum.c **** #endif
1230:quantum/quantum.c **** }
1231:quantum/quantum.c **** 
1232:quantum/quantum.c **** __attribute__ ((weak))
1233:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 2557               		.loc 1 1233 0
 2558               		.cfi_startproc
 2559               	.LVL268:
 2560               	/* prologue: function */
 2561               	/* frame size = 0 */
 2562               	/* stack size = 0 */
 2563               	.L__stack_usage = 0
 2564 0000 0895      		ret
 2565               		.cfi_endproc
 2566               	.LFE137:
 2568               		.section	.text.led_set_kb,"ax",@progbits
 2569               		.weak	led_set_kb
 2571               	led_set_kb:
 2572               	.LFB138:
1234:quantum/quantum.c **** 
1235:quantum/quantum.c **** }
1236:quantum/quantum.c **** 
1237:quantum/quantum.c **** __attribute__ ((weak))
1238:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 2573               		.loc 1 1238 0
 2574               		.cfi_startproc
 2575               	.LVL269:
 2576               	/* prologue: function */
 2577               	/* frame size = 0 */
 2578               	/* stack size = 0 */
 2579               	.L__stack_usage = 0
1239:quantum/quantum.c ****     led_set_user(usb_led);
 2580               		.loc 1 1239 0
 2581 0000 0C94 0000 		jmp led_set_user
 2582               	.LVL270:
 2583               		.cfi_endproc
 2584               	.LFE138:
 2586               		.section	.text.led_init_ports,"ax",@progbits
 2587               		.weak	led_init_ports
 2589               	led_init_ports:
 2590               	.LFB139:
1240:quantum/quantum.c **** }
1241:quantum/quantum.c **** 
1242:quantum/quantum.c **** __attribute__ ((weak))
1243:quantum/quantum.c **** void led_init_ports(void)
1244:quantum/quantum.c **** {
 2591               		.loc 1 1244 0
 2592               		.cfi_startproc
 2593               	/* prologue: function */
 2594               	/* frame size = 0 */
 2595               	/* stack size = 0 */
 2596               	.L__stack_usage = 0
 2597 0000 0895      		ret
 2598               		.cfi_endproc
 2599               	.LFE139:
 2601               		.section	.text.led_set,"ax",@progbits
 2602               		.weak	led_set
 2604               	led_set:
 2605               	.LFB140:
1245:quantum/quantum.c **** 
1246:quantum/quantum.c **** }
1247:quantum/quantum.c **** 
1248:quantum/quantum.c **** __attribute__ ((weak))
1249:quantum/quantum.c **** void led_set(uint8_t usb_led)
1250:quantum/quantum.c **** {
 2606               		.loc 1 1250 0
 2607               		.cfi_startproc
 2608               	.LVL271:
 2609               	/* prologue: function */
 2610               	/* frame size = 0 */
 2611               	/* stack size = 0 */
 2612               	.L__stack_usage = 0
1251:quantum/quantum.c **** 
1252:quantum/quantum.c ****   // Example LED Code
1253:quantum/quantum.c ****   //
1254:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1255:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1256:quantum/quantum.c ****     // {
1257:quantum/quantum.c ****     //     // Output high.
1258:quantum/quantum.c ****     //     DDRE |= (1<<6);
1259:quantum/quantum.c ****     //     PORTE |= (1<<6);
1260:quantum/quantum.c ****     // }
1261:quantum/quantum.c ****     // else
1262:quantum/quantum.c ****     // {
1263:quantum/quantum.c ****     //     // Output low.
1264:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1265:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1266:quantum/quantum.c ****     // }
1267:quantum/quantum.c **** 
1268:quantum/quantum.c ****   led_set_kb(usb_led);
 2613               		.loc 1 1268 0
 2614 0000 0C94 0000 		jmp led_set_kb
 2615               	.LVL272:
 2616               		.cfi_endproc
 2617               	.LFE140:
 2619               		.section	.text.startup_user,"ax",@progbits
 2620               		.weak	startup_user
 2622               	startup_user:
 2623               	.LFB141:
1269:quantum/quantum.c **** }
1270:quantum/quantum.c **** 
1271:quantum/quantum.c **** 
1272:quantum/quantum.c **** //------------------------------------------------------------------------------
1273:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1274:quantum/quantum.c **** // different events such as startup and bootloader jump
1275:quantum/quantum.c **** 
1276:quantum/quantum.c **** __attribute__ ((weak))
1277:quantum/quantum.c **** void startup_user() {}
 2624               		.loc 1 1277 0
 2625               		.cfi_startproc
 2626               	/* prologue: function */
 2627               	/* frame size = 0 */
 2628               	/* stack size = 0 */
 2629               	.L__stack_usage = 0
 2630 0000 0895      		ret
 2631               		.cfi_endproc
 2632               	.LFE141:
 2634               		.section	.text.shutdown_user,"ax",@progbits
 2635               		.weak	shutdown_user
 2637               	shutdown_user:
 2638               	.LFB142:
1278:quantum/quantum.c **** 
1279:quantum/quantum.c **** __attribute__ ((weak))
1280:quantum/quantum.c **** void shutdown_user() {}
 2639               		.loc 1 1280 0
 2640               		.cfi_startproc
 2641               	/* prologue: function */
 2642               	/* frame size = 0 */
 2643               	/* stack size = 0 */
 2644               	.L__stack_usage = 0
 2645 0000 0895      		ret
 2646               		.cfi_endproc
 2647               	.LFE142:
 2649               	.global	rgb_matrix_task_counter
 2650               		.section	.bss.rgb_matrix_task_counter,"aw",@nobits
 2653               	rgb_matrix_task_counter:
 2654 0000 00        		.zero	1
 2655               		.weak	ascii_to_keycode_lut
 2656               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2659               	ascii_to_keycode_lut:
 2660 0000 00        		.byte	0
 2661 0001 00        		.byte	0
 2662 0002 00        		.byte	0
 2663 0003 00        		.byte	0
 2664 0004 00        		.byte	0
 2665 0005 00        		.byte	0
 2666 0006 00        		.byte	0
 2667 0007 00        		.byte	0
 2668 0008 2A        		.byte	42
 2669 0009 2B        		.byte	43
 2670 000a 28        		.byte	40
 2671 000b 00        		.byte	0
 2672 000c 00        		.byte	0
 2673 000d 00        		.byte	0
 2674 000e 00        		.byte	0
 2675 000f 00        		.byte	0
 2676 0010 00        		.byte	0
 2677 0011 00        		.byte	0
 2678 0012 00        		.byte	0
 2679 0013 00        		.byte	0
 2680 0014 00        		.byte	0
 2681 0015 00        		.byte	0
 2682 0016 00        		.byte	0
 2683 0017 00        		.byte	0
 2684 0018 00        		.byte	0
 2685 0019 00        		.byte	0
 2686 001a 00        		.byte	0
 2687 001b 29        		.byte	41
 2688 001c 00        		.byte	0
 2689 001d 00        		.byte	0
 2690 001e 00        		.byte	0
 2691 001f 00        		.byte	0
 2692 0020 2C        		.byte	44
 2693 0021 1E        		.byte	30
 2694 0022 34        		.byte	52
 2695 0023 20        		.byte	32
 2696 0024 21        		.byte	33
 2697 0025 22        		.byte	34
 2698 0026 24        		.byte	36
 2699 0027 34        		.byte	52
 2700 0028 26        		.byte	38
 2701 0029 27        		.byte	39
 2702 002a 25        		.byte	37
 2703 002b 2E        		.byte	46
 2704 002c 36        		.byte	54
 2705 002d 2D        		.byte	45
 2706 002e 37        		.byte	55
 2707 002f 38        		.byte	56
 2708 0030 27        		.byte	39
 2709 0031 1E        		.byte	30
 2710 0032 1F        		.byte	31
 2711 0033 20        		.byte	32
 2712 0034 21        		.byte	33
 2713 0035 22        		.byte	34
 2714 0036 23        		.byte	35
 2715 0037 24        		.byte	36
 2716 0038 25        		.byte	37
 2717 0039 26        		.byte	38
 2718 003a 33        		.byte	51
 2719 003b 33        		.byte	51
 2720 003c 36        		.byte	54
 2721 003d 2E        		.byte	46
 2722 003e 37        		.byte	55
 2723 003f 38        		.byte	56
 2724 0040 1F        		.byte	31
 2725 0041 04        		.byte	4
 2726 0042 05        		.byte	5
 2727 0043 06        		.byte	6
 2728 0044 07        		.byte	7
 2729 0045 08        		.byte	8
 2730 0046 09        		.byte	9
 2731 0047 0A        		.byte	10
 2732 0048 0B        		.byte	11
 2733 0049 0C        		.byte	12
 2734 004a 0D        		.byte	13
 2735 004b 0E        		.byte	14
 2736 004c 0F        		.byte	15
 2737 004d 10        		.byte	16
 2738 004e 11        		.byte	17
 2739 004f 12        		.byte	18
 2740 0050 13        		.byte	19
 2741 0051 14        		.byte	20
 2742 0052 15        		.byte	21
 2743 0053 16        		.byte	22
 2744 0054 17        		.byte	23
 2745 0055 18        		.byte	24
 2746 0056 19        		.byte	25
 2747 0057 1A        		.byte	26
 2748 0058 1B        		.byte	27
 2749 0059 1C        		.byte	28
 2750 005a 1D        		.byte	29
 2751 005b 2F        		.byte	47
 2752 005c 31        		.byte	49
 2753 005d 30        		.byte	48
 2754 005e 23        		.byte	35
 2755 005f 2D        		.byte	45
 2756 0060 35        		.byte	53
 2757 0061 04        		.byte	4
 2758 0062 05        		.byte	5
 2759 0063 06        		.byte	6
 2760 0064 07        		.byte	7
 2761 0065 08        		.byte	8
 2762 0066 09        		.byte	9
 2763 0067 0A        		.byte	10
 2764 0068 0B        		.byte	11
 2765 0069 0C        		.byte	12
 2766 006a 0D        		.byte	13
 2767 006b 0E        		.byte	14
 2768 006c 0F        		.byte	15
 2769 006d 10        		.byte	16
 2770 006e 11        		.byte	17
 2771 006f 12        		.byte	18
 2772 0070 13        		.byte	19
 2773 0071 14        		.byte	20
 2774 0072 15        		.byte	21
 2775 0073 16        		.byte	22
 2776 0074 17        		.byte	23
 2777 0075 18        		.byte	24
 2778 0076 19        		.byte	25
 2779 0077 1A        		.byte	26
 2780 0078 1B        		.byte	27
 2781 0079 1C        		.byte	28
 2782 007a 1D        		.byte	29
 2783 007b 2F        		.byte	47
 2784 007c 31        		.byte	49
 2785 007d 30        		.byte	48
 2786 007e 35        		.byte	53
 2787 007f 4C        		.byte	76
 2788               		.weak	ascii_to_shift_lut
 2789               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2792               	ascii_to_shift_lut:
 2793 0000 00        		.byte	0
 2794 0001 00        		.byte	0
 2795 0002 00        		.byte	0
 2796 0003 00        		.byte	0
 2797 0004 00        		.byte	0
 2798 0005 00        		.byte	0
 2799 0006 00        		.byte	0
 2800 0007 00        		.byte	0
 2801 0008 00        		.byte	0
 2802 0009 00        		.byte	0
 2803 000a 00        		.byte	0
 2804 000b 00        		.byte	0
 2805 000c 00        		.byte	0
 2806 000d 00        		.byte	0
 2807 000e 00        		.byte	0
 2808 000f 00        		.byte	0
 2809 0010 00        		.byte	0
 2810 0011 00        		.byte	0
 2811 0012 00        		.byte	0
 2812 0013 00        		.byte	0
 2813 0014 00        		.byte	0
 2814 0015 00        		.byte	0
 2815 0016 00        		.byte	0
 2816 0017 00        		.byte	0
 2817 0018 00        		.byte	0
 2818 0019 00        		.byte	0
 2819 001a 00        		.byte	0
 2820 001b 00        		.byte	0
 2821 001c 00        		.byte	0
 2822 001d 00        		.byte	0
 2823 001e 00        		.byte	0
 2824 001f 00        		.byte	0
 2825 0020 00        		.byte	0
 2826 0021 01        		.byte	1
 2827 0022 01        		.byte	1
 2828 0023 01        		.byte	1
 2829 0024 01        		.byte	1
 2830 0025 01        		.byte	1
 2831 0026 01        		.byte	1
 2832 0027 00        		.byte	0
 2833 0028 01        		.byte	1
 2834 0029 01        		.byte	1
 2835 002a 01        		.byte	1
 2836 002b 01        		.byte	1
 2837 002c 00        		.byte	0
 2838 002d 00        		.byte	0
 2839 002e 00        		.byte	0
 2840 002f 00        		.byte	0
 2841 0030 00        		.byte	0
 2842 0031 00        		.byte	0
 2843 0032 00        		.byte	0
 2844 0033 00        		.byte	0
 2845 0034 00        		.byte	0
 2846 0035 00        		.byte	0
 2847 0036 00        		.byte	0
 2848 0037 00        		.byte	0
 2849 0038 00        		.byte	0
 2850 0039 00        		.byte	0
 2851 003a 01        		.byte	1
 2852 003b 00        		.byte	0
 2853 003c 01        		.byte	1
 2854 003d 00        		.byte	0
 2855 003e 01        		.byte	1
 2856 003f 01        		.byte	1
 2857 0040 01        		.byte	1
 2858 0041 01        		.byte	1
 2859 0042 01        		.byte	1
 2860 0043 01        		.byte	1
 2861 0044 01        		.byte	1
 2862 0045 01        		.byte	1
 2863 0046 01        		.byte	1
 2864 0047 01        		.byte	1
 2865 0048 01        		.byte	1
 2866 0049 01        		.byte	1
 2867 004a 01        		.byte	1
 2868 004b 01        		.byte	1
 2869 004c 01        		.byte	1
 2870 004d 01        		.byte	1
 2871 004e 01        		.byte	1
 2872 004f 01        		.byte	1
 2873 0050 01        		.byte	1
 2874 0051 01        		.byte	1
 2875 0052 01        		.byte	1
 2876 0053 01        		.byte	1
 2877 0054 01        		.byte	1
 2878 0055 01        		.byte	1
 2879 0056 01        		.byte	1
 2880 0057 01        		.byte	1
 2881 0058 01        		.byte	1
 2882 0059 01        		.byte	1
 2883 005a 01        		.byte	1
 2884 005b 00        		.byte	0
 2885 005c 00        		.byte	0
 2886 005d 00        		.byte	0
 2887 005e 01        		.byte	1
 2888 005f 01        		.byte	1
 2889 0060 00        		.byte	0
 2890 0061 00        		.byte	0
 2891 0062 00        		.byte	0
 2892 0063 00        		.byte	0
 2893 0064 00        		.byte	0
 2894 0065 00        		.byte	0
 2895 0066 00        		.byte	0
 2896 0067 00        		.byte	0
 2897 0068 00        		.byte	0
 2898 0069 00        		.byte	0
 2899 006a 00        		.byte	0
 2900 006b 00        		.byte	0
 2901 006c 00        		.byte	0
 2902 006d 00        		.byte	0
 2903 006e 00        		.byte	0
 2904 006f 00        		.byte	0
 2905 0070 00        		.byte	0
 2906 0071 00        		.byte	0
 2907 0072 00        		.byte	0
 2908 0073 00        		.byte	0
 2909 0074 00        		.byte	0
 2910 0075 00        		.byte	0
 2911 0076 00        		.byte	0
 2912 0077 00        		.byte	0
 2913 0078 00        		.byte	0
 2914 0079 00        		.byte	0
 2915 007a 00        		.byte	0
 2916 007b 01        		.byte	1
 2917 007c 01        		.byte	1
 2918 007d 01        		.byte	1
 2919 007e 01        		.byte	1
 2920 007f 00        		.byte	0
 2921               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2924               	grave_esc_was_shifted:
 2925 0000 00        		.zero	1
 2926               		.section	.bss.scs_timer,"aw",@nobits
 2929               	scs_timer:
 2930 0000 0000 0000 		.zero	4
 2931               		.section	.bss.shift_interrupted,"aw",@nobits
 2934               	shift_interrupted:
 2935 0000 0000      		.zero	2
 2936               		.text
 2937               	.Letext0:
 2938               		.file 4 "/usr/lib/avr/include/stdint.h"
 2939               		.file 5 "./tmk_core/common/keyboard.h"
 2940               		.file 6 "./tmk_core/common/action.h"
 2941               		.file 7 "./tmk_core/common/report.h"
 2942               		.file 8 "./tmk_core/common/debug.h"
 2943               		.file 9 "quantum/keycode_config.h"
 2944               		.file 10 "./tmk_core/common/keycode.h"
 2945               		.file 11 "quantum/quantum_keycodes.h"
 2946               		.file 12 "./tmk_core/protocol/lufa/outputselect.h"
 2947               		.file 13 "./lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2948               		.file 14 "quantum/quantum.h"
 2949               		.file 15 "./tmk_core/common/bootloader.h"
 2950               		.file 16 "quantum/rgblight.h"
 2951               		.file 17 "./tmk_core/common/action_layer.h"
 2952               		.file 18 "quantum/keymap.h"
 2953               		.file 19 "./quantum/process_keycode/process_leader.h"
 2954               		.file 20 "./tmk_core/common/eeconfig.h"
 2955               		.file 21 "./tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/ccH7VlEW.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccH7VlEW.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccH7VlEW.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccH7VlEW.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccH7VlEW.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccH7VlEW.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/ccH7VlEW.s:130    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
     /tmp/ccH7VlEW.s:160    .text.qk_register_mods:0000000000000000 qk_register_mods
     /tmp/ccH7VlEW.s:190    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
     /tmp/ccH7VlEW.s:220    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
     /tmp/ccH7VlEW.s:251    .text.register_code16:0000000000000000 register_code16
     /tmp/ccH7VlEW.s:307    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/ccH7VlEW.s:362    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/ccH7VlEW.s:381    .text.process_record_user:0000000000000000 process_record_user
     /tmp/ccH7VlEW.s:400    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/ccH7VlEW.s:418    .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/ccH7VlEW.s:453    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccH7VlEW.s:2934   .bss.shift_interrupted:0000000000000000 shift_interrupted
     /tmp/ccH7VlEW.s:2924   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted
     /tmp/ccH7VlEW.s:2929   .bss.scs_timer:0000000000000000 scs_timer
     /tmp/ccH7VlEW.s:1411   .text.send_char:0000000000000000 send_char
     /tmp/ccH7VlEW.s:2659   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
     /tmp/ccH7VlEW.s:2792   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
     /tmp/ccH7VlEW.s:1497   .text.send_string_with_delay:0000000000000000 send_string_with_delay
     /tmp/ccH7VlEW.s:1641   .text.send_string:0000000000000000 send_string
     /tmp/ccH7VlEW.s:1660   .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
     /tmp/ccH7VlEW.s:1836   .text.send_string_P:0000000000000000 send_string_P
     /tmp/ccH7VlEW.s:1855   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/ccH7VlEW.s:1903   .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
     /tmp/ccH7VlEW.s:2088   .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/ccH7VlEW.s:2127   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/ccH7VlEW.s:2249   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccH7VlEW.s:2266   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccH7VlEW.s:2283   .text.backlight_init_ports:0000000000000000 backlight_init_ports
     /tmp/ccH7VlEW.s:2298   .text.backlight_set:0000000000000000 backlight_set
     /tmp/ccH7VlEW.s:2314   .text.send_nibble:0000000000000000 send_nibble
     /tmp/ccH7VlEW.s:2379   .text.send_byte:0000000000000000 send_byte
     /tmp/ccH7VlEW.s:2416   .text.send_word:0000000000000000 send_word
     /tmp/ccH7VlEW.s:2450   .text.send_dword:0000000000000000 send_dword
     /tmp/ccH7VlEW.s:2500   .text.hex_to_keycode:0000000000000000 hex_to_keycode
     /tmp/ccH7VlEW.s:2539   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/ccH7VlEW.s:2555   .text.led_set_user:0000000000000000 led_set_user
     /tmp/ccH7VlEW.s:2571   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/ccH7VlEW.s:2589   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/ccH7VlEW.s:2604   .text.led_set:0000000000000000 led_set
     /tmp/ccH7VlEW.s:2622   .text.startup_user:0000000000000000 startup_user
     /tmp/ccH7VlEW.s:2637   .text.shutdown_user:0000000000000000 shutdown_user
     /tmp/ccH7VlEW.s:2653   .bss.rgb_matrix_task_counter:0000000000000000 rgb_matrix_task_counter

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
clear_keyboard
bootloader_jump
layer_switch_get_layer
keymap_key_to_keycode
process_leader
rgblight_increase_speed
get_mods
rgblight_step_reverse
rgblight_step
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
debug_config
keyboard_report
add_key_to_report
del_key_from_report
rgblight_toggle
rgblight_increase_sat
rgblight_increase_hue
rgblight_decrease_hue
rgblight_increase_val
rgblight_decrease_sat
rgblight_decrease_val
rgblight_get_mode
rgblight_mode
rgblight_decrease_speed
timer_read
register_mods
timer_elapsed
unregister_mods
set_output
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_init_kb
matrix_scan_kb
__do_clear_bss
