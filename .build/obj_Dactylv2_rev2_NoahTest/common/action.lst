   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "./tmk_core/common/action.c"
   1:./tmk_core/common/action.c **** /*
   2:./tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action.c **** 
   4:./tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action.c **** (at your option) any later version.
   8:./tmk_core/common/action.c **** 
   9:./tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action.c **** GNU General Public License for more details.
  13:./tmk_core/common/action.c **** 
  14:./tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action.c **** */
  17:./tmk_core/common/action.c **** #include "host.h"
  18:./tmk_core/common/action.c **** #include "keycode.h"
  19:./tmk_core/common/action.c **** #include "keyboard.h"
  20:./tmk_core/common/action.c **** #include "mousekey.h"
  21:./tmk_core/common/action.c **** #include "command.h"
  22:./tmk_core/common/action.c **** #include "led.h"
  23:./tmk_core/common/action.c **** #include "backlight.h"
  24:./tmk_core/common/action.c **** #include "action_layer.h"
  25:./tmk_core/common/action.c **** #include "action_tapping.h"
  26:./tmk_core/common/action.c **** #include "action_macro.h"
  27:./tmk_core/common/action.c **** #include "action_util.h"
  28:./tmk_core/common/action.c **** #include "action.h"
  29:./tmk_core/common/action.c **** #include "wait.h"
  30:./tmk_core/common/action.c **** 
  31:./tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:./tmk_core/common/action.c **** #include "debug.h"
  33:./tmk_core/common/action.c **** #else
  34:./tmk_core/common/action.c **** #include "nodebug.h"
  35:./tmk_core/common/action.c **** #endif
  36:./tmk_core/common/action.c **** 
  37:./tmk_core/common/action.c **** int tp_buttons;
  38:./tmk_core/common/action.c **** 
  39:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:./tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:./tmk_core/common/action.c **** #endif
  42:./tmk_core/common/action.c **** 
  43:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:./tmk_core/common/action.c **** #include <fauxclicky.h>
  45:./tmk_core/common/action.c **** #endif
  46:./tmk_core/common/action.c **** 
  47:./tmk_core/common/action.c **** /** \brief Called to execute an action.
  48:./tmk_core/common/action.c ****  *
  49:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
  50:./tmk_core/common/action.c ****  */
  51:./tmk_core/common/action.c **** void action_exec(keyevent_t event)
  52:./tmk_core/common/action.c **** {
  16               		.loc 1 52 0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  53:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  54:./tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  55:./tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  56:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  57:./tmk_core/common/action.c ****         retro_tapping_counter++;
  58:./tmk_core/common/action.c **** #endif
  59:./tmk_core/common/action.c ****     }
  60:./tmk_core/common/action.c **** 
  61:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  62:./tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  63:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  64:./tmk_core/common/action.c ****     }
  65:./tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  66:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  67:./tmk_core/common/action.c ****     }
  68:./tmk_core/common/action.c ****     fauxclicky_check();
  69:./tmk_core/common/action.c **** #endif
  70:./tmk_core/common/action.c **** 
  71:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  72:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  73:./tmk_core/common/action.c ****         process_hand_swap(&event);
  74:./tmk_core/common/action.c ****     }
  75:./tmk_core/common/action.c **** #endif
  76:./tmk_core/common/action.c **** 
  77:./tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  48               		.loc 1 77 0
  49 001e 1E82      		std Y+6,__zero_reg__
  50 0020 1D82      		std Y+5,__zero_reg__
  51 0022 85E0      		ldi r24,lo8(5)
  52 0024 FE01      		movw r30,r28
  53 0026 3796      		adiw r30,7
  54 0028 DE01      		movw r26,r28
  55 002a 1196      		adiw r26,1
  56               		0:
  57 002c 0190      		ld r0,Z+
  58 002e 0D92      		st X+,r0
  59 0030 8A95      		dec r24
  60 0032 01F4      		brne 0b
  78:./tmk_core/common/action.c **** 
  79:./tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  80:./tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  81:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  82:./tmk_core/common/action.c ****     }
  83:./tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  84:./tmk_core/common/action.c ****         clear_oneshot_mods();
  85:./tmk_core/common/action.c ****     }
  86:./tmk_core/common/action.c **** #endif
  87:./tmk_core/common/action.c **** 
  88:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  89:./tmk_core/common/action.c ****     action_tapping_process(record);
  61               		.loc 1 89 0
  62 0034 4981      		ldd r20,Y+1
  63               	.LVL1:
  64 0036 5A81      		ldd r21,Y+2
  65               	.LVL2:
  66 0038 6B81      		ldd r22,Y+3
  67 003a 7C81      		ldd r23,Y+4
  68 003c 8D81      		ldd r24,Y+5
  69 003e 9E81      		ldd r25,Y+6
  70               	/* epilogue start */
  90:./tmk_core/common/action.c **** #else
  91:./tmk_core/common/action.c ****     process_record(&record);
  92:./tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  93:./tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
  94:./tmk_core/common/action.c ****     }
  95:./tmk_core/common/action.c **** #endif
  96:./tmk_core/common/action.c **** }
  71               		.loc 1 96 0
  72 0040 2B96      		adiw r28,11
  73 0042 0FB6      		in __tmp_reg__,__SREG__
  74 0044 F894      		cli
  75 0046 DEBF      		out __SP_H__,r29
  76 0048 0FBE      		out __SREG__,__tmp_reg__
  77 004a CDBF      		out __SP_L__,r28
  78 004c DF91      		pop r29
  79 004e CF91      		pop r28
  89:./tmk_core/common/action.c **** #else
  80               		.loc 1 89 0
  81 0050 0C94 0000 		jmp action_tapping_process
  82               	.LVL3:
  83               		.cfi_endproc
  84               	.LFE13:
  86               		.section	.text.process_record_quantum,"ax",@progbits
  87               		.weak	process_record_quantum
  89               	process_record_quantum:
  90               	.LFB15:
  97:./tmk_core/common/action.c **** 
  98:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  99:./tmk_core/common/action.c **** bool swap_hands = false;
 100:./tmk_core/common/action.c **** bool swap_held = false;
 101:./tmk_core/common/action.c **** 
 102:./tmk_core/common/action.c **** /** \brief Process Hand Swap
 103:./tmk_core/common/action.c ****  *
 104:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 105:./tmk_core/common/action.c ****  */
 106:./tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 107:./tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 108:./tmk_core/common/action.c **** 
 109:./tmk_core/common/action.c ****     keypos_t pos = event->key;
 110:./tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1<<pos.col;
 111:./tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
 112:./tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 113:./tmk_core/common/action.c **** 
 114:./tmk_core/common/action.c ****     if (do_swap) {
 115:./tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 116:./tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 117:./tmk_core/common/action.c ****     } else {
 118:./tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 119:./tmk_core/common/action.c ****     }
 120:./tmk_core/common/action.c **** }
 121:./tmk_core/common/action.c **** #endif
 122:./tmk_core/common/action.c **** 
 123:./tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 124:./tmk_core/common/action.c **** bool disable_action_cache = false;
 125:./tmk_core/common/action.c **** 
 126:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 127:./tmk_core/common/action.c **** {
 128:./tmk_core/common/action.c ****     disable_action_cache = true;
 129:./tmk_core/common/action.c ****     process_record(record);
 130:./tmk_core/common/action.c ****     disable_action_cache = false;
 131:./tmk_core/common/action.c **** }
 132:./tmk_core/common/action.c **** #else
 133:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 134:./tmk_core/common/action.c **** {
 135:./tmk_core/common/action.c ****     process_record(record);
 136:./tmk_core/common/action.c **** }
 137:./tmk_core/common/action.c **** #endif
 138:./tmk_core/common/action.c **** 
 139:./tmk_core/common/action.c **** __attribute__ ((weak))
 140:./tmk_core/common/action.c **** bool process_record_quantum(keyrecord_t *record) {
  91               		.loc 1 140 0
  92               		.cfi_startproc
  93               	.LVL4:
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
 141:./tmk_core/common/action.c ****     return true;
 142:./tmk_core/common/action.c **** }
  98               		.loc 1 142 0
  99 0000 81E0      		ldi r24,lo8(1)
 100               	.LVL5:
 101               	/* epilogue start */
 102 0002 0895      		ret
 103               		.cfi_endproc
 104               	.LFE15:
 106               		.section	.text.process_record_tap_hint,"ax",@progbits
 107               	.global	process_record_tap_hint
 109               	process_record_tap_hint:
 110               	.LFB16:
 143:./tmk_core/common/action.c **** 
 144:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 145:./tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 146:./tmk_core/common/action.c ****  *
 147:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 148:./tmk_core/common/action.c ****  */
 149:./tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record)
 150:./tmk_core/common/action.c **** {
 111               		.loc 1 150 0
 112               		.cfi_startproc
 113               	.LVL6:
 114               	/* prologue: function */
 115               	/* frame size = 0 */
 116               	/* stack size = 0 */
 117               	.L__stack_usage = 0
 151:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 118               		.loc 1 151 0
 119 0000 FC01      		movw r30,r24
 120 0002 8081      		ld r24,Z
 121 0004 9181      		ldd r25,Z+1
 122               	.LVL7:
 123 0006 0C94 0000 		jmp layer_switch_get_action
 124               	.LVL8:
 125               		.cfi_endproc
 126               	.LFE16:
 128               		.section	.text.register_code,"ax",@progbits
 129               	.global	register_code
 131               	register_code:
 132               	.LFB19:
 152:./tmk_core/common/action.c **** 
 153:./tmk_core/common/action.c ****     switch (action.kind.id) {
 154:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 155:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 156:./tmk_core/common/action.c ****             switch (action.swap.code) {
 157:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 158:./tmk_core/common/action.c ****                 default:
 159:./tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 160:./tmk_core/common/action.c ****                     swap_held = true;
 161:./tmk_core/common/action.c ****             }
 162:./tmk_core/common/action.c ****             break;
 163:./tmk_core/common/action.c **** #endif
 164:./tmk_core/common/action.c ****     }
 165:./tmk_core/common/action.c **** }
 166:./tmk_core/common/action.c **** #endif
 167:./tmk_core/common/action.c **** 
 168:./tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 169:./tmk_core/common/action.c ****  *
 170:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 171:./tmk_core/common/action.c ****  */
 172:./tmk_core/common/action.c **** void process_record(keyrecord_t *record)
 173:./tmk_core/common/action.c **** {
 174:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 175:./tmk_core/common/action.c **** 
 176:./tmk_core/common/action.c ****     if(!process_record_quantum(record))
 177:./tmk_core/common/action.c ****         return;
 178:./tmk_core/common/action.c **** 
 179:./tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 180:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 181:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 182:./tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 183:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 184:./tmk_core/common/action.c **** #endif
 185:./tmk_core/common/action.c ****     dprintln();
 186:./tmk_core/common/action.c **** 
 187:./tmk_core/common/action.c ****     process_action(record, action);
 188:./tmk_core/common/action.c **** }
 189:./tmk_core/common/action.c **** 
 190:./tmk_core/common/action.c **** /** \brief Take an action and processes it.
 191:./tmk_core/common/action.c ****  *
 192:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 193:./tmk_core/common/action.c ****  */
 194:./tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action)
 195:./tmk_core/common/action.c **** {
 196:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 197:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 198:./tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 199:./tmk_core/common/action.c **** #endif
 200:./tmk_core/common/action.c **** 
 201:./tmk_core/common/action.c ****     if (event.pressed) {
 202:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 203:./tmk_core/common/action.c ****         clear_weak_mods();
 204:./tmk_core/common/action.c ****     }
 205:./tmk_core/common/action.c **** 
 206:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 207:./tmk_core/common/action.c ****     bool do_release_oneshot = false;
 208:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 209:./tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 210:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 211:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 212:./tmk_core/common/action.c ****     }
 213:./tmk_core/common/action.c **** #endif
 214:./tmk_core/common/action.c **** 
 215:./tmk_core/common/action.c ****     switch (action.kind.id) {
 216:./tmk_core/common/action.c ****         /* Key and Mods */
 217:./tmk_core/common/action.c ****         case ACT_LMODS:
 218:./tmk_core/common/action.c ****         case ACT_RMODS:
 219:./tmk_core/common/action.c ****             {
 220:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 221:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 222:./tmk_core/common/action.c ****                 if (event.pressed) {
 223:./tmk_core/common/action.c ****                     if (mods) {
 224:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 225:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 226:./tmk_core/common/action.c ****                             // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSF
 227:./tmk_core/common/action.c ****                             // Same applies for some keys like KC_MEH which are declared as MEH(KC_
 228:./tmk_core/common/action.c ****                             add_mods(mods);
 229:./tmk_core/common/action.c ****                         } else {
 230:./tmk_core/common/action.c ****                             add_weak_mods(mods);
 231:./tmk_core/common/action.c ****                         }
 232:./tmk_core/common/action.c ****                         send_keyboard_report();
 233:./tmk_core/common/action.c ****                     }
 234:./tmk_core/common/action.c ****                     register_code(action.key.code);
 235:./tmk_core/common/action.c ****                 } else {
 236:./tmk_core/common/action.c ****                     unregister_code(action.key.code);
 237:./tmk_core/common/action.c ****                     if (mods) {
 238:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 239:./tmk_core/common/action.c ****                             del_mods(mods);
 240:./tmk_core/common/action.c ****                         } else {
 241:./tmk_core/common/action.c ****                             del_weak_mods(mods);
 242:./tmk_core/common/action.c ****                         }
 243:./tmk_core/common/action.c ****                         send_keyboard_report();
 244:./tmk_core/common/action.c ****                     }
 245:./tmk_core/common/action.c ****                 }
 246:./tmk_core/common/action.c ****             }
 247:./tmk_core/common/action.c ****             break;
 248:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 249:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 250:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 251:./tmk_core/common/action.c ****             {
 252:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 253:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 254:./tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 255:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 256:./tmk_core/common/action.c ****                     case MODS_ONESHOT:
 257:./tmk_core/common/action.c ****                         // Oneshot modifier
 258:./tmk_core/common/action.c ****                         if (event.pressed) {
 259:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 260:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 261:./tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 262:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 263:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 264:./tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 265:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 266:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 267:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Toggling oneshot");
 268:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 269:./tmk_core/common/action.c ****                                 set_oneshot_locked_mods(mods);
 270:./tmk_core/common/action.c ****                                 register_mods(mods);
 271:./tmk_core/common/action.c ****                     #endif
 272:./tmk_core/common/action.c ****                             } else {
 273:./tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 274:./tmk_core/common/action.c ****                             }
 275:./tmk_core/common/action.c ****                         } else {
 276:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 277:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 278:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 279:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 280:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 281:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 282:./tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 283:./tmk_core/common/action.c ****                                     clear_oneshot_locked_mods();
 284:./tmk_core/common/action.c ****                                     clear_oneshot_mods();
 285:./tmk_core/common/action.c ****                                     unregister_mods(mods);
 286:./tmk_core/common/action.c ****                                 }
 287:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 288:./tmk_core/common/action.c ****                                 // Toggle Oneshot Layer
 289:./tmk_core/common/action.c ****                     #endif
 290:./tmk_core/common/action.c ****                             } else {
 291:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 292:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 293:./tmk_core/common/action.c ****                             }
 294:./tmk_core/common/action.c ****                         }
 295:./tmk_core/common/action.c ****                         break;
 296:./tmk_core/common/action.c ****     #endif
 297:./tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 298:./tmk_core/common/action.c ****                         if (event.pressed) {
 299:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 300:./tmk_core/common/action.c ****                                 register_mods(mods);
 301:./tmk_core/common/action.c ****                             }
 302:./tmk_core/common/action.c ****                         } else {
 303:./tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 304:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 305:./tmk_core/common/action.c ****                             }
 306:./tmk_core/common/action.c ****                         }
 307:./tmk_core/common/action.c ****                         break;
 308:./tmk_core/common/action.c ****                     default:
 309:./tmk_core/common/action.c ****                         if (event.pressed) {
 310:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 311:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 312:./tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 313:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 314:./tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 315:./tmk_core/common/action.c ****                                     record->tap.count = 0;
 316:./tmk_core/common/action.c ****                                     register_mods(mods);
 317:./tmk_core/common/action.c ****                                 } else
 318:./tmk_core/common/action.c **** #endif
 319:./tmk_core/common/action.c ****                                 {
 320:./tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 321:./tmk_core/common/action.c ****                                     register_code(action.key.code);
 322:./tmk_core/common/action.c ****                                 }
 323:./tmk_core/common/action.c ****                             } else {
 324:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 325:./tmk_core/common/action.c ****                                 register_mods(mods);
 326:./tmk_core/common/action.c ****                             }
 327:./tmk_core/common/action.c ****                         } else {
 328:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 329:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 330:./tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 331:./tmk_core/common/action.c ****                             } else {
 332:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 333:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 334:./tmk_core/common/action.c ****                             }
 335:./tmk_core/common/action.c ****                         }
 336:./tmk_core/common/action.c ****                         break;
 337:./tmk_core/common/action.c ****                 }
 338:./tmk_core/common/action.c ****             }
 339:./tmk_core/common/action.c ****             break;
 340:./tmk_core/common/action.c **** #endif
 341:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 342:./tmk_core/common/action.c ****         /* other HID usage */
 343:./tmk_core/common/action.c ****         case ACT_USAGE:
 344:./tmk_core/common/action.c ****             switch (action.usage.page) {
 345:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 346:./tmk_core/common/action.c ****                     if (event.pressed) {
 347:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 348:./tmk_core/common/action.c ****                     } else {
 349:./tmk_core/common/action.c ****                         host_system_send(0);
 350:./tmk_core/common/action.c ****                     }
 351:./tmk_core/common/action.c ****                     break;
 352:./tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 353:./tmk_core/common/action.c ****                     if (event.pressed) {
 354:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 355:./tmk_core/common/action.c ****                     } else {
 356:./tmk_core/common/action.c ****                         host_consumer_send(0);
 357:./tmk_core/common/action.c ****                     }
 358:./tmk_core/common/action.c ****                     break;
 359:./tmk_core/common/action.c ****             }
 360:./tmk_core/common/action.c ****             break;
 361:./tmk_core/common/action.c **** #endif
 362:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 363:./tmk_core/common/action.c ****         /* Mouse key */
 364:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 365:./tmk_core/common/action.c ****             if (event.pressed) {
 366:./tmk_core/common/action.c ****                 switch (action.key.code) {
 367:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 368:./tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 369:./tmk_core/common/action.c ****                         break;
 370:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 371:./tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 372:./tmk_core/common/action.c ****                         break;
 373:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 374:./tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 375:./tmk_core/common/action.c ****                         break;
 376:./tmk_core/common/action.c ****                     default:
 377:./tmk_core/common/action.c ****                         break;
 378:./tmk_core/common/action.c ****                 }
 379:./tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 380:./tmk_core/common/action.c ****                 mousekey_send();
 381:./tmk_core/common/action.c ****             } else {
 382:./tmk_core/common/action.c ****                 switch (action.key.code) {
 383:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 384:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 385:./tmk_core/common/action.c ****                         break;
 386:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 387:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 388:./tmk_core/common/action.c ****                         break;
 389:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 390:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 391:./tmk_core/common/action.c ****                         break;
 392:./tmk_core/common/action.c ****                     default:
 393:./tmk_core/common/action.c ****                         break;
 394:./tmk_core/common/action.c ****                 }
 395:./tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 396:./tmk_core/common/action.c ****                 mousekey_send();
 397:./tmk_core/common/action.c ****             }
 398:./tmk_core/common/action.c ****             break;
 399:./tmk_core/common/action.c **** #endif
 400:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 401:./tmk_core/common/action.c ****         case ACT_LAYER:
 402:./tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 403:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 404:./tmk_core/common/action.c ****                 if (!event.pressed) {
 405:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 406:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 407:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 408:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 409:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 410:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 411:./tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 412:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 413:./tmk_core/common/action.c ****                     }
 414:./tmk_core/common/action.c ****                 }
 415:./tmk_core/common/action.c ****             } else {
 416:./tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 417:./tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 418:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 419:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 420:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 421:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 422:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 423:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 424:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 425:./tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 426:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 427:./tmk_core/common/action.c ****                     }
 428:./tmk_core/common/action.c ****                 }
 429:./tmk_core/common/action.c ****             }
 430:./tmk_core/common/action.c ****             break;
 431:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 432:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 433:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 434:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 435:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 436:./tmk_core/common/action.c ****                     /* layer On/Off with modifiers(left only) */
 437:./tmk_core/common/action.c ****                     if (event.pressed) {
 438:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 439:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 440:./tmk_core/common/action.c ****                     } else {
 441:./tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 442:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 443:./tmk_core/common/action.c ****                     }
 444:./tmk_core/common/action.c ****                     break;
 445:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 446:./tmk_core/common/action.c ****                     /* tap toggle */
 447:./tmk_core/common/action.c ****                     if (event.pressed) {
 448:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 449:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 450:./tmk_core/common/action.c ****                         }
 451:./tmk_core/common/action.c ****                     } else {
 452:./tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 453:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 454:./tmk_core/common/action.c ****                         }
 455:./tmk_core/common/action.c ****                     }
 456:./tmk_core/common/action.c ****                     break;
 457:./tmk_core/common/action.c ****                 case OP_ON_OFF:
 458:./tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 459:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 460:./tmk_core/common/action.c ****                     break;
 461:./tmk_core/common/action.c ****                 case OP_OFF_ON:
 462:./tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 463:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 464:./tmk_core/common/action.c ****                     break;
 465:./tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 466:./tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 467:./tmk_core/common/action.c ****                                     layer_clear();
 468:./tmk_core/common/action.c ****                     break;
 469:./tmk_core/common/action.c ****             #ifndef NO_ACTION_ONESHOT
 470:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 471:./tmk_core/common/action.c ****                     // Oneshot modifier
 472:./tmk_core/common/action.c ****                 #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 473:./tmk_core/common/action.c ****                     do_release_oneshot = false;
 474:./tmk_core/common/action.c ****                     if (event.pressed) {
 475:./tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 476:./tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 477:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 478:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 479:./tmk_core/common/action.c ****                             break;
 480:./tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 481:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 482:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 483:./tmk_core/common/action.c ****                         }
 484:./tmk_core/common/action.c ****                     } else {
 485:./tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 486:./tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 487:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 488:./tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 489:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 490:./tmk_core/common/action.c ****                         } else {
 491:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 492:./tmk_core/common/action.c ****                         }
 493:./tmk_core/common/action.c ****                     }
 494:./tmk_core/common/action.c ****                 #else
 495:./tmk_core/common/action.c ****                     if (event.pressed) {
 496:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 497:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 498:./tmk_core/common/action.c ****                     } else {
 499:./tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 500:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 501:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 502:./tmk_core/common/action.c ****                         }
 503:./tmk_core/common/action.c ****                     }
 504:./tmk_core/common/action.c ****                 #endif
 505:./tmk_core/common/action.c ****                     break;
 506:./tmk_core/common/action.c ****             #endif
 507:./tmk_core/common/action.c ****                 default:
 508:./tmk_core/common/action.c ****                     /* tap key */
 509:./tmk_core/common/action.c ****                     if (event.pressed) {
 510:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 511:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 512:./tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 513:./tmk_core/common/action.c ****                         } else {
 514:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 515:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 516:./tmk_core/common/action.c ****                         }
 517:./tmk_core/common/action.c ****                     } else {
 518:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 519:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 520:./tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 521:./tmk_core/common/action.c ****                                 wait_ms(80);
 522:./tmk_core/common/action.c ****                             }
 523:./tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 524:./tmk_core/common/action.c ****                         } else {
 525:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 526:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 527:./tmk_core/common/action.c ****                         }
 528:./tmk_core/common/action.c ****                     }
 529:./tmk_core/common/action.c ****                     break;
 530:./tmk_core/common/action.c ****             }
 531:./tmk_core/common/action.c ****             break;
 532:./tmk_core/common/action.c ****     #endif
 533:./tmk_core/common/action.c **** #endif
 534:./tmk_core/common/action.c ****         /* Extentions */
 535:./tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 536:./tmk_core/common/action.c ****         case ACT_MACRO:
 537:./tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 538:./tmk_core/common/action.c ****             break;
 539:./tmk_core/common/action.c **** #endif
 540:./tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
 541:./tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 542:./tmk_core/common/action.c ****             if (!event.pressed) {
 543:./tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 544:./tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 545:./tmk_core/common/action.c ****                         backlight_increase();
 546:./tmk_core/common/action.c ****                         break;
 547:./tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 548:./tmk_core/common/action.c ****                         backlight_decrease();
 549:./tmk_core/common/action.c ****                         break;
 550:./tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 551:./tmk_core/common/action.c ****                         backlight_toggle();
 552:./tmk_core/common/action.c ****                         break;
 553:./tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 554:./tmk_core/common/action.c ****                         backlight_step();
 555:./tmk_core/common/action.c ****                         break;
 556:./tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 557:./tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 558:./tmk_core/common/action.c ****                         break;
 559:./tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 560:./tmk_core/common/action.c ****                         backlight_level(0);
 561:./tmk_core/common/action.c ****                         break;
 562:./tmk_core/common/action.c ****                 }
 563:./tmk_core/common/action.c ****             }
 564:./tmk_core/common/action.c ****             break;
 565:./tmk_core/common/action.c **** #endif
 566:./tmk_core/common/action.c ****         case ACT_COMMAND:
 567:./tmk_core/common/action.c ****             break;
 568:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 569:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 570:./tmk_core/common/action.c ****             switch (action.swap.code) {
 571:./tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 572:./tmk_core/common/action.c ****                     if (event.pressed) {
 573:./tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 574:./tmk_core/common/action.c ****                     }
 575:./tmk_core/common/action.c ****                     break;
 576:./tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 577:./tmk_core/common/action.c ****                     swap_hands = event.pressed;
 578:./tmk_core/common/action.c ****                     break;
 579:./tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 580:./tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 581:./tmk_core/common/action.c ****                     break;
 582:./tmk_core/common/action.c ****                 case OP_SH_ON:
 583:./tmk_core/common/action.c ****                     if (!event.pressed) {
 584:./tmk_core/common/action.c ****                         swap_hands = true;
 585:./tmk_core/common/action.c ****                     }
 586:./tmk_core/common/action.c ****                     break;
 587:./tmk_core/common/action.c ****                 case OP_SH_OFF:
 588:./tmk_core/common/action.c ****                     if (!event.pressed) {
 589:./tmk_core/common/action.c ****                         swap_hands = false;
 590:./tmk_core/common/action.c ****                     }
 591:./tmk_core/common/action.c ****                     break;
 592:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 593:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 594:./tmk_core/common/action.c ****                     /* tap toggle */
 595:./tmk_core/common/action.c **** 
 596:./tmk_core/common/action.c ****                     if (event.pressed) {
 597:./tmk_core/common/action.c ****                         if (swap_held) {
 598:./tmk_core/common/action.c ****                             swap_held = false;
 599:./tmk_core/common/action.c ****                         } else {
 600:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 601:./tmk_core/common/action.c ****                         }
 602:./tmk_core/common/action.c ****                     } else {
 603:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 604:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 605:./tmk_core/common/action.c ****                         }
 606:./tmk_core/common/action.c ****                     }
 607:./tmk_core/common/action.c ****                     break;
 608:./tmk_core/common/action.c ****                 default:
 609:./tmk_core/common/action.c ****                     /* tap key */
 610:./tmk_core/common/action.c ****                     if (tap_count > 0) {
 611:./tmk_core/common/action.c ****                         if (swap_held) {
 612:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 613:./tmk_core/common/action.c ****                             swap_held = false;
 614:./tmk_core/common/action.c ****                         }
 615:./tmk_core/common/action.c ****                         if (event.pressed) {
 616:./tmk_core/common/action.c ****                             register_code(action.swap.code);
 617:./tmk_core/common/action.c ****                         } else {
 618:./tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 619:./tmk_core/common/action.c ****                             *record = (keyrecord_t){}; // hack: reset tap mode
 620:./tmk_core/common/action.c ****                         }
 621:./tmk_core/common/action.c ****                     } else {
 622:./tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 623:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 624:./tmk_core/common/action.c ****                             swap_held = false;
 625:./tmk_core/common/action.c ****                         }
 626:./tmk_core/common/action.c ****                     }
 627:./tmk_core/common/action.c ****     #endif
 628:./tmk_core/common/action.c ****             }
 629:./tmk_core/common/action.c **** #endif
 630:./tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 631:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 632:./tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 633:./tmk_core/common/action.c ****             break;
 634:./tmk_core/common/action.c **** #endif
 635:./tmk_core/common/action.c ****         default:
 636:./tmk_core/common/action.c ****             break;
 637:./tmk_core/common/action.c ****     }
 638:./tmk_core/common/action.c **** 
 639:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 640:./tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 641:./tmk_core/common/action.c ****     switch (action.kind.id) {
 642:./tmk_core/common/action.c ****         case ACT_LAYER:
 643:./tmk_core/common/action.c ****         #ifndef NO_ACTION_TAPPING
 644:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 645:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 646:./tmk_core/common/action.c ****         #endif
 647:./tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 648:./tmk_core/common/action.c ****             break;
 649:./tmk_core/common/action.c ****         default:
 650:./tmk_core/common/action.c ****             break;
 651:./tmk_core/common/action.c ****     }
 652:./tmk_core/common/action.c **** #endif
 653:./tmk_core/common/action.c **** 
 654:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 655:./tmk_core/common/action.c ****   #ifdef RETRO_TAPPING
 656:./tmk_core/common/action.c ****   if (!is_tap_key(record->event.key)) {
 657:./tmk_core/common/action.c ****     retro_tapping_counter = 0;
 658:./tmk_core/common/action.c ****   } else {
 659:./tmk_core/common/action.c ****     if (event.pressed) {
 660:./tmk_core/common/action.c ****         if (tap_count > 0) {
 661:./tmk_core/common/action.c ****           retro_tapping_counter = 0;
 662:./tmk_core/common/action.c ****         } else {
 663:./tmk_core/common/action.c **** 
 664:./tmk_core/common/action.c ****         }
 665:./tmk_core/common/action.c ****     } else {
 666:./tmk_core/common/action.c ****       if (tap_count > 0) {
 667:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 668:./tmk_core/common/action.c ****       } else {
 669:./tmk_core/common/action.c ****         if (retro_tapping_counter == 2) {
 670:./tmk_core/common/action.c ****           register_code(action.layer_tap.code);
 671:./tmk_core/common/action.c ****           unregister_code(action.layer_tap.code);
 672:./tmk_core/common/action.c ****         }
 673:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 674:./tmk_core/common/action.c ****       }
 675:./tmk_core/common/action.c ****     }
 676:./tmk_core/common/action.c ****   }
 677:./tmk_core/common/action.c ****   #endif
 678:./tmk_core/common/action.c **** #endif
 679:./tmk_core/common/action.c **** 
 680:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 681:./tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 682:./tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 683:./tmk_core/common/action.c ****      */
 684:./tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 685:./tmk_core/common/action.c ****         record->event.pressed = false;
 686:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 687:./tmk_core/common/action.c ****         process_record(record);
 688:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 689:./tmk_core/common/action.c ****     }
 690:./tmk_core/common/action.c **** #endif
 691:./tmk_core/common/action.c **** }
 692:./tmk_core/common/action.c **** 
 693:./tmk_core/common/action.c **** 
 694:./tmk_core/common/action.c **** 
 695:./tmk_core/common/action.c **** 
 696:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 697:./tmk_core/common/action.c ****  *
 698:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 699:./tmk_core/common/action.c ****  */
 700:./tmk_core/common/action.c **** void register_code(uint8_t code)
 701:./tmk_core/common/action.c **** {
 133               		.loc 1 701 0
 134               		.cfi_startproc
 135               	.LVL9:
 136 0000 CF93      		push r28
 137               	.LCFI4:
 138               		.cfi_def_cfa_offset 3
 139               		.cfi_offset 28, -2
 140               	/* prologue: function */
 141               	/* frame size = 0 */
 142               	/* stack size = 1 */
 143               	.L__stack_usage = 1
 144 0002 C82F      		mov r28,r24
 702:./tmk_core/common/action.c ****     if (code == KC_NO) {
 145               		.loc 1 702 0
 146 0004 8823      		tst r24
 147 0006 01F4      		brne .+2
 148 0008 00C0      		rjmp .L4
 703:./tmk_core/common/action.c ****         return;
 704:./tmk_core/common/action.c ****     }
 705:./tmk_core/common/action.c **** 
 706:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 707:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 149               		.loc 1 707 0
 150 000a 8238      		cpi r24,lo8(-126)
 151 000c 01F4      		brne .L7
 708:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 709:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 710:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 152               		.loc 1 710 0
 153 000e 0E94 0000 		call host_keyboard_leds
 154               	.LVL10:
 155 0012 81FD      		sbrc r24,1
 156 0014 00C0      		rjmp .L4
 711:./tmk_core/common/action.c **** #endif
 712:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 157               		.loc 1 712 0
 158 0016 89E3      		ldi r24,lo8(57)
 159 0018 0E94 0000 		call add_key
 160               	.LVL11:
 713:./tmk_core/common/action.c ****         send_keyboard_report();
 161               		.loc 1 713 0
 162 001c 0E94 0000 		call send_keyboard_report
 163               	.LVL12:
 164               	.LBB14:
 165               	.LBB15:
 166               		.file 2 "/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 167               		.loc 2 187 0
 168 0020 2FEF      		ldi r18,lo8(319999)
 169 0022 81EE      		ldi r24,hi8(319999)
 170 0024 94E0      		ldi r25,hlo8(319999)
 171 0026 2150      	1:	subi r18,1
 172 0028 8040      		sbci r24,0
 173 002a 9040      		sbci r25,0
 174 002c 01F4      		brne 1b
 175 002e 00C0      		rjmp .
 176 0030 0000      		nop
 177               	.LVL13:
 178               	.LBE15:
 179               	.LBE14:
 714:./tmk_core/common/action.c ****         wait_ms(100);
 715:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 180               		.loc 1 715 0
 181 0032 89E3      		ldi r24,lo8(57)
 182               	.L39:
 716:./tmk_core/common/action.c ****         send_keyboard_report();
 717:./tmk_core/common/action.c ****     }
 718:./tmk_core/common/action.c **** 
 719:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 720:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 721:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 722:./tmk_core/common/action.c **** #endif
 723:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 724:./tmk_core/common/action.c ****         send_keyboard_report();
 725:./tmk_core/common/action.c ****         wait_ms(100);
 726:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 183               		.loc 1 726 0
 184 0034 0E94 0000 		call del_key
 185               	.LVL14:
 186               	.L40:
 187               	/* epilogue start */
 727:./tmk_core/common/action.c ****         send_keyboard_report();
 728:./tmk_core/common/action.c ****     }
 729:./tmk_core/common/action.c **** 
 730:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 731:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 732:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 733:./tmk_core/common/action.c **** #endif
 734:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 735:./tmk_core/common/action.c ****         send_keyboard_report();
 736:./tmk_core/common/action.c ****         wait_ms(100);
 737:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 738:./tmk_core/common/action.c ****         send_keyboard_report();
 739:./tmk_core/common/action.c ****     }
 740:./tmk_core/common/action.c **** #endif
 741:./tmk_core/common/action.c **** 
 742:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 743:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 744:./tmk_core/common/action.c ****         if (command_proc(code)) return;
 745:./tmk_core/common/action.c **** 
 746:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 747:./tmk_core/common/action.c **** /* TODO: remove
 748:./tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 749:./tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 750:./tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 751:./tmk_core/common/action.c **** 
 752:./tmk_core/common/action.c ****             add_key(code);
 753:./tmk_core/common/action.c ****             send_keyboard_report();
 754:./tmk_core/common/action.c **** 
 755:./tmk_core/common/action.c ****             set_mods(tmp_mods);
 756:./tmk_core/common/action.c ****             send_keyboard_report();
 757:./tmk_core/common/action.c ****             oneshot_cancel();
 758:./tmk_core/common/action.c ****         } else
 759:./tmk_core/common/action.c **** */
 760:./tmk_core/common/action.c **** #endif
 761:./tmk_core/common/action.c ****         {
 762:./tmk_core/common/action.c ****             add_key(code);
 763:./tmk_core/common/action.c ****             send_keyboard_report();
 764:./tmk_core/common/action.c ****         }
 765:./tmk_core/common/action.c ****     }
 766:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 767:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 768:./tmk_core/common/action.c ****         send_keyboard_report();
 769:./tmk_core/common/action.c ****     }
 770:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 771:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 772:./tmk_core/common/action.c ****     }
 773:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 775:./tmk_core/common/action.c ****     }
 776:./tmk_core/common/action.c **** }
 188               		.loc 1 776 0
 189 0038 CF91      		pop r28
 727:./tmk_core/common/action.c ****         send_keyboard_report();
 190               		.loc 1 727 0
 191 003a 0C94 0000 		jmp send_keyboard_report
 192               	.LVL15:
 193               	.L7:
 719:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 194               		.loc 1 719 0
 195 003e 8338      		cpi r24,lo8(-125)
 196 0040 01F4      		brne .L9
 721:./tmk_core/common/action.c **** #endif
 197               		.loc 1 721 0
 198 0042 0E94 0000 		call host_keyboard_leds
 199               	.LVL16:
 200 0046 80FD      		sbrc r24,0
 201 0048 00C0      		rjmp .L4
 723:./tmk_core/common/action.c ****         send_keyboard_report();
 202               		.loc 1 723 0
 203 004a 83E5      		ldi r24,lo8(83)
 204 004c 0E94 0000 		call add_key
 205               	.LVL17:
 724:./tmk_core/common/action.c ****         wait_ms(100);
 206               		.loc 1 724 0
 207 0050 0E94 0000 		call send_keyboard_report
 208               	.LVL18:
 209               	.LBB16:
 210               	.LBB17:
 211               		.loc 2 187 0
 212 0054 2FEF      		ldi r18,lo8(319999)
 213 0056 81EE      		ldi r24,hi8(319999)
 214 0058 94E0      		ldi r25,hlo8(319999)
 215 005a 2150      	1:	subi r18,1
 216 005c 8040      		sbci r24,0
 217 005e 9040      		sbci r25,0
 218 0060 01F4      		brne 1b
 219 0062 00C0      		rjmp .
 220 0064 0000      		nop
 221               	.LVL19:
 222               	.LBE17:
 223               	.LBE16:
 726:./tmk_core/common/action.c ****         send_keyboard_report();
 224               		.loc 1 726 0
 225 0066 83E5      		ldi r24,lo8(83)
 226 0068 00C0      		rjmp .L39
 227               	.LVL20:
 228               	.L9:
 730:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 229               		.loc 1 730 0
 230 006a 8438      		cpi r24,lo8(-124)
 231 006c 01F4      		brne .L10
 732:./tmk_core/common/action.c **** #endif
 232               		.loc 1 732 0
 233 006e 0E94 0000 		call host_keyboard_leds
 234               	.LVL21:
 235 0072 82FD      		sbrc r24,2
 236 0074 00C0      		rjmp .L4
 734:./tmk_core/common/action.c ****         send_keyboard_report();
 237               		.loc 1 734 0
 238 0076 87E4      		ldi r24,lo8(71)
 239 0078 0E94 0000 		call add_key
 240               	.LVL22:
 735:./tmk_core/common/action.c ****         wait_ms(100);
 241               		.loc 1 735 0
 242 007c 0E94 0000 		call send_keyboard_report
 243               	.LVL23:
 244               	.LBB18:
 245               	.LBB19:
 246               		.loc 2 187 0
 247 0080 2FEF      		ldi r18,lo8(319999)
 248 0082 81EE      		ldi r24,hi8(319999)
 249 0084 94E0      		ldi r25,hlo8(319999)
 250 0086 2150      	1:	subi r18,1
 251 0088 8040      		sbci r24,0
 252 008a 9040      		sbci r25,0
 253 008c 01F4      		brne 1b
 254 008e 00C0      		rjmp .
 255 0090 0000      		nop
 256               	.LVL24:
 257               	.LBE19:
 258               	.LBE18:
 737:./tmk_core/common/action.c ****         send_keyboard_report();
 259               		.loc 1 737 0
 260 0092 87E4      		ldi r24,lo8(71)
 261 0094 00C0      		rjmp .L39
 262               	.LVL25:
 263               	.L10:
 742:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 264               		.loc 1 742 0
 265 0096 8CEF      		ldi r24,lo8(-4)
 266               	.LVL26:
 267 0098 8C0F      		add r24,r28
 268 009a 813A      		cpi r24,lo8(-95)
 269 009c 00F4      		brsh .L11
 744:./tmk_core/common/action.c **** 
 270               		.loc 1 744 0
 271 009e 8C2F      		mov r24,r28
 272 00a0 0E94 0000 		call command_proc
 273               	.LVL27:
 274 00a4 8111      		cpse r24,__zero_reg__
 275 00a6 00C0      		rjmp .L4
 762:./tmk_core/common/action.c ****             send_keyboard_report();
 276               		.loc 1 762 0
 277 00a8 8C2F      		mov r24,r28
 278 00aa 0E94 0000 		call add_key
 279               	.LVL28:
 280 00ae 00C0      		rjmp .L40
 281               	.L11:
 766:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 282               		.loc 1 766 0
 283 00b0 80E2      		ldi r24,lo8(32)
 284 00b2 8C0F      		add r24,r28
 285 00b4 8830      		cpi r24,lo8(8)
 286 00b6 00F4      		brsh .L12
 767:./tmk_core/common/action.c ****         send_keyboard_report();
 287               		.loc 1 767 0
 288 00b8 C770      		andi r28,lo8(7)
 289               	.LVL29:
 290 00ba 81E0      		ldi r24,lo8(1)
 291 00bc 00C0      		rjmp 2f
 292               		1:
 293 00be 880F      		lsl r24
 294               		2:
 295 00c0 CA95      		dec r28
 296 00c2 02F4      		brpl 1b
 297 00c4 0E94 0000 		call add_mods
 298               	.LVL30:
 299 00c8 00C0      		rjmp .L40
 300               	.LVL31:
 301               	.L12:
 770:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 302               		.loc 1 770 0
 303 00ca 8BE5      		ldi r24,lo8(91)
 304 00cc 8C0F      		add r24,r28
 305 00ce 8330      		cpi r24,lo8(3)
 306 00d0 00F4      		brsh .L13
 771:./tmk_core/common/action.c ****     }
 307               		.loc 1 771 0
 308 00d2 81E8      		ldi r24,lo8(-127)
 309 00d4 90E0      		ldi r25,0
 310 00d6 C53A      		cpi r28,lo8(-91)
 311 00d8 01F0      		breq .L14
 771:./tmk_core/common/action.c ****     }
 312               		.loc 1 771 0 is_stmt 0 discriminator 1
 313 00da 83E8      		ldi r24,lo8(-125)
 314 00dc 90E0      		ldi r25,0
 315 00de C63A      		cpi r28,lo8(-90)
 316 00e0 01F4      		brne .L14
 771:./tmk_core/common/action.c ****     }
 317               		.loc 1 771 0
 318 00e2 82E8      		ldi r24,lo8(-126)
 319 00e4 90E0      		ldi r25,0
 320               	.L14:
 321               	/* epilogue start */
 322               		.loc 1 776 0 is_stmt 1 discriminator 12
 323 00e6 CF91      		pop r28
 324               	.LVL32:
 771:./tmk_core/common/action.c ****     }
 325               		.loc 1 771 0 discriminator 12
 326 00e8 0C94 0000 		jmp host_system_send
 327               	.LVL33:
 328               	.L13:
 773:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 329               		.loc 1 773 0
 330 00ec 88E5      		ldi r24,lo8(88)
 331 00ee 8C0F      		add r24,r28
 332 00f0 8531      		cpi r24,lo8(21)
 333 00f2 00F0      		brlo .+2
 334 00f4 00C0      		rjmp .L4
 774:./tmk_core/common/action.c ****     }
 335               		.loc 1 774 0
 336 00f6 82EE      		ldi r24,lo8(-30)
 337 00f8 90E0      		ldi r25,0
 338 00fa C83A      		cpi r28,lo8(-88)
 339 00fc 01F4      		brne .+2
 340 00fe 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 341               		.loc 1 774 0 is_stmt 0 discriminator 1
 342 0100 89EE      		ldi r24,lo8(-23)
 343 0102 90E0      		ldi r25,0
 344 0104 C93A      		cpi r28,lo8(-87)
 345 0106 01F4      		brne .+2
 346 0108 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 347               		.loc 1 774 0 discriminator 3
 348 010a 8AEE      		ldi r24,lo8(-22)
 349 010c 90E0      		ldi r25,0
 350 010e CA3A      		cpi r28,lo8(-86)
 351 0110 01F4      		brne .+2
 352 0112 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 353               		.loc 1 774 0 discriminator 5
 354 0114 85EB      		ldi r24,lo8(-75)
 355 0116 90E0      		ldi r25,0
 356 0118 CB3A      		cpi r28,lo8(-85)
 357 011a 01F4      		brne .+2
 358 011c 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 359               		.loc 1 774 0 discriminator 7
 360 011e 86EB      		ldi r24,lo8(-74)
 361 0120 90E0      		ldi r25,0
 362 0122 CC3A      		cpi r28,lo8(-84)
 363 0124 01F4      		brne .+2
 364 0126 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 365               		.loc 1 774 0 discriminator 9
 366 0128 83EB      		ldi r24,lo8(-77)
 367 012a 90E0      		ldi r25,0
 368 012c CB3B      		cpi r28,lo8(-69)
 369 012e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 370               		.loc 1 774 0 discriminator 11
 371 0130 84EB      		ldi r24,lo8(-76)
 372 0132 90E0      		ldi r25,0
 373 0134 CC3B      		cpi r28,lo8(-68)
 374 0136 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 375               		.loc 1 774 0 discriminator 13
 376 0138 87EB      		ldi r24,lo8(-73)
 377 013a 90E0      		ldi r25,0
 378 013c CD3A      		cpi r28,lo8(-83)
 379 013e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 380               		.loc 1 774 0 discriminator 15
 381 0140 8CEC      		ldi r24,lo8(-52)
 382 0142 90E0      		ldi r25,0
 383 0144 C03B      		cpi r28,lo8(-80)
 384 0146 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 385               		.loc 1 774 0 discriminator 17
 386 0148 8DEC      		ldi r24,lo8(-51)
 387 014a 90E0      		ldi r25,0
 388 014c CE3A      		cpi r28,lo8(-82)
 389 014e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 390               		.loc 1 774 0 discriminator 19
 391 0150 83E8      		ldi r24,lo8(-125)
 392 0152 91E0      		ldi r25,lo8(1)
 393 0154 CF3A      		cpi r28,lo8(-81)
 394 0156 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 395               		.loc 1 774 0 discriminator 21
 396 0158 8AE8      		ldi r24,lo8(-118)
 397 015a 91E0      		ldi r25,lo8(1)
 398 015c C13B      		cpi r28,lo8(-79)
 399 015e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 400               		.loc 1 774 0 discriminator 23
 401 0160 82E9      		ldi r24,lo8(-110)
 402 0162 91E0      		ldi r25,lo8(1)
 403 0164 C23B      		cpi r28,lo8(-78)
 404 0166 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 405               		.loc 1 774 0 discriminator 25
 406 0168 84E9      		ldi r24,lo8(-108)
 407 016a 91E0      		ldi r25,lo8(1)
 408 016c C33B      		cpi r28,lo8(-77)
 409 016e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 410               		.loc 1 774 0 discriminator 27
 411 0170 81E2      		ldi r24,lo8(33)
 412 0172 92E0      		ldi r25,lo8(2)
 413 0174 C43B      		cpi r28,lo8(-76)
 414 0176 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 415               		.loc 1 774 0 discriminator 29
 416 0178 83E2      		ldi r24,lo8(35)
 417 017a 92E0      		ldi r25,lo8(2)
 418 017c C53B      		cpi r28,lo8(-75)
 419 017e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 420               		.loc 1 774 0 discriminator 31
 421 0180 84E2      		ldi r24,lo8(36)
 422 0182 92E0      		ldi r25,lo8(2)
 423 0184 C63B      		cpi r28,lo8(-74)
 424 0186 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 425               		.loc 1 774 0 discriminator 33
 426 0188 85E2      		ldi r24,lo8(37)
 427 018a 92E0      		ldi r25,lo8(2)
 428 018c C73B      		cpi r28,lo8(-73)
 429 018e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 430               		.loc 1 774 0 discriminator 35
 431 0190 86E2      		ldi r24,lo8(38)
 432 0192 92E0      		ldi r25,lo8(2)
 433 0194 C83B      		cpi r28,lo8(-72)
 434 0196 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 435               		.loc 1 774 0 discriminator 37
 436 0198 87E2      		ldi r24,lo8(39)
 437 019a 92E0      		ldi r25,lo8(2)
 438 019c C93B      		cpi r28,lo8(-71)
 439 019e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 440               		.loc 1 774 0 discriminator 39
 441 01a0 90E0      		ldi r25,0
 442 01a2 80E0      		ldi r24,0
 443 01a4 CA3B      		cpi r28,lo8(-70)
 444 01a6 01F4      		brne .L15
 774:./tmk_core/common/action.c ****     }
 445               		.loc 1 774 0
 446 01a8 8AE2      		ldi r24,lo8(42)
 447 01aa 92E0      		ldi r25,lo8(2)
 448               	.L15:
 449               	/* epilogue start */
 450               		.loc 1 776 0 is_stmt 1 discriminator 84
 451 01ac CF91      		pop r28
 452               	.LVL34:
 774:./tmk_core/common/action.c ****     }
 453               		.loc 1 774 0 discriminator 84
 454 01ae 0C94 0000 		jmp host_consumer_send
 455               	.LVL35:
 456               	.L4:
 457               	/* epilogue start */
 458               		.loc 1 776 0
 459 01b2 CF91      		pop r28
 460               	.LVL36:
 461 01b4 0895      		ret
 462               		.cfi_endproc
 463               	.LFE19:
 465               		.section	.text.unregister_code,"ax",@progbits
 466               	.global	unregister_code
 468               	unregister_code:
 469               	.LFB20:
 777:./tmk_core/common/action.c **** 
 778:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 779:./tmk_core/common/action.c ****  *
 780:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 781:./tmk_core/common/action.c ****  */
 782:./tmk_core/common/action.c **** void unregister_code(uint8_t code)
 783:./tmk_core/common/action.c **** {
 470               		.loc 1 783 0
 471               		.cfi_startproc
 472               	.LVL37:
 473               	/* prologue: function */
 474               	/* frame size = 0 */
 475               	/* stack size = 0 */
 476               	.L__stack_usage = 0
 784:./tmk_core/common/action.c ****     if (code == KC_NO) {
 477               		.loc 1 784 0
 478 0000 8823      		tst r24
 479 0002 01F4      		brne .+2
 480 0004 00C0      		rjmp .L41
 785:./tmk_core/common/action.c ****         return;
 786:./tmk_core/common/action.c ****     }
 787:./tmk_core/common/action.c **** 
 788:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 789:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 481               		.loc 1 789 0
 482 0006 8238      		cpi r24,lo8(-126)
 483 0008 01F4      		brne .L44
 790:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 791:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 792:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 484               		.loc 1 792 0
 485 000a 0E94 0000 		call host_keyboard_leds
 486               	.LVL38:
 487 000e 81FF      		sbrs r24,1
 488 0010 00C0      		rjmp .L41
 793:./tmk_core/common/action.c **** #endif
 794:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 489               		.loc 1 794 0
 490 0012 89E3      		ldi r24,lo8(57)
 491 0014 0E94 0000 		call add_key
 492               	.LVL39:
 795:./tmk_core/common/action.c ****         send_keyboard_report();
 493               		.loc 1 795 0
 494 0018 0E94 0000 		call send_keyboard_report
 495               	.LVL40:
 796:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 496               		.loc 1 796 0
 497 001c 89E3      		ldi r24,lo8(57)
 498               	.L60:
 797:./tmk_core/common/action.c ****         send_keyboard_report();
 798:./tmk_core/common/action.c ****     }
 799:./tmk_core/common/action.c **** 
 800:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 801:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 802:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 803:./tmk_core/common/action.c **** #endif
 804:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 805:./tmk_core/common/action.c ****         send_keyboard_report();
 806:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 499               		.loc 1 806 0
 500 001e 0E94 0000 		call del_key
 501               	.LVL41:
 502               	.L61:
 807:./tmk_core/common/action.c ****         send_keyboard_report();
 503               		.loc 1 807 0
 504 0022 0C94 0000 		jmp send_keyboard_report
 505               	.LVL42:
 506               	.L44:
 800:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 507               		.loc 1 800 0
 508 0026 8338      		cpi r24,lo8(-125)
 509 0028 01F4      		brne .L46
 802:./tmk_core/common/action.c **** #endif
 510               		.loc 1 802 0
 511 002a 0E94 0000 		call host_keyboard_leds
 512               	.LVL43:
 513 002e 80FF      		sbrs r24,0
 514 0030 00C0      		rjmp .L41
 804:./tmk_core/common/action.c ****         send_keyboard_report();
 515               		.loc 1 804 0
 516 0032 83E5      		ldi r24,lo8(83)
 517 0034 0E94 0000 		call add_key
 518               	.LVL44:
 805:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 519               		.loc 1 805 0
 520 0038 0E94 0000 		call send_keyboard_report
 521               	.LVL45:
 806:./tmk_core/common/action.c ****         send_keyboard_report();
 522               		.loc 1 806 0
 523 003c 83E5      		ldi r24,lo8(83)
 524 003e 00C0      		rjmp .L60
 525               	.LVL46:
 526               	.L46:
 808:./tmk_core/common/action.c ****     }
 809:./tmk_core/common/action.c **** 
 810:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 527               		.loc 1 810 0
 528 0040 8438      		cpi r24,lo8(-124)
 529 0042 01F4      		brne .L47
 811:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 812:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 530               		.loc 1 812 0
 531 0044 0E94 0000 		call host_keyboard_leds
 532               	.LVL47:
 533 0048 82FF      		sbrs r24,2
 534 004a 00C0      		rjmp .L41
 813:./tmk_core/common/action.c **** #endif
 814:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 535               		.loc 1 814 0
 536 004c 87E4      		ldi r24,lo8(71)
 537 004e 0E94 0000 		call add_key
 538               	.LVL48:
 815:./tmk_core/common/action.c ****         send_keyboard_report();
 539               		.loc 1 815 0
 540 0052 0E94 0000 		call send_keyboard_report
 541               	.LVL49:
 816:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 542               		.loc 1 816 0
 543 0056 87E4      		ldi r24,lo8(71)
 544 0058 00C0      		rjmp .L60
 545               	.LVL50:
 546               	.L47:
 817:./tmk_core/common/action.c ****         send_keyboard_report();
 818:./tmk_core/common/action.c ****     }
 819:./tmk_core/common/action.c **** #endif
 820:./tmk_core/common/action.c **** 
 821:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 547               		.loc 1 821 0
 548 005a 9CEF      		ldi r25,lo8(-4)
 549 005c 980F      		add r25,r24
 550 005e 913A      		cpi r25,lo8(-95)
 551 0060 00F0      		brlo .L60
 822:./tmk_core/common/action.c ****         del_key(code);
 823:./tmk_core/common/action.c ****         send_keyboard_report();
 824:./tmk_core/common/action.c ****     }
 825:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 552               		.loc 1 825 0
 553 0062 90E2      		ldi r25,lo8(32)
 554 0064 980F      		add r25,r24
 555 0066 9830      		cpi r25,lo8(8)
 556 0068 00F4      		brsh .L49
 826:./tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 557               		.loc 1 826 0
 558 006a 8770      		andi r24,lo8(7)
 559               	.LVL51:
 560 006c 91E0      		ldi r25,lo8(1)
 561 006e 00C0      		rjmp 2f
 562               		1:
 563 0070 990F      		lsl r25
 564               		2:
 565 0072 8A95      		dec r24
 566 0074 02F4      		brpl 1b
 567 0076 892F      		mov r24,r25
 568 0078 0E94 0000 		call del_mods
 569               	.LVL52:
 570 007c 00C0      		rjmp .L61
 571               	.LVL53:
 572               	.L49:
 827:./tmk_core/common/action.c ****         send_keyboard_report();
 828:./tmk_core/common/action.c ****     }
 829:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 573               		.loc 1 829 0
 574 007e 9BE5      		ldi r25,lo8(91)
 575 0080 980F      		add r25,r24
 576 0082 9330      		cpi r25,lo8(3)
 577 0084 00F4      		brsh .L50
 830:./tmk_core/common/action.c ****         host_system_send(0);
 578               		.loc 1 830 0
 579 0086 90E0      		ldi r25,0
 580 0088 80E0      		ldi r24,0
 581               	.LVL54:
 582 008a 0C94 0000 		jmp host_system_send
 583               	.LVL55:
 584               	.L50:
 831:./tmk_core/common/action.c ****     }
 832:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 585               		.loc 1 832 0
 586 008e 885A      		subi r24,lo8(-(88))
 587               	.LVL56:
 588 0090 8531      		cpi r24,lo8(21)
 589 0092 00F4      		brsh .L41
 833:./tmk_core/common/action.c ****         host_consumer_send(0);
 590               		.loc 1 833 0
 591 0094 90E0      		ldi r25,0
 592 0096 80E0      		ldi r24,0
 593               	.LVL57:
 594 0098 0C94 0000 		jmp host_consumer_send
 595               	.LVL58:
 596               	.L41:
 597               	/* epilogue start */
 834:./tmk_core/common/action.c ****     }
 835:./tmk_core/common/action.c **** }
 598               		.loc 1 835 0
 599 009c 0895      		ret
 600               		.cfi_endproc
 601               	.LFE20:
 603               		.section	.text.register_mods,"ax",@progbits
 604               	.global	register_mods
 606               	register_mods:
 607               	.LFB21:
 836:./tmk_core/common/action.c **** 
 837:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 838:./tmk_core/common/action.c ****  *
 839:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 840:./tmk_core/common/action.c ****  */
 841:./tmk_core/common/action.c **** void register_mods(uint8_t mods)
 842:./tmk_core/common/action.c **** {
 608               		.loc 1 842 0
 609               		.cfi_startproc
 610               	.LVL59:
 611               	/* prologue: function */
 612               	/* frame size = 0 */
 613               	/* stack size = 0 */
 614               	.L__stack_usage = 0
 843:./tmk_core/common/action.c ****     if (mods) {
 615               		.loc 1 843 0
 616 0000 8823      		tst r24
 617 0002 01F0      		breq .L62
 844:./tmk_core/common/action.c ****         add_mods(mods);
 618               		.loc 1 844 0
 619 0004 0E94 0000 		call add_mods
 620               	.LVL60:
 845:./tmk_core/common/action.c ****         send_keyboard_report();
 621               		.loc 1 845 0
 622 0008 0C94 0000 		jmp send_keyboard_report
 623               	.LVL61:
 624               	.L62:
 625               	/* epilogue start */
 846:./tmk_core/common/action.c ****     }
 847:./tmk_core/common/action.c **** }
 626               		.loc 1 847 0
 627 000c 0895      		ret
 628               		.cfi_endproc
 629               	.LFE21:
 631               		.section	.text.unregister_mods,"ax",@progbits
 632               	.global	unregister_mods
 634               	unregister_mods:
 635               	.LFB22:
 848:./tmk_core/common/action.c **** 
 849:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 850:./tmk_core/common/action.c ****  *
 851:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 852:./tmk_core/common/action.c ****  */
 853:./tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 854:./tmk_core/common/action.c **** {
 636               		.loc 1 854 0
 637               		.cfi_startproc
 638               	.LVL62:
 639               	/* prologue: function */
 640               	/* frame size = 0 */
 641               	/* stack size = 0 */
 642               	.L__stack_usage = 0
 855:./tmk_core/common/action.c ****     if (mods) {
 643               		.loc 1 855 0
 644 0000 8823      		tst r24
 645 0002 01F0      		breq .L64
 856:./tmk_core/common/action.c ****         del_mods(mods);
 646               		.loc 1 856 0
 647 0004 0E94 0000 		call del_mods
 648               	.LVL63:
 857:./tmk_core/common/action.c ****         send_keyboard_report();
 649               		.loc 1 857 0
 650 0008 0C94 0000 		jmp send_keyboard_report
 651               	.LVL64:
 652               	.L64:
 653               	/* epilogue start */
 858:./tmk_core/common/action.c ****     }
 859:./tmk_core/common/action.c **** }
 654               		.loc 1 859 0
 655 000c 0895      		ret
 656               		.cfi_endproc
 657               	.LFE22:
 659               		.section	.text.process_action,"ax",@progbits
 660               	.global	process_action
 662               	process_action:
 663               	.LFB18:
 195:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 664               		.loc 1 195 0
 665               		.cfi_startproc
 666               	.LVL65:
 667 0000 8F92      		push r8
 668               	.LCFI5:
 669               		.cfi_def_cfa_offset 3
 670               		.cfi_offset 8, -2
 671 0002 9F92      		push r9
 672               	.LCFI6:
 673               		.cfi_def_cfa_offset 4
 674               		.cfi_offset 9, -3
 675 0004 AF92      		push r10
 676               	.LCFI7:
 677               		.cfi_def_cfa_offset 5
 678               		.cfi_offset 10, -4
 679 0006 BF92      		push r11
 680               	.LCFI8:
 681               		.cfi_def_cfa_offset 6
 682               		.cfi_offset 11, -5
 683 0008 DF92      		push r13
 684               	.LCFI9:
 685               		.cfi_def_cfa_offset 7
 686               		.cfi_offset 13, -6
 687 000a EF92      		push r14
 688               	.LCFI10:
 689               		.cfi_def_cfa_offset 8
 690               		.cfi_offset 14, -7
 691 000c FF92      		push r15
 692               	.LCFI11:
 693               		.cfi_def_cfa_offset 9
 694               		.cfi_offset 15, -8
 695 000e 0F93      		push r16
 696               	.LCFI12:
 697               		.cfi_def_cfa_offset 10
 698               		.cfi_offset 16, -9
 699 0010 1F93      		push r17
 700               	.LCFI13:
 701               		.cfi_def_cfa_offset 11
 702               		.cfi_offset 17, -10
 703 0012 CF93      		push r28
 704               	.LCFI14:
 705               		.cfi_def_cfa_offset 12
 706               		.cfi_offset 28, -11
 707 0014 DF93      		push r29
 708               	.LCFI15:
 709               		.cfi_def_cfa_offset 13
 710               		.cfi_offset 29, -12
 711               	/* prologue: function */
 712               	/* frame size = 0 */
 713               	/* stack size = 11 */
 714               	.L__stack_usage = 11
 715 0016 7C01      		movw r14,r24
 716 0018 D62F      		mov r29,r22
 717 001a C72F      		mov r28,r23
 718               	.LVL66:
 198:./tmk_core/common/action.c **** #endif
 719               		.loc 1 198 0
 720 001c FC01      		movw r30,r24
 721 001e 0581      		ldd r16,Z+5
 722 0020 0295      		swap r16
 723 0022 0F70      		andi r16,lo8(15)
 724               	.LVL67:
 201:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 725               		.loc 1 201 0
 726 0024 1281      		ldd r17,Z+2
 727 0026 1111      		cpse r17,__zero_reg__
 203:./tmk_core/common/action.c ****     }
 728               		.loc 1 203 0
 729 0028 0E94 0000 		call clear_weak_mods
 730               	.LVL68:
 731               	.L67:
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 732               		.loc 1 209 0
 733 002c 0E94 0000 		call is_oneshot_layer_active
 734               	.LVL69:
 735 0030 D82E      		mov r13,r24
 736 0032 8823      		tst r24
 737 0034 01F0      		breq .L68
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 738               		.loc 1 209 0 is_stmt 0 discriminator 1
 739 0036 1123      		tst r17
 740 0038 01F0      		breq .L155
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 741               		.loc 1 209 0 discriminator 2
 742 003a 80E2      		ldi r24,lo8(32)
 743 003c 8D0F      		add r24,r29
 744 003e 8830      		cpi r24,lo8(8)
 745 0040 00F0      		brlo .L155
 210:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 746               		.loc 1 210 0 is_stmt 1
 747 0042 82E0      		ldi r24,lo8(2)
 748 0044 0E94 0000 		call clear_oneshot_layer_state
 749               	.LVL70:
 211:./tmk_core/common/action.c ****     }
 750               		.loc 1 211 0
 751 0048 0E94 0000 		call is_oneshot_layer_active
 752               	.LVL71:
 753 004c 91E0      		ldi r25,lo8(1)
 754 004e D82E      		mov r13,r24
 755 0050 D926      		eor r13,r25
 756               	.LVL72:
 757               	.L68:
 215:./tmk_core/common/action.c ****         /* Key and Mods */
 758               		.loc 1 215 0
 759 0052 BC2E      		mov r11,r28
 760 0054 B294      		swap r11
 761 0056 9FE0      		ldi r25,lo8(15)
 762 0058 B922      		and r11,r25
 763 005a EB2D      		mov r30,r11
 764 005c F0E0      		ldi r31,0
 765 005e E050      		subi r30,lo8(-(gs(.L71)))
 766 0060 F040      		sbci r31,hi8(-(gs(.L71)))
 767 0062 0C94 0000 		jmp __tablejump2__
 768               		.p2align	1
 769               	.L71:
 770 0066 0000      		.word gs(.L70)
 771 0068 0000      		.word gs(.L70)
 772 006a 0000      		.word gs(.L72)
 773 006c 0000      		.word gs(.L72)
 774 006e 0000      		.word gs(.L73)
 775 0070 0000      		.word gs(.L74)
 776 0072 0000      		.word gs(.L69)
 777 0074 0000      		.word gs(.L69)
 778 0076 0000      		.word gs(.L75)
 779 0078 0000      		.word gs(.L69)
 780 007a 0000      		.word gs(.L76)
 781 007c 0000      		.word gs(.L76)
 782 007e 0000      		.word gs(.L77)
 783 0080 0000      		.word gs(.L69)
 784 0082 0000      		.word gs(.L69)
 785 0084 0000      		.word gs(.L78)
 786               	.LVL73:
 787               	.L155:
 207:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 788               		.loc 1 207 0
 789 0086 D12C      		mov r13,__zero_reg__
 790 0088 00C0      		rjmp .L68
 791               	.LVL74:
 792               	.L70:
 793 008a 0C2F      		mov r16,r28
 794               	.LVL75:
 795 008c 0F70      		andi r16,lo8(15)
 796               	.LBB20:
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 797               		.loc 1 220 0
 798 008e C07F      		andi r28,lo8(-16)
 799               	.LVL76:
 800 0090 01F0      		breq .L79
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 801               		.loc 1 220 0 is_stmt 0 discriminator 2
 802 0092 0295      		swap r16
 803 0094 007F      		andi r16,lo8(-16)
 804               	.L79:
 805               	.LVL77:
 222:./tmk_core/common/action.c ****                     if (mods) {
 806               		.loc 1 222 0 is_stmt 1 discriminator 4
 807 0096 1123      		tst r17
 808 0098 01F0      		breq .L80
 223:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 809               		.loc 1 223 0
 810 009a 0023      		tst r16
 811 009c 01F0      		breq .L102
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 812               		.loc 1 224 0
 813 009e 80E2      		ldi r24,lo8(32)
 814 00a0 8D0F      		add r24,r29
 815 00a2 8830      		cpi r24,lo8(8)
 816 00a4 00F0      		brlo .L82
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 817               		.loc 1 224 0 is_stmt 0 discriminator 1
 818 00a6 D111      		cpse r29,__zero_reg__
 819 00a8 00C0      		rjmp .L83
 820               	.L82:
 228:./tmk_core/common/action.c ****                         } else {
 821               		.loc 1 228 0 is_stmt 1
 822 00aa 802F      		mov r24,r16
 823 00ac 0E94 0000 		call add_mods
 824               	.LVL78:
 825               	.L84:
 232:./tmk_core/common/action.c ****                     }
 826               		.loc 1 232 0
 827 00b0 0E94 0000 		call send_keyboard_report
 828               	.LVL79:
 829               	.L102:
 830               	.LBE20:
 831               	.LBB21:
 321:./tmk_core/common/action.c ****                                 }
 832               		.loc 1 321 0
 833 00b4 8D2F      		mov r24,r29
 834 00b6 0E94 0000 		call register_code
 835               	.LVL80:
 836 00ba 00C0      		rjmp .L85
 837               	.LVL81:
 838               	.L83:
 839               	.LBE21:
 840               	.LBB22:
 230:./tmk_core/common/action.c ****                         }
 841               		.loc 1 230 0
 842 00bc 802F      		mov r24,r16
 843 00be 0E94 0000 		call add_weak_mods
 844               	.LVL82:
 845 00c2 00C0      		rjmp .L84
 846               	.L80:
 236:./tmk_core/common/action.c ****                     if (mods) {
 847               		.loc 1 236 0
 848 00c4 8D2F      		mov r24,r29
 849 00c6 0E94 0000 		call unregister_code
 850               	.LVL83:
 237:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 851               		.loc 1 237 0
 852 00ca 0023      		tst r16
 853 00cc 01F0      		breq .L85
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 854               		.loc 1 238 0
 855 00ce 80E2      		ldi r24,lo8(32)
 856 00d0 8D0F      		add r24,r29
 857 00d2 8830      		cpi r24,lo8(8)
 858 00d4 00F0      		brlo .L87
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 859               		.loc 1 238 0 is_stmt 0 discriminator 1
 860 00d6 D111      		cpse r29,__zero_reg__
 861 00d8 00C0      		rjmp .L88
 862               	.L87:
 239:./tmk_core/common/action.c ****                         } else {
 863               		.loc 1 239 0 is_stmt 1
 864 00da 802F      		mov r24,r16
 865 00dc 0E94 0000 		call del_mods
 866               	.LVL84:
 867               	.L89:
 243:./tmk_core/common/action.c ****                     }
 868               		.loc 1 243 0
 869 00e0 0E94 0000 		call send_keyboard_report
 870               	.LVL85:
 871               	.L85:
 872               	.LBE22:
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 873               		.loc 1 684 0
 874 00e4 DD20      		tst r13
 875 00e6 01F4      		brne .+2
 876 00e8 00C0      		rjmp .L66
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 877               		.loc 1 684 0 is_stmt 0 discriminator 1
 878 00ea 0E94 0000 		call get_oneshot_layer_state
 879               	.LVL86:
 880 00ee 80FD      		sbrc r24,0
 881 00f0 00C0      		rjmp .L66
 685:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 882               		.loc 1 685 0 is_stmt 1
 883 00f2 F701      		movw r30,r14
 884 00f4 1282      		std Z+2,__zero_reg__
 686:./tmk_core/common/action.c ****         process_record(record);
 885               		.loc 1 686 0
 886 00f6 0E94 0000 		call get_oneshot_layer
 887               	.LVL87:
 888 00fa 0E94 0000 		call layer_on
 889               	.LVL88:
 687:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 890               		.loc 1 687 0
 891 00fe C701      		movw r24,r14
 892 0100 0E94 0000 		call process_record
 893               	.LVL89:
 688:./tmk_core/common/action.c ****     }
 894               		.loc 1 688 0
 895 0104 0E94 0000 		call get_oneshot_layer
 896               	.LVL90:
 897               	/* epilogue start */
 691:./tmk_core/common/action.c **** 
 898               		.loc 1 691 0
 899 0108 DF91      		pop r29
 900               	.LVL91:
 901 010a CF91      		pop r28
 902 010c 1F91      		pop r17
 903               	.LVL92:
 904 010e 0F91      		pop r16
 905 0110 FF90      		pop r15
 906 0112 EF90      		pop r14
 907               	.LVL93:
 908 0114 DF90      		pop r13
 909               	.LVL94:
 910 0116 BF90      		pop r11
 911 0118 AF90      		pop r10
 912 011a 9F90      		pop r9
 913 011c 8F90      		pop r8
 688:./tmk_core/common/action.c ****     }
 914               		.loc 1 688 0
 915 011e 0C94 0000 		jmp layer_off
 916               	.LVL95:
 917               	.L88:
 918               	.LBB23:
 241:./tmk_core/common/action.c ****                         }
 919               		.loc 1 241 0
 920 0122 802F      		mov r24,r16
 921 0124 0E94 0000 		call del_weak_mods
 922               	.LVL96:
 923 0128 00C0      		rjmp .L89
 924               	.LVL97:
 925               	.L72:
 926 012a FC2F      		mov r31,r28
 927 012c FF70      		andi r31,lo8(15)
 928 012e BF2E      		mov r11,r31
 929               	.LBE23:
 930               	.LBB24:
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 931               		.loc 1 252 0
 932 0130 C07F      		andi r28,lo8(-16)
 933               	.LVL98:
 934 0132 C032      		cpi r28,lo8(32)
 935 0134 01F0      		breq .L90
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 936               		.loc 1 252 0 is_stmt 0 discriminator 2
 937 0136 B294      		swap r11
 938 0138 80EF      		ldi r24,lo8(-16)
 939 013a B822      		and r11,r24
 940               	.L90:
 941               	.LVL99:
 254:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 942               		.loc 1 254 0 is_stmt 1 discriminator 4
 943 013c DD23      		tst r29
 944 013e 01F0      		breq .L92
 945 0140 D130      		cpi r29,lo8(1)
 946 0142 01F0      		breq .L93
 309:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 947               		.loc 1 309 0
 948 0144 1123      		tst r17
 949 0146 01F0      		breq .L100
 310:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 950               		.loc 1 310 0
 951 0148 0023      		tst r16
 952 014a 01F0      		breq .L101
 312:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 953               		.loc 1 312 0
 954 014c F701      		movw r30,r14
 955 014e 8581      		ldd r24,Z+5
 956 0150 80FF      		sbrs r24,0
 957 0152 00C0      		rjmp .L102
 315:./tmk_core/common/action.c ****                                     register_mods(mods);
 958               		.loc 1 315 0
 959 0154 8F70      		andi r24,lo8(15)
 960 0156 8583      		std Z+5,r24
 961 0158 00C0      		rjmp .L101
 962               	.L92:
 258:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 963               		.loc 1 258 0
 964 015a 1123      		tst r17
 965 015c 01F0      		breq .L94
 259:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 966               		.loc 1 259 0
 967 015e 0111      		cpse r16,__zero_reg__
 968 0160 00C0      		rjmp .L95
 969               	.L96:
 273:./tmk_core/common/action.c ****                             }
 970               		.loc 1 273 0
 971 0162 0E94 0000 		call get_oneshot_mods
 972               	.LVL100:
 973 0166 8B29      		or r24,r11
 974               	.L192:
 325:./tmk_core/common/action.c ****                             }
 975               		.loc 1 325 0
 976 0168 0E94 0000 		call register_mods
 977               	.LVL101:
 978 016c 00C0      		rjmp .L85
 979               	.L95:
 262:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 980               		.loc 1 262 0
 981 016e 0130      		cpi r16,lo8(1)
 982 0170 01F4      		brne .L96
 264:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 983               		.loc 1 264 0
 984 0172 0E94 0000 		call get_oneshot_mods
 985               	.LVL102:
 986 0176 8B29      		or r24,r11
 987 0178 0E94 0000 		call set_oneshot_mods
 988               	.LVL103:
 989 017c 00C0      		rjmp .L85
 990               	.L94:
 276:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 991               		.loc 1 276 0
 992 017e 0111      		cpse r16,__zero_reg__
 993 0180 00C0      		rjmp .L97
 994               	.L193:
 291:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 995               		.loc 1 291 0
 996 0182 0E94 0000 		call clear_oneshot_mods
 997               	.LVL104:
 998               	.L103:
 333:./tmk_core/common/action.c ****                             }
 999               		.loc 1 333 0
 1000 0186 8B2D      		mov r24,r11
 1001 0188 0E94 0000 		call unregister_mods
 1002               	.LVL105:
 1003 018c 00C0      		rjmp .L85
 1004               	.L97:
 279:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1005               		.loc 1 279 0
 1006 018e 0130      		cpi r16,lo8(1)
 1007 0190 01F4      		brne .+2
 1008 0192 00C0      		rjmp .L85
 1009 0194 00C0      		rjmp .L193
 1010               	.L93:
 298:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1011               		.loc 1 298 0
 1012 0196 1123      		tst r17
 1013 0198 01F0      		breq .L99
 299:./tmk_core/common/action.c ****                                 register_mods(mods);
 1014               		.loc 1 299 0
 1015 019a 0630      		cpi r16,lo8(6)
 1016 019c 00F0      		brlo .+2
 1017 019e 00C0      		rjmp .L85
 1018               	.L101:
 325:./tmk_core/common/action.c ****                             }
 1019               		.loc 1 325 0
 1020 01a0 8B2D      		mov r24,r11
 1021 01a2 00C0      		rjmp .L192
 1022               	.L99:
 303:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1023               		.loc 1 303 0
 1024 01a4 0530      		cpi r16,lo8(5)
 1025 01a6 00F0      		brlo .+2
 1026 01a8 00C0      		rjmp .L85
 1027 01aa 00C0      		rjmp .L103
 1028               	.L100:
 328:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1029               		.loc 1 328 0
 1030 01ac 0023      		tst r16
 1031 01ae 01F0      		breq .L103
 330:./tmk_core/common/action.c ****                             } else {
 1032               		.loc 1 330 0
 1033 01b0 8D2F      		mov r24,r29
 1034 01b2 0E94 0000 		call unregister_code
 1035               	.LVL106:
 1036 01b6 00C0      		rjmp .L85
 1037               	.LVL107:
 1038               	.L73:
 1039               	.LBE24:
 344:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1040               		.loc 1 344 0
 1041 01b8 8C2F      		mov r24,r28
 1042 01ba 8695      		lsr r24
 1043 01bc 8695      		lsr r24
 1044 01be 8370      		andi r24,lo8(3)
 1045 01c0 01F0      		breq .L104
 1046 01c2 8130      		cpi r24,lo8(1)
 1047 01c4 01F0      		breq .L105
 1048               	.L69:
 641:./tmk_core/common/action.c ****         case ACT_LAYER:
 1049               		.loc 1 641 0
 1050 01c6 98E0      		ldi r25,lo8(8)
 1051 01c8 B916      		cp r11,r25
 1052 01ca 01F4      		brne .+2
 1053 01cc 00C0      		rjmp .L118
 1054 01ce B916      		cp r11,r25
 1055 01d0 00F4      		brsh .+2
 1056 01d2 00C0      		rjmp .L85
 1057 01d4 86EF      		ldi r24,lo8(-10)
 1058 01d6 8B0D      		add r24,r11
 1059 01d8 8230      		cpi r24,lo8(2)
 1060 01da 00F4      		brsh .+2
 1061 01dc 00C0      		rjmp .L118
 1062 01de 00C0      		rjmp .L85
 1063               	.L104:
 347:./tmk_core/common/action.c ****                     } else {
 1064               		.loc 1 347 0
 1065 01e0 8D2F      		mov r24,r29
 1066 01e2 9C2F      		mov r25,r28
 1067 01e4 9370      		andi r25,lo8(3)
 346:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1068               		.loc 1 346 0
 1069 01e6 1111      		cpse r17,__zero_reg__
 1070 01e8 00C0      		rjmp .L190
 349:./tmk_core/common/action.c ****                     }
 1071               		.loc 1 349 0
 1072 01ea 90E0      		ldi r25,0
 1073 01ec 80E0      		ldi r24,0
 1074               	.L190:
 1075 01ee 0E94 0000 		call host_system_send
 1076               	.LVL108:
 1077 01f2 00C0      		rjmp .L85
 1078               	.L105:
 354:./tmk_core/common/action.c ****                     } else {
 1079               		.loc 1 354 0
 1080 01f4 8D2F      		mov r24,r29
 1081 01f6 9C2F      		mov r25,r28
 1082 01f8 9370      		andi r25,lo8(3)
 353:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1083               		.loc 1 353 0
 1084 01fa 1111      		cpse r17,__zero_reg__
 1085 01fc 00C0      		rjmp .L189
 356:./tmk_core/common/action.c ****                     }
 1086               		.loc 1 356 0
 1087 01fe 90E0      		ldi r25,0
 1088 0200 80E0      		ldi r24,0
 1089               	.L189:
 1090 0202 0E94 0000 		call host_consumer_send
 1091               	.LVL109:
 1092 0206 00C0      		rjmp .L85
 1093               	.L74:
 365:./tmk_core/common/action.c ****                 switch (action.key.code) {
 1094               		.loc 1 365 0
 1095 0208 1123      		tst r17
 1096 020a 01F0      		breq .L108
 366:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1097               		.loc 1 366 0
 1098 020c D53F      		cpi r29,lo8(-11)
 1099 020e 01F0      		breq .L110
 1100 0210 D63F      		cpi r29,lo8(-10)
 1101 0212 01F0      		breq .L111
 1102 0214 D43F      		cpi r29,lo8(-12)
 1103 0216 01F4      		brne .L109
 368:./tmk_core/common/action.c ****                         break;
 1104               		.loc 1 368 0
 1105 0218 8091 0000 		lds r24,tp_buttons
 1106 021c 9091 0000 		lds r25,tp_buttons+1
 1107 0220 8160      		ori r24,1
 1108               	.L183:
 374:./tmk_core/common/action.c ****                         break;
 1109               		.loc 1 374 0
 1110 0222 9093 0000 		sts tp_buttons+1,r25
 1111 0226 8093 0000 		sts tp_buttons,r24
 1112               	.L109:
 379:./tmk_core/common/action.c ****                 mousekey_send();
 1113               		.loc 1 379 0
 1114 022a 8D2F      		mov r24,r29
 1115 022c 0E94 0000 		call mousekey_on
 1116               	.LVL110:
 1117               	.L191:
 396:./tmk_core/common/action.c ****             }
 1118               		.loc 1 396 0
 1119 0230 0E94 0000 		call mousekey_send
 1120               	.LVL111:
 1121 0234 00C0      		rjmp .L85
 1122               	.L110:
 371:./tmk_core/common/action.c ****                         break;
 1123               		.loc 1 371 0
 1124 0236 8091 0000 		lds r24,tp_buttons
 1125 023a 9091 0000 		lds r25,tp_buttons+1
 1126 023e 8260      		ori r24,2
 1127 0240 00C0      		rjmp .L183
 1128               	.L111:
 374:./tmk_core/common/action.c ****                         break;
 1129               		.loc 1 374 0
 1130 0242 8091 0000 		lds r24,tp_buttons
 1131 0246 9091 0000 		lds r25,tp_buttons+1
 1132 024a 8460      		ori r24,4
 1133 024c 00C0      		rjmp .L183
 1134               	.L108:
 382:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1135               		.loc 1 382 0
 1136 024e D53F      		cpi r29,lo8(-11)
 1137 0250 01F0      		breq .L114
 1138 0252 D63F      		cpi r29,lo8(-10)
 1139 0254 01F0      		breq .L115
 1140 0256 D43F      		cpi r29,lo8(-12)
 1141 0258 01F4      		brne .L113
 384:./tmk_core/common/action.c ****                         break;
 1142               		.loc 1 384 0
 1143 025a 8091 0000 		lds r24,tp_buttons
 1144 025e 9091 0000 		lds r25,tp_buttons+1
 1145 0262 8E7F      		andi r24,254
 1146               	.L184:
 390:./tmk_core/common/action.c ****                         break;
 1147               		.loc 1 390 0
 1148 0264 9093 0000 		sts tp_buttons+1,r25
 1149 0268 8093 0000 		sts tp_buttons,r24
 1150               	.L113:
 395:./tmk_core/common/action.c ****                 mousekey_send();
 1151               		.loc 1 395 0
 1152 026c 8D2F      		mov r24,r29
 1153 026e 0E94 0000 		call mousekey_off
 1154               	.LVL112:
 1155 0272 00C0      		rjmp .L191
 1156               	.L114:
 387:./tmk_core/common/action.c ****                         break;
 1157               		.loc 1 387 0
 1158 0274 8091 0000 		lds r24,tp_buttons
 1159 0278 9091 0000 		lds r25,tp_buttons+1
 1160 027c 8D7F      		andi r24,253
 1161 027e 00C0      		rjmp .L184
 1162               	.L115:
 390:./tmk_core/common/action.c ****                         break;
 1163               		.loc 1 390 0
 1164 0280 8091 0000 		lds r24,tp_buttons
 1165 0284 9091 0000 		lds r25,tp_buttons+1
 1166 0288 8B7F      		andi r24,251
 1167 028a 00C0      		rjmp .L184
 1168               	.L75:
 402:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1169               		.loc 1 402 0
 1170 028c 8C2F      		mov r24,r28
 1171 028e 8370      		andi r24,lo8(3)
 1172 0290 01F0      		breq .+2
 1173 0292 00C0      		rjmp .L117
 404:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1174               		.loc 1 404 0
 1175 0294 1111      		cpse r17,__zero_reg__
 1176 0296 00C0      		rjmp .L118
 1177               	.LVL113:
 1178               	.LBB25:
 405:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1179               		.loc 1 405 0
 1180 0298 2D2F      		mov r18,r29
 1181 029a 2295      		swap r18
 1182 029c 2695      		lsr r18
 1183 029e 2770      		andi r18,lo8(7)
 1184 02a0 220F      		lsl r18
 1185 02a2 220F      		lsl r18
 406:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1186               		.loc 1 406 0
 1187 02a4 6D2F      		mov r22,r29
 1188 02a6 6F70      		andi r22,lo8(15)
 1189 02a8 862E      		mov r8,r22
 1190 02aa 912C      		mov r9,__zero_reg__
 1191 02ac B12C      		mov r11,__zero_reg__
 1192 02ae A12C      		mov r10,__zero_reg__
 1193 02b0 022E      		mov r0,r18
 1194 02b2 00C0      		rjmp 2f
 1195               		1:
 1196 02b4 880C      		lsl r8
 1197 02b6 991C      		rol r9
 1198 02b8 AA1C      		rol r10
 1199 02ba BB1C      		rol r11
 1200               		2:
 1201 02bc 0A94      		dec r0
 1202 02be 02F4      		brpl 1b
 1203               	.LVL114:
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1204               		.loc 1 407 0
 1205 02c0 60E0      		ldi r22,0
 1206 02c2 70E0      		ldi r23,0
 1207 02c4 CB01      		movw r24,r22
 1208 02c6 D4FF      		sbrs r29,4
 1209 02c8 00C0      		rjmp .L119
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1210               		.loc 1 407 0 is_stmt 0 discriminator 1
 1211 02ca 6FE0      		ldi r22,lo8(15)
 1212 02cc 70E0      		ldi r23,0
 1213 02ce 80E0      		ldi r24,0
 1214 02d0 90E0      		ldi r25,0
 1215 02d2 00C0      		rjmp 2f
 1216               		1:
 1217 02d4 660F      		lsl r22
 1218 02d6 771F      		rol r23
 1219 02d8 881F      		rol r24
 1220 02da 991F      		rol r25
 1221               		2:
 1222 02dc 2A95      		dec r18
 1223 02de 02F4      		brpl 1b
 1224 02e0 6095      		com r22
 1225 02e2 7095      		com r23
 1226 02e4 8095      		com r24
 1227 02e6 9095      		com r25
 1228               	.L119:
 1229               	.LVL115:
 408:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1230               		.loc 1 408 0 is_stmt 1 discriminator 4
 1231 02e8 C695      		lsr r28
 1232 02ea C695      		lsr r28
 1233               	.LVL116:
 1234 02ec C370      		andi r28,lo8(3)
 1235 02ee C230      		cpi r28,lo8(2)
 1236 02f0 01F0      		breq .L121
 1237 02f2 00F4      		brsh .L122
 1238 02f4 6829      		or r22,r8
 1239               	.LVL117:
 1240 02f6 7929      		or r23,r9
 1241 02f8 8A29      		or r24,r10
 1242 02fa 9B29      		or r25,r11
 1243 02fc C130      		cpi r28,lo8(1)
 1244 02fe 01F0      		breq .L188
 409:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1245               		.loc 1 409 0 discriminator 4
 1246 0300 0E94 0000 		call default_layer_and
 1247               	.LVL118:
 1248               	.L118:
 1249               	.LBE25:
 647:./tmk_core/common/action.c ****             break;
 1250               		.loc 1 647 0
 1251 0304 0E94 0000 		call host_keyboard_leds
 1252               	.LVL119:
 1253 0308 0E94 0000 		call led_set
 1254               	.LVL120:
 648:./tmk_core/common/action.c ****         default:
 1255               		.loc 1 648 0
 1256 030c 00C0      		rjmp .L85
 1257               	.LVL121:
 1258               	.L121:
 1259               	.LBB26:
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1260               		.loc 1 411 0
 1261 030e 6829      		or r22,r8
 1262               	.LVL122:
 1263 0310 7929      		or r23,r9
 1264 0312 8A29      		or r24,r10
 1265 0314 9B29      		or r25,r11
 1266 0316 0E94 0000 		call default_layer_xor
 1267               	.LVL123:
 1268 031a 00C0      		rjmp .L118
 1269               	.LVL124:
 1270               	.L122:
 412:./tmk_core/common/action.c ****                     }
 1271               		.loc 1 412 0
 1272 031c 0E94 0000 		call default_layer_and
 1273               	.LVL125:
 1274 0320 C501      		movw r24,r10
 1275 0322 B401      		movw r22,r8
 1276               	.L188:
 1277 0324 0E94 0000 		call default_layer_or
 1278               	.LVL126:
 1279 0328 00C0      		rjmp .L118
 1280               	.LVL127:
 1281               	.L117:
 1282               	.LBE26:
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1283               		.loc 1 417 0
 1284 032a 8695      		lsr r24
 1285 032c 1123      		tst r17
 1286 032e 01F0      		breq .L125
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1287               		.loc 1 417 0 is_stmt 0 discriminator 1
 1288 0330 8C2F      		mov r24,r28
 1289 0332 8170      		andi r24,lo8(1)
 1290               	.L125:
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1291               		.loc 1 417 0 discriminator 4
 1292 0334 8823      		tst r24
 1293 0336 01F0      		breq .L118
 1294               	.LVL128:
 1295               	.LBB27:
 419:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1296               		.loc 1 419 0 is_stmt 1
 1297 0338 2D2F      		mov r18,r29
 1298 033a 2295      		swap r18
 1299 033c 2695      		lsr r18
 1300 033e 2770      		andi r18,lo8(7)
 1301 0340 220F      		lsl r18
 1302 0342 220F      		lsl r18
 420:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1303               		.loc 1 420 0
 1304 0344 6D2F      		mov r22,r29
 1305 0346 6F70      		andi r22,lo8(15)
 1306 0348 862E      		mov r8,r22
 1307 034a 912C      		mov r9,__zero_reg__
 1308 034c B12C      		mov r11,__zero_reg__
 1309 034e A12C      		mov r10,__zero_reg__
 1310 0350 022E      		mov r0,r18
 1311 0352 00C0      		rjmp 2f
 1312               		1:
 1313 0354 880C      		lsl r8
 1314 0356 991C      		rol r9
 1315 0358 AA1C      		rol r10
 1316 035a BB1C      		rol r11
 1317               		2:
 1318 035c 0A94      		dec r0
 1319 035e 02F4      		brpl 1b
 1320               	.LVL129:
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1321               		.loc 1 421 0
 1322 0360 60E0      		ldi r22,0
 1323 0362 70E0      		ldi r23,0
 1324 0364 CB01      		movw r24,r22
 1325 0366 D4FF      		sbrs r29,4
 1326 0368 00C0      		rjmp .L126
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1327               		.loc 1 421 0 is_stmt 0 discriminator 1
 1328 036a 6FE0      		ldi r22,lo8(15)
 1329 036c 70E0      		ldi r23,0
 1330 036e 80E0      		ldi r24,0
 1331 0370 90E0      		ldi r25,0
 1332 0372 00C0      		rjmp 2f
 1333               		1:
 1334 0374 660F      		lsl r22
 1335 0376 771F      		rol r23
 1336 0378 881F      		rol r24
 1337 037a 991F      		rol r25
 1338               		2:
 1339 037c 2A95      		dec r18
 1340 037e 02F4      		brpl 1b
 1341 0380 6095      		com r22
 1342 0382 7095      		com r23
 1343 0384 8095      		com r24
 1344 0386 9095      		com r25
 1345               	.L126:
 1346               	.LVL130:
 422:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1347               		.loc 1 422 0 is_stmt 1 discriminator 4
 1348 0388 C695      		lsr r28
 1349 038a C695      		lsr r28
 1350               	.LVL131:
 1351 038c C370      		andi r28,lo8(3)
 1352 038e C230      		cpi r28,lo8(2)
 1353 0390 01F0      		breq .L128
 1354 0392 00F4      		brsh .L129
 1355 0394 6829      		or r22,r8
 1356               	.LVL132:
 1357 0396 7929      		or r23,r9
 1358 0398 8A29      		or r24,r10
 1359 039a 9B29      		or r25,r11
 1360 039c C130      		cpi r28,lo8(1)
 1361 039e 01F0      		breq .L187
 423:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1362               		.loc 1 423 0 discriminator 4
 1363 03a0 0E94 0000 		call layer_and
 1364               	.LVL133:
 1365 03a4 00C0      		rjmp .L118
 1366               	.LVL134:
 1367               	.L128:
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1368               		.loc 1 425 0
 1369 03a6 6829      		or r22,r8
 1370               	.LVL135:
 1371 03a8 7929      		or r23,r9
 1372 03aa 8A29      		or r24,r10
 1373 03ac 9B29      		or r25,r11
 1374 03ae 0E94 0000 		call layer_xor
 1375               	.LVL136:
 1376 03b2 00C0      		rjmp .L118
 1377               	.LVL137:
 1378               	.L129:
 426:./tmk_core/common/action.c ****                     }
 1379               		.loc 1 426 0
 1380 03b4 0E94 0000 		call layer_and
 1381               	.LVL138:
 1382 03b8 C501      		movw r24,r10
 1383 03ba B401      		movw r22,r8
 1384               	.L187:
 1385 03bc 0E94 0000 		call layer_or
 1386               	.LVL139:
 1387 03c0 00C0      		rjmp .L118
 1388               	.LVL140:
 1389               	.L76:
 1390               	.LBE27:
 434:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 1391               		.loc 1 434 0
 1392 03c2 E0E2      		ldi r30,lo8(32)
 1393 03c4 ED0F      		add r30,r29
 1394 03c6 E531      		cpi r30,lo8(21)
 1395 03c8 00F0      		brlo .+2
 1396 03ca 00C0      		rjmp .L131
 1397 03cc F0E0      		ldi r31,0
 1398 03ce E050      		subi r30,lo8(-(gs(.L133)))
 1399 03d0 F040      		sbci r31,hi8(-(gs(.L133)))
 1400 03d2 0C94 0000 		jmp __tablejump2__
 1401               		.p2align	1
 1402               	.L133:
 1403 03d6 0000      		.word gs(.L132)
 1404 03d8 0000      		.word gs(.L132)
 1405 03da 0000      		.word gs(.L132)
 1406 03dc 0000      		.word gs(.L132)
 1407 03de 0000      		.word gs(.L132)
 1408 03e0 0000      		.word gs(.L132)
 1409 03e2 0000      		.word gs(.L132)
 1410 03e4 0000      		.word gs(.L132)
 1411 03e6 0000      		.word gs(.L132)
 1412 03e8 0000      		.word gs(.L132)
 1413 03ea 0000      		.word gs(.L132)
 1414 03ec 0000      		.word gs(.L132)
 1415 03ee 0000      		.word gs(.L132)
 1416 03f0 0000      		.word gs(.L132)
 1417 03f2 0000      		.word gs(.L132)
 1418 03f4 0000      		.word gs(.L132)
 1419 03f6 0000      		.word gs(.L134)
 1420 03f8 0000      		.word gs(.L135)
 1421 03fa 0000      		.word gs(.L136)
 1422 03fc 0000      		.word gs(.L137)
 1423 03fe 0000      		.word gs(.L138)
 1424               	.L132:
 1425 0400 DF70      		andi r29,lo8(15)
 1426               	.LVL141:
 1427 0402 8C2F      		mov r24,r28
 1428 0404 8F71      		andi r24,lo8(31)
 437:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1429               		.loc 1 437 0
 1430 0406 1123      		tst r17
 1431 0408 01F0      		breq .L139
 438:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 1432               		.loc 1 438 0
 1433 040a 0E94 0000 		call layer_on
 1434               	.LVL142:
 439:./tmk_core/common/action.c ****                     } else {
 1435               		.loc 1 439 0
 1436 040e 8D2F      		mov r24,r29
 1437 0410 0E94 0000 		call register_mods
 1438               	.LVL143:
 1439 0414 00C0      		rjmp .L69
 1440               	.L139:
 441:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 1441               		.loc 1 441 0
 1442 0416 0E94 0000 		call layer_off
 1443               	.LVL144:
 442:./tmk_core/common/action.c ****                     }
 1444               		.loc 1 442 0
 1445 041a 8D2F      		mov r24,r29
 1446 041c 0E94 0000 		call unregister_mods
 1447               	.LVL145:
 1448 0420 00C0      		rjmp .L69
 1449               	.LVL146:
 1450               	.L134:
 447:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1451               		.loc 1 447 0
 1452 0422 1123      		tst r17
 1453 0424 01F0      		breq .L140
 448:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1454               		.loc 1 448 0
 1455 0426 0530      		cpi r16,lo8(5)
 1456 0428 00F0      		brlo .+2
 1457 042a 00C0      		rjmp .L69
 1458               	.L141:
 449:./tmk_core/common/action.c ****                         }
 1459               		.loc 1 449 0
 1460 042c 8C2F      		mov r24,r28
 1461 042e 8F71      		andi r24,lo8(31)
 1462 0430 0E94 0000 		call layer_invert
 1463               	.LVL147:
 1464 0434 00C0      		rjmp .L69
 1465               	.L140:
 452:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1466               		.loc 1 452 0
 1467 0436 0630      		cpi r16,lo8(6)
 1468 0438 00F0      		brlo .+2
 1469 043a 00C0      		rjmp .L69
 1470 043c 00C0      		rjmp .L141
 1471               	.L135:
 1472 043e 8C2F      		mov r24,r28
 1473 0440 8F71      		andi r24,lo8(31)
 458:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1474               		.loc 1 458 0
 1475 0442 1123      		tst r17
 1476 0444 01F0      		breq .L185
 1477               	.L186:
 515:./tmk_core/common/action.c ****                         }
 1478               		.loc 1 515 0
 1479 0446 0E94 0000 		call layer_on
 1480               	.LVL148:
 1481 044a 00C0      		rjmp .L69
 1482               	.L136:
 1483 044c 8C2F      		mov r24,r28
 1484 044e 8F71      		andi r24,lo8(31)
 462:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1485               		.loc 1 462 0
 1486 0450 1123      		tst r17
 1487 0452 01F0      		breq .L186
 1488               	.L185:
 526:./tmk_core/common/action.c ****                         }
 1489               		.loc 1 526 0
 1490 0454 0E94 0000 		call layer_off
 1491               	.LVL149:
 1492 0458 00C0      		rjmp .L69
 1493               	.L137:
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1494               		.loc 1 466 0
 1495 045a 1123      		tst r17
 1496 045c 01F0      		breq .L145
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1497               		.loc 1 466 0 is_stmt 0 discriminator 1
 1498 045e 8C2F      		mov r24,r28
 1499 0460 8F71      		andi r24,lo8(31)
 1500 0462 0E94 0000 		call layer_move
 1501               	.LVL150:
 1502 0466 00C0      		rjmp .L69
 1503               	.L145:
 467:./tmk_core/common/action.c ****                     break;
 1504               		.loc 1 467 0 is_stmt 1
 1505 0468 0E94 0000 		call layer_clear
 1506               	.LVL151:
 1507 046c 00C0      		rjmp .L69
 1508               	.L138:
 495:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1509               		.loc 1 495 0
 1510 046e 1123      		tst r17
 1511 0470 01F0      		breq .L146
 496:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1512               		.loc 1 496 0
 1513 0472 CF71      		andi r28,lo8(31)
 1514               	.LVL152:
 1515 0474 8C2F      		mov r24,r28
 1516 0476 0E94 0000 		call layer_on
 1517               	.LVL153:
 497:./tmk_core/common/action.c ****                     } else {
 1518               		.loc 1 497 0
 1519 047a 63E0      		ldi r22,lo8(3)
 1520 047c 8C2F      		mov r24,r28
 1521 047e 0E94 0000 		call set_oneshot_layer
 1522               	.LVL154:
 1523 0482 00C0      		rjmp .L69
 1524               	.LVL155:
 1525               	.L146:
 499:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 1526               		.loc 1 499 0
 1527 0484 81E0      		ldi r24,lo8(1)
 1528 0486 0E94 0000 		call clear_oneshot_layer_state
 1529               	.LVL156:
 500:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1530               		.loc 1 500 0
 1531 048a 0230      		cpi r16,lo8(2)
 1532 048c 00F4      		brsh .+2
 1533 048e 00C0      		rjmp .L69
 501:./tmk_core/common/action.c ****                         }
 1534               		.loc 1 501 0
 1535 0490 82E0      		ldi r24,lo8(2)
 1536 0492 0E94 0000 		call clear_oneshot_layer_state
 1537               	.LVL157:
 1538 0496 00C0      		rjmp .L69
 1539               	.L131:
 509:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 1540               		.loc 1 509 0
 1541 0498 1123      		tst r17
 1542 049a 01F0      		breq .L147
 510:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1543               		.loc 1 510 0
 1544 049c 0023      		tst r16
 1545 049e 01F0      		breq .L148
 512:./tmk_core/common/action.c ****                         } else {
 1546               		.loc 1 512 0
 1547 04a0 8D2F      		mov r24,r29
 1548 04a2 0E94 0000 		call register_code
 1549               	.LVL158:
 1550 04a6 00C0      		rjmp .L69
 1551               	.L148:
 515:./tmk_core/common/action.c ****                         }
 1552               		.loc 1 515 0
 1553 04a8 8C2F      		mov r24,r28
 1554 04aa 8F71      		andi r24,lo8(31)
 1555 04ac 00C0      		rjmp .L186
 1556               	.L147:
 518:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1557               		.loc 1 518 0
 1558 04ae 0023      		tst r16
 1559 04b0 01F0      		breq .L149
 520:./tmk_core/common/action.c ****                                 wait_ms(80);
 1560               		.loc 1 520 0
 1561 04b2 D933      		cpi r29,lo8(57)
 1562 04b4 01F4      		brne .L150
 1563               	.LVL159:
 1564               	.LBB28:
 1565               	.LBB29:
 1566               		.loc 2 187 0
 1567 04b6 FFEF      		ldi r31,lo8(255999)
 1568 04b8 27EE      		ldi r18,hi8(255999)
 1569 04ba 83E0      		ldi r24,hlo8(255999)
 1570 04bc F150      	1:	subi r31,1
 1571 04be 2040      		sbci r18,0
 1572 04c0 8040      		sbci r24,0
 1573 04c2 01F4      		brne 1b
 1574 04c4 00C0      		rjmp .
 1575 04c6 0000      		nop
 1576               	.LVL160:
 1577               	.L150:
 1578               	.LBE29:
 1579               	.LBE28:
 523:./tmk_core/common/action.c ****                         } else {
 1580               		.loc 1 523 0
 1581 04c8 8D2F      		mov r24,r29
 1582 04ca 0E94 0000 		call unregister_code
 1583               	.LVL161:
 1584 04ce 00C0      		rjmp .L69
 1585               	.L149:
 526:./tmk_core/common/action.c ****                         }
 1586               		.loc 1 526 0
 1587 04d0 8C2F      		mov r24,r28
 1588 04d2 8F71      		andi r24,lo8(31)
 1589 04d4 00C0      		rjmp .L185
 1590               	.L77:
 537:./tmk_core/common/action.c ****             break;
 1591               		.loc 1 537 0
 1592 04d6 4C2F      		mov r20,r28
 1593 04d8 4F70      		andi r20,lo8(15)
 1594 04da 6D2F      		mov r22,r29
 1595 04dc C701      		movw r24,r14
 1596 04de 0E94 0000 		call action_get_macro
 1597               	.LVL162:
 1598 04e2 0E94 0000 		call action_macro_play
 1599               	.LVL163:
 538:./tmk_core/common/action.c **** #endif
 1600               		.loc 1 538 0
 1601 04e6 00C0      		rjmp .L85
 1602               	.L78:
 632:./tmk_core/common/action.c ****             break;
 1603               		.loc 1 632 0
 1604 04e8 4C2F      		mov r20,r28
 1605 04ea 4F70      		andi r20,lo8(15)
 1606 04ec 6D2F      		mov r22,r29
 1607 04ee C701      		movw r24,r14
 1608 04f0 0E94 0000 		call action_function
 1609               	.LVL164:
 633:./tmk_core/common/action.c **** #endif
 1610               		.loc 1 633 0
 1611 04f4 00C0      		rjmp .L85
 1612               	.LVL165:
 1613               	.L66:
 1614               	/* epilogue start */
 691:./tmk_core/common/action.c **** 
 1615               		.loc 1 691 0
 1616 04f6 DF91      		pop r29
 1617               	.LVL166:
 1618 04f8 CF91      		pop r28
 1619 04fa 1F91      		pop r17
 1620               	.LVL167:
 1621 04fc 0F91      		pop r16
 1622 04fe FF90      		pop r15
 1623 0500 EF90      		pop r14
 1624               	.LVL168:
 1625 0502 DF90      		pop r13
 1626               	.LVL169:
 1627 0504 BF90      		pop r11
 1628 0506 AF90      		pop r10
 1629 0508 9F90      		pop r9
 1630 050a 8F90      		pop r8
 1631 050c 0895      		ret
 1632               		.cfi_endproc
 1633               	.LFE18:
 1635               		.section	.text.process_record,"ax",@progbits
 1636               	.global	process_record
 1638               	process_record:
 1639               	.LFB17:
 173:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1640               		.loc 1 173 0
 1641               		.cfi_startproc
 1642               	.LVL170:
 1643 0000 0F93      		push r16
 1644               	.LCFI16:
 1645               		.cfi_def_cfa_offset 3
 1646               		.cfi_offset 16, -2
 1647 0002 1F93      		push r17
 1648               	.LCFI17:
 1649               		.cfi_def_cfa_offset 4
 1650               		.cfi_offset 17, -3
 1651 0004 CF93      		push r28
 1652               	.LCFI18:
 1653               		.cfi_def_cfa_offset 5
 1654               		.cfi_offset 28, -4
 1655 0006 DF93      		push r29
 1656               	.LCFI19:
 1657               		.cfi_def_cfa_offset 6
 1658               		.cfi_offset 29, -5
 1659               	/* prologue: function */
 1660               	/* frame size = 0 */
 1661               	/* stack size = 4 */
 1662               	.L__stack_usage = 4
 1663 0008 EC01      		movw r28,r24
 1664 000a 9881      		ld r25,Y
 1665 000c 8981      		ldd r24,Y+1
 1666               	.LVL171:
 1667               	.LBB32:
 1668               	.LBB33:
 1669               		.file 3 "./tmk_core/common/keyboard.h"
   1:./tmk_core/common/keyboard.h **** /*
   2:./tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/keyboard.h **** 
   4:./tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/keyboard.h **** (at your option) any later version.
   8:./tmk_core/common/keyboard.h **** 
   9:./tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:./tmk_core/common/keyboard.h **** 
  14:./tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/keyboard.h **** */
  17:./tmk_core/common/keyboard.h **** 
  18:./tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:./tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:./tmk_core/common/keyboard.h **** 
  21:./tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:./tmk_core/common/keyboard.h **** #include <stdint.h>
  23:./tmk_core/common/keyboard.h **** 
  24:./tmk_core/common/keyboard.h **** 
  25:./tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:./tmk_core/common/keyboard.h **** extern "C" {
  27:./tmk_core/common/keyboard.h **** #endif
  28:./tmk_core/common/keyboard.h **** 
  29:./tmk_core/common/keyboard.h **** /* key matrix position */
  30:./tmk_core/common/keyboard.h **** typedef struct {
  31:./tmk_core/common/keyboard.h ****     uint8_t col;
  32:./tmk_core/common/keyboard.h ****     uint8_t row;
  33:./tmk_core/common/keyboard.h **** } keypos_t;
  34:./tmk_core/common/keyboard.h **** 
  35:./tmk_core/common/keyboard.h **** /* key event */
  36:./tmk_core/common/keyboard.h **** typedef struct {
  37:./tmk_core/common/keyboard.h ****     keypos_t key;
  38:./tmk_core/common/keyboard.h ****     bool     pressed;
  39:./tmk_core/common/keyboard.h ****     uint16_t time;
  40:./tmk_core/common/keyboard.h **** } keyevent_t;
  41:./tmk_core/common/keyboard.h **** 
  42:./tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:./tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:./tmk_core/common/keyboard.h **** 
  45:./tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:./tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:./tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:./tmk_core/common/keyboard.h ****  */
  49:./tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1670               		.loc 3 49 0
 1671 000e 2B81      		ldd r18,Y+3
 1672 0010 3C81      		ldd r19,Y+4
 1673 0012 232B      		or r18,r19
 1674 0014 01F0      		breq .L198
 1675 0016 8F3F      		cpi r24,lo8(-1)
 1676 0018 01F4      		brne .L199
 1677 001a 81E0      		ldi r24,lo8(1)
 1678 001c 9F3F      		cpi r25,lo8(-1)
 1679 001e 01F0      		breq .L195
 1680               	.L199:
 1681 0020 80E0      		ldi r24,0
 1682 0022 00C0      		rjmp .L195
 1683               	.L198:
 1684 0024 81E0      		ldi r24,lo8(1)
 1685               	.L195:
 1686               	.LBE33:
 1687               	.LBE32:
 174:./tmk_core/common/action.c **** 
 1688               		.loc 1 174 0
 1689 0026 80FD      		sbrc r24,0
 1690 0028 00C0      		rjmp .L194
 176:./tmk_core/common/action.c ****         return;
 1691               		.loc 1 176 0
 1692 002a CE01      		movw r24,r28
 1693 002c 0E94 0000 		call process_record_quantum
 1694               	.LVL172:
 1695 0030 8823      		tst r24
 1696 0032 01F0      		breq .L194
 179:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 1697               		.loc 1 179 0
 1698 0034 6881      		ld r22,Y
 1699 0036 7981      		ldd r23,Y+1
 1700 0038 8A81      		ldd r24,Y+2
 1701 003a 0E94 0000 		call store_or_get_action
 1702               	.LVL173:
 1703 003e 8C01      		movw r16,r24
 1704               	.LVL174:
 182:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 1705               		.loc 1 182 0
 1706 0040 0E94 0000 		call layer_debug
 1707               	.LVL175:
 183:./tmk_core/common/action.c **** #endif
 1708               		.loc 1 183 0
 1709 0044 0E94 0000 		call default_layer_debug
 1710               	.LVL176:
 187:./tmk_core/common/action.c **** }
 1711               		.loc 1 187 0
 1712 0048 B801      		movw r22,r16
 1713 004a CE01      		movw r24,r28
 1714               	/* epilogue start */
 188:./tmk_core/common/action.c **** 
 1715               		.loc 1 188 0
 1716 004c DF91      		pop r29
 1717 004e CF91      		pop r28
 1718               	.LVL177:
 1719 0050 1F91      		pop r17
 1720 0052 0F91      		pop r16
 1721               	.LVL178:
 187:./tmk_core/common/action.c **** }
 1722               		.loc 1 187 0
 1723 0054 0C94 0000 		jmp process_action
 1724               	.LVL179:
 1725               	.L194:
 1726               	/* epilogue start */
 188:./tmk_core/common/action.c **** 
 1727               		.loc 1 188 0
 1728 0058 DF91      		pop r29
 1729 005a CF91      		pop r28
 1730               	.LVL180:
 1731 005c 1F91      		pop r17
 1732 005e 0F91      		pop r16
 1733 0060 0895      		ret
 1734               		.cfi_endproc
 1735               	.LFE17:
 1737               		.section	.text.process_record_nocache,"ax",@progbits
 1738               	.global	process_record_nocache
 1740               	process_record_nocache:
 1741               	.LFB14:
 134:./tmk_core/common/action.c ****     process_record(record);
 1742               		.loc 1 134 0
 1743               		.cfi_startproc
 1744               	.LVL181:
 1745               	/* prologue: function */
 1746               	/* frame size = 0 */
 1747               	/* stack size = 0 */
 1748               	.L__stack_usage = 0
 135:./tmk_core/common/action.c **** }
 1749               		.loc 1 135 0
 1750 0000 0C94 0000 		jmp process_record
 1751               	.LVL182:
 1752               		.cfi_endproc
 1753               	.LFE14:
 1755               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1756               	.global	clear_keyboard_but_mods
 1758               	clear_keyboard_but_mods:
 1759               	.LFB24:
 860:./tmk_core/common/action.c **** 
 861:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 862:./tmk_core/common/action.c ****  *
 863:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 864:./tmk_core/common/action.c ****  */
 865:./tmk_core/common/action.c **** void clear_keyboard(void)
 866:./tmk_core/common/action.c **** {
 867:./tmk_core/common/action.c ****     clear_mods();
 868:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 869:./tmk_core/common/action.c **** }
 870:./tmk_core/common/action.c **** 
 871:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 872:./tmk_core/common/action.c ****  *
 873:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 874:./tmk_core/common/action.c ****  */
 875:./tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 876:./tmk_core/common/action.c **** {
 1760               		.loc 1 876 0
 1761               		.cfi_startproc
 1762               	/* prologue: function */
 1763               	/* frame size = 0 */
 1764               	/* stack size = 0 */
 1765               	.L__stack_usage = 0
 877:./tmk_core/common/action.c ****     clear_weak_mods();
 1766               		.loc 1 877 0
 1767 0000 0E94 0000 		call clear_weak_mods
 1768               	.LVL183:
 878:./tmk_core/common/action.c ****     clear_macro_mods();
 1769               		.loc 1 878 0
 1770 0004 0E94 0000 		call clear_macro_mods
 1771               	.LVL184:
 879:./tmk_core/common/action.c ****     clear_keys();
 1772               		.loc 1 879 0
 1773 0008 0E94 0000 		call clear_keys
 1774               	.LVL185:
 880:./tmk_core/common/action.c ****     send_keyboard_report();
 1775               		.loc 1 880 0
 1776 000c 0E94 0000 		call send_keyboard_report
 1777               	.LVL186:
 881:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 882:./tmk_core/common/action.c ****     mousekey_clear();
 1778               		.loc 1 882 0
 1779 0010 0E94 0000 		call mousekey_clear
 1780               	.LVL187:
 883:./tmk_core/common/action.c ****     mousekey_send();
 1781               		.loc 1 883 0
 1782 0014 0E94 0000 		call mousekey_send
 1783               	.LVL188:
 884:./tmk_core/common/action.c **** #endif
 885:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 886:./tmk_core/common/action.c ****     host_system_send(0);
 1784               		.loc 1 886 0
 1785 0018 90E0      		ldi r25,0
 1786 001a 80E0      		ldi r24,0
 1787 001c 0E94 0000 		call host_system_send
 1788               	.LVL189:
 887:./tmk_core/common/action.c ****     host_consumer_send(0);
 1789               		.loc 1 887 0
 1790 0020 90E0      		ldi r25,0
 1791 0022 80E0      		ldi r24,0
 1792 0024 0C94 0000 		jmp host_consumer_send
 1793               	.LVL190:
 1794               		.cfi_endproc
 1795               	.LFE24:
 1797               		.section	.text.clear_keyboard,"ax",@progbits
 1798               	.global	clear_keyboard
 1800               	clear_keyboard:
 1801               	.LFB23:
 866:./tmk_core/common/action.c ****     clear_mods();
 1802               		.loc 1 866 0
 1803               		.cfi_startproc
 1804               	/* prologue: function */
 1805               	/* frame size = 0 */
 1806               	/* stack size = 0 */
 1807               	.L__stack_usage = 0
 867:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 1808               		.loc 1 867 0
 1809 0000 0E94 0000 		call clear_mods
 1810               	.LVL191:
 868:./tmk_core/common/action.c **** }
 1811               		.loc 1 868 0
 1812 0004 0C94 0000 		jmp clear_keyboard_but_mods
 1813               	.LVL192:
 1814               		.cfi_endproc
 1815               	.LFE23:
 1817               		.section	.text.is_tap_key,"ax",@progbits
 1818               	.global	is_tap_key
 1820               	is_tap_key:
 1821               	.LFB25:
 888:./tmk_core/common/action.c **** #endif
 889:./tmk_core/common/action.c **** }
 890:./tmk_core/common/action.c **** 
 891:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 892:./tmk_core/common/action.c ****  *
 893:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 894:./tmk_core/common/action.c ****  */
 895:./tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 896:./tmk_core/common/action.c **** {
 1822               		.loc 1 896 0
 1823               		.cfi_startproc
 1824               	.LVL193:
 1825               	/* prologue: function */
 1826               	/* frame size = 0 */
 1827               	/* stack size = 0 */
 1828               	.L__stack_usage = 0
 897:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 1829               		.loc 1 897 0
 1830 0000 0E94 0000 		call layer_switch_get_action
 1831               	.LVL194:
 898:./tmk_core/common/action.c **** 
 899:./tmk_core/common/action.c ****     switch (action.kind.id) {
 1832               		.loc 1 899 0
 1833 0004 E92F      		mov r30,r25
 1834 0006 E295      		swap r30
 1835 0008 EF70      		andi r30,lo8(15)
 1836 000a E250      		subi r30,lo8(-(-2))
 1837 000c EE30      		cpi r30,lo8(14)
 1838 000e 00F4      		brsh .L218
 1839 0010 F0E0      		ldi r31,0
 1840 0012 E050      		subi r30,lo8(-(gs(.L212)))
 1841 0014 F040      		sbci r31,hi8(-(gs(.L212)))
 1842 0016 0C94 0000 		jmp __tablejump2__
 1843               		.p2align	1
 1844               	.L212:
 1845 001a 0000      		.word gs(.L211)
 1846 001c 0000      		.word gs(.L211)
 1847 001e 0000      		.word gs(.L218)
 1848 0020 0000      		.word gs(.L218)
 1849 0022 0000      		.word gs(.L213)
 1850 0024 0000      		.word gs(.L218)
 1851 0026 0000      		.word gs(.L218)
 1852 0028 0000      		.word gs(.L218)
 1853 002a 0000      		.word gs(.L211)
 1854 002c 0000      		.word gs(.L211)
 1855 002e 0000      		.word gs(.L214)
 1856 0030 0000      		.word gs(.L218)
 1857 0032 0000      		.word gs(.L218)
 1858 0034 0000      		.word gs(.L214)
 1859               	.L211:
 900:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 901:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 902:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 903:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 904:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1860               		.loc 1 904 0
 1861 0036 803F      		cpi r24,lo8(-16)
 1862 0038 01F0      		breq .L220
 1863 003a 00F4      		brsh .L216
 1864 003c 803E      		cpi r24,lo8(-32)
 1865 003e 00F4      		brsh .L218
 1866               	.L220:
 905:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 906:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 907:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 908:./tmk_core/common/action.c ****                     return true;
 1867               		.loc 1 908 0
 1868 0040 81E0      		ldi r24,lo8(1)
 1869               	.LVL195:
 1870               	/* epilogue start */
 909:./tmk_core/common/action.c ****             }
 910:./tmk_core/common/action.c ****             return false;
 911:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 912:./tmk_core/common/action.c ****             switch (action.swap.code) {
 913:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 914:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 915:./tmk_core/common/action.c ****                     return true;
 916:./tmk_core/common/action.c ****             }
 917:./tmk_core/common/action.c ****             return false;
 918:./tmk_core/common/action.c ****         case ACT_MACRO:
 919:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 920:./tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 921:./tmk_core/common/action.c ****             return false;
 922:./tmk_core/common/action.c ****     }
 923:./tmk_core/common/action.c ****     return false;
 924:./tmk_core/common/action.c **** }
 1871               		.loc 1 924 0
 1872 0042 0895      		ret
 1873               	.LVL196:
 1874               	.L216:
 904:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 1875               		.loc 1 904 0
 1876 0044 843F      		cpi r24,lo8(-12)
 1877 0046 01F0      		breq .L220
 1878               	.L218:
 910:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 1879               		.loc 1 910 0
 1880 0048 80E0      		ldi r24,0
 1881               	.LVL197:
 1882 004a 0895      		ret
 1883               	.LVL198:
 1884               	.L213:
 912:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 1885               		.loc 1 912 0
 1886 004c 803E      		cpi r24,lo8(-32)
 1887 004e 00F0      		brlo .L220
 1888 0050 813F      		cpi r24,lo8(-15)
 1889 0052 01F4      		brne .L218
 1890 0054 00C0      		rjmp .L220
 1891               	.L214:
 920:./tmk_core/common/action.c ****             return false;
 1892               		.loc 1 920 0
 1893 0056 93FB      		bst r25,3
 1894 0058 8827      		clr r24
 1895 005a 80F9      		bld r24,0
 1896               	.LVL199:
 1897 005c 0895      		ret
 1898               		.cfi_endproc
 1899               	.LFE25:
 1901               		.section	.text.debug_event,"ax",@progbits
 1902               	.global	debug_event
 1904               	debug_event:
 1905               	.LFB26:
 925:./tmk_core/common/action.c **** 
 926:./tmk_core/common/action.c **** 
 927:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 928:./tmk_core/common/action.c ****  *
 929:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 930:./tmk_core/common/action.c ****  */
 931:./tmk_core/common/action.c **** void debug_event(keyevent_t event)
 932:./tmk_core/common/action.c **** {
 1906               		.loc 1 932 0
 1907               		.cfi_startproc
 1908 0000 CF93      		push r28
 1909               	.LCFI20:
 1910               		.cfi_def_cfa_offset 3
 1911               		.cfi_offset 28, -2
 1912 0002 DF93      		push r29
 1913               	.LCFI21:
 1914               		.cfi_def_cfa_offset 4
 1915               		.cfi_offset 29, -3
 1916 0004 00D0      		rcall .
 1917 0006 00D0      		rcall .
 1918 0008 1F92      		push __zero_reg__
 1919               	.LCFI22:
 1920               		.cfi_def_cfa_offset 9
 1921 000a CDB7      		in r28,__SP_L__
 1922 000c DEB7      		in r29,__SP_H__
 1923               	.LCFI23:
 1924               		.cfi_def_cfa_register 28
 1925               	/* prologue: function */
 1926               	/* frame size = 5 */
 1927               	/* stack size = 7 */
 1928               	.L__stack_usage = 7
 1929               	/* epilogue start */
 933:./tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 934:./tmk_core/common/action.c **** }
 1930               		.loc 1 934 0
 1931 000e 0F90      		pop __tmp_reg__
 1932 0010 0F90      		pop __tmp_reg__
 1933 0012 0F90      		pop __tmp_reg__
 1934 0014 0F90      		pop __tmp_reg__
 1935 0016 0F90      		pop __tmp_reg__
 1936 0018 DF91      		pop r29
 1937 001a CF91      		pop r28
 1938 001c 0895      		ret
 1939               		.cfi_endproc
 1940               	.LFE26:
 1942               		.section	.text.debug_record,"ax",@progbits
 1943               	.global	debug_record
 1945               	debug_record:
 1946               	.LFB27:
 935:./tmk_core/common/action.c **** 
 936:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 937:./tmk_core/common/action.c ****  *
 938:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 939:./tmk_core/common/action.c ****  */
 940:./tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 941:./tmk_core/common/action.c **** {
 1947               		.loc 1 941 0
 1948               		.cfi_startproc
 1949 0000 CF93      		push r28
 1950               	.LCFI24:
 1951               		.cfi_def_cfa_offset 3
 1952               		.cfi_offset 28, -2
 1953 0002 DF93      		push r29
 1954               	.LCFI25:
 1955               		.cfi_def_cfa_offset 4
 1956               		.cfi_offset 29, -3
 1957 0004 00D0      		rcall .
 1958 0006 00D0      		rcall .
 1959 0008 00D0      		rcall .
 1960               	.LCFI26:
 1961               		.cfi_def_cfa_offset 10
 1962 000a CDB7      		in r28,__SP_L__
 1963 000c DEB7      		in r29,__SP_H__
 1964               	.LCFI27:
 1965               		.cfi_def_cfa_register 28
 1966               	/* prologue: function */
 1967               	/* frame size = 6 */
 1968               	/* stack size = 8 */
 1969               	.L__stack_usage = 8
 1970               	/* epilogue start */
 942:./tmk_core/common/action.c ****     debug_event(record.event);
 943:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 944:./tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 945:./tmk_core/common/action.c **** #endif
 946:./tmk_core/common/action.c **** }
 1971               		.loc 1 946 0
 1972 000e 2696      		adiw r28,6
 1973 0010 0FB6      		in __tmp_reg__,__SREG__
 1974 0012 F894      		cli
 1975 0014 DEBF      		out __SP_H__,r29
 1976 0016 0FBE      		out __SREG__,__tmp_reg__
 1977 0018 CDBF      		out __SP_L__,r28
 1978 001a DF91      		pop r29
 1979 001c CF91      		pop r28
 1980 001e 0895      		ret
 1981               		.cfi_endproc
 1982               	.LFE27:
 1984               		.section	.text.debug_action,"ax",@progbits
 1985               	.global	debug_action
 1987               	debug_action:
 1988               	.LFB28:
 947:./tmk_core/common/action.c **** 
 948:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 949:./tmk_core/common/action.c ****  *
 950:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 951:./tmk_core/common/action.c ****  */
 952:./tmk_core/common/action.c **** void debug_action(action_t action)
 953:./tmk_core/common/action.c **** {
 1989               		.loc 1 953 0
 1990               		.cfi_startproc
 1991               	.LVL200:
 1992               	/* prologue: function */
 1993               	/* frame size = 0 */
 1994               	/* stack size = 0 */
 1995               	.L__stack_usage = 0
 1996               	/* epilogue start */
 954:./tmk_core/common/action.c ****     switch (action.kind.id) {
 955:./tmk_core/common/action.c ****         case ACT_LMODS:             dprint("ACT_LMODS");             break;
 956:./tmk_core/common/action.c ****         case ACT_RMODS:             dprint("ACT_RMODS");             break;
 957:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:         dprint("ACT_LMODS_TAP");         break;
 958:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:         dprint("ACT_RMODS_TAP");         break;
 959:./tmk_core/common/action.c ****         case ACT_USAGE:             dprint("ACT_USAGE");             break;
 960:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:          dprint("ACT_MOUSEKEY");          break;
 961:./tmk_core/common/action.c ****         case ACT_LAYER:             dprint("ACT_LAYER");             break;
 962:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:         dprint("ACT_LAYER_TAP");         break;
 963:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:     dprint("ACT_LAYER_TAP_EXT");     break;
 964:./tmk_core/common/action.c ****         case ACT_MACRO:             dprint("ACT_MACRO");             break;
 965:./tmk_core/common/action.c ****         case ACT_COMMAND:           dprint("ACT_COMMAND");           break;
 966:./tmk_core/common/action.c ****         case ACT_FUNCTION:          dprint("ACT_FUNCTION");          break;
 967:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:        dprint("ACT_SWAP_HANDS");        break;
 968:./tmk_core/common/action.c ****         default:                    dprint("UNKNOWN");               break;
 969:./tmk_core/common/action.c ****     }
 970:./tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param>>8, action.kind.param&0xff);
 971:./tmk_core/common/action.c **** }
 1997               		.loc 1 971 0
 1998 0000 0895      		ret
 1999               		.cfi_endproc
 2000               	.LFE28:
 2002               		.comm	tp_buttons,2,1
 2003               		.text
 2004               	.Letext0:
 2005               		.file 4 "/usr/local/Cellar/avr-gcc@7/7.3.0/avr/include/stdint.h"
 2006               		.file 5 "./tmk_core/common/keycode.h"
 2007               		.file 6 "./tmk_core/common/report.h"
 2008               		.file 7 "./tmk_core/common/host.h"
 2009               		.file 8 "./tmk_core/common/mousekey.h"
 2010               		.file 9 "./tmk_core/common/command.h"
 2011               		.file 10 "./tmk_core/common/action_code.h"
 2012               		.file 11 "./tmk_core/common/action.h"
 2013               		.file 12 "./tmk_core/common/action_layer.h"
 2014               		.file 13 "./tmk_core/common/action_util.h"
 2015               		.file 14 "./tmk_core/common/debug.h"
 2016               		.file 15 "./tmk_core/common/led.h"
 2017               		.file 16 "./tmk_core/common/action_macro.h"
 2018               		.file 17 "./tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:4      *ABS*:000000000000003f __SREG__
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:13     .text.action_exec:0000000000000000 action_exec
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:89     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:109    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:131    .text.register_code:0000000000000000 register_code
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:468    .text.unregister_code:0000000000000000 unregister_code
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:606    .text.register_mods:0000000000000000 register_mods
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:634    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:662    .text.process_action:0000000000000000 process_action
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:1638   .text.process_record:0000000000000000 process_record
                            *COM*:0000000000000002 tp_buttons
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:1740   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:1758   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:1800   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:1820   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:1904   .text.debug_event:0000000000000000 debug_event
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:1945   .text.debug_record:0000000000000000 debug_record
/var/folders/x3/bbndryhj5bd9s7h49yn0kv480000gn/T//cc05bvQa.s:1987   .text.debug_action:0000000000000000 debug_action

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
command_proc
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
mousekey_on
mousekey_send
mousekey_off
default_layer_and
led_set
default_layer_xor
default_layer_or
layer_and
layer_xor
layer_or
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
mousekey_clear
clear_mods
__do_clear_bss
