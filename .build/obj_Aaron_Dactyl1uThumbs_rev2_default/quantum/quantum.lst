   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB24:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  19:quantum/quantum.c **** #include "outputselect.h"
  20:quantum/quantum.c **** #endif
  21:quantum/quantum.c **** 
  22:quantum/quantum.c **** #ifndef TAPPING_TERM
  23:quantum/quantum.c **** #define TAPPING_TERM 200
  24:quantum/quantum.c **** #endif
  25:quantum/quantum.c **** 
  26:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  27:quantum/quantum.c **** #define BREATHING_PERIOD 6
  28:quantum/quantum.c **** #endif
  29:quantum/quantum.c **** 
  30:quantum/quantum.c **** #include "backlight.h"
  31:quantum/quantum.c **** extern backlight_config_t backlight_config;
  32:quantum/quantum.c **** 
  33:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  34:quantum/quantum.c **** #include "fauxclicky.h"
  35:quantum/quantum.c **** #endif
  36:quantum/quantum.c **** 
  37:quantum/quantum.c **** #ifdef API_ENABLE
  38:quantum/quantum.c **** #include "api.h"
  39:quantum/quantum.c **** #endif
  40:quantum/quantum.c **** 
  41:quantum/quantum.c **** #ifdef MIDI_ENABLE
  42:quantum/quantum.c **** #include "process_midi.h"
  43:quantum/quantum.c **** #endif
  44:quantum/quantum.c **** 
  45:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  46:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  47:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  48:quantum/quantum.c ****   #endif
  49:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  50:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  51:quantum/quantum.c ****   #endif
  52:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  53:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  54:quantum/quantum.c ****   #endif
  55:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  56:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  57:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  58:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  59:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  60:quantum/quantum.c ****   #endif
  61:quantum/quantum.c **** #endif
  62:quantum/quantum.c **** 
  63:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 63 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  38 0008 8C01      		movw r16,r24
  39 000a EB01      		movw r28,r22
  64:quantum/quantum.c ****   switch (code) {
  40               		.loc 1 64 0
  41 000c 9A95      		dec r25
  42               	.LVL1:
  43 000e 8115      		cp r24,__zero_reg__
  44 0010 9F41      		sbci r25,31
  45 0012 00F4      		brsh .L1
  65:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  66:quantum/quantum.c ****     break;
  67:quantum/quantum.c ****   default:
  68:quantum/quantum.c ****     return;
  69:quantum/quantum.c ****   }
  70:quantum/quantum.c **** 
  71:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 71 0
  47 0014 10FF      		sbrs r17,0
  48 0016 00C0      		rjmp .L4
  72:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 72 0
  50 0018 80EE      		ldi r24,lo8(-32)
  51 001a FB01      		movw r30,r22
  52 001c 0995      		icall
  53               	.LVL2:
  54               	.L4:
  73:quantum/quantum.c ****   if (code & QK_LSFT)
  55               		.loc 1 73 0
  56 001e 11FF      		sbrs r17,1
  57 0020 00C0      		rjmp .L5
  74:quantum/quantum.c ****     f(KC_LSFT);
  58               		.loc 1 74 0
  59 0022 81EE      		ldi r24,lo8(-31)
  60 0024 FE01      		movw r30,r28
  61 0026 0995      		icall
  62               	.LVL3:
  63               	.L5:
  75:quantum/quantum.c ****   if (code & QK_LALT)
  64               		.loc 1 75 0
  65 0028 12FF      		sbrs r17,2
  66 002a 00C0      		rjmp .L6
  76:quantum/quantum.c ****     f(KC_LALT);
  67               		.loc 1 76 0
  68 002c 82EE      		ldi r24,lo8(-30)
  69 002e FE01      		movw r30,r28
  70 0030 0995      		icall
  71               	.LVL4:
  72               	.L6:
  77:quantum/quantum.c ****   if (code & QK_LGUI)
  73               		.loc 1 77 0
  74 0032 13FF      		sbrs r17,3
  75 0034 00C0      		rjmp .L7
  78:quantum/quantum.c ****     f(KC_LGUI);
  76               		.loc 1 78 0
  77 0036 83EE      		ldi r24,lo8(-29)
  78 0038 FE01      		movw r30,r28
  79 003a 0995      		icall
  80               	.LVL5:
  81               	.L7:
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  82               		.loc 1 80 0
  83 003c 0115      		cp r16,__zero_reg__
  84 003e 1041      		sbci r17,16
  85 0040 00F0      		brlo .L1
  81:quantum/quantum.c **** 
  82:quantum/quantum.c ****   if (code & QK_RCTL)
  83:quantum/quantum.c ****     f(KC_RCTL);
  86               		.loc 1 83 0
  87 0042 84EE      		ldi r24,lo8(-28)
  88 0044 FE01      		movw r30,r28
  89 0046 0995      		icall
  90               	.LVL6:
  84:quantum/quantum.c ****   if (code & QK_RSFT)
  85:quantum/quantum.c ****     f(KC_RSFT);
  91               		.loc 1 85 0
  92 0048 85EE      		ldi r24,lo8(-27)
  93 004a FE01      		movw r30,r28
  94 004c 0995      		icall
  95               	.LVL7:
  86:quantum/quantum.c ****   if (code & QK_RALT)
  87:quantum/quantum.c ****     f(KC_RALT);
  96               		.loc 1 87 0
  97 004e 86EE      		ldi r24,lo8(-26)
  98 0050 FE01      		movw r30,r28
  99 0052 0995      		icall
 100               	.LVL8:
  88:quantum/quantum.c ****   if (code & QK_RGUI)
  89:quantum/quantum.c ****     f(KC_RGUI);
 101               		.loc 1 89 0
 102 0054 87EE      		ldi r24,lo8(-25)
 103 0056 FE01      		movw r30,r28
 104               	/* epilogue start */
  90:quantum/quantum.c **** }
 105               		.loc 1 90 0
 106 0058 DF91      		pop r29
 107 005a CF91      		pop r28
 108               	.LVL9:
 109 005c 1F91      		pop r17
 110 005e 0F91      		pop r16
 111               	.LVL10:
  89:quantum/quantum.c ****     f(KC_RGUI);
 112               		.loc 1 89 0
 113 0060 0994      		ijmp
 114               	.LVL11:
 115               	.L1:
 116               	/* epilogue start */
 117               		.loc 1 90 0
 118 0062 DF91      		pop r29
 119 0064 CF91      		pop r28
 120               	.LVL12:
 121 0066 1F91      		pop r17
 122 0068 0F91      		pop r16
 123               	.LVL13:
 124 006a 0895      		ret
 125               		.cfi_endproc
 126               	.LFE24:
 128               		.section	.text.qk_register_weak_mods,"ax",@progbits
 130               	qk_register_weak_mods:
 131               	.LFB25:
  91:quantum/quantum.c **** 
  92:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 132               		.loc 1 92 0
 133               		.cfi_startproc
 134               	.LVL14:
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  93:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 139               		.loc 1 93 0
 140 0000 8770      		andi r24,lo8(7)
 141               	.LVL15:
 142 0002 91E0      		ldi r25,lo8(1)
 143 0004 00C0      		rjmp 2f
 144               		1:
 145 0006 990F      		lsl r25
 146               		2:
 147 0008 8A95      		dec r24
 148 000a 02F4      		brpl 1b
 149 000c 892F      		mov r24,r25
 150 000e 0E94 0000 		call add_weak_mods
 151               	.LVL16:
  94:quantum/quantum.c ****     send_keyboard_report();
 152               		.loc 1 94 0
 153 0012 0C94 0000 		jmp send_keyboard_report
 154               	.LVL17:
 155               		.cfi_endproc
 156               	.LFE25:
 158               		.section	.text.qk_register_mods,"ax",@progbits
 160               	qk_register_mods:
 161               	.LFB27:
  95:quantum/quantum.c **** }
  96:quantum/quantum.c **** 
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
  99:quantum/quantum.c ****     send_keyboard_report();
 100:quantum/quantum.c **** }
 101:quantum/quantum.c **** 
 102:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 162               		.loc 1 102 0
 163               		.cfi_startproc
 164               	.LVL18:
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 103:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 169               		.loc 1 103 0
 170 0000 8770      		andi r24,lo8(7)
 171               	.LVL19:
 172 0002 91E0      		ldi r25,lo8(1)
 173 0004 00C0      		rjmp 2f
 174               		1:
 175 0006 990F      		lsl r25
 176               		2:
 177 0008 8A95      		dec r24
 178 000a 02F4      		brpl 1b
 179 000c 892F      		mov r24,r25
 180 000e 0E94 0000 		call add_weak_mods
 181               	.LVL20:
 104:quantum/quantum.c ****     send_keyboard_report();
 182               		.loc 1 104 0
 183 0012 0C94 0000 		jmp send_keyboard_report
 184               	.LVL21:
 185               		.cfi_endproc
 186               	.LFE27:
 188               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 190               	qk_unregister_weak_mods:
 191               	.LFB26:
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
 192               		.loc 1 97 0
 193               		.cfi_startproc
 194               	.LVL22:
 195               	/* prologue: function */
 196               	/* frame size = 0 */
 197               	/* stack size = 0 */
 198               	.L__stack_usage = 0
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 199               		.loc 1 98 0
 200 0000 8770      		andi r24,lo8(7)
 201               	.LVL23:
 202 0002 91E0      		ldi r25,lo8(1)
 203 0004 00C0      		rjmp 2f
 204               		1:
 205 0006 990F      		lsl r25
 206               		2:
 207 0008 8A95      		dec r24
 208 000a 02F4      		brpl 1b
 209 000c 892F      		mov r24,r25
 210 000e 0E94 0000 		call del_weak_mods
 211               	.LVL24:
  99:quantum/quantum.c ****     send_keyboard_report();
 212               		.loc 1 99 0
 213 0012 0C94 0000 		jmp send_keyboard_report
 214               	.LVL25:
 215               		.cfi_endproc
 216               	.LFE26:
 218               		.section	.text.qk_unregister_mods,"ax",@progbits
 220               	qk_unregister_mods:
 221               	.LFB28:
 105:quantum/quantum.c **** }
 106:quantum/quantum.c **** 
 107:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 222               		.loc 1 107 0
 223               		.cfi_startproc
 224               	.LVL26:
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 227               	/* stack size = 0 */
 228               	.L__stack_usage = 0
 108:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 229               		.loc 1 108 0
 230 0000 8770      		andi r24,lo8(7)
 231               	.LVL27:
 232 0002 91E0      		ldi r25,lo8(1)
 233 0004 00C0      		rjmp 2f
 234               		1:
 235 0006 990F      		lsl r25
 236               		2:
 237 0008 8A95      		dec r24
 238 000a 02F4      		brpl 1b
 239 000c 892F      		mov r24,r25
 240 000e 0E94 0000 		call del_weak_mods
 241               	.LVL28:
 109:quantum/quantum.c ****     send_keyboard_report();
 242               		.loc 1 109 0
 243 0012 0C94 0000 		jmp send_keyboard_report
 244               	.LVL29:
 245               		.cfi_endproc
 246               	.LFE28:
 248               		.section	.text.rgblight_toggle,"ax",@progbits
 249               		.weak	rgblight_toggle
 251               	rgblight_toggle:
 252               	.LFB10:
 253               		.file 2 "quantum/rgb.h"
   1:quantum/rgb.h **** /* Copyright 2017 Jack Humbert
   2:quantum/rgb.h ****  *
   3:quantum/rgb.h ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/rgb.h ****  * it under the terms of the GNU General Public License as published by
   5:quantum/rgb.h ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/rgb.h ****  * (at your option) any later version.
   7:quantum/rgb.h ****  *
   8:quantum/rgb.h ****  * This program is distributed in the hope that it will be useful,
   9:quantum/rgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/rgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/rgb.h ****  * GNU General Public License for more details.
  12:quantum/rgb.h ****  *
  13:quantum/rgb.h ****  * You should have received a copy of the GNU General Public License
  14:quantum/rgb.h ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/rgb.h ****  */
  16:quantum/rgb.h **** 
  17:quantum/rgb.h **** #ifndef RGB_H
  18:quantum/rgb.h **** #define RGB_H
  19:quantum/rgb.h **** 
  20:quantum/rgb.h **** __attribute__((weak))
  21:quantum/rgb.h **** void rgblight_toggle(void) {};
 254               		.loc 2 21 0
 255               		.cfi_startproc
 256               	/* prologue: function */
 257               	/* frame size = 0 */
 258               	/* stack size = 0 */
 259               	.L__stack_usage = 0
 260 0000 0895      		ret
 261               		.cfi_endproc
 262               	.LFE10:
 264               		.section	.text.rgblight_step,"ax",@progbits
 265               		.weak	rgblight_step
 267               	rgblight_step:
 268               	.LFB11:
  22:quantum/rgb.h **** 
  23:quantum/rgb.h **** __attribute__((weak))
  24:quantum/rgb.h **** void rgblight_step(void) {};
 269               		.loc 2 24 0
 270               		.cfi_startproc
 271               	/* prologue: function */
 272               	/* frame size = 0 */
 273               	/* stack size = 0 */
 274               	.L__stack_usage = 0
 275 0000 0895      		ret
 276               		.cfi_endproc
 277               	.LFE11:
 279               		.section	.text.rgblight_step_reverse,"ax",@progbits
 280               		.weak	rgblight_step_reverse
 282               	rgblight_step_reverse:
 283               	.LFB12:
  25:quantum/rgb.h **** 
  26:quantum/rgb.h **** __attribute__((weak))
  27:quantum/rgb.h **** void rgblight_step_reverse(void) {};
 284               		.loc 2 27 0
 285               		.cfi_startproc
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 288               	/* stack size = 0 */
 289               	.L__stack_usage = 0
 290 0000 0895      		ret
 291               		.cfi_endproc
 292               	.LFE12:
 294               		.section	.text.rgblight_increase_hue,"ax",@progbits
 295               		.weak	rgblight_increase_hue
 297               	rgblight_increase_hue:
 298               	.LFB13:
  28:quantum/rgb.h **** 
  29:quantum/rgb.h **** __attribute__((weak))
  30:quantum/rgb.h **** void rgblight_increase_hue(void) {};
 299               		.loc 2 30 0
 300               		.cfi_startproc
 301               	/* prologue: function */
 302               	/* frame size = 0 */
 303               	/* stack size = 0 */
 304               	.L__stack_usage = 0
 305 0000 0895      		ret
 306               		.cfi_endproc
 307               	.LFE13:
 309               		.section	.text.rgblight_decrease_hue,"ax",@progbits
 310               		.weak	rgblight_decrease_hue
 312               	rgblight_decrease_hue:
 313               	.LFB14:
  31:quantum/rgb.h **** 
  32:quantum/rgb.h **** __attribute__((weak))
  33:quantum/rgb.h **** void rgblight_decrease_hue(void) {};
 314               		.loc 2 33 0
 315               		.cfi_startproc
 316               	/* prologue: function */
 317               	/* frame size = 0 */
 318               	/* stack size = 0 */
 319               	.L__stack_usage = 0
 320 0000 0895      		ret
 321               		.cfi_endproc
 322               	.LFE14:
 324               		.section	.text.rgblight_increase_sat,"ax",@progbits
 325               		.weak	rgblight_increase_sat
 327               	rgblight_increase_sat:
 328               	.LFB15:
  34:quantum/rgb.h **** 
  35:quantum/rgb.h **** __attribute__((weak))
  36:quantum/rgb.h **** void rgblight_increase_sat(void) {};
 329               		.loc 2 36 0
 330               		.cfi_startproc
 331               	/* prologue: function */
 332               	/* frame size = 0 */
 333               	/* stack size = 0 */
 334               	.L__stack_usage = 0
 335 0000 0895      		ret
 336               		.cfi_endproc
 337               	.LFE15:
 339               		.section	.text.rgblight_decrease_sat,"ax",@progbits
 340               		.weak	rgblight_decrease_sat
 342               	rgblight_decrease_sat:
 343               	.LFB16:
  37:quantum/rgb.h **** 
  38:quantum/rgb.h **** __attribute__((weak))
  39:quantum/rgb.h **** void rgblight_decrease_sat(void) {};
 344               		.loc 2 39 0
 345               		.cfi_startproc
 346               	/* prologue: function */
 347               	/* frame size = 0 */
 348               	/* stack size = 0 */
 349               	.L__stack_usage = 0
 350 0000 0895      		ret
 351               		.cfi_endproc
 352               	.LFE16:
 354               		.section	.text.rgblight_increase_val,"ax",@progbits
 355               		.weak	rgblight_increase_val
 357               	rgblight_increase_val:
 358               	.LFB17:
  40:quantum/rgb.h **** 
  41:quantum/rgb.h **** __attribute__((weak))
  42:quantum/rgb.h **** void rgblight_increase_val(void) {};
 359               		.loc 2 42 0
 360               		.cfi_startproc
 361               	/* prologue: function */
 362               	/* frame size = 0 */
 363               	/* stack size = 0 */
 364               	.L__stack_usage = 0
 365 0000 0895      		ret
 366               		.cfi_endproc
 367               	.LFE17:
 369               		.section	.text.rgblight_decrease_val,"ax",@progbits
 370               		.weak	rgblight_decrease_val
 372               	rgblight_decrease_val:
 373               	.LFB18:
  43:quantum/rgb.h **** 
  44:quantum/rgb.h **** __attribute__((weak))
  45:quantum/rgb.h **** void rgblight_decrease_val(void) {};
 374               		.loc 2 45 0
 375               		.cfi_startproc
 376               	/* prologue: function */
 377               	/* frame size = 0 */
 378               	/* stack size = 0 */
 379               	.L__stack_usage = 0
 380 0000 0895      		ret
 381               		.cfi_endproc
 382               	.LFE18:
 384               		.section	.text.rgblight_increase_speed,"ax",@progbits
 385               		.weak	rgblight_increase_speed
 387               	rgblight_increase_speed:
 388               	.LFB19:
  46:quantum/rgb.h **** 
  47:quantum/rgb.h **** __attribute__((weak))
  48:quantum/rgb.h **** void rgblight_increase_speed(void) {};
 389               		.loc 2 48 0
 390               		.cfi_startproc
 391               	/* prologue: function */
 392               	/* frame size = 0 */
 393               	/* stack size = 0 */
 394               	.L__stack_usage = 0
 395 0000 0895      		ret
 396               		.cfi_endproc
 397               	.LFE19:
 399               		.section	.text.rgblight_decrease_speed,"ax",@progbits
 400               		.weak	rgblight_decrease_speed
 402               	rgblight_decrease_speed:
 403               	.LFB20:
  49:quantum/rgb.h **** 
  50:quantum/rgb.h **** __attribute__((weak))
  51:quantum/rgb.h **** void rgblight_decrease_speed(void) {};
 404               		.loc 2 51 0
 405               		.cfi_startproc
 406               	/* prologue: function */
 407               	/* frame size = 0 */
 408               	/* stack size = 0 */
 409               	.L__stack_usage = 0
 410 0000 0895      		ret
 411               		.cfi_endproc
 412               	.LFE20:
 414               		.section	.text.register_code16,"ax",@progbits
 415               	.global	register_code16
 417               	register_code16:
 418               	.LFB29:
 110:quantum/quantum.c **** }
 111:quantum/quantum.c **** 
 112:quantum/quantum.c **** void register_code16 (uint16_t code) {
 419               		.loc 1 112 0
 420               		.cfi_startproc
 421               	.LVL30:
 422               		.loc 1 112 0
 423 0000 CF93      		push r28
 424               	.LCFI4:
 425               		.cfi_def_cfa_offset 3
 426               		.cfi_offset 28, -2
 427 0002 DF93      		push r29
 428               	.LCFI5:
 429               		.cfi_def_cfa_offset 4
 430               		.cfi_offset 29, -3
 431               	/* prologue: function */
 432               	/* frame size = 0 */
 433               	/* stack size = 2 */
 434               	.L__stack_usage = 2
 435 0004 EC01      		movw r28,r24
 113:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 436               		.loc 1 113 0
 437 0006 805E      		subi r24,-32
 438 0008 9109      		sbc r25,__zero_reg__
 439               	.LVL31:
 440 000a 0897      		sbiw r24,8
 441 000c 00F0      		brlo .L37
 442               		.loc 1 113 0 is_stmt 0 discriminator 1
 443 000e 2097      		sbiw r28,0
 444 0010 01F4      		brne .L38
 445               	.L37:
 114:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 446               		.loc 1 114 0 is_stmt 1
 447 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 448 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 449 0016 00C0      		rjmp .L40
 450               	.L38:
 115:quantum/quantum.c ****   } else {
 116:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 451               		.loc 1 116 0
 452 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 453 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 454               	.L40:
 455 001c CE01      		movw r24,r28
 456 001e 0E94 0000 		call do_code16
 457               	.LVL32:
 117:quantum/quantum.c ****   }
 118:quantum/quantum.c ****   register_code (code);
 458               		.loc 1 118 0
 459 0022 8C2F      		mov r24,r28
 460               	/* epilogue start */
 119:quantum/quantum.c **** }
 461               		.loc 1 119 0
 462 0024 DF91      		pop r29
 463 0026 CF91      		pop r28
 464               	.LVL33:
 118:quantum/quantum.c ****   register_code (code);
 465               		.loc 1 118 0
 466 0028 0C94 0000 		jmp register_code
 467               	.LVL34:
 468               		.cfi_endproc
 469               	.LFE29:
 471               		.section	.text.unregister_code16,"ax",@progbits
 472               	.global	unregister_code16
 474               	unregister_code16:
 475               	.LFB30:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 476               		.loc 1 121 0
 477               		.cfi_startproc
 478               	.LVL35:
 479 0000 CF93      		push r28
 480               	.LCFI6:
 481               		.cfi_def_cfa_offset 3
 482               		.cfi_offset 28, -2
 483 0002 DF93      		push r29
 484               	.LCFI7:
 485               		.cfi_def_cfa_offset 4
 486               		.cfi_offset 29, -3
 487               	/* prologue: function */
 488               	/* frame size = 0 */
 489               	/* stack size = 2 */
 490               	.L__stack_usage = 2
 491 0004 EC01      		movw r28,r24
 122:quantum/quantum.c ****   unregister_code (code);
 492               		.loc 1 122 0
 493 0006 0E94 0000 		call unregister_code
 494               	.LVL36:
 123:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 495               		.loc 1 123 0
 496 000a CE01      		movw r24,r28
 497 000c 805E      		subi r24,-32
 498 000e 9109      		sbc r25,__zero_reg__
 499 0010 0897      		sbiw r24,8
 500 0012 00F0      		brlo .L42
 501               		.loc 1 123 0 is_stmt 0 discriminator 1
 502 0014 2097      		sbiw r28,0
 503 0016 01F4      		brne .L43
 504               	.L42:
 124:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 505               		.loc 1 124 0 is_stmt 1
 506 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 507 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 508 001c 00C0      		rjmp .L44
 509               	.L43:
 125:quantum/quantum.c ****   } else {
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 510               		.loc 1 126 0
 511 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 512 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 513               	.L44:
 514 0022 CE01      		movw r24,r28
 515               	/* epilogue start */
 127:quantum/quantum.c ****   }
 128:quantum/quantum.c **** }
 516               		.loc 1 128 0
 517 0024 DF91      		pop r29
 518 0026 CF91      		pop r28
 519               	.LVL37:
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 520               		.loc 1 126 0
 521 0028 0C94 0000 		jmp do_code16
 522               	.LVL38:
 523               		.cfi_endproc
 524               	.LFE30:
 526               		.section	.text.process_action_kb,"ax",@progbits
 527               		.weak	process_action_kb
 529               	process_action_kb:
 530               	.LFB31:
 129:quantum/quantum.c **** 
 130:quantum/quantum.c **** __attribute__ ((weak))
 131:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 531               		.loc 1 131 0
 532               		.cfi_startproc
 533               	.LVL39:
 534               	/* prologue: function */
 535               	/* frame size = 0 */
 536               	/* stack size = 0 */
 537               	.L__stack_usage = 0
 132:quantum/quantum.c ****   return true;
 133:quantum/quantum.c **** }
 538               		.loc 1 133 0
 539 0000 81E0      		ldi r24,lo8(1)
 540               	.LVL40:
 541 0002 0895      		ret
 542               		.cfi_endproc
 543               	.LFE31:
 545               		.section	.text.process_record_user,"ax",@progbits
 546               		.weak	process_record_user
 548               	process_record_user:
 549               	.LFB33:
 134:quantum/quantum.c **** 
 135:quantum/quantum.c **** __attribute__ ((weak))
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 138:quantum/quantum.c **** }
 139:quantum/quantum.c **** 
 140:quantum/quantum.c **** __attribute__ ((weak))
 141:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 550               		.loc 1 141 0
 551               		.cfi_startproc
 552               	.LVL41:
 553               	/* prologue: function */
 554               	/* frame size = 0 */
 555               	/* stack size = 0 */
 556               	.L__stack_usage = 0
 142:quantum/quantum.c ****   return true;
 143:quantum/quantum.c **** }
 557               		.loc 1 143 0
 558 0000 81E0      		ldi r24,lo8(1)
 559               	.LVL42:
 560 0002 0895      		ret
 561               		.cfi_endproc
 562               	.LFE33:
 564               		.section	.text.process_record_kb,"ax",@progbits
 565               		.weak	process_record_kb
 567               	process_record_kb:
 568               	.LFB32:
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 569               		.loc 1 136 0
 570               		.cfi_startproc
 571               	.LVL43:
 572               	/* prologue: function */
 573               	/* frame size = 0 */
 574               	/* stack size = 0 */
 575               	.L__stack_usage = 0
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 576               		.loc 1 137 0
 577 0000 0C94 0000 		jmp process_record_user
 578               	.LVL44:
 579               		.cfi_endproc
 580               	.LFE32:
 582               		.section	.text.reset_keyboard,"ax",@progbits
 583               	.global	reset_keyboard
 585               	reset_keyboard:
 586               	.LFB34:
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** void reset_keyboard(void) {
 587               		.loc 1 145 0
 588               		.cfi_startproc
 589               	/* prologue: function */
 590               	/* frame size = 0 */
 591               	/* stack size = 0 */
 592               	.L__stack_usage = 0
 146:quantum/quantum.c ****   clear_keyboard();
 593               		.loc 1 146 0
 594 0000 0E94 0000 		call clear_keyboard
 595               	.LVL45:
 596               	.LBB27:
 597               	.LBB28:
 598               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 599               		.loc 3 164 0
 600 0004 2FEF      		ldi r18,lo8(799999)
 601 0006 84E3      		ldi r24,hi8(799999)
 602 0008 9CE0      		ldi r25,hlo8(799999)
 603 000a 2150      		1: subi r18,1
 604 000c 8040      		sbci r24,0
 605 000e 9040      		sbci r25,0
 606 0010 01F4      		brne 1b
 607 0012 00C0      		rjmp .
 608 0014 0000      		nop
 609               	.LBE28:
 610               	.LBE27:
 147:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 148:quantum/quantum.c ****   process_midi_all_notes_off();
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 151:quantum/quantum.c ****   music_all_notes_off();
 152:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 153:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 154:quantum/quantum.c ****   shutdown_user();
 155:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 156:quantum/quantum.c ****     wait_ms(1);
 157:quantum/quantum.c ****   stop_all_notes();
 158:quantum/quantum.c **** #else
 159:quantum/quantum.c ****   wait_ms(250);
 160:quantum/quantum.c **** #endif
 161:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 162:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 163:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 164:quantum/quantum.c **** #endif
 165:quantum/quantum.c ****   bootloader_jump();
 611               		.loc 1 165 0
 612 0016 0C94 0000 		jmp bootloader_jump
 613               	.LVL46:
 614               		.cfi_endproc
 615               	.LFE34:
 617               		.section	.text.process_record_quantum,"ax",@progbits
 618               	.global	process_record_quantum
 620               	process_record_quantum:
 621               	.LFB35:
 166:quantum/quantum.c **** }
 167:quantum/quantum.c **** 
 168:quantum/quantum.c **** // Shift / paren setup
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** #ifndef LSPO_KEY
 171:quantum/quantum.c ****   #define LSPO_KEY KC_9
 172:quantum/quantum.c **** #endif
 173:quantum/quantum.c **** #ifndef RSPC_KEY
 174:quantum/quantum.c ****   #define RSPC_KEY KC_0
 175:quantum/quantum.c **** #endif
 176:quantum/quantum.c **** 
 177:quantum/quantum.c **** // Shift / Enter setup
 178:quantum/quantum.c **** #ifndef SFTENT_KEY
 179:quantum/quantum.c ****   #define SFTENT_KEY KC_ENT
 180:quantum/quantum.c **** #endif
 181:quantum/quantum.c **** 
 182:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 183:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 184:quantum/quantum.c **** 
 185:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 186:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 187:quantum/quantum.c ****  */
 188:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 622               		.loc 1 190 0
 623               		.cfi_startproc
 624               	.LVL47:
 625 0000 0F93      		push r16
 626               	.LCFI8:
 627               		.cfi_def_cfa_offset 3
 628               		.cfi_offset 16, -2
 629 0002 1F93      		push r17
 630               	.LCFI9:
 631               		.cfi_def_cfa_offset 4
 632               		.cfi_offset 17, -3
 633 0004 CF93      		push r28
 634               	.LCFI10:
 635               		.cfi_def_cfa_offset 5
 636               		.cfi_offset 28, -4
 637 0006 DF93      		push r29
 638               	.LCFI11:
 639               		.cfi_def_cfa_offset 6
 640               		.cfi_offset 29, -5
 641               	/* prologue: function */
 642               	/* frame size = 0 */
 643               	/* stack size = 4 */
 644               	.L__stack_usage = 4
 645 0008 8C01      		movw r16,r24
 191:quantum/quantum.c **** 
 192:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 193:quantum/quantum.c ****   keypos_t key = record->event.key;
 646               		.loc 1 193 0
 647 000a FC01      		movw r30,r24
 648 000c C081      		ld r28,Z
 649 000e D181      		ldd r29,Z+1
 650               	.LVL48:
 194:quantum/quantum.c ****   uint16_t keycode;
 195:quantum/quantum.c **** 
 196:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 197:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 198:quantum/quantum.c ****     if (!disable_action_cache) {
 199:quantum/quantum.c ****       uint8_t layer;
 200:quantum/quantum.c **** 
 201:quantum/quantum.c ****       if (record->event.pressed) {
 202:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 203:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 204:quantum/quantum.c ****       } else {
 205:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 206:quantum/quantum.c ****       }
 207:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 208:quantum/quantum.c ****     } else
 209:quantum/quantum.c ****   #endif
 210:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 651               		.loc 1 210 0
 652 0010 CE01      		movw r24,r28
 653               	.LVL49:
 654 0012 0E94 0000 		call layer_switch_get_layer
 655               	.LVL50:
 656 0016 BE01      		movw r22,r28
 657 0018 0E94 0000 		call keymap_key_to_keycode
 658               	.LVL51:
 659 001c EC01      		movw r28,r24
 660               	.LVL52:
 211:quantum/quantum.c **** 
 212:quantum/quantum.c ****     // This is how you use actions here
 213:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 214:quantum/quantum.c ****     //   action_t action;
 215:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 216:quantum/quantum.c ****     //   process_action(record, action);
 217:quantum/quantum.c ****     //   return false;
 218:quantum/quantum.c ****     // }
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 221:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 661               		.loc 1 221 0
 662 001e B801      		movw r22,r16
 663 0020 0E94 0000 		call preprocess_tap_dance
 664               	.LVL53:
 222:quantum/quantum.c ****   #endif
 223:quantum/quantum.c **** 
 224:quantum/quantum.c ****   if (!(
 225:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 226:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 227:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 228:quantum/quantum.c ****   #endif
 229:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 230:quantum/quantum.c ****       process_clicky(keycode, record) &&
 231:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 665               		.loc 1 232 0
 666 0024 B801      		movw r22,r16
 667 0026 CE01      		movw r24,r28
 668 0028 0E94 0000 		call process_record_kb
 669               	.LVL54:
 233:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 234:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 235:quantum/quantum.c ****   #endif
 236:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 237:quantum/quantum.c ****     process_midi(keycode, record) &&
 238:quantum/quantum.c ****   #endif
 239:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 240:quantum/quantum.c ****     process_audio(keycode, record) &&
 241:quantum/quantum.c ****   #endif
 242:quantum/quantum.c ****   #ifdef STENO_ENABLE
 243:quantum/quantum.c ****     process_steno(keycode, record) &&
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c ****   #if ( defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSI
 246:quantum/quantum.c ****     process_music(keycode, record) &&
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 670               		.loc 1 249 0
 671 002c 8823      		tst r24
 672 002e 01F4      		brne .+2
 673 0030 00C0      		rjmp .L111
 674               		.loc 1 249 0 is_stmt 0 discriminator 2
 675 0032 B801      		movw r22,r16
 676 0034 CE01      		movw r24,r28
 677 0036 0E94 0000 		call process_tap_dance
 678               	.LVL55:
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 679               		.loc 1 232 0 is_stmt 1 discriminator 2
 680 003a 8823      		tst r24
 681 003c 01F4      		brne .+2
 682 003e 00C0      		rjmp .L111
 250:quantum/quantum.c ****   #endif
 251:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 252:quantum/quantum.c ****     process_leader(keycode, record) &&
 683               		.loc 1 252 0
 684 0040 B801      		movw r22,r16
 685 0042 CE01      		movw r24,r28
 686 0044 0E94 0000 		call process_leader
 687               	.LVL56:
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 688               		.loc 1 249 0
 689 0048 8823      		tst r24
 690 004a 01F4      		brne .+2
 691 004c 00C0      		rjmp .L111
 253:quantum/quantum.c ****   #endif
 254:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 255:quantum/quantum.c ****     process_chording(keycode, record) &&
 256:quantum/quantum.c ****   #endif
 257:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 258:quantum/quantum.c ****     process_combo(keycode, record) &&
 259:quantum/quantum.c ****   #endif
 260:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 261:quantum/quantum.c ****     process_unicode(keycode, record) &&
 262:quantum/quantum.c ****   #endif
 263:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 264:quantum/quantum.c ****     process_ucis(keycode, record) &&
 265:quantum/quantum.c ****   #endif
 266:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 267:quantum/quantum.c ****     process_printer(keycode, record) &&
 268:quantum/quantum.c ****   #endif
 269:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 270:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 271:quantum/quantum.c ****   #endif
 272:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 273:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 274:quantum/quantum.c ****   #endif
 275:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 276:quantum/quantum.c ****     process_terminal(keycode, record) &&
 277:quantum/quantum.c ****   #endif
 278:quantum/quantum.c ****       true)) {
 279:quantum/quantum.c ****     return false;
 280:quantum/quantum.c ****   }
 281:quantum/quantum.c **** 
 282:quantum/quantum.c ****   // Shift / paren setup
 283:quantum/quantum.c **** 
 284:quantum/quantum.c ****   switch(keycode) {
 692               		.loc 1 284 0
 693 004e C531      		cpi r28,21
 694 0050 FCE5      		ldi r31,92
 695 0052 DF07      		cpc r29,r31
 696 0054 01F4      		brne .L132
 697               	.LBB29:
 285:quantum/quantum.c ****     case RESET:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 287:quantum/quantum.c ****         reset_keyboard();
 288:quantum/quantum.c ****       }
 289:quantum/quantum.c ****     return false;
 290:quantum/quantum.c ****     case DEBUG:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 292:quantum/quantum.c ****           debug_enable = true;
 293:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 294:quantum/quantum.c ****       }
 295:quantum/quantum.c ****     return false;
 296:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 297:quantum/quantum.c ****   case FC_TOG:
 298:quantum/quantum.c ****     if (record->event.pressed) {
 299:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 300:quantum/quantum.c ****     }
 301:quantum/quantum.c ****     return false;
 302:quantum/quantum.c ****   case FC_ON:
 303:quantum/quantum.c ****     if (record->event.pressed) {
 304:quantum/quantum.c ****       FAUXCLICKY_ON;
 305:quantum/quantum.c ****     }
 306:quantum/quantum.c ****     return false;
 307:quantum/quantum.c ****   case FC_OFF:
 308:quantum/quantum.c ****     if (record->event.pressed) {
 309:quantum/quantum.c ****       FAUXCLICKY_OFF;
 310:quantum/quantum.c ****     }
 311:quantum/quantum.c ****     return false;
 312:quantum/quantum.c ****   #endif
 313:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 314:quantum/quantum.c ****   case RGB_TOG:
 315:quantum/quantum.c ****     if (record->event.pressed) {
 316:quantum/quantum.c ****       rgblight_toggle();
 317:quantum/quantum.c ****     }
 318:quantum/quantum.c ****     return false;
 319:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 320:quantum/quantum.c ****     if (record->event.pressed) {
 321:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 322:quantum/quantum.c ****       if(shifted) {
 323:quantum/quantum.c ****         rgblight_step_reverse();
 324:quantum/quantum.c ****       }
 325:quantum/quantum.c ****       else {
 326:quantum/quantum.c ****         rgblight_step();
 327:quantum/quantum.c ****       }
 328:quantum/quantum.c ****     }
 329:quantum/quantum.c ****     return false;
 330:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 331:quantum/quantum.c ****     if (record->event.pressed) {
 332:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 333:quantum/quantum.c ****       if(shifted) {
 334:quantum/quantum.c ****         rgblight_step();
 335:quantum/quantum.c ****       }
 336:quantum/quantum.c ****       else {
 337:quantum/quantum.c ****         rgblight_step_reverse();
 338:quantum/quantum.c ****       }
 339:quantum/quantum.c ****     }
 340:quantum/quantum.c ****     return false;
 341:quantum/quantum.c ****   case RGB_HUI:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 343:quantum/quantum.c ****       rgblight_increase_hue();
 344:quantum/quantum.c ****     }
 345:quantum/quantum.c ****     return false;
 346:quantum/quantum.c ****   case RGB_HUD:
 347:quantum/quantum.c ****     if (record->event.pressed) {
 348:quantum/quantum.c ****       rgblight_decrease_hue();
 349:quantum/quantum.c ****     }
 350:quantum/quantum.c ****     return false;
 351:quantum/quantum.c ****   case RGB_SAI:
 352:quantum/quantum.c ****     if (record->event.pressed) {
 353:quantum/quantum.c ****       rgblight_increase_sat();
 354:quantum/quantum.c ****     }
 355:quantum/quantum.c ****     return false;
 356:quantum/quantum.c ****   case RGB_SAD:
 357:quantum/quantum.c ****     if (record->event.pressed) {
 358:quantum/quantum.c ****       rgblight_decrease_sat();
 359:quantum/quantum.c ****     }
 360:quantum/quantum.c ****     return false;
 361:quantum/quantum.c ****   case RGB_VAI:
 362:quantum/quantum.c ****     if (record->event.pressed) {
 363:quantum/quantum.c ****       rgblight_increase_val();
 364:quantum/quantum.c ****     }
 365:quantum/quantum.c ****     return false;
 366:quantum/quantum.c ****   case RGB_VAD:
 367:quantum/quantum.c ****     if (record->event.pressed) {
 368:quantum/quantum.c ****       rgblight_decrease_val();
 369:quantum/quantum.c ****     }
 370:quantum/quantum.c ****     return false;
 371:quantum/quantum.c ****   case RGB_SPI:
 372:quantum/quantum.c ****     if (record->event.pressed) {
 373:quantum/quantum.c ****       rgblight_increase_speed();
 374:quantum/quantum.c ****     }
 375:quantum/quantum.c ****     return false;
 376:quantum/quantum.c ****   case RGB_SPD:
 377:quantum/quantum.c ****     if (record->event.pressed) {
 378:quantum/quantum.c ****       rgblight_decrease_speed();
 379:quantum/quantum.c ****     }
 380:quantum/quantum.c ****     return false;
 381:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 382:quantum/quantum.c ****     if (record->event.pressed) {
 383:quantum/quantum.c ****       rgblight_mode(1);
 384:quantum/quantum.c ****     }
 385:quantum/quantum.c ****     return false;
 386:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 387:quantum/quantum.c ****     if (record->event.pressed) {
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 389:quantum/quantum.c ****         rgblight_step();
 390:quantum/quantum.c ****       } else {
 391:quantum/quantum.c ****         rgblight_mode(2);
 392:quantum/quantum.c ****       }
 393:quantum/quantum.c ****     }
 394:quantum/quantum.c ****     return false;
 395:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 396:quantum/quantum.c ****     if (record->event.pressed) {
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 398:quantum/quantum.c ****         rgblight_step();
 399:quantum/quantum.c ****       } else {
 400:quantum/quantum.c ****         rgblight_mode(6);
 401:quantum/quantum.c ****       }
 402:quantum/quantum.c ****     }
 403:quantum/quantum.c ****     return false;
 404:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 405:quantum/quantum.c ****     if (record->event.pressed) {
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 407:quantum/quantum.c ****         rgblight_step();
 408:quantum/quantum.c ****       } else {
 409:quantum/quantum.c ****         rgblight_mode(9);
 410:quantum/quantum.c ****       }
 411:quantum/quantum.c ****     }
 412:quantum/quantum.c ****     return false;
 413:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 414:quantum/quantum.c ****     if (record->event.pressed) {
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 416:quantum/quantum.c ****         rgblight_step();
 417:quantum/quantum.c ****       } else {
 418:quantum/quantum.c ****         rgblight_mode(15);
 419:quantum/quantum.c ****       }
 420:quantum/quantum.c ****     }
 421:quantum/quantum.c ****     return false;
 422:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 423:quantum/quantum.c ****     if (record->event.pressed) {
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 425:quantum/quantum.c ****         rgblight_step();
 426:quantum/quantum.c ****       } else {
 427:quantum/quantum.c ****         rgblight_mode(21);
 428:quantum/quantum.c ****       }
 429:quantum/quantum.c ****     }
 430:quantum/quantum.c ****     return false;
 431:quantum/quantum.c ****   case RGB_MODE_XMAS:
 432:quantum/quantum.c ****     if (record->event.pressed) {
 433:quantum/quantum.c ****       rgblight_mode(24);
 434:quantum/quantum.c ****     }
 435:quantum/quantum.c ****     return false;
 436:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 437:quantum/quantum.c ****     if (record->event.pressed) {
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 439:quantum/quantum.c ****         rgblight_step();
 440:quantum/quantum.c ****       } else {
 441:quantum/quantum.c ****         rgblight_mode(25);
 442:quantum/quantum.c ****       }
 443:quantum/quantum.c ****     }
 444:quantum/quantum.c ****     return false;
 445:quantum/quantum.c ****   #endif
 446:quantum/quantum.c ****     #ifdef PROTOCOL_LUFA
 447:quantum/quantum.c ****     case OUT_AUTO:
 448:quantum/quantum.c ****       if (record->event.pressed) {
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 450:quantum/quantum.c ****       }
 451:quantum/quantum.c ****       return false;
 452:quantum/quantum.c ****     case OUT_USB:
 453:quantum/quantum.c ****       if (record->event.pressed) {
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 455:quantum/quantum.c ****       }
 456:quantum/quantum.c ****       return false;
 457:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 458:quantum/quantum.c ****     case OUT_BT:
 459:quantum/quantum.c ****       if (record->event.pressed) {
 460:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 461:quantum/quantum.c ****       }
 462:quantum/quantum.c ****       return false;
 463:quantum/quantum.c ****     #endif
 464:quantum/quantum.c ****     #endif
 465:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 466:quantum/quantum.c ****       if (record->event.pressed) {
 467:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 468:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 469:quantum/quantum.c ****             eeconfig_init();
 470:quantum/quantum.c ****         }
 471:quantum/quantum.c ****         /* keymap config */
 472:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 473:quantum/quantum.c ****         switch (keycode)
 474:quantum/quantum.c ****         {
 475:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 476:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 477:quantum/quantum.c ****             break;
 478:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 479:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 480:quantum/quantum.c ****             break;
 481:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 482:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 483:quantum/quantum.c ****             break;
 484:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 485:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 486:quantum/quantum.c ****             break;
 487:quantum/quantum.c ****           case MAGIC_NO_GUI:
 488:quantum/quantum.c ****             keymap_config.no_gui = true;
 489:quantum/quantum.c ****             break;
 490:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 491:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 492:quantum/quantum.c ****             break;
 493:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 494:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 495:quantum/quantum.c ****             break;
 496:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 497:quantum/quantum.c ****             keymap_config.nkro = true;
 498:quantum/quantum.c ****             break;
 499:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 500:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 501:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 502:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 503:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 504:quantum/quantum.c ****             #endif
 505:quantum/quantum.c ****             break;
 506:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 507:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 508:quantum/quantum.c ****             break;
 509:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 510:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 511:quantum/quantum.c ****             break;
 512:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 513:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 514:quantum/quantum.c ****             break;
 515:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 516:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 517:quantum/quantum.c ****             break;
 518:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 519:quantum/quantum.c ****             keymap_config.no_gui = false;
 520:quantum/quantum.c ****             break;
 521:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 522:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 523:quantum/quantum.c ****             break;
 524:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 525:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 526:quantum/quantum.c ****             break;
 527:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 528:quantum/quantum.c ****             keymap_config.nkro = false;
 529:quantum/quantum.c ****             break;
 530:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 531:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 532:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 533:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 534:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 535:quantum/quantum.c ****             #endif
 536:quantum/quantum.c ****             break;
 537:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 538:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 539:quantum/quantum.c ****             break;
 540:quantum/quantum.c ****           default:
 541:quantum/quantum.c ****             break;
 542:quantum/quantum.c ****         }
 543:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 544:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 545:quantum/quantum.c **** 
 546:quantum/quantum.c ****         return false;
 547:quantum/quantum.c ****       }
 548:quantum/quantum.c ****       break;
 549:quantum/quantum.c ****     case KC_LSPO: {
 550:quantum/quantum.c ****       if (record->event.pressed) {
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 554:quantum/quantum.c ****       }
 555:quantum/quantum.c ****       else {
 556:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 557:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 558:quantum/quantum.c ****             shift_interrupted[0] = true;
 559:quantum/quantum.c ****             shift_interrupted[1] = true;
 560:quantum/quantum.c ****           }
 561:quantum/quantum.c ****         #endif
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 565:quantum/quantum.c ****         }
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 567:quantum/quantum.c ****       }
 568:quantum/quantum.c ****       return false;
 569:quantum/quantum.c ****     }
 570:quantum/quantum.c **** 
 571:quantum/quantum.c ****     case KC_RSPC: {
 572:quantum/quantum.c ****       if (record->event.pressed) {
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 576:quantum/quantum.c ****       }
 577:quantum/quantum.c ****       else {
 578:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 579:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 580:quantum/quantum.c ****             shift_interrupted[0] = true;
 581:quantum/quantum.c ****             shift_interrupted[1] = true;
 582:quantum/quantum.c ****           }
 583:quantum/quantum.c ****         #endif
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 587:quantum/quantum.c ****         }
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 589:quantum/quantum.c ****       }
 590:quantum/quantum.c ****       return false;
 591:quantum/quantum.c ****     }
 592:quantum/quantum.c **** 
 593:quantum/quantum.c ****     case KC_SFTENT: {
 594:quantum/quantum.c ****       if (record->event.pressed) {
 595:quantum/quantum.c ****         shift_interrupted[1] = false;
 596:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 597:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 598:quantum/quantum.c ****       }
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 603:quantum/quantum.c ****       }
 604:quantum/quantum.c ****       else {
 605:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 606:quantum/quantum.c ****       }
 607:quantum/quantum.c ****       return false;
 608:quantum/quantum.c ****     }
 609:quantum/quantum.c **** 
 610:quantum/quantum.c ****     case GRAVE_ESC: {
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 698               		.loc 1 611 0
 699 0056 0E94 0000 		call get_mods
 700               	.LVL57:
 701 005a 382F      		mov r19,r24
 702               	.LVL58:
 612:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 613:quantum/quantum.c **** 
 614:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 615:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 616:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 617:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 618:quantum/quantum.c ****         shifted = 0;
 619:quantum/quantum.c ****       }
 620:quantum/quantum.c **** #endif
 621:quantum/quantum.c **** 
 622:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 623:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 624:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 625:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 626:quantum/quantum.c ****         shifted = 0;
 627:quantum/quantum.c ****       }
 628:quantum/quantum.c **** #endif
 629:quantum/quantum.c **** 
 630:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 631:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 632:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 633:quantum/quantum.c ****         shifted = 0;
 634:quantum/quantum.c ****       }
 635:quantum/quantum.c **** #endif
 636:quantum/quantum.c **** 
 637:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 638:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 639:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 640:quantum/quantum.c ****         shifted = 0;
 641:quantum/quantum.c ****       }
 642:quantum/quantum.c **** #endif
 643:quantum/quantum.c **** 
 644:quantum/quantum.c ****       if (record->event.pressed) {
 703               		.loc 1 644 0
 704 005c F801      		movw r30,r16
 705 005e 2281      		ldd r18,Z+2
 706 0060 8091 0000 		lds r24,keyboard_report
 707 0064 9091 0000 		lds r25,keyboard_report+1
 708 0068 2223      		tst r18
 709 006a 01F0      		breq .L94
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 710               		.loc 1 611 0
 711 006c 3A7A      		andi r19,lo8(-86)
 712               	.LVL59:
 645:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 713               		.loc 1 645 0
 714 006e 21E0      		ldi r18,lo8(1)
 715 0070 01F4      		brne .L95
 716 0072 20E0      		ldi r18,0
 717               	.L95:
 718 0074 2093 0000 		sts grave_esc_was_shifted,r18
 646:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 719               		.loc 1 646 0
 720 0078 2223      		tst r18
 721 007a 01F0      		breq .L102
 722 007c 65E3      		ldi r22,lo8(53)
 723 007e 00C0      		rjmp .L96
 724               	.L102:
 725 0080 69E2      		ldi r22,lo8(41)
 726               	.L96:
 727               	.LVL60:
 728               	.LBB30:
 729               	.LBB31:
 730               		.file 4 "./tmk_core/common/action_util.h"
   1:./tmk_core/common/action_util.h **** /*
   2:./tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action_util.h **** 
   4:./tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action_util.h **** (at your option) any later version.
   8:./tmk_core/common/action_util.h **** 
   9:./tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:./tmk_core/common/action_util.h **** 
  14:./tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action_util.h **** */
  17:./tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:./tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:./tmk_core/common/action_util.h **** 
  20:./tmk_core/common/action_util.h **** #include <stdint.h>
  21:./tmk_core/common/action_util.h **** #include "report.h"
  22:./tmk_core/common/action_util.h **** 
  23:./tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:./tmk_core/common/action_util.h **** extern "C" {
  25:./tmk_core/common/action_util.h **** #endif
  26:./tmk_core/common/action_util.h **** 
  27:./tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:./tmk_core/common/action_util.h **** 
  29:./tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:./tmk_core/common/action_util.h **** 
  31:./tmk_core/common/action_util.h **** /* key */
  32:./tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 731               		.loc 4 33 0 discriminator 1
 732 0082 0E94 0000 		call add_key_to_report
 733               	.LVL61:
 734 0086 00C0      		rjmp .L97
 735               	.LVL62:
 736               	.L94:
 737               	.LBE31:
 738               	.LBE30:
 647:quantum/quantum.c ****       }
 648:quantum/quantum.c ****       else {
 649:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 739               		.loc 1 649 0
 740 0088 2091 0000 		lds r18,grave_esc_was_shifted
 741 008c 2223      		tst r18
 742 008e 01F0      		breq .L103
 743 0090 65E3      		ldi r22,lo8(53)
 744 0092 00C0      		rjmp .L98
 745               	.L103:
 746 0094 69E2      		ldi r22,lo8(41)
 747               	.L98:
 748               	.LVL63:
 749               	.LBB32:
 750               	.LBB33:
  34:./tmk_core/common/action_util.h **** }
  35:./tmk_core/common/action_util.h **** 
  36:./tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:./tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 751               		.loc 4 37 0 discriminator 3
 752 0096 0E94 0000 		call del_key_from_report
 753               	.LVL64:
 754               	.L97:
 755               	.LBE33:
 756               	.LBE32:
 650:quantum/quantum.c ****       }
 651:quantum/quantum.c **** 
 652:quantum/quantum.c ****       send_keyboard_report();
 757               		.loc 1 652 0
 758 009a 0E94 0000 		call send_keyboard_report
 759               	.LVL65:
 653:quantum/quantum.c ****       return false;
 760               		.loc 1 653 0
 761 009e 00C0      		rjmp .L111
 762               	.L132:
 763               	.LBE29:
 284:quantum/quantum.c ****   switch(keycode) {
 764               		.loc 1 284 0
 765 00a0 C631      		cpi r28,22
 766 00a2 8CE5      		ldi r24,92
 767 00a4 D807      		cpc r29,r24
 768 00a6 00F0      		brlo .+2
 769 00a8 00C0      		rjmp .L100
 770 00aa C130      		cpi r28,1
 771 00ac ECE5      		ldi r30,92
 772 00ae DE07      		cpc r29,r30
 773 00b0 01F4      		brne .L133
 291:quantum/quantum.c ****       if (record->event.pressed) {
 774               		.loc 1 291 0
 775 00b2 F801      		movw r30,r16
 776 00b4 8281      		ldd r24,Z+2
 777 00b6 8823      		tst r24
 778 00b8 01F4      		brne .+2
 779 00ba 00C0      		rjmp .L111
 292:quantum/quantum.c ****           debug_enable = true;
 780               		.loc 1 292 0
 781 00bc 8091 0000 		lds r24,debug_config
 782 00c0 8160      		ori r24,lo8(1<<0)
 783 00c2 8093 0000 		sts debug_config,r24
 784 00c6 00C0      		rjmp .L111
 785               	.L133:
 284:quantum/quantum.c ****   switch(keycode) {
 786               		.loc 1 284 0
 787 00c8 C230      		cpi r28,2
 788 00ca FCE5      		ldi r31,92
 789 00cc DF07      		cpc r29,r31
 790 00ce 00F4      		brsh .+2
 791 00d0 00C0      		rjmp .L134
 466:quantum/quantum.c ****       if (record->event.pressed) {
 792               		.loc 1 466 0
 793 00d2 F801      		movw r30,r16
 794 00d4 8281      		ldd r24,Z+2
 795 00d6 8823      		tst r24
 796 00d8 01F4      		brne .+2
 797 00da 00C0      		rjmp .L58
 468:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 798               		.loc 1 468 0
 799 00dc 0E94 0000 		call eeconfig_is_enabled
 800               	.LVL66:
 801 00e0 8111      		cpse r24,__zero_reg__
 802 00e2 00C0      		rjmp .L59
 469:quantum/quantum.c ****             eeconfig_init();
 803               		.loc 1 469 0
 804 00e4 0E94 0000 		call eeconfig_init
 805               	.LVL67:
 806               	.L59:
 472:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 807               		.loc 1 472 0
 808 00e8 0E94 0000 		call eeconfig_read_keymap
 809               	.LVL68:
 810 00ec 90E0      		ldi r25,0
 811 00ee 9093 0000 		sts keymap_config+1,r25
 812 00f2 8093 0000 		sts keymap_config,r24
 473:quantum/quantum.c ****         switch (keycode)
 813               		.loc 1 473 0
 814 00f6 FE01      		movw r30,r28
 815 00f8 E350      		subi r30,3
 816 00fa FC45      		sbci r31,92
 817 00fc E231      		cpi r30,18
 818 00fe F105      		cpc r31,__zero_reg__
 819 0100 00F4      		brsh .L60
 820 0102 E050      		subi r30,lo8(-(gs(.L62)))
 821 0104 F040      		sbci r31,hi8(-(gs(.L62)))
 822 0106 0C94 0000 		jmp __tablejump2__
 823               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 824               		.p2align	1
 825               	.L62:
 826 0000 0000      		.word gs(.L61)
 827 0002 0000      		.word gs(.L63)
 828 0004 0000      		.word gs(.L64)
 829 0006 0000      		.word gs(.L65)
 830 0008 0000      		.word gs(.L66)
 831 000a 0000      		.word gs(.L67)
 832 000c 0000      		.word gs(.L68)
 833 000e 0000      		.word gs(.L69)
 834 0010 0000      		.word gs(.L70)
 835 0012 0000      		.word gs(.L71)
 836 0014 0000      		.word gs(.L72)
 837 0016 0000      		.word gs(.L73)
 838 0018 0000      		.word gs(.L74)
 839 001a 0000      		.word gs(.L75)
 840 001c 0000      		.word gs(.L76)
 841 001e 0000      		.word gs(.L77)
 842 0020 0000      		.word gs(.L78)
 843 0022 0000      		.word gs(.L79)
 844               		.section	.text.process_record_quantum
 845               	.L60:
 476:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 846               		.loc 1 476 0
 847 010a 8091 0000 		lds r24,keymap_config
 848 010e 8160      		ori r24,lo8(1<<0)
 849 0110 00C0      		rjmp .L126
 850               	.L61:
 479:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 851               		.loc 1 479 0
 852 0112 8091 0000 		lds r24,keymap_config
 853 0116 8260      		ori r24,lo8(1<<1)
 854               	.L126:
 855 0118 8093 0000 		sts keymap_config,r24
 480:quantum/quantum.c ****             break;
 856               		.loc 1 480 0
 857 011c 00C0      		rjmp .L80
 858               	.L63:
 482:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 859               		.loc 1 482 0
 860 011e 8091 0000 		lds r24,keymap_config
 861 0122 8460      		ori r24,lo8(1<<2)
 862 0124 00C0      		rjmp .L126
 863               	.L64:
 485:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 864               		.loc 1 485 0
 865 0126 8091 0000 		lds r24,keymap_config
 866 012a 00C0      		rjmp .L131
 867               	.L65:
 488:quantum/quantum.c ****             keymap_config.no_gui = true;
 868               		.loc 1 488 0
 869 012c 8091 0000 		lds r24,keymap_config
 870 0130 8061      		ori r24,lo8(1<<4)
 871 0132 00C0      		rjmp .L126
 872               	.L66:
 491:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 873               		.loc 1 491 0
 874 0134 8091 0000 		lds r24,keymap_config
 875 0138 8062      		ori r24,lo8(1<<5)
 876 013a 00C0      		rjmp .L126
 877               	.L67:
 494:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 878               		.loc 1 494 0
 879 013c 8091 0000 		lds r24,keymap_config
 880 0140 8064      		ori r24,lo8(1<<6)
 881 0142 00C0      		rjmp .L126
 882               	.L68:
 497:quantum/quantum.c ****             keymap_config.nkro = true;
 883               		.loc 1 497 0
 884 0144 8091 0000 		lds r24,keymap_config
 885 0148 8068      		ori r24,lo8(1<<7)
 886 014a 00C0      		rjmp .L126
 887               	.L69:
 500:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 888               		.loc 1 500 0
 889 014c 8091 0000 		lds r24,keymap_config
 501:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 890               		.loc 1 501 0
 891 0150 8460      		ori r24,lo8(4)
 892               	.L131:
 893 0152 8860      		ori r24,lo8(1<<3)
 894 0154 00C0      		rjmp .L126
 895               	.L70:
 507:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 896               		.loc 1 507 0
 897 0156 8091 0000 		lds r24,keymap_config
 898 015a 8E7F      		andi r24,lo8(~(1<<0))
 899 015c 00C0      		rjmp .L126
 900               	.L71:
 510:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 901               		.loc 1 510 0
 902 015e 8091 0000 		lds r24,keymap_config
 903 0162 8D7F      		andi r24,lo8(~(1<<1))
 904 0164 00C0      		rjmp .L126
 905               	.L72:
 513:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 906               		.loc 1 513 0
 907 0166 8091 0000 		lds r24,keymap_config
 908 016a 8B7F      		andi r24,lo8(~(1<<2))
 909 016c 00C0      		rjmp .L126
 910               	.L73:
 516:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 911               		.loc 1 516 0
 912 016e 8091 0000 		lds r24,keymap_config
 913 0172 00C0      		rjmp .L130
 914               	.L74:
 519:quantum/quantum.c ****             keymap_config.no_gui = false;
 915               		.loc 1 519 0
 916 0174 8091 0000 		lds r24,keymap_config
 917 0178 8F7E      		andi r24,lo8(~(1<<4))
 918 017a 00C0      		rjmp .L126
 919               	.L75:
 522:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 920               		.loc 1 522 0
 921 017c 8091 0000 		lds r24,keymap_config
 922 0180 8F7D      		andi r24,lo8(~(1<<5))
 923 0182 00C0      		rjmp .L126
 924               	.L76:
 525:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 925               		.loc 1 525 0
 926 0184 8091 0000 		lds r24,keymap_config
 927 0188 8F7B      		andi r24,lo8(~(1<<6))
 928 018a 00C0      		rjmp .L126
 929               	.L77:
 528:quantum/quantum.c ****             keymap_config.nkro = false;
 930               		.loc 1 528 0
 931 018c 8091 0000 		lds r24,keymap_config
 932 0190 8F77      		andi r24,lo8(~(1<<7))
 933 0192 00C0      		rjmp .L126
 934               	.L78:
 531:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 935               		.loc 1 531 0
 936 0194 8091 0000 		lds r24,keymap_config
 532:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 937               		.loc 1 532 0
 938 0198 8B7F      		andi r24,lo8(-5)
 939               	.L130:
 940 019a 877F      		andi r24,lo8(~(1<<3))
 941 019c 00C0      		rjmp .L126
 942               	.L79:
 538:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 943               		.loc 1 538 0
 944 019e 9091 0000 		lds r25,keymap_config
 945 01a2 97FB      		bst r25,7
 946 01a4 8827      		clr r24
 947 01a6 80F9      		bld r24,0
 948 01a8 21E0      		ldi r18,lo8(1)
 949 01aa 8227      		eor r24,r18
 950 01ac 80FB      		bst r24,0
 951 01ae 97F9      		bld r25,7
 952 01b0 9093 0000 		sts keymap_config,r25
 953               	.L80:
 543:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 954               		.loc 1 543 0
 955 01b4 8091 0000 		lds r24,keymap_config
 956 01b8 0E94 0000 		call eeconfig_update_keymap
 957               	.LVL69:
 544:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 958               		.loc 1 544 0
 959 01bc 0E94 0000 		call clear_keyboard
 960               	.LVL70:
 546:quantum/quantum.c ****         return false;
 961               		.loc 1 546 0
 962 01c0 00C0      		rjmp .L111
 963               	.L134:
 284:quantum/quantum.c ****   switch(keycode) {
 964               		.loc 1 284 0
 965 01c2 C115      		cp r28,__zero_reg__
 966 01c4 DC45      		sbci r29,92
 967 01c6 01F0      		breq .L52
 968               	.L99:
 654:quantum/quantum.c ****     }
 655:quantum/quantum.c **** 
 656:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 657:quantum/quantum.c ****     case BL_BRTG: {
 658:quantum/quantum.c ****       if (record->event.pressed)
 659:quantum/quantum.c ****         breathing_toggle();
 660:quantum/quantum.c ****       return false;
 661:quantum/quantum.c ****     }
 662:quantum/quantum.c **** #endif
 663:quantum/quantum.c **** 
 664:quantum/quantum.c ****     default: {
 665:quantum/quantum.c ****       shift_interrupted[0] = true;
 969               		.loc 1 665 0
 970 01c8 81E0      		ldi r24,lo8(1)
 971 01ca 8093 0000 		sts shift_interrupted,r24
 666:quantum/quantum.c ****       shift_interrupted[1] = true;
 972               		.loc 1 666 0
 973 01ce 8093 0000 		sts shift_interrupted+1,r24
 974               	.L58:
 667:quantum/quantum.c ****       break;
 668:quantum/quantum.c ****     }
 669:quantum/quantum.c ****   }
 670:quantum/quantum.c **** 
 671:quantum/quantum.c ****   return process_action_kb(record);
 975               		.loc 1 671 0
 976 01d2 C801      		movw r24,r16
 977               	/* epilogue start */
 672:quantum/quantum.c **** }
 978               		.loc 1 672 0
 979 01d4 DF91      		pop r29
 980 01d6 CF91      		pop r28
 981               	.LVL71:
 982 01d8 1F91      		pop r17
 983 01da 0F91      		pop r16
 984               	.LVL72:
 671:quantum/quantum.c ****   return process_action_kb(record);
 985               		.loc 1 671 0
 986 01dc 0C94 0000 		jmp process_action_kb
 987               	.LVL73:
 988               	.L52:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 989               		.loc 1 286 0
 990 01e0 F801      		movw r30,r16
 991 01e2 8281      		ldd r24,Z+2
 992 01e4 8823      		tst r24
 993 01e6 01F4      		brne .+2
 994 01e8 00C0      		rjmp .L111
 287:quantum/quantum.c ****         reset_keyboard();
 995               		.loc 1 287 0
 996 01ea 0E94 0000 		call reset_keyboard
 997               	.LVL74:
 998 01ee 00C0      		rjmp .L111
 999               	.L100:
 284:quantum/quantum.c ****   switch(keycode) {
 1000               		.loc 1 284 0
 1001 01f0 C53D      		cpi r28,-43
 1002 01f2 ECE5      		ldi r30,92
 1003 01f4 DE07      		cpc r29,r30
 1004 01f6 01F4      		brne .L135
 594:quantum/quantum.c ****       if (record->event.pressed) {
 1005               		.loc 1 594 0
 1006 01f8 F801      		movw r30,r16
 1007 01fa 8281      		ldd r24,Z+2
 1008 01fc 8823      		tst r24
 1009 01fe 01F0      		breq .L136
 1010               	.L92:
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 1011               		.loc 1 573 0
 1012 0200 1092 0000 		sts shift_interrupted+1,__zero_reg__
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 1013               		.loc 1 574 0
 1014 0204 0E94 0000 		call timer_read
 1015               	.LVL75:
 1016 0208 9093 0000 		sts scs_timer+2+1,r25
 1017 020c 8093 0000 		sts scs_timer+2,r24
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 1018               		.loc 1 575 0
 1019 0210 80E2      		ldi r24,lo8(32)
 1020               	.L128:
 1021 0212 0E94 0000 		call register_mods
 1022               	.LVL76:
 1023 0216 00C0      		rjmp .L111
 1024               	.L136:
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1025               		.loc 1 599 0
 1026 0218 8091 0000 		lds r24,shift_interrupted+1
 1027 021c 8823      		tst r24
 1028 021e 01F0      		breq .L137
 1029               	.L89:
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1030               		.loc 1 588 0
 1031 0220 80E2      		ldi r24,lo8(32)
 1032               	.L129:
 1033 0222 0E94 0000 		call unregister_mods
 1034               	.LVL77:
 1035 0226 00C0      		rjmp .L111
 1036               	.L137:
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1037               		.loc 1 599 0 discriminator 1
 1038 0228 8091 0000 		lds r24,scs_timer+2
 1039 022c 9091 0000 		lds r25,scs_timer+2+1
 1040 0230 0E94 0000 		call timer_elapsed
 1041               	.LVL78:
 1042 0234 8639      		cpi r24,-106
 1043 0236 9105      		cpc r25,__zero_reg__
 1044 0238 00F4      		brsh .L89
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1045               		.loc 1 600 0
 1046 023a 80E2      		ldi r24,lo8(32)
 1047 023c 0E94 0000 		call unregister_mods
 1048               	.LVL79:
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 1049               		.loc 1 601 0
 1050 0240 88E2      		ldi r24,lo8(40)
 1051 0242 0E94 0000 		call register_code
 1052               	.LVL80:
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 1053               		.loc 1 602 0
 1054 0246 88E2      		ldi r24,lo8(40)
 1055 0248 0E94 0000 		call unregister_code
 1056               	.LVL81:
 1057 024c 00C0      		rjmp .L111
 1058               	.L135:
 284:quantum/quantum.c ****   switch(keycode) {
 1059               		.loc 1 284 0
 1060 024e C63D      		cpi r28,-42
 1061 0250 FCE5      		ldi r31,92
 1062 0252 DF07      		cpc r29,r31
 1063 0254 00F0      		brlo .+2
 1064 0256 00C0      		rjmp .L101
 1065 0258 C33D      		cpi r28,-45
 1066 025a 8CE5      		ldi r24,92
 1067 025c D807      		cpc r29,r24
 1068 025e 01F4      		brne .L138
 550:quantum/quantum.c ****       if (record->event.pressed) {
 1069               		.loc 1 550 0
 1070 0260 F801      		movw r30,r16
 1071 0262 8281      		ldd r24,Z+2
 1072 0264 8823      		tst r24
 1073 0266 01F0      		breq .L82
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 1074               		.loc 1 551 0
 1075 0268 1092 0000 		sts shift_interrupted,__zero_reg__
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 1076               		.loc 1 552 0
 1077 026c 0E94 0000 		call timer_read
 1078               	.LVL82:
 1079 0270 9093 0000 		sts scs_timer+1,r25
 1080 0274 8093 0000 		sts scs_timer,r24
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 1081               		.loc 1 553 0
 1082 0278 82E0      		ldi r24,lo8(2)
 1083 027a 00C0      		rjmp .L128
 1084               	.L82:
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 1085               		.loc 1 562 0
 1086 027c 8091 0000 		lds r24,shift_interrupted
 1087 0280 8111      		cpse r24,__zero_reg__
 1088 0282 00C0      		rjmp .L84
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 1089               		.loc 1 562 0 is_stmt 0 discriminator 1
 1090 0284 8091 0000 		lds r24,scs_timer
 1091 0288 9091 0000 		lds r25,scs_timer+1
 1092 028c 0E94 0000 		call timer_elapsed
 1093               	.LVL83:
 1094 0290 8639      		cpi r24,-106
 1095 0292 9105      		cpc r25,__zero_reg__
 1096 0294 00F4      		brsh .L84
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 1097               		.loc 1 563 0 is_stmt 1
 1098 0296 86E2      		ldi r24,lo8(38)
 1099 0298 0E94 0000 		call register_code
 1100               	.LVL84:
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 1101               		.loc 1 564 0
 1102 029c 86E2      		ldi r24,lo8(38)
 1103 029e 0E94 0000 		call unregister_code
 1104               	.LVL85:
 1105               	.L84:
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 1106               		.loc 1 566 0
 1107 02a2 82E0      		ldi r24,lo8(2)
 1108 02a4 00C0      		rjmp .L129
 1109               	.L138:
 284:quantum/quantum.c ****   switch(keycode) {
 1110               		.loc 1 284 0
 1111 02a6 C43D      		cpi r28,-44
 1112 02a8 DC45      		sbci r29,92
 1113 02aa 01F0      		breq .+2
 1114 02ac 00C0      		rjmp .L99
 572:quantum/quantum.c ****       if (record->event.pressed) {
 1115               		.loc 1 572 0
 1116 02ae F801      		movw r30,r16
 1117 02b0 8281      		ldd r24,Z+2
 1118 02b2 8111      		cpse r24,__zero_reg__
 1119 02b4 00C0      		rjmp .L92
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1120               		.loc 1 584 0
 1121 02b6 8091 0000 		lds r24,shift_interrupted+1
 1122 02ba 8111      		cpse r24,__zero_reg__
 1123 02bc 00C0      		rjmp .L89
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 1124               		.loc 1 584 0 is_stmt 0 discriminator 1
 1125 02be 8091 0000 		lds r24,scs_timer+2
 1126 02c2 9091 0000 		lds r25,scs_timer+2+1
 1127 02c6 0E94 0000 		call timer_elapsed
 1128               	.LVL86:
 1129 02ca 8639      		cpi r24,-106
 1130 02cc 9105      		cpc r25,__zero_reg__
 1131 02ce 00F0      		brlo .+2
 1132 02d0 00C0      		rjmp .L89
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 1133               		.loc 1 585 0 is_stmt 1
 1134 02d2 87E2      		ldi r24,lo8(39)
 1135 02d4 0E94 0000 		call register_code
 1136               	.LVL87:
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 1137               		.loc 1 586 0
 1138 02d8 87E2      		ldi r24,lo8(39)
 1139 02da 0E94 0000 		call unregister_code
 1140               	.LVL88:
 1141 02de 00C0      		rjmp .L89
 1142               	.L101:
 284:quantum/quantum.c ****   switch(keycode) {
 1143               		.loc 1 284 0
 1144 02e0 C83D      		cpi r28,-40
 1145 02e2 FCE5      		ldi r31,92
 1146 02e4 DF07      		cpc r29,r31
 1147 02e6 01F4      		brne .L139
 448:quantum/quantum.c ****       if (record->event.pressed) {
 1148               		.loc 1 448 0
 1149 02e8 F801      		movw r30,r16
 1150 02ea 8281      		ldd r24,Z+2
 1151 02ec 8823      		tst r24
 1152 02ee 01F0      		breq .L111
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 1153               		.loc 1 449 0
 1154 02f0 80E0      		ldi r24,0
 1155 02f2 00C0      		rjmp .L127
 1156               	.L139:
 284:quantum/quantum.c ****   switch(keycode) {
 1157               		.loc 1 284 0
 1158 02f4 C93D      		cpi r28,-39
 1159 02f6 DC45      		sbci r29,92
 1160 02f8 01F0      		breq .+2
 1161 02fa 00C0      		rjmp .L99
 453:quantum/quantum.c ****       if (record->event.pressed) {
 1162               		.loc 1 453 0
 1163 02fc F801      		movw r30,r16
 1164 02fe 8281      		ldd r24,Z+2
 1165 0300 8823      		tst r24
 1166 0302 01F0      		breq .L111
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 1167               		.loc 1 454 0
 1168 0304 82E0      		ldi r24,lo8(2)
 1169               	.L127:
 1170 0306 0E94 0000 		call set_output
 1171               	.LVL89:
 1172               	.L111:
 1173               		.loc 1 672 0
 1174 030a 80E0      		ldi r24,0
 1175               	/* epilogue start */
 1176 030c DF91      		pop r29
 1177 030e CF91      		pop r28
 1178               	.LVL90:
 1179 0310 1F91      		pop r17
 1180 0312 0F91      		pop r16
 1181               	.LVL91:
 1182 0314 0895      		ret
 1183               		.cfi_endproc
 1184               	.LFE35:
 1186               		.section	.text.send_char,"ax",@progbits
 1187               	.global	send_char
 1189               	send_char:
 1190               	.LFB40:
 673:quantum/quantum.c **** 
 674:quantum/quantum.c **** __attribute__ ((weak))
 675:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 676:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 677:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 678:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 679:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 680:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 681:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 682:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 683:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 684:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 685:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 686:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 687:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 688:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 689:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 690:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 691:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 692:quantum/quantum.c **** };
 693:quantum/quantum.c **** 
 694:quantum/quantum.c **** __attribute__ ((weak))
 695:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 696:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 697:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 698:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 699:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 700:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 701:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 702:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 703:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 704:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 705:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 706:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 707:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 708:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 709:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 710:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 711:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 712:quantum/quantum.c **** };
 713:quantum/quantum.c **** 
 714:quantum/quantum.c **** void send_string(const char *str) {
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 716:quantum/quantum.c **** }
 717:quantum/quantum.c **** 
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 720:quantum/quantum.c **** }
 721:quantum/quantum.c **** 
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 723:quantum/quantum.c ****     while (1) {
 724:quantum/quantum.c ****         char ascii_code = *str;
 725:quantum/quantum.c ****         if (!ascii_code) break;
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 727:quantum/quantum.c ****           // tap
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 729:quantum/quantum.c ****           register_code(keycode);
 730:quantum/quantum.c ****           unregister_code(keycode);
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 732:quantum/quantum.c ****           // down
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 734:quantum/quantum.c ****           register_code(keycode);
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 736:quantum/quantum.c ****           // up
 737:quantum/quantum.c ****           uint8_t keycode = *(++str);
 738:quantum/quantum.c ****           unregister_code(keycode);
 739:quantum/quantum.c ****         } else {
 740:quantum/quantum.c ****           send_char(ascii_code);
 741:quantum/quantum.c ****         }
 742:quantum/quantum.c ****         ++str;
 743:quantum/quantum.c ****         // interval
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 745:quantum/quantum.c ****     }
 746:quantum/quantum.c **** }
 747:quantum/quantum.c **** 
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 749:quantum/quantum.c ****     while (1) {
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 751:quantum/quantum.c ****         if (!ascii_code) break;
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 753:quantum/quantum.c ****           // tap
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 755:quantum/quantum.c ****           register_code(keycode);
 756:quantum/quantum.c ****           unregister_code(keycode);
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 758:quantum/quantum.c ****           // down
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 760:quantum/quantum.c ****           register_code(keycode);
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 762:quantum/quantum.c ****           // up
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 764:quantum/quantum.c ****           unregister_code(keycode);
 765:quantum/quantum.c ****         } else {
 766:quantum/quantum.c ****           send_char(ascii_code);
 767:quantum/quantum.c ****         }
 768:quantum/quantum.c ****         ++str;
 769:quantum/quantum.c ****         // interval
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 771:quantum/quantum.c ****     }
 772:quantum/quantum.c **** }
 773:quantum/quantum.c **** 
 774:quantum/quantum.c **** void send_char(char ascii_code) {
 1191               		.loc 1 774 0
 1192               		.cfi_startproc
 1193               	.LVL92:
 1194 0000 CF93      		push r28
 1195               	.LCFI12:
 1196               		.cfi_def_cfa_offset 3
 1197               		.cfi_offset 28, -2
 1198               	/* prologue: function */
 1199               	/* frame size = 0 */
 1200               	/* stack size = 1 */
 1201               	.L__stack_usage = 1
 1202               	.LBB34:
 775:quantum/quantum.c ****   uint8_t keycode;
 776:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 1203               		.loc 1 776 0
 1204 0002 282F      		mov r18,r24
 1205 0004 30E0      		ldi r19,0
 1206               	.LVL93:
 1207 0006 F901      		movw r30,r18
 1208 0008 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 1209 000a F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 1210               	.LVL94:
 1211               	/* #APP */
 1212               	 ;  776 "quantum/quantum.c" 1
 1213 000c C491      		lpm r28, Z
 1214               		
 1215               	 ;  0 "" 2
 1216               	.LVL95:
 1217               	/* #NOAPP */
 1218               	.LBE34:
 1219               	.LBB35:
 777:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 1220               		.loc 1 777 0
 1221 000e F901      		movw r30,r18
 1222               	.LVL96:
 1223 0010 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 1224 0012 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 1225               	.LVL97:
 1226               	/* #APP */
 1227               	 ;  777 "quantum/quantum.c" 1
 1228 0014 2491      		lpm r18, Z
 1229               		
 1230               	 ;  0 "" 2
 1231               	.LVL98:
 1232               	/* #NOAPP */
 1233               	.LBE35:
 1234 0016 2223      		tst r18
 1235 0018 01F0      		breq .L141
 778:quantum/quantum.c ****       register_code(KC_LSFT);
 1236               		.loc 1 778 0
 1237 001a 81EE      		ldi r24,lo8(-31)
 1238               	.LVL99:
 1239 001c 0E94 0000 		call register_code
 1240               	.LVL100:
 779:quantum/quantum.c ****       register_code(keycode);
 1241               		.loc 1 779 0
 1242 0020 8C2F      		mov r24,r28
 1243 0022 0E94 0000 		call register_code
 1244               	.LVL101:
 780:quantum/quantum.c ****       unregister_code(keycode);
 1245               		.loc 1 780 0
 1246 0026 8C2F      		mov r24,r28
 1247 0028 0E94 0000 		call unregister_code
 1248               	.LVL102:
 781:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1249               		.loc 1 781 0
 1250 002c 81EE      		ldi r24,lo8(-31)
 1251 002e 00C0      		rjmp .L142
 1252               	.LVL103:
 1253               	.L141:
 782:quantum/quantum.c ****   } else {
 783:quantum/quantum.c ****       register_code(keycode);
 1254               		.loc 1 783 0
 1255 0030 8C2F      		mov r24,r28
 1256               	.LVL104:
 1257 0032 0E94 0000 		call register_code
 1258               	.LVL105:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1259               		.loc 1 784 0
 1260 0036 8C2F      		mov r24,r28
 1261               	.L142:
 1262               	/* epilogue start */
 785:quantum/quantum.c ****   }
 786:quantum/quantum.c **** }
 1263               		.loc 1 786 0
 1264 0038 CF91      		pop r28
 1265               	.LVL106:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1266               		.loc 1 784 0
 1267 003a 0C94 0000 		jmp unregister_code
 1268               	.LVL107:
 1269               		.cfi_endproc
 1270               	.LFE40:
 1272               		.section	.text.send_string_with_delay,"ax",@progbits
 1273               	.global	send_string_with_delay
 1275               	send_string_with_delay:
 1276               	.LFB38:
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 1277               		.loc 1 722 0
 1278               		.cfi_startproc
 1279               	.LVL108:
 1280 0000 FF92      		push r15
 1281               	.LCFI13:
 1282               		.cfi_def_cfa_offset 3
 1283               		.cfi_offset 15, -2
 1284 0002 0F93      		push r16
 1285               	.LCFI14:
 1286               		.cfi_def_cfa_offset 4
 1287               		.cfi_offset 16, -3
 1288 0004 1F93      		push r17
 1289               	.LCFI15:
 1290               		.cfi_def_cfa_offset 5
 1291               		.cfi_offset 17, -4
 1292 0006 CF93      		push r28
 1293               	.LCFI16:
 1294               		.cfi_def_cfa_offset 6
 1295               		.cfi_offset 28, -5
 1296 0008 DF93      		push r29
 1297               	.LCFI17:
 1298               		.cfi_def_cfa_offset 7
 1299               		.cfi_offset 29, -6
 1300               	/* prologue: function */
 1301               	/* frame size = 0 */
 1302               	/* stack size = 5 */
 1303               	.L__stack_usage = 5
 1304 000a EC01      		movw r28,r24
 1305 000c F62E      		mov r15,r22
 1306               	.LVL109:
 1307               	.L151:
 1308               	.LBB36:
 724:quantum/quantum.c ****         char ascii_code = *str;
 1309               		.loc 1 724 0
 1310 000e 8881      		ld r24,Y
 1311               	.LVL110:
 725:quantum/quantum.c ****         if (!ascii_code) break;
 1312               		.loc 1 725 0
 1313 0010 8823      		tst r24
 1314 0012 01F0      		breq .L143
 1315 0014 8E01      		movw r16,r28
 1316 0016 0F5F      		subi r16,-1
 1317 0018 1F4F      		sbci r17,-1
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 1318               		.loc 1 726 0
 1319 001a 8130      		cpi r24,lo8(1)
 1320 001c 01F4      		brne .L145
 1321               	.LVL111:
 1322               	.LBB37:
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 1323               		.loc 1 728 0
 1324 001e C981      		ldd r28,Y+1
 1325               	.LVL112:
 729:quantum/quantum.c ****           register_code(keycode);
 1326               		.loc 1 729 0
 1327 0020 8C2F      		mov r24,r28
 1328               	.LVL113:
 1329 0022 0E94 0000 		call register_code
 1330               	.LVL114:
 730:quantum/quantum.c ****           unregister_code(keycode);
 1331               		.loc 1 730 0
 1332 0026 8C2F      		mov r24,r28
 1333 0028 00C0      		rjmp .L153
 1334               	.LVL115:
 1335               	.L145:
 1336               	.LBE37:
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1337               		.loc 1 731 0
 1338 002a 8230      		cpi r24,lo8(2)
 1339 002c 01F4      		brne .L147
 1340               	.LVL116:
 1341               	.LBB38:
 734:quantum/quantum.c ****           register_code(keycode);
 1342               		.loc 1 734 0
 1343 002e 8981      		ldd r24,Y+1
 1344               	.LVL117:
 1345 0030 0E94 0000 		call register_code
 1346               	.LVL118:
 1347               	.L152:
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 1348               		.loc 1 733 0
 1349 0034 E801      		movw r28,r16
 1350               	.LBE38:
 1351 0036 00C0      		rjmp .L146
 1352               	.LVL119:
 1353               	.L147:
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1354               		.loc 1 735 0
 1355 0038 8330      		cpi r24,lo8(3)
 1356 003a 01F4      		brne .L148
 1357               	.LVL120:
 1358               	.LBB39:
 738:quantum/quantum.c ****           unregister_code(keycode);
 1359               		.loc 1 738 0
 1360 003c 8981      		ldd r24,Y+1
 1361               	.LVL121:
 1362               	.L153:
 1363 003e 0E94 0000 		call unregister_code
 1364               	.LVL122:
 1365 0042 00C0      		rjmp .L152
 1366               	.LVL123:
 1367               	.L148:
 1368               	.LBE39:
 740:quantum/quantum.c ****           send_char(ascii_code);
 1369               		.loc 1 740 0
 1370 0044 0E94 0000 		call send_char
 1371               	.LVL124:
 1372               	.L146:
 742:quantum/quantum.c ****         ++str;
 1373               		.loc 1 742 0
 1374 0048 2196      		adiw r28,1
 1375               	.LVL125:
 1376               	.LBB40:
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1377               		.loc 1 744 0
 1378 004a 8F2D      		mov r24,r15
 1379               	.LVL126:
 1380               	.L149:
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1381               		.loc 1 744 0 is_stmt 0 discriminator 1
 1382 004c 8823      		tst r24
 1383 004e 01F0      		breq .L151
 1384               	.LVL127:
 1385               	.LBB41:
 1386               	.LBB42:
 1387               		.loc 3 164 0 is_stmt 1
 1388 0050 EFE9      		ldi r30,lo8(3999)
 1389 0052 FFE0      		ldi r31,hi8(3999)
 1390 0054 3197      		1: sbiw r30,1
 1391 0056 01F4      		brne 1b
 1392 0058 00C0      		rjmp .
 1393 005a 0000      		nop
 1394 005c 8150      		subi r24,lo8(-(-1))
 1395               	.LVL128:
 1396 005e 00C0      		rjmp .L149
 1397               	.LVL129:
 1398               	.L143:
 1399               	/* epilogue start */
 1400               	.LBE42:
 1401               	.LBE41:
 1402               	.LBE40:
 1403               	.LBE36:
 746:quantum/quantum.c **** }
 1404               		.loc 1 746 0
 1405 0060 DF91      		pop r29
 1406 0062 CF91      		pop r28
 1407               	.LVL130:
 1408 0064 1F91      		pop r17
 1409 0066 0F91      		pop r16
 1410 0068 FF90      		pop r15
 1411               	.LVL131:
 1412 006a 0895      		ret
 1413               		.cfi_endproc
 1414               	.LFE38:
 1416               		.section	.text.send_string,"ax",@progbits
 1417               	.global	send_string
 1419               	send_string:
 1420               	.LFB36:
 714:quantum/quantum.c **** void send_string(const char *str) {
 1421               		.loc 1 714 0
 1422               		.cfi_startproc
 1423               	.LVL132:
 1424               	/* prologue: function */
 1425               	/* frame size = 0 */
 1426               	/* stack size = 0 */
 1427               	.L__stack_usage = 0
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 1428               		.loc 1 715 0
 1429 0000 60E0      		ldi r22,0
 1430 0002 0C94 0000 		jmp send_string_with_delay
 1431               	.LVL133:
 1432               		.cfi_endproc
 1433               	.LFE36:
 1435               		.section	.text.send_string_with_delay_P,"ax",@progbits
 1436               	.global	send_string_with_delay_P
 1438               	send_string_with_delay_P:
 1439               	.LFB39:
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 1440               		.loc 1 748 0
 1441               		.cfi_startproc
 1442               	.LVL134:
 1443 0000 0F93      		push r16
 1444               	.LCFI18:
 1445               		.cfi_def_cfa_offset 3
 1446               		.cfi_offset 16, -2
 1447 0002 1F93      		push r17
 1448               	.LCFI19:
 1449               		.cfi_def_cfa_offset 4
 1450               		.cfi_offset 17, -3
 1451 0004 CF93      		push r28
 1452               	.LCFI20:
 1453               		.cfi_def_cfa_offset 5
 1454               		.cfi_offset 28, -4
 1455 0006 DF93      		push r29
 1456               	.LCFI21:
 1457               		.cfi_def_cfa_offset 6
 1458               		.cfi_offset 29, -5
 1459               	/* prologue: function */
 1460               	/* frame size = 0 */
 1461               	/* stack size = 4 */
 1462               	.L__stack_usage = 4
 1463 0008 EC01      		movw r28,r24
 1464 000a 062F      		mov r16,r22
 1465               	.LVL135:
 1466               	.L163:
 1467               	.LBB43:
 1468               	.LBB44:
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 1469               		.loc 1 750 0
 1470 000c FE01      		movw r30,r28
 1471               	/* #APP */
 1472               	 ;  750 "quantum/quantum.c" 1
 1473 000e 8491      		lpm r24, Z
 1474               		
 1475               	 ;  0 "" 2
 1476               	.LVL136:
 1477               	/* #NOAPP */
 1478               	.LBE44:
 751:quantum/quantum.c ****         if (!ascii_code) break;
 1479               		.loc 1 751 0
 1480 0010 8823      		tst r24
 1481 0012 01F0      		breq .L155
 1482 0014 9E01      		movw r18,r28
 1483 0016 2F5F      		subi r18,-1
 1484 0018 3F4F      		sbci r19,-1
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 1485               		.loc 1 752 0
 1486 001a 8130      		cpi r24,lo8(1)
 1487 001c 01F4      		brne .L157
 1488               	.LBB45:
 1489               	.LBB46:
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1490               		.loc 1 754 0
 1491 001e E901      		movw r28,r18
 1492               	.LVL137:
 1493 0020 F901      		movw r30,r18
 1494               	.LVL138:
 1495               	/* #APP */
 1496               	 ;  754 "quantum/quantum.c" 1
 1497 0022 1491      		lpm r17, Z
 1498               		
 1499               	 ;  0 "" 2
 1500               	.LVL139:
 1501               	/* #NOAPP */
 1502               	.LBE46:
 755:quantum/quantum.c ****           register_code(keycode);
 1503               		.loc 1 755 0
 1504 0024 812F      		mov r24,r17
 1505               	.LVL140:
 1506 0026 0E94 0000 		call register_code
 1507               	.LVL141:
 756:quantum/quantum.c ****           unregister_code(keycode);
 1508               		.loc 1 756 0
 1509 002a 812F      		mov r24,r17
 1510 002c 00C0      		rjmp .L164
 1511               	.LVL142:
 1512               	.L157:
 1513               	.LBE45:
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1514               		.loc 1 757 0
 1515 002e 8230      		cpi r24,lo8(2)
 1516 0030 01F4      		brne .L159
 1517               	.LBB47:
 1518               	.LBB48:
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1519               		.loc 1 759 0
 1520 0032 E901      		movw r28,r18
 1521               	.LVL143:
 1522 0034 F901      		movw r30,r18
 1523               	.LVL144:
 1524               	/* #APP */
 1525               	 ;  759 "quantum/quantum.c" 1
 1526 0036 8491      		lpm r24, Z
 1527               		
 1528               	 ;  0 "" 2
 1529               	.LVL145:
 1530               	/* #NOAPP */
 1531               	.LBE48:
 760:quantum/quantum.c ****           register_code(keycode);
 1532               		.loc 1 760 0
 1533 0038 0E94 0000 		call register_code
 1534               	.LVL146:
 1535               	.LBE47:
 1536 003c 00C0      		rjmp .L158
 1537               	.LVL147:
 1538               	.L159:
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1539               		.loc 1 761 0
 1540 003e 8330      		cpi r24,lo8(3)
 1541 0040 01F4      		brne .L160
 1542               	.LBB49:
 1543               	.LBB50:
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 1544               		.loc 1 763 0
 1545 0042 E901      		movw r28,r18
 1546               	.LVL148:
 1547 0044 F901      		movw r30,r18
 1548               	.LVL149:
 1549               	/* #APP */
 1550               	 ;  763 "quantum/quantum.c" 1
 1551 0046 8491      		lpm r24, Z
 1552               		
 1553               	 ;  0 "" 2
 1554               	.LVL150:
 1555               	/* #NOAPP */
 1556               	.L164:
 1557               	.LBE50:
 764:quantum/quantum.c ****           unregister_code(keycode);
 1558               		.loc 1 764 0
 1559 0048 0E94 0000 		call unregister_code
 1560               	.LVL151:
 1561               	.LBE49:
 1562 004c 00C0      		rjmp .L158
 1563               	.LVL152:
 1564               	.L160:
 766:quantum/quantum.c ****           send_char(ascii_code);
 1565               		.loc 1 766 0
 1566 004e 0E94 0000 		call send_char
 1567               	.LVL153:
 1568               	.L158:
 768:quantum/quantum.c ****         ++str;
 1569               		.loc 1 768 0
 1570 0052 2196      		adiw r28,1
 1571               	.LVL154:
 1572               	.LBB51:
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1573               		.loc 1 770 0
 1574 0054 802F      		mov r24,r16
 1575               	.LVL155:
 1576               	.L161:
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 1577               		.loc 1 770 0 is_stmt 0 discriminator 1
 1578 0056 8823      		tst r24
 1579 0058 01F0      		breq .L163
 1580               	.LVL156:
 1581               	.LBB52:
 1582               	.LBB53:
 1583               		.loc 3 164 0 is_stmt 1
 1584 005a EFE9      		ldi r30,lo8(3999)
 1585 005c FFE0      		ldi r31,hi8(3999)
 1586 005e 3197      		1: sbiw r30,1
 1587 0060 01F4      		brne 1b
 1588 0062 00C0      		rjmp .
 1589 0064 0000      		nop
 1590 0066 8150      		subi r24,lo8(-(-1))
 1591               	.LVL157:
 1592 0068 00C0      		rjmp .L161
 1593               	.LVL158:
 1594               	.L155:
 1595               	/* epilogue start */
 1596               	.LBE53:
 1597               	.LBE52:
 1598               	.LBE51:
 1599               	.LBE43:
 772:quantum/quantum.c **** }
 1600               		.loc 1 772 0
 1601 006a DF91      		pop r29
 1602 006c CF91      		pop r28
 1603               	.LVL159:
 1604 006e 1F91      		pop r17
 1605 0070 0F91      		pop r16
 1606               	.LVL160:
 1607 0072 0895      		ret
 1608               		.cfi_endproc
 1609               	.LFE39:
 1611               		.section	.text.send_string_P,"ax",@progbits
 1612               	.global	send_string_P
 1614               	send_string_P:
 1615               	.LFB37:
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 1616               		.loc 1 718 0
 1617               		.cfi_startproc
 1618               	.LVL161:
 1619               	/* prologue: function */
 1620               	/* frame size = 0 */
 1621               	/* stack size = 0 */
 1622               	.L__stack_usage = 0
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1623               		.loc 1 719 0
 1624 0000 60E0      		ldi r22,0
 1625 0002 0C94 0000 		jmp send_string_with_delay_P
 1626               	.LVL162:
 1627               		.cfi_endproc
 1628               	.LFE37:
 1630               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1631               	.global	set_single_persistent_default_layer
 1633               	set_single_persistent_default_layer:
 1634               	.LFB41:
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1635               		.loc 1 788 0
 1636               		.cfi_startproc
 1637               	.LVL163:
 1638 0000 CF93      		push r28
 1639               	.LCFI22:
 1640               		.cfi_def_cfa_offset 3
 1641               		.cfi_offset 28, -2
 1642 0002 DF93      		push r29
 1643               	.LCFI23:
 1644               		.cfi_def_cfa_offset 4
 1645               		.cfi_offset 29, -3
 1646               	/* prologue: function */
 1647               	/* frame size = 0 */
 1648               	/* stack size = 2 */
 1649               	.L__stack_usage = 2
 789:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 790:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 791:quantum/quantum.c ****   #endif
 792:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1650               		.loc 1 792 0
 1651 0004 C1E0      		ldi r28,lo8(1)
 1652 0006 D0E0      		ldi r29,0
 1653 0008 00C0      		rjmp 2f
 1654               		1:
 1655 000a CC0F      		lsl r28
 1656 000c DD1F      		rol r29
 1657               		2:
 1658 000e 8A95      		dec r24
 1659 0010 02F4      		brpl 1b
 1660 0012 8C2F      		mov r24,r28
 1661               	.LVL164:
 1662 0014 0E94 0000 		call eeconfig_update_default_layer
 1663               	.LVL165:
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1664               		.loc 1 793 0
 1665 0018 BE01      		movw r22,r28
 1666 001a 80E0      		ldi r24,0
 1667 001c 90E0      		ldi r25,0
 1668               	/* epilogue start */
 794:quantum/quantum.c **** }
 1669               		.loc 1 794 0
 1670 001e DF91      		pop r29
 1671 0020 CF91      		pop r28
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1672               		.loc 1 793 0
 1673 0022 0C94 0000 		jmp default_layer_set
 1674               	.LVL166:
 1675               		.cfi_endproc
 1676               	.LFE41:
 1678               		.section	.text.update_tri_layer_state,"ax",@progbits
 1679               	.global	update_tri_layer_state
 1681               	update_tri_layer_state:
 1682               	.LFB42:
 795:quantum/quantum.c **** 
 796:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1683               		.loc 1 796 0
 1684               		.cfi_startproc
 1685               	.LVL167:
 1686 0000 4F92      		push r4
 1687               	.LCFI24:
 1688               		.cfi_def_cfa_offset 3
 1689               		.cfi_offset 4, -2
 1690 0002 5F92      		push r5
 1691               	.LCFI25:
 1692               		.cfi_def_cfa_offset 4
 1693               		.cfi_offset 5, -3
 1694 0004 6F92      		push r6
 1695               	.LCFI26:
 1696               		.cfi_def_cfa_offset 5
 1697               		.cfi_offset 6, -4
 1698 0006 7F92      		push r7
 1699               	.LCFI27:
 1700               		.cfi_def_cfa_offset 6
 1701               		.cfi_offset 7, -5
 1702 0008 8F92      		push r8
 1703               	.LCFI28:
 1704               		.cfi_def_cfa_offset 7
 1705               		.cfi_offset 8, -6
 1706 000a 9F92      		push r9
 1707               	.LCFI29:
 1708               		.cfi_def_cfa_offset 8
 1709               		.cfi_offset 9, -7
 1710 000c AF92      		push r10
 1711               	.LCFI30:
 1712               		.cfi_def_cfa_offset 9
 1713               		.cfi_offset 10, -8
 1714 000e BF92      		push r11
 1715               	.LCFI31:
 1716               		.cfi_def_cfa_offset 10
 1717               		.cfi_offset 11, -9
 1718 0010 CF92      		push r12
 1719               	.LCFI32:
 1720               		.cfi_def_cfa_offset 11
 1721               		.cfi_offset 12, -10
 1722 0012 DF92      		push r13
 1723               	.LCFI33:
 1724               		.cfi_def_cfa_offset 12
 1725               		.cfi_offset 13, -11
 1726 0014 EF92      		push r14
 1727               	.LCFI34:
 1728               		.cfi_def_cfa_offset 13
 1729               		.cfi_offset 14, -12
 1730 0016 FF92      		push r15
 1731               	.LCFI35:
 1732               		.cfi_def_cfa_offset 14
 1733               		.cfi_offset 15, -13
 1734 0018 0F93      		push r16
 1735               	.LCFI36:
 1736               		.cfi_def_cfa_offset 15
 1737               		.cfi_offset 16, -14
 1738 001a 1F93      		push r17
 1739               	.LCFI37:
 1740               		.cfi_def_cfa_offset 16
 1741               		.cfi_offset 17, -15
 1742               	/* prologue: function */
 1743               	/* frame size = 0 */
 1744               	/* stack size = 14 */
 1745               	.L__stack_usage = 14
 1746 001c 2B01      		movw r4,r22
 1747 001e 3C01      		movw r6,r24
 797:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 1748               		.loc 1 797 0
 1749 0020 C12C      		mov r12,__zero_reg__
 1750 0022 D12C      		mov r13,__zero_reg__
 1751 0024 7601      		movw r14,r12
 1752 0026 C394      		inc r12
 1753 0028 D701      		movw r26,r14
 1754 002a C601      		movw r24,r12
 1755 002c 00C0      		rjmp 2f
 1756               		1:
 1757 002e 880F      		lsl r24
 1758 0030 991F      		rol r25
 1759 0032 AA1F      		rol r26
 1760 0034 BB1F      		rol r27
 1761               		2:
 1762 0036 4A95      		dec r20
 1763 0038 02F4      		brpl 1b
 1764 003a AC01      		movw r20,r24
 1765 003c BD01      		movw r22,r26
 1766               	.LVL168:
 1767 003e 4601      		movw r8,r12
 1768 0040 5701      		movw r10,r14
 1769 0042 00C0      		rjmp 2f
 1770               		1:
 1771 0044 880C      		lsl r8
 1772 0046 991C      		rol r9
 1773 0048 AA1C      		rol r10
 1774 004a BB1C      		rol r11
 1775               		2:
 1776 004c 2A95      		dec r18
 1777 004e 02F4      		brpl 1b
 1778 0050 4829      		or r20,r8
 1779 0052 5929      		or r21,r9
 1780 0054 6A29      		or r22,r10
 1781 0056 7B29      		or r23,r11
 1782               	.LVL169:
 798:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 1783               		.loc 1 798 0
 1784 0058 D701      		movw r26,r14
 1785 005a C601      		movw r24,r12
 1786 005c 00C0      		rjmp 2f
 1787               		1:
 1788 005e 880F      		lsl r24
 1789 0060 991F      		rol r25
 1790 0062 AA1F      		rol r26
 1791 0064 BB1F      		rol r27
 1792               		2:
 1793 0066 0A95      		dec r16
 1794 0068 02F4      		brpl 1b
 1795               	.LVL170:
 799:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1796               		.loc 1 799 0
 1797 006a 6A01      		movw r12,r20
 1798 006c 7B01      		movw r14,r22
 1799 006e C420      		and r12,r4
 1800 0070 D520      		and r13,r5
 1801 0072 E620      		and r14,r6
 1802 0074 F720      		and r15,r7
 1803 0076 C416      		cp r12,r20
 1804 0078 D506      		cpc r13,r21
 1805 007a E606      		cpc r14,r22
 1806 007c F706      		cpc r15,r23
 1807 007e 01F4      		brne .L168
 1808               		.loc 1 799 0 is_stmt 0 discriminator 1
 1809 0080 BC01      		movw r22,r24
 1810 0082 CD01      		movw r24,r26
 1811               	.LVL171:
 1812 0084 6429      		or r22,r4
 1813 0086 7529      		or r23,r5
 1814 0088 8629      		or r24,r6
 1815 008a 9729      		or r25,r7
 1816 008c 00C0      		rjmp .L169
 1817               	.L168:
 1818               		.loc 1 799 0 discriminator 2
 1819 008e BC01      		movw r22,r24
 1820 0090 CD01      		movw r24,r26
 1821 0092 6095      		com r22
 1822 0094 7095      		com r23
 1823 0096 8095      		com r24
 1824 0098 9095      		com r25
 1825 009a 6421      		and r22,r4
 1826 009c 7521      		and r23,r5
 1827 009e 8621      		and r24,r6
 1828 00a0 9721      		and r25,r7
 1829               	.L169:
 1830               	/* epilogue start */
 800:quantum/quantum.c **** }
 1831               		.loc 1 800 0 is_stmt 1 discriminator 3
 1832 00a2 1F91      		pop r17
 1833 00a4 0F91      		pop r16
 1834               	.LVL172:
 1835 00a6 FF90      		pop r15
 1836               	.LVL173:
 1837 00a8 EF90      		pop r14
 1838               	.LVL174:
 1839 00aa DF90      		pop r13
 1840               	.LVL175:
 1841 00ac CF90      		pop r12
 1842               	.LVL176:
 1843 00ae BF90      		pop r11
 1844               	.LVL177:
 1845 00b0 AF90      		pop r10
 1846               	.LVL178:
 1847 00b2 9F90      		pop r9
 1848               	.LVL179:
 1849 00b4 8F90      		pop r8
 1850               	.LVL180:
 1851 00b6 7F90      		pop r7
 1852               	.LVL181:
 1853 00b8 6F90      		pop r6
 1854               	.LVL182:
 1855 00ba 5F90      		pop r5
 1856               	.LVL183:
 1857 00bc 4F90      		pop r4
 1858               	.LVL184:
 1859 00be 0895      		ret
 1860               		.cfi_endproc
 1861               	.LFE42:
 1863               		.section	.text.update_tri_layer,"ax",@progbits
 1864               	.global	update_tri_layer
 1866               	update_tri_layer:
 1867               	.LFB43:
 801:quantum/quantum.c **** 
 802:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1868               		.loc 1 802 0
 1869               		.cfi_startproc
 1870               	.LVL185:
 1871 0000 0F93      		push r16
 1872               	.LCFI38:
 1873               		.cfi_def_cfa_offset 3
 1874               		.cfi_offset 16, -2
 1875               	/* prologue: function */
 1876               	/* frame size = 0 */
 1877               	/* stack size = 1 */
 1878               	.L__stack_usage = 1
 1879 0002 382F      		mov r19,r24
 1880 0004 262F      		mov r18,r22
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1881               		.loc 1 803 0
 1882 0006 6091 0000 		lds r22,layer_state
 1883 000a 7091 0000 		lds r23,layer_state+1
 1884 000e 8091 0000 		lds r24,layer_state+2
 1885 0012 9091 0000 		lds r25,layer_state+3
 1886               	.LVL186:
 1887 0016 042F      		mov r16,r20
 1888 0018 432F      		mov r20,r19
 1889               	.LVL187:
 1890 001a 0E94 0000 		call update_tri_layer_state
 1891               	.LVL188:
 1892               	/* epilogue start */
 804:quantum/quantum.c **** }
 1893               		.loc 1 804 0
 1894 001e 0F91      		pop r16
 1895               	.LVL189:
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1896               		.loc 1 803 0
 1897 0020 0C94 0000 		jmp layer_state_set
 1898               	.LVL190:
 1899               		.cfi_endproc
 1900               	.LFE43:
 1902               		.section	.text.tap_random_base64,"ax",@progbits
 1903               	.global	tap_random_base64
 1905               	tap_random_base64:
 1906               	.LFB44:
 805:quantum/quantum.c **** 
 806:quantum/quantum.c **** void tap_random_base64(void) {
 1907               		.loc 1 806 0
 1908               		.cfi_startproc
 1909 0000 CF93      		push r28
 1910               	.LCFI39:
 1911               		.cfi_def_cfa_offset 3
 1912               		.cfi_offset 28, -2
 1913               	/* prologue: function */
 1914               	/* frame size = 0 */
 1915               	/* stack size = 1 */
 1916               	.L__stack_usage = 1
 807:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 808:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1917               		.loc 1 808 0
 1918 0002 66B5      		in r22,0x26
 1919 0004 4091 8400 		lds r20,132
 1920 0008 5091 8500 		lds r21,132+1
 1921 000c 8091 9400 		lds r24,148
 1922 0010 9091 9500 		lds r25,148+1
 1923 0014 2091 BE00 		lds r18,190
 1924 0018 3091 BF00 		lds r19,190+1
 1925 001c C42F      		mov r28,r20
 1926 001e C80F      		add r28,r24
 1927 0020 C60F      		add r28,r22
 1928 0022 C20F      		add r28,r18
 1929 0024 CF73      		andi r28,lo8(63)
 1930               	.LVL191:
 809:quantum/quantum.c ****   #else
 810:quantum/quantum.c ****     uint8_t key = rand() % 64;
 811:quantum/quantum.c ****   #endif
 812:quantum/quantum.c ****   switch (key) {
 1931               		.loc 1 812 0
 1932 0026 CE33      		cpi r28,lo8(62)
 1933 0028 00F4      		brsh .L173
 1934 002a C533      		cpi r28,lo8(53)
 1935 002c 00F4      		brsh .L174
 1936 002e CA31      		cpi r28,lo8(26)
 1937 0030 00F0      		brlo .L172
 1938 0032 C433      		cpi r28,lo8(52)
 1939 0034 00F4      		brsh .L179
 813:quantum/quantum.c ****     case 0 ... 25:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 815:quantum/quantum.c ****       register_code(key + KC_A);
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 817:quantum/quantum.c ****       unregister_code(KC_LSFT);
 818:quantum/quantum.c ****       break;
 819:quantum/quantum.c ****     case 26 ... 51:
 820:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 1940               		.loc 1 820 0
 1941 0036 C651      		subi r28,lo8(-(-22))
 1942               	.LVL192:
 1943 0038 00C0      		rjmp .L182
 1944               	.LVL193:
 1945               	.L173:
 812:quantum/quantum.c ****   switch (key) {
 1946               		.loc 1 812 0
 1947 003a CE33      		cpi r28,lo8(62)
 1948 003c 01F0      		breq .L177
 1949 003e CF33      		cpi r28,lo8(63)
 1950 0040 01F0      		breq .L178
 1951               	.L172:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 1952               		.loc 1 814 0
 1953 0042 81EE      		ldi r24,lo8(-31)
 1954 0044 0E94 0000 		call register_code
 1955               	.LVL194:
 815:quantum/quantum.c ****       register_code(key + KC_A);
 1956               		.loc 1 815 0
 1957 0048 CC5F      		subi r28,lo8(-(4))
 1958               	.LVL195:
 1959 004a 8C2F      		mov r24,r28
 1960 004c 0E94 0000 		call register_code
 1961               	.LVL196:
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 1962               		.loc 1 816 0
 1963 0050 8C2F      		mov r24,r28
 1964 0052 00C0      		rjmp .L181
 1965               	.LVL197:
 1966               	.L179:
 821:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 822:quantum/quantum.c ****       break;
 823:quantum/quantum.c ****     case 52:
 824:quantum/quantum.c ****       register_code(KC_0);
 1967               		.loc 1 824 0
 1968 0054 87E2      		ldi r24,lo8(39)
 1969 0056 0E94 0000 		call register_code
 1970               	.LVL198:
 825:quantum/quantum.c ****       unregister_code(KC_0);
 1971               		.loc 1 825 0
 1972 005a 87E2      		ldi r24,lo8(39)
 1973 005c 00C0      		rjmp .L180
 1974               	.L174:
 826:quantum/quantum.c ****       break;
 827:quantum/quantum.c ****     case 53 ... 61:
 828:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 1975               		.loc 1 828 0
 1976 005e C751      		subi r28,lo8(-(-23))
 1977               	.LVL199:
 1978               	.L182:
 1979 0060 8C2F      		mov r24,r28
 1980               	.LVL200:
 1981 0062 0E94 0000 		call register_code
 1982               	.LVL201:
 829:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1983               		.loc 1 829 0
 1984 0066 8C2F      		mov r24,r28
 1985 0068 00C0      		rjmp .L180
 1986               	.LVL202:
 1987               	.L177:
 830:quantum/quantum.c ****       break;
 831:quantum/quantum.c ****     case 62:
 832:quantum/quantum.c ****       register_code(KC_LSFT);
 1988               		.loc 1 832 0
 1989 006a 81EE      		ldi r24,lo8(-31)
 1990 006c 0E94 0000 		call register_code
 1991               	.LVL203:
 833:quantum/quantum.c ****       register_code(KC_EQL);
 1992               		.loc 1 833 0
 1993 0070 8EE2      		ldi r24,lo8(46)
 1994 0072 0E94 0000 		call register_code
 1995               	.LVL204:
 834:quantum/quantum.c ****       unregister_code(KC_EQL);
 1996               		.loc 1 834 0
 1997 0076 8EE2      		ldi r24,lo8(46)
 1998               	.LVL205:
 1999               	.L181:
 2000 0078 0E94 0000 		call unregister_code
 2001               	.LVL206:
 835:quantum/quantum.c ****       unregister_code(KC_LSFT);
 2002               		.loc 1 835 0
 2003 007c 81EE      		ldi r24,lo8(-31)
 2004 007e 00C0      		rjmp .L180
 2005               	.LVL207:
 2006               	.L178:
 836:quantum/quantum.c ****       break;
 837:quantum/quantum.c ****     case 63:
 838:quantum/quantum.c ****       register_code(KC_SLSH);
 2007               		.loc 1 838 0
 2008 0080 88E3      		ldi r24,lo8(56)
 2009 0082 0E94 0000 		call register_code
 2010               	.LVL208:
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2011               		.loc 1 839 0
 2012 0086 88E3      		ldi r24,lo8(56)
 2013               	.LVL209:
 2014               	.L180:
 2015               	/* epilogue start */
 840:quantum/quantum.c ****       break;
 841:quantum/quantum.c ****   }
 842:quantum/quantum.c **** }
 2016               		.loc 1 842 0
 2017 0088 CF91      		pop r28
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 2018               		.loc 1 839 0
 2019 008a 0C94 0000 		jmp unregister_code
 2020               	.LVL210:
 2021               		.cfi_endproc
 2022               	.LFE44:
 2024               		.section	.text.matrix_init_quantum,"ax",@progbits
 2025               	.global	matrix_init_quantum
 2027               	matrix_init_quantum:
 2028               	.LFB45:
 843:quantum/quantum.c **** 
 844:quantum/quantum.c **** void matrix_init_quantum() {
 2029               		.loc 1 844 0
 2030               		.cfi_startproc
 2031               	/* prologue: function */
 2032               	/* frame size = 0 */
 2033               	/* stack size = 0 */
 2034               	.L__stack_usage = 0
 845:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 846:quantum/quantum.c ****     backlight_init_ports();
 847:quantum/quantum.c ****   #endif
 848:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 849:quantum/quantum.c ****     audio_init();
 850:quantum/quantum.c ****   #endif
 851:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 852:quantum/quantum.c ****     rgb_matrix_init_drivers();
 853:quantum/quantum.c ****   #endif
 854:quantum/quantum.c ****   matrix_init_kb();
 2035               		.loc 1 854 0
 2036 0000 0C94 0000 		jmp matrix_init_kb
 2037               	.LVL211:
 2038               		.cfi_endproc
 2039               	.LFE45:
 2041               		.section	.text.matrix_scan_quantum,"ax",@progbits
 2042               	.global	matrix_scan_quantum
 2044               	matrix_scan_quantum:
 2045               	.LFB46:
 855:quantum/quantum.c **** }
 856:quantum/quantum.c **** 
 857:quantum/quantum.c **** uint8_t rgb_matrix_task_counter = 0;
 858:quantum/quantum.c **** 
 859:quantum/quantum.c **** #ifndef RGB_MATRIX_SKIP_FRAMES
 860:quantum/quantum.c ****   #define RGB_MATRIX_SKIP_FRAMES 1
 861:quantum/quantum.c **** #endif
 862:quantum/quantum.c **** 
 863:quantum/quantum.c **** void matrix_scan_quantum() {
 2046               		.loc 1 863 0
 2047               		.cfi_startproc
 2048               	/* prologue: function */
 2049               	/* frame size = 0 */
 2050               	/* stack size = 0 */
 2051               	.L__stack_usage = 0
 864:quantum/quantum.c ****   #if defined(AUDIO_ENABLE)
 865:quantum/quantum.c ****     matrix_scan_music();
 866:quantum/quantum.c ****   #endif
 867:quantum/quantum.c **** 
 868:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 869:quantum/quantum.c ****     matrix_scan_tap_dance();
 2052               		.loc 1 869 0
 2053 0000 0E94 0000 		call matrix_scan_tap_dance
 2054               	.LVL212:
 870:quantum/quantum.c ****   #endif
 871:quantum/quantum.c **** 
 872:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 873:quantum/quantum.c ****     matrix_scan_combo();
 874:quantum/quantum.c ****   #endif
 875:quantum/quantum.c **** 
 876:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 877:quantum/quantum.c ****     backlight_task();
 878:quantum/quantum.c ****   #endif
 879:quantum/quantum.c **** 
 880:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 881:quantum/quantum.c ****     rgb_matrix_task();
 882:quantum/quantum.c ****     if (rgb_matrix_task_counter == 0) {
 883:quantum/quantum.c ****       rgb_matrix_update_pwm_buffers();
 884:quantum/quantum.c ****     }
 885:quantum/quantum.c ****     rgb_matrix_task_counter = ((rgb_matrix_task_counter + 1) % (RGB_MATRIX_SKIP_FRAMES + 1));
 886:quantum/quantum.c ****   #endif
 887:quantum/quantum.c **** 
 888:quantum/quantum.c ****   matrix_scan_kb();
 2055               		.loc 1 888 0
 2056 0004 0C94 0000 		jmp matrix_scan_kb
 2057               	.LVL213:
 2058               		.cfi_endproc
 2059               	.LFE46:
 2061               		.section	.text.backlight_init_ports,"ax",@progbits
 2062               		.weak	backlight_init_ports
 2064               	backlight_init_ports:
 2065               	.LFB47:
 889:quantum/quantum.c **** }
 890:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 891:quantum/quantum.c **** 
 892:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 893:quantum/quantum.c **** 
 894:quantum/quantum.c **** // depending on the pin, we use a different output compare unit
 895:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 896:quantum/quantum.c **** #  define COM1x1 COM1C1
 897:quantum/quantum.c **** #  define OCR1x  OCR1C
 898:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 899:quantum/quantum.c **** #  define COM1x1 COM1B1
 900:quantum/quantum.c **** #  define OCR1x  OCR1B
 901:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 902:quantum/quantum.c **** #  define COM1x1 COM1A1
 903:quantum/quantum.c **** #  define OCR1x  OCR1A
 904:quantum/quantum.c **** #else
 905:quantum/quantum.c **** #  define NO_HARDWARE_PWM
 906:quantum/quantum.c **** #endif
 907:quantum/quantum.c **** 
 908:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
 909:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
 910:quantum/quantum.c **** #endif
 911:quantum/quantum.c **** 
 912:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM // pwm through software
 913:quantum/quantum.c **** 
 914:quantum/quantum.c **** __attribute__ ((weak))
 915:quantum/quantum.c **** void backlight_init_ports(void)
 916:quantum/quantum.c **** {
 917:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
 918:quantum/quantum.c ****   // DDRx |= n
 919:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 920:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
 921:quantum/quantum.c ****     // PORTx &= ~n
 922:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 923:quantum/quantum.c ****   #else
 924:quantum/quantum.c ****     // PORTx |= n
 925:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 926:quantum/quantum.c ****   #endif
 927:quantum/quantum.c **** }
 928:quantum/quantum.c **** 
 929:quantum/quantum.c **** __attribute__ ((weak))
 930:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 931:quantum/quantum.c **** 
 932:quantum/quantum.c **** uint8_t backlight_tick = 0;
 933:quantum/quantum.c **** 
 934:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 935:quantum/quantum.c **** void backlight_task(void) {
 936:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
 937:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 938:quantum/quantum.c ****       // PORTx &= ~n
 939:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 940:quantum/quantum.c ****     #else
 941:quantum/quantum.c ****       // PORTx |= n
 942:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 943:quantum/quantum.c ****     #endif
 944:quantum/quantum.c ****   } else {
 945:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 946:quantum/quantum.c ****       // PORTx |= n
 947:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 948:quantum/quantum.c ****     #else
 949:quantum/quantum.c ****       // PORTx &= ~n
 950:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 951:quantum/quantum.c ****     #endif
 952:quantum/quantum.c ****   }
 953:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
 954:quantum/quantum.c **** }
 955:quantum/quantum.c **** #endif
 956:quantum/quantum.c **** 
 957:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 958:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
 959:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
 960:quantum/quantum.c ****   #endif
 961:quantum/quantum.c **** #endif
 962:quantum/quantum.c **** 
 963:quantum/quantum.c **** #else // pwm through timer
 964:quantum/quantum.c **** 
 965:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
 966:quantum/quantum.c **** 
 967:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
 968:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
 969:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
 970:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 971:quantum/quantum.c ****   else {
 972:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
 973:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
 974:quantum/quantum.c ****     // and revert what we've done again after squaring.
 975:quantum/quantum.c ****     y = y * y * y >> 8;
 976:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 977:quantum/quantum.c ****       return 0xFFFFU;
 978:quantum/quantum.c ****     else
 979:quantum/quantum.c ****       return (uint16_t) y;
 980:quantum/quantum.c ****   }
 981:quantum/quantum.c **** }
 982:quantum/quantum.c **** 
 983:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
 984:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
 985:quantum/quantum.c ****   OCR1x = val;
 986:quantum/quantum.c **** }
 987:quantum/quantum.c **** 
 988:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 989:quantum/quantum.c **** __attribute__ ((weak))
 990:quantum/quantum.c **** void backlight_set(uint8_t level) {
 991:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
 992:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 993:quantum/quantum.c **** 
 994:quantum/quantum.c ****   if (level == 0) {
 995:quantum/quantum.c ****     // Turn off PWM control on backlight pin
 996:quantum/quantum.c ****     TCCR1A &= ~(_BV(COM1x1));
 997:quantum/quantum.c ****   } else {
 998:quantum/quantum.c ****     // Turn on PWM control of backlight pin
 999:quantum/quantum.c ****     TCCR1A |= _BV(COM1x1);
1000:quantum/quantum.c ****   }
1001:quantum/quantum.c ****   // Set the brightness
1002:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
1003:quantum/quantum.c **** }
1004:quantum/quantum.c **** 
1005:quantum/quantum.c **** void backlight_task(void) {}
1006:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1007:quantum/quantum.c **** 
1008:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1009:quantum/quantum.c **** 
1010:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1011:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1012:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1013:quantum/quantum.c **** #define BREATHING_STEPS 128
1014:quantum/quantum.c **** 
1015:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1016:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1017:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1018:quantum/quantum.c **** 
1019:quantum/quantum.c **** bool is_breathing(void) {
1020:quantum/quantum.c ****     return !!(TIMSK1 & _BV(TOIE1));
1021:quantum/quantum.c **** }
1022:quantum/quantum.c **** 
1023:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSK1 |= _BV(TOIE1);} while (0)
1024:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSK1 &= ~_BV(TOIE1);} while (0)
1025:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1026:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1027:quantum/quantum.c **** 
1028:quantum/quantum.c **** void breathing_enable(void)
1029:quantum/quantum.c **** {
1030:quantum/quantum.c ****   breathing_counter = 0;
1031:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1032:quantum/quantum.c ****   breathing_interrupt_enable();
1033:quantum/quantum.c **** }
1034:quantum/quantum.c **** 
1035:quantum/quantum.c **** void breathing_pulse(void)
1036:quantum/quantum.c **** {
1037:quantum/quantum.c ****     if (get_backlight_level() == 0)
1038:quantum/quantum.c ****       breathing_min();
1039:quantum/quantum.c ****     else
1040:quantum/quantum.c ****       breathing_max();
1041:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1042:quantum/quantum.c ****     breathing_interrupt_enable();
1043:quantum/quantum.c **** }
1044:quantum/quantum.c **** 
1045:quantum/quantum.c **** void breathing_disable(void)
1046:quantum/quantum.c **** {
1047:quantum/quantum.c ****     breathing_interrupt_disable();
1048:quantum/quantum.c ****     // Restore backlight level
1049:quantum/quantum.c ****     backlight_set(get_backlight_level());
1050:quantum/quantum.c **** }
1051:quantum/quantum.c **** 
1052:quantum/quantum.c **** void breathing_self_disable(void)
1053:quantum/quantum.c **** {
1054:quantum/quantum.c ****   if (get_backlight_level() == 0)
1055:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1056:quantum/quantum.c ****   else
1057:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1058:quantum/quantum.c **** }
1059:quantum/quantum.c **** 
1060:quantum/quantum.c **** void breathing_toggle(void) {
1061:quantum/quantum.c ****   if (is_breathing())
1062:quantum/quantum.c ****     breathing_disable();
1063:quantum/quantum.c ****   else
1064:quantum/quantum.c ****     breathing_enable();
1065:quantum/quantum.c **** }
1066:quantum/quantum.c **** 
1067:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1068:quantum/quantum.c **** {
1069:quantum/quantum.c ****   if (!value)
1070:quantum/quantum.c ****     value = 1;
1071:quantum/quantum.c ****   breathing_period = value;
1072:quantum/quantum.c **** }
1073:quantum/quantum.c **** 
1074:quantum/quantum.c **** void breathing_period_default(void) {
1075:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1076:quantum/quantum.c **** }
1077:quantum/quantum.c **** 
1078:quantum/quantum.c **** void breathing_period_inc(void)
1079:quantum/quantum.c **** {
1080:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1081:quantum/quantum.c **** }
1082:quantum/quantum.c **** 
1083:quantum/quantum.c **** void breathing_period_dec(void)
1084:quantum/quantum.c **** {
1085:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1086:quantum/quantum.c **** }
1087:quantum/quantum.c **** 
1088:quantum/quantum.c **** /* To generate breathing curve in python:
1089:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1090:quantum/quantum.c ****  */
1091:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1092:quantum/quantum.c **** 
1093:quantum/quantum.c **** // Use this before the cie_lightness function.
1094:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1095:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1096:quantum/quantum.c **** }
1097:quantum/quantum.c **** 
1098:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1099:quantum/quantum.c ****  * about 244 times per second.
1100:quantum/quantum.c ****  */
1101:quantum/quantum.c **** ISR(TIMER1_OVF_vect)
1102:quantum/quantum.c **** {
1103:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1104:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1105:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1106:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1107:quantum/quantum.c **** 
1108:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1109:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1110:quantum/quantum.c ****   {
1111:quantum/quantum.c ****       breathing_interrupt_disable();
1112:quantum/quantum.c ****   }
1113:quantum/quantum.c **** 
1114:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1115:quantum/quantum.c **** }
1116:quantum/quantum.c **** 
1117:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1118:quantum/quantum.c **** 
1119:quantum/quantum.c **** __attribute__ ((weak))
1120:quantum/quantum.c **** void backlight_init_ports(void)
1121:quantum/quantum.c **** {
1122:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1123:quantum/quantum.c ****   // DDRx |= n
1124:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
1125:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1126:quantum/quantum.c ****     // PORTx &= ~n
1127:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1128:quantum/quantum.c ****   #else
1129:quantum/quantum.c ****     // PORTx |= n
1130:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1131:quantum/quantum.c ****   #endif
1132:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1133:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1134:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1135:quantum/quantum.c **** 
1136:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1137:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1138:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1139:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1140:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1141:quantum/quantum.c **** 
1142:quantum/quantum.c ****   /*
1143:quantum/quantum.c ****   14.8.3:
1144:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1145:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1146:quantum/quantum.c ****   */
1147:quantum/quantum.c **** 
1148:quantum/quantum.c ****   TCCR1A = _BV(COM1x1) | _BV(WGM11); // = 0b00001010;
1149:quantum/quantum.c ****   TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1150:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1151:quantum/quantum.c ****   ICR1 = TIMER_TOP;
1152:quantum/quantum.c **** 
1153:quantum/quantum.c ****   backlight_init();
1154:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1155:quantum/quantum.c ****     breathing_enable();
1156:quantum/quantum.c ****   #endif
1157:quantum/quantum.c **** }
1158:quantum/quantum.c **** 
1159:quantum/quantum.c **** #endif // NO_HARDWARE_PWM
1160:quantum/quantum.c **** 
1161:quantum/quantum.c **** #else // backlight
1162:quantum/quantum.c **** 
1163:quantum/quantum.c **** __attribute__ ((weak))
1164:quantum/quantum.c **** void backlight_init_ports(void) {}
 2066               		.loc 1 1164 0
 2067               		.cfi_startproc
 2068               	/* prologue: function */
 2069               	/* frame size = 0 */
 2070               	/* stack size = 0 */
 2071               	.L__stack_usage = 0
 2072 0000 0895      		ret
 2073               		.cfi_endproc
 2074               	.LFE47:
 2076               		.section	.text.backlight_set,"ax",@progbits
 2077               		.weak	backlight_set
 2079               	backlight_set:
 2080               	.LFB48:
1165:quantum/quantum.c **** 
1166:quantum/quantum.c **** __attribute__ ((weak))
1167:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 2081               		.loc 1 1167 0
 2082               		.cfi_startproc
 2083               	.LVL214:
 2084               	/* prologue: function */
 2085               	/* frame size = 0 */
 2086               	/* stack size = 0 */
 2087               	.L__stack_usage = 0
 2088 0000 0895      		ret
 2089               		.cfi_endproc
 2090               	.LFE48:
 2092               		.section	.text.send_nibble,"ax",@progbits
 2093               	.global	send_nibble
 2095               	send_nibble:
 2096               	.LFB52:
1168:quantum/quantum.c **** 
1169:quantum/quantum.c **** #endif // backlight
1170:quantum/quantum.c **** 
1171:quantum/quantum.c **** 
1172:quantum/quantum.c **** // Functions for spitting out values
1173:quantum/quantum.c **** //
1174:quantum/quantum.c **** 
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1176:quantum/quantum.c ****     uint16_t word = (number >> 16);
1177:quantum/quantum.c ****     send_word(word);
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1179:quantum/quantum.c **** }
1180:quantum/quantum.c **** 
1181:quantum/quantum.c **** void send_word(uint16_t number) {
1182:quantum/quantum.c ****     uint8_t byte = number >> 8;
1183:quantum/quantum.c ****     send_byte(byte);
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
1185:quantum/quantum.c **** }
1186:quantum/quantum.c **** 
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
1188:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1189:quantum/quantum.c ****     send_nibble(nibble);
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
1191:quantum/quantum.c **** }
1192:quantum/quantum.c **** 
1193:quantum/quantum.c **** void send_nibble(uint8_t number) {
 2097               		.loc 1 1193 0
 2098               		.cfi_startproc
 2099               	.LVL215:
 2100               		.loc 1 1193 0
 2101 0000 CF93      		push r28
 2102               	.LCFI40:
 2103               		.cfi_def_cfa_offset 3
 2104               		.cfi_offset 28, -2
 2105               	/* prologue: function */
 2106               	/* frame size = 0 */
 2107               	/* stack size = 1 */
 2108               	.L__stack_usage = 1
1194:quantum/quantum.c ****     switch (number) {
 2109               		.loc 1 1194 0
 2110 0002 8A30      		cpi r24,lo8(10)
 2111 0004 00F4      		brsh .L189
 2112 0006 8130      		cpi r24,lo8(1)
 2113 0008 00F4      		brsh .L197
1195:quantum/quantum.c ****         case 0:
1196:quantum/quantum.c ****             register_code(KC_0);
 2114               		.loc 1 1196 0
 2115 000a 87E2      		ldi r24,lo8(39)
 2116               	.LVL216:
 2117 000c 0E94 0000 		call register_code
 2118               	.LVL217:
1197:quantum/quantum.c ****             unregister_code(KC_0);
 2119               		.loc 1 1197 0
 2120 0010 87E2      		ldi r24,lo8(39)
 2121 0012 00C0      		rjmp .L195
 2122               	.LVL218:
 2123               	.L189:
1194:quantum/quantum.c ****     switch (number) {
 2124               		.loc 1 1194 0
 2125 0014 8031      		cpi r24,lo8(16)
 2126 0016 00F4      		brsh .L198
1198:quantum/quantum.c ****             break;
1199:quantum/quantum.c ****         case 1 ... 9:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1201:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1202:quantum/quantum.c ****             break;
1203:quantum/quantum.c ****         case 0xA ... 0xF:
1204:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 2127               		.loc 1 1204 0
 2128 0018 CAEF      		ldi r28,lo8(-6)
 2129 001a 00C0      		rjmp .L196
 2130               	.L197:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
 2131               		.loc 1 1200 0
 2132 001c CDE1      		ldi r28,lo8(29)
 2133               	.L196:
 2134               		.loc 1 1204 0
 2135 001e C80F      		add r28,r24
 2136 0020 8C2F      		mov r24,r28
 2137               	.LVL219:
 2138 0022 0E94 0000 		call register_code
 2139               	.LVL220:
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2140               		.loc 1 1205 0
 2141 0026 8C2F      		mov r24,r28
 2142               	.L195:
 2143               	/* epilogue start */
1206:quantum/quantum.c ****             break;
1207:quantum/quantum.c ****     }
1208:quantum/quantum.c **** }
 2144               		.loc 1 1208 0
 2145 0028 CF91      		pop r28
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2146               		.loc 1 1205 0
 2147 002a 0C94 0000 		jmp unregister_code
 2148               	.LVL221:
 2149               	.L198:
 2150               	/* epilogue start */
 2151               		.loc 1 1208 0
 2152 002e CF91      		pop r28
 2153 0030 0895      		ret
 2154               		.cfi_endproc
 2155               	.LFE52:
 2157               		.section	.text.send_byte,"ax",@progbits
 2158               	.global	send_byte
 2160               	send_byte:
 2161               	.LFB51:
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
 2162               		.loc 1 1187 0
 2163               		.cfi_startproc
 2164               	.LVL222:
 2165 0000 CF93      		push r28
 2166               	.LCFI41:
 2167               		.cfi_def_cfa_offset 3
 2168               		.cfi_offset 28, -2
 2169               	/* prologue: function */
 2170               	/* frame size = 0 */
 2171               	/* stack size = 1 */
 2172               	.L__stack_usage = 1
 2173 0002 C82F      		mov r28,r24
 2174               	.LVL223:
1189:quantum/quantum.c ****     send_nibble(nibble);
 2175               		.loc 1 1189 0
 2176 0004 8295      		swap r24
 2177               	.LVL224:
 2178 0006 8F70      		andi r24,lo8(15)
 2179 0008 0E94 0000 		call send_nibble
 2180               	.LVL225:
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
 2181               		.loc 1 1190 0
 2182 000c 8C2F      		mov r24,r28
 2183 000e 8F70      		andi r24,lo8(15)
 2184               	/* epilogue start */
1191:quantum/quantum.c **** }
 2185               		.loc 1 1191 0
 2186 0010 CF91      		pop r28
 2187               	.LVL226:
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
 2188               		.loc 1 1190 0
 2189 0012 0C94 0000 		jmp send_nibble
 2190               	.LVL227:
 2191               		.cfi_endproc
 2192               	.LFE51:
 2194               		.section	.text.send_word,"ax",@progbits
 2195               	.global	send_word
 2197               	send_word:
 2198               	.LFB50:
1181:quantum/quantum.c **** void send_word(uint16_t number) {
 2199               		.loc 1 1181 0
 2200               		.cfi_startproc
 2201               	.LVL228:
 2202 0000 CF93      		push r28
 2203               	.LCFI42:
 2204               		.cfi_def_cfa_offset 3
 2205               		.cfi_offset 28, -2
 2206               	/* prologue: function */
 2207               	/* frame size = 0 */
 2208               	/* stack size = 1 */
 2209               	.L__stack_usage = 1
 2210 0002 C82F      		mov r28,r24
 2211               	.LVL229:
1183:quantum/quantum.c ****     send_byte(byte);
 2212               		.loc 1 1183 0
 2213 0004 892F      		mov r24,r25
 2214               	.LVL230:
 2215 0006 0E94 0000 		call send_byte
 2216               	.LVL231:
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
 2217               		.loc 1 1184 0
 2218 000a 8C2F      		mov r24,r28
 2219               	/* epilogue start */
1185:quantum/quantum.c **** }
 2220               		.loc 1 1185 0
 2221 000c CF91      		pop r28
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
 2222               		.loc 1 1184 0
 2223 000e 0C94 0000 		jmp send_byte
 2224               	.LVL232:
 2225               		.cfi_endproc
 2226               	.LFE50:
 2228               		.section	.text.send_dword,"ax",@progbits
 2229               	.global	send_dword
 2231               	send_dword:
 2232               	.LFB49:
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
 2233               		.loc 1 1175 0
 2234               		.cfi_startproc
 2235               	.LVL233:
 2236 0000 CF92      		push r12
 2237               	.LCFI43:
 2238               		.cfi_def_cfa_offset 3
 2239               		.cfi_offset 12, -2
 2240 0002 DF92      		push r13
 2241               	.LCFI44:
 2242               		.cfi_def_cfa_offset 4
 2243               		.cfi_offset 13, -3
 2244 0004 EF92      		push r14
 2245               	.LCFI45:
 2246               		.cfi_def_cfa_offset 5
 2247               		.cfi_offset 14, -4
 2248 0006 FF92      		push r15
 2249               	.LCFI46:
 2250               		.cfi_def_cfa_offset 6
 2251               		.cfi_offset 15, -5
 2252               	/* prologue: function */
 2253               	/* frame size = 0 */
 2254               	/* stack size = 4 */
 2255               	.L__stack_usage = 4
 2256 0008 6B01      		movw r12,r22
 2257 000a 7C01      		movw r14,r24
 2258               	.LVL234:
1177:quantum/quantum.c ****     send_word(word);
 2259               		.loc 1 1177 0
 2260 000c C701      		movw r24,r14
 2261 000e 0E94 0000 		call send_word
 2262               	.LVL235:
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2263               		.loc 1 1178 0
 2264 0012 C601      		movw r24,r12
 2265               	/* epilogue start */
1179:quantum/quantum.c **** }
 2266               		.loc 1 1179 0
 2267 0014 FF90      		pop r15
 2268 0016 EF90      		pop r14
 2269 0018 DF90      		pop r13
 2270 001a CF90      		pop r12
 2271               	.LVL236:
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2272               		.loc 1 1178 0
 2273 001c 0C94 0000 		jmp send_word
 2274               	.LVL237:
 2275               		.cfi_endproc
 2276               	.LFE49:
 2278               		.section	.text.hex_to_keycode,"ax",@progbits
 2279               		.weak	hex_to_keycode
 2281               	hex_to_keycode:
 2282               	.LFB53:
1209:quantum/quantum.c **** 
1210:quantum/quantum.c **** 
1211:quantum/quantum.c **** __attribute__((weak))
1212:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1213:quantum/quantum.c **** {
 2283               		.loc 1 1213 0
 2284               		.cfi_startproc
 2285               	.LVL238:
 2286               	/* prologue: function */
 2287               	/* frame size = 0 */
 2288               	/* stack size = 0 */
 2289               	.L__stack_usage = 0
1214:quantum/quantum.c ****   hex = hex & 0xF;
 2290               		.loc 1 1214 0
 2291 0000 282F      		mov r18,r24
 2292 0002 2F70      		andi r18,lo8(15)
 2293               	.LVL239:
1215:quantum/quantum.c ****   if (hex == 0x0) {
 2294               		.loc 1 1215 0
 2295 0004 01F0      		breq .L205
 2296 0006 822F      		mov r24,r18
 2297 0008 90E0      		ldi r25,0
1216:quantum/quantum.c ****     return KC_0;
1217:quantum/quantum.c ****   } else if (hex < 0xA) {
 2298               		.loc 1 1217 0
 2299 000a 2A30      		cpi r18,lo8(10)
 2300 000c 00F4      		brsh .L204
1218:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 2301               		.loc 1 1218 0
 2302 000e 4D96      		adiw r24,29
 2303 0010 0895      		ret
 2304               	.L204:
1219:quantum/quantum.c ****   } else {
1220:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 2305               		.loc 1 1220 0
 2306 0012 0697      		sbiw r24,6
 2307 0014 0895      		ret
 2308               	.L205:
1216:quantum/quantum.c ****     return KC_0;
 2309               		.loc 1 1216 0
 2310 0016 87E2      		ldi r24,lo8(39)
 2311 0018 90E0      		ldi r25,0
1221:quantum/quantum.c ****   }
1222:quantum/quantum.c **** }
 2312               		.loc 1 1222 0
 2313 001a 0895      		ret
 2314               		.cfi_endproc
 2315               	.LFE53:
 2317               		.section	.text.api_send_unicode,"ax",@progbits
 2318               	.global	api_send_unicode
 2320               	api_send_unicode:
 2321               	.LFB54:
1223:quantum/quantum.c **** 
1224:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 2322               		.loc 1 1224 0
 2323               		.cfi_startproc
 2324               	.LVL240:
 2325               	/* prologue: function */
 2326               	/* frame size = 0 */
 2327               	/* stack size = 0 */
 2328               	.L__stack_usage = 0
 2329 0000 0895      		ret
 2330               		.cfi_endproc
 2331               	.LFE54:
 2333               		.section	.text.led_set_user,"ax",@progbits
 2334               		.weak	led_set_user
 2336               	led_set_user:
 2337               	.LFB55:
1225:quantum/quantum.c **** #ifdef API_ENABLE
1226:quantum/quantum.c ****     uint8_t chunk[4];
1227:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1228:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1229:quantum/quantum.c **** #endif
1230:quantum/quantum.c **** }
1231:quantum/quantum.c **** 
1232:quantum/quantum.c **** __attribute__ ((weak))
1233:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 2338               		.loc 1 1233 0
 2339               		.cfi_startproc
 2340               	.LVL241:
 2341               	/* prologue: function */
 2342               	/* frame size = 0 */
 2343               	/* stack size = 0 */
 2344               	.L__stack_usage = 0
 2345 0000 0895      		ret
 2346               		.cfi_endproc
 2347               	.LFE55:
 2349               		.section	.text.led_set_kb,"ax",@progbits
 2350               		.weak	led_set_kb
 2352               	led_set_kb:
 2353               	.LFB56:
1234:quantum/quantum.c **** 
1235:quantum/quantum.c **** }
1236:quantum/quantum.c **** 
1237:quantum/quantum.c **** __attribute__ ((weak))
1238:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 2354               		.loc 1 1238 0
 2355               		.cfi_startproc
 2356               	.LVL242:
 2357               	/* prologue: function */
 2358               	/* frame size = 0 */
 2359               	/* stack size = 0 */
 2360               	.L__stack_usage = 0
1239:quantum/quantum.c ****     led_set_user(usb_led);
 2361               		.loc 1 1239 0
 2362 0000 0C94 0000 		jmp led_set_user
 2363               	.LVL243:
 2364               		.cfi_endproc
 2365               	.LFE56:
 2367               		.section	.text.led_init_ports,"ax",@progbits
 2368               		.weak	led_init_ports
 2370               	led_init_ports:
 2371               	.LFB57:
1240:quantum/quantum.c **** }
1241:quantum/quantum.c **** 
1242:quantum/quantum.c **** __attribute__ ((weak))
1243:quantum/quantum.c **** void led_init_ports(void)
1244:quantum/quantum.c **** {
 2372               		.loc 1 1244 0
 2373               		.cfi_startproc
 2374               	/* prologue: function */
 2375               	/* frame size = 0 */
 2376               	/* stack size = 0 */
 2377               	.L__stack_usage = 0
 2378 0000 0895      		ret
 2379               		.cfi_endproc
 2380               	.LFE57:
 2382               		.section	.text.led_set,"ax",@progbits
 2383               		.weak	led_set
 2385               	led_set:
 2386               	.LFB58:
1245:quantum/quantum.c **** 
1246:quantum/quantum.c **** }
1247:quantum/quantum.c **** 
1248:quantum/quantum.c **** __attribute__ ((weak))
1249:quantum/quantum.c **** void led_set(uint8_t usb_led)
1250:quantum/quantum.c **** {
 2387               		.loc 1 1250 0
 2388               		.cfi_startproc
 2389               	.LVL244:
 2390               	/* prologue: function */
 2391               	/* frame size = 0 */
 2392               	/* stack size = 0 */
 2393               	.L__stack_usage = 0
1251:quantum/quantum.c **** 
1252:quantum/quantum.c ****   // Example LED Code
1253:quantum/quantum.c ****   //
1254:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1255:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1256:quantum/quantum.c ****     // {
1257:quantum/quantum.c ****     //     // Output high.
1258:quantum/quantum.c ****     //     DDRE |= (1<<6);
1259:quantum/quantum.c ****     //     PORTE |= (1<<6);
1260:quantum/quantum.c ****     // }
1261:quantum/quantum.c ****     // else
1262:quantum/quantum.c ****     // {
1263:quantum/quantum.c ****     //     // Output low.
1264:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1265:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1266:quantum/quantum.c ****     // }
1267:quantum/quantum.c **** 
1268:quantum/quantum.c ****   led_set_kb(usb_led);
 2394               		.loc 1 1268 0
 2395 0000 0C94 0000 		jmp led_set_kb
 2396               	.LVL245:
 2397               		.cfi_endproc
 2398               	.LFE58:
 2400               		.section	.text.startup_user,"ax",@progbits
 2401               		.weak	startup_user
 2403               	startup_user:
 2404               	.LFB59:
1269:quantum/quantum.c **** }
1270:quantum/quantum.c **** 
1271:quantum/quantum.c **** 
1272:quantum/quantum.c **** //------------------------------------------------------------------------------
1273:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1274:quantum/quantum.c **** // different events such as startup and bootloader jump
1275:quantum/quantum.c **** 
1276:quantum/quantum.c **** __attribute__ ((weak))
1277:quantum/quantum.c **** void startup_user() {}
 2405               		.loc 1 1277 0
 2406               		.cfi_startproc
 2407               	/* prologue: function */
 2408               	/* frame size = 0 */
 2409               	/* stack size = 0 */
 2410               	.L__stack_usage = 0
 2411 0000 0895      		ret
 2412               		.cfi_endproc
 2413               	.LFE59:
 2415               		.section	.text.shutdown_user,"ax",@progbits
 2416               		.weak	shutdown_user
 2418               	shutdown_user:
 2419               	.LFB60:
1278:quantum/quantum.c **** 
1279:quantum/quantum.c **** __attribute__ ((weak))
1280:quantum/quantum.c **** void shutdown_user() {}
 2420               		.loc 1 1280 0
 2421               		.cfi_startproc
 2422               	/* prologue: function */
 2423               	/* frame size = 0 */
 2424               	/* stack size = 0 */
 2425               	.L__stack_usage = 0
 2426 0000 0895      		ret
 2427               		.cfi_endproc
 2428               	.LFE60:
 2430               	.global	rgb_matrix_task_counter
 2431               		.section	.bss.rgb_matrix_task_counter,"aw",@nobits
 2434               	rgb_matrix_task_counter:
 2435 0000 00        		.zero	1
 2436               		.weak	ascii_to_keycode_lut
 2437               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2440               	ascii_to_keycode_lut:
 2441 0000 00        		.byte	0
 2442 0001 00        		.byte	0
 2443 0002 00        		.byte	0
 2444 0003 00        		.byte	0
 2445 0004 00        		.byte	0
 2446 0005 00        		.byte	0
 2447 0006 00        		.byte	0
 2448 0007 00        		.byte	0
 2449 0008 2A        		.byte	42
 2450 0009 2B        		.byte	43
 2451 000a 28        		.byte	40
 2452 000b 00        		.byte	0
 2453 000c 00        		.byte	0
 2454 000d 00        		.byte	0
 2455 000e 00        		.byte	0
 2456 000f 00        		.byte	0
 2457 0010 00        		.byte	0
 2458 0011 00        		.byte	0
 2459 0012 00        		.byte	0
 2460 0013 00        		.byte	0
 2461 0014 00        		.byte	0
 2462 0015 00        		.byte	0
 2463 0016 00        		.byte	0
 2464 0017 00        		.byte	0
 2465 0018 00        		.byte	0
 2466 0019 00        		.byte	0
 2467 001a 00        		.byte	0
 2468 001b 29        		.byte	41
 2469 001c 00        		.byte	0
 2470 001d 00        		.byte	0
 2471 001e 00        		.byte	0
 2472 001f 00        		.byte	0
 2473 0020 2C        		.byte	44
 2474 0021 1E        		.byte	30
 2475 0022 34        		.byte	52
 2476 0023 20        		.byte	32
 2477 0024 21        		.byte	33
 2478 0025 22        		.byte	34
 2479 0026 24        		.byte	36
 2480 0027 34        		.byte	52
 2481 0028 26        		.byte	38
 2482 0029 27        		.byte	39
 2483 002a 25        		.byte	37
 2484 002b 2E        		.byte	46
 2485 002c 36        		.byte	54
 2486 002d 2D        		.byte	45
 2487 002e 37        		.byte	55
 2488 002f 38        		.byte	56
 2489 0030 27        		.byte	39
 2490 0031 1E        		.byte	30
 2491 0032 1F        		.byte	31
 2492 0033 20        		.byte	32
 2493 0034 21        		.byte	33
 2494 0035 22        		.byte	34
 2495 0036 23        		.byte	35
 2496 0037 24        		.byte	36
 2497 0038 25        		.byte	37
 2498 0039 26        		.byte	38
 2499 003a 33        		.byte	51
 2500 003b 33        		.byte	51
 2501 003c 36        		.byte	54
 2502 003d 2E        		.byte	46
 2503 003e 37        		.byte	55
 2504 003f 38        		.byte	56
 2505 0040 1F        		.byte	31
 2506 0041 04        		.byte	4
 2507 0042 05        		.byte	5
 2508 0043 06        		.byte	6
 2509 0044 07        		.byte	7
 2510 0045 08        		.byte	8
 2511 0046 09        		.byte	9
 2512 0047 0A        		.byte	10
 2513 0048 0B        		.byte	11
 2514 0049 0C        		.byte	12
 2515 004a 0D        		.byte	13
 2516 004b 0E        		.byte	14
 2517 004c 0F        		.byte	15
 2518 004d 10        		.byte	16
 2519 004e 11        		.byte	17
 2520 004f 12        		.byte	18
 2521 0050 13        		.byte	19
 2522 0051 14        		.byte	20
 2523 0052 15        		.byte	21
 2524 0053 16        		.byte	22
 2525 0054 17        		.byte	23
 2526 0055 18        		.byte	24
 2527 0056 19        		.byte	25
 2528 0057 1A        		.byte	26
 2529 0058 1B        		.byte	27
 2530 0059 1C        		.byte	28
 2531 005a 1D        		.byte	29
 2532 005b 2F        		.byte	47
 2533 005c 31        		.byte	49
 2534 005d 30        		.byte	48
 2535 005e 23        		.byte	35
 2536 005f 2D        		.byte	45
 2537 0060 35        		.byte	53
 2538 0061 04        		.byte	4
 2539 0062 05        		.byte	5
 2540 0063 06        		.byte	6
 2541 0064 07        		.byte	7
 2542 0065 08        		.byte	8
 2543 0066 09        		.byte	9
 2544 0067 0A        		.byte	10
 2545 0068 0B        		.byte	11
 2546 0069 0C        		.byte	12
 2547 006a 0D        		.byte	13
 2548 006b 0E        		.byte	14
 2549 006c 0F        		.byte	15
 2550 006d 10        		.byte	16
 2551 006e 11        		.byte	17
 2552 006f 12        		.byte	18
 2553 0070 13        		.byte	19
 2554 0071 14        		.byte	20
 2555 0072 15        		.byte	21
 2556 0073 16        		.byte	22
 2557 0074 17        		.byte	23
 2558 0075 18        		.byte	24
 2559 0076 19        		.byte	25
 2560 0077 1A        		.byte	26
 2561 0078 1B        		.byte	27
 2562 0079 1C        		.byte	28
 2563 007a 1D        		.byte	29
 2564 007b 2F        		.byte	47
 2565 007c 31        		.byte	49
 2566 007d 30        		.byte	48
 2567 007e 35        		.byte	53
 2568 007f 4C        		.byte	76
 2569               		.weak	ascii_to_shift_lut
 2570               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2573               	ascii_to_shift_lut:
 2574 0000 00        		.byte	0
 2575 0001 00        		.byte	0
 2576 0002 00        		.byte	0
 2577 0003 00        		.byte	0
 2578 0004 00        		.byte	0
 2579 0005 00        		.byte	0
 2580 0006 00        		.byte	0
 2581 0007 00        		.byte	0
 2582 0008 00        		.byte	0
 2583 0009 00        		.byte	0
 2584 000a 00        		.byte	0
 2585 000b 00        		.byte	0
 2586 000c 00        		.byte	0
 2587 000d 00        		.byte	0
 2588 000e 00        		.byte	0
 2589 000f 00        		.byte	0
 2590 0010 00        		.byte	0
 2591 0011 00        		.byte	0
 2592 0012 00        		.byte	0
 2593 0013 00        		.byte	0
 2594 0014 00        		.byte	0
 2595 0015 00        		.byte	0
 2596 0016 00        		.byte	0
 2597 0017 00        		.byte	0
 2598 0018 00        		.byte	0
 2599 0019 00        		.byte	0
 2600 001a 00        		.byte	0
 2601 001b 00        		.byte	0
 2602 001c 00        		.byte	0
 2603 001d 00        		.byte	0
 2604 001e 00        		.byte	0
 2605 001f 00        		.byte	0
 2606 0020 00        		.byte	0
 2607 0021 01        		.byte	1
 2608 0022 01        		.byte	1
 2609 0023 01        		.byte	1
 2610 0024 01        		.byte	1
 2611 0025 01        		.byte	1
 2612 0026 01        		.byte	1
 2613 0027 00        		.byte	0
 2614 0028 01        		.byte	1
 2615 0029 01        		.byte	1
 2616 002a 01        		.byte	1
 2617 002b 01        		.byte	1
 2618 002c 00        		.byte	0
 2619 002d 00        		.byte	0
 2620 002e 00        		.byte	0
 2621 002f 00        		.byte	0
 2622 0030 00        		.byte	0
 2623 0031 00        		.byte	0
 2624 0032 00        		.byte	0
 2625 0033 00        		.byte	0
 2626 0034 00        		.byte	0
 2627 0035 00        		.byte	0
 2628 0036 00        		.byte	0
 2629 0037 00        		.byte	0
 2630 0038 00        		.byte	0
 2631 0039 00        		.byte	0
 2632 003a 01        		.byte	1
 2633 003b 00        		.byte	0
 2634 003c 01        		.byte	1
 2635 003d 00        		.byte	0
 2636 003e 01        		.byte	1
 2637 003f 01        		.byte	1
 2638 0040 01        		.byte	1
 2639 0041 01        		.byte	1
 2640 0042 01        		.byte	1
 2641 0043 01        		.byte	1
 2642 0044 01        		.byte	1
 2643 0045 01        		.byte	1
 2644 0046 01        		.byte	1
 2645 0047 01        		.byte	1
 2646 0048 01        		.byte	1
 2647 0049 01        		.byte	1
 2648 004a 01        		.byte	1
 2649 004b 01        		.byte	1
 2650 004c 01        		.byte	1
 2651 004d 01        		.byte	1
 2652 004e 01        		.byte	1
 2653 004f 01        		.byte	1
 2654 0050 01        		.byte	1
 2655 0051 01        		.byte	1
 2656 0052 01        		.byte	1
 2657 0053 01        		.byte	1
 2658 0054 01        		.byte	1
 2659 0055 01        		.byte	1
 2660 0056 01        		.byte	1
 2661 0057 01        		.byte	1
 2662 0058 01        		.byte	1
 2663 0059 01        		.byte	1
 2664 005a 01        		.byte	1
 2665 005b 00        		.byte	0
 2666 005c 00        		.byte	0
 2667 005d 00        		.byte	0
 2668 005e 01        		.byte	1
 2669 005f 01        		.byte	1
 2670 0060 00        		.byte	0
 2671 0061 00        		.byte	0
 2672 0062 00        		.byte	0
 2673 0063 00        		.byte	0
 2674 0064 00        		.byte	0
 2675 0065 00        		.byte	0
 2676 0066 00        		.byte	0
 2677 0067 00        		.byte	0
 2678 0068 00        		.byte	0
 2679 0069 00        		.byte	0
 2680 006a 00        		.byte	0
 2681 006b 00        		.byte	0
 2682 006c 00        		.byte	0
 2683 006d 00        		.byte	0
 2684 006e 00        		.byte	0
 2685 006f 00        		.byte	0
 2686 0070 00        		.byte	0
 2687 0071 00        		.byte	0
 2688 0072 00        		.byte	0
 2689 0073 00        		.byte	0
 2690 0074 00        		.byte	0
 2691 0075 00        		.byte	0
 2692 0076 00        		.byte	0
 2693 0077 00        		.byte	0
 2694 0078 00        		.byte	0
 2695 0079 00        		.byte	0
 2696 007a 00        		.byte	0
 2697 007b 01        		.byte	1
 2698 007c 01        		.byte	1
 2699 007d 01        		.byte	1
 2700 007e 01        		.byte	1
 2701 007f 00        		.byte	0
 2702               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2705               	grave_esc_was_shifted:
 2706 0000 00        		.zero	1
 2707               		.section	.bss.scs_timer,"aw",@nobits
 2710               	scs_timer:
 2711 0000 0000 0000 		.zero	4
 2712               		.section	.bss.shift_interrupted,"aw",@nobits
 2715               	shift_interrupted:
 2716 0000 0000      		.zero	2
 2717               		.text
 2718               	.Letext0:
 2719               		.file 5 "/usr/lib/avr/include/stdint.h"
 2720               		.file 6 "./tmk_core/common/keyboard.h"
 2721               		.file 7 "./tmk_core/common/action.h"
 2722               		.file 8 "./tmk_core/common/report.h"
 2723               		.file 9 "./tmk_core/common/debug.h"
 2724               		.file 10 "quantum/keycode_config.h"
 2725               		.file 11 "./tmk_core/common/keycode.h"
 2726               		.file 12 "quantum/quantum_keycodes.h"
 2727               		.file 13 "./tmk_core/protocol/lufa/outputselect.h"
 2728               		.file 14 "quantum/quantum.h"
 2729               		.file 15 "./tmk_core/common/bootloader.h"
 2730               		.file 16 "./tmk_core/common/action_layer.h"
 2731               		.file 17 "quantum/keymap.h"
 2732               		.file 18 "./quantum/process_keycode/process_tap_dance.h"
 2733               		.file 19 "./quantum/process_keycode/process_leader.h"
 2734               		.file 20 "./tmk_core/common/eeconfig.h"
 2735               		.file 21 "./tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
     /tmp/ccyXb893.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccyXb893.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccyXb893.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccyXb893.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccyXb893.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccyXb893.s:12     .text.do_code16:0000000000000000 do_code16
     /tmp/ccyXb893.s:130    .text.qk_register_weak_mods:0000000000000000 qk_register_weak_mods
     /tmp/ccyXb893.s:160    .text.qk_register_mods:0000000000000000 qk_register_mods
     /tmp/ccyXb893.s:190    .text.qk_unregister_weak_mods:0000000000000000 qk_unregister_weak_mods
     /tmp/ccyXb893.s:220    .text.qk_unregister_mods:0000000000000000 qk_unregister_mods
     /tmp/ccyXb893.s:251    .text.rgblight_toggle:0000000000000000 rgblight_toggle
     /tmp/ccyXb893.s:267    .text.rgblight_step:0000000000000000 rgblight_step
     /tmp/ccyXb893.s:282    .text.rgblight_step_reverse:0000000000000000 rgblight_step_reverse
     /tmp/ccyXb893.s:297    .text.rgblight_increase_hue:0000000000000000 rgblight_increase_hue
     /tmp/ccyXb893.s:312    .text.rgblight_decrease_hue:0000000000000000 rgblight_decrease_hue
     /tmp/ccyXb893.s:327    .text.rgblight_increase_sat:0000000000000000 rgblight_increase_sat
     /tmp/ccyXb893.s:342    .text.rgblight_decrease_sat:0000000000000000 rgblight_decrease_sat
     /tmp/ccyXb893.s:357    .text.rgblight_increase_val:0000000000000000 rgblight_increase_val
     /tmp/ccyXb893.s:372    .text.rgblight_decrease_val:0000000000000000 rgblight_decrease_val
     /tmp/ccyXb893.s:387    .text.rgblight_increase_speed:0000000000000000 rgblight_increase_speed
     /tmp/ccyXb893.s:402    .text.rgblight_decrease_speed:0000000000000000 rgblight_decrease_speed
     /tmp/ccyXb893.s:417    .text.register_code16:0000000000000000 register_code16
     /tmp/ccyXb893.s:474    .text.unregister_code16:0000000000000000 unregister_code16
     /tmp/ccyXb893.s:529    .text.process_action_kb:0000000000000000 process_action_kb
     /tmp/ccyXb893.s:548    .text.process_record_user:0000000000000000 process_record_user
     /tmp/ccyXb893.s:567    .text.process_record_kb:0000000000000000 process_record_kb
     /tmp/ccyXb893.s:585    .text.reset_keyboard:0000000000000000 reset_keyboard
     /tmp/ccyXb893.s:620    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccyXb893.s:2705   .bss.grave_esc_was_shifted:0000000000000000 grave_esc_was_shifted
     /tmp/ccyXb893.s:2715   .bss.shift_interrupted:0000000000000000 shift_interrupted
     /tmp/ccyXb893.s:2710   .bss.scs_timer:0000000000000000 scs_timer
     /tmp/ccyXb893.s:1189   .text.send_char:0000000000000000 send_char
     /tmp/ccyXb893.s:2440   .progmem.data.ascii_to_keycode_lut:0000000000000000 ascii_to_keycode_lut
     /tmp/ccyXb893.s:2573   .progmem.data.ascii_to_shift_lut:0000000000000000 ascii_to_shift_lut
     /tmp/ccyXb893.s:1275   .text.send_string_with_delay:0000000000000000 send_string_with_delay
     /tmp/ccyXb893.s:1419   .text.send_string:0000000000000000 send_string
     /tmp/ccyXb893.s:1438   .text.send_string_with_delay_P:0000000000000000 send_string_with_delay_P
     /tmp/ccyXb893.s:1614   .text.send_string_P:0000000000000000 send_string_P
     /tmp/ccyXb893.s:1633   .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
     /tmp/ccyXb893.s:1681   .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
     /tmp/ccyXb893.s:1866   .text.update_tri_layer:0000000000000000 update_tri_layer
     /tmp/ccyXb893.s:1905   .text.tap_random_base64:0000000000000000 tap_random_base64
     /tmp/ccyXb893.s:2027   .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
     /tmp/ccyXb893.s:2044   .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
     /tmp/ccyXb893.s:2064   .text.backlight_init_ports:0000000000000000 backlight_init_ports
     /tmp/ccyXb893.s:2079   .text.backlight_set:0000000000000000 backlight_set
     /tmp/ccyXb893.s:2095   .text.send_nibble:0000000000000000 send_nibble
     /tmp/ccyXb893.s:2160   .text.send_byte:0000000000000000 send_byte
     /tmp/ccyXb893.s:2197   .text.send_word:0000000000000000 send_word
     /tmp/ccyXb893.s:2231   .text.send_dword:0000000000000000 send_dword
     /tmp/ccyXb893.s:2281   .text.hex_to_keycode:0000000000000000 hex_to_keycode
     /tmp/ccyXb893.s:2320   .text.api_send_unicode:0000000000000000 api_send_unicode
     /tmp/ccyXb893.s:2336   .text.led_set_user:0000000000000000 led_set_user
     /tmp/ccyXb893.s:2352   .text.led_set_kb:0000000000000000 led_set_kb
     /tmp/ccyXb893.s:2370   .text.led_init_ports:0000000000000000 led_init_ports
     /tmp/ccyXb893.s:2385   .text.led_set:0000000000000000 led_set
     /tmp/ccyXb893.s:2403   .text.startup_user:0000000000000000 startup_user
     /tmp/ccyXb893.s:2418   .text.shutdown_user:0000000000000000 shutdown_user
     /tmp/ccyXb893.s:2434   .bss.rgb_matrix_task_counter:0000000000000000 rgb_matrix_task_counter

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
clear_keyboard
bootloader_jump
layer_switch_get_layer
keymap_key_to_keycode
preprocess_tap_dance
process_tap_dance
process_leader
get_mods
keyboard_report
add_key_to_report
del_key_from_report
debug_config
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
timer_read
register_mods
unregister_mods
timer_elapsed
set_output
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_init_kb
matrix_scan_tap_dance
matrix_scan_kb
__do_clear_bss
